<?xml version="1.0"?>
<javascript>
  <class type="dijit">
    <methods>
      <method name="_underlay" scope="instance">
        <description>A shared instance of a `dijit.DialogUnderlay` created and
	used by `dijit.Dialog`, though never created until some Dialog
	or subclass thereof is shown.</description>
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showTooltip" scope="instance">
        <parameters>
          <parameter name="innerHTML" type="String" usage="required"/>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="position" type="Array&lt;String&gt;" usage="optional"/>
          <parameter name="rtl" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="hideTooltip" scope="instance">
        <parameters>
          <parameter name="aroundNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_connectOnUseEventHandler" scope="instance">
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="isCollapsed" scope="instance"/>
      <method name="getBookmark" scope="instance">
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="moveToBookmark" scope="instance">
        <parameters>
          <parameter name="bookmark" type="Object" usage="required">
            <description>This should be a returned object from dijit.getBookmark()</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFocus" scope="instance">
        <parameters>
          <parameter name="menu" type="Widget" usage="optional">
            <description>dijit._Widget or {domNode: DomNode} structure
	The button that was just pressed.  If focus has disappeared or moved
	to this button, returns the previous focus.  In this case the bookmark
	information is already lost, and null is returned.</description>
          </parameter>
          <parameter name="openedForWindow" type="Window" usage="optional">
            <description>iframe in which menu was opened</description>
          </parameter>
        </parameters>
        <return-description>A handle to restore focus/selection, to be passed to `dijit.focus`</return-description>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required">
            <description>object returned by get(), or a DomNode</description>
          </parameter>
        </parameters>
      </method>
      <method name="registerIframe" scope="instance">
        <description>Currently only used by editor.</description>
        <parameters>
          <parameter name="iframe" type="DomNode" usage="required"/>
        </parameters>
        <return-description>Handle to pass to unregisterIframe()</return-description>
      </method>
      <method name="unregisterIframe" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required">
            <description>Handle returned by registerIframe()</description>
          </parameter>
        </parameters>
      </method>
      <method name="registerWin" scope="instance">
        <description>Users should call registerIframe() instead of this method.</description>
        <parameters>
          <parameter name="targetWindow" type="Window" usage="optional">
            <description>If specified this is the window associated with the iframe,
	i.e. iframe.contentWindow.</description>
          </parameter>
          <parameter name="effectiveNode" type="DomNode" usage="optional">
            <description>If specified, report any focus events inside targetWindow as
	an event on effectiveNode, rather than on evt.target.</description>
          </parameter>
        </parameters>
        <return-description>Handle to pass to unregisterWin()</return-description>
      </method>
      <method name="unregisterWin" scope="instance">
        <parameters>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlurNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_onTouchNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node that was touched.</description>
          </parameter>
          <parameter name="by" type="String" usage="required">
            <description>&amp;quot;mouse&amp;quot; if the focus/touch was caused by a mouse down event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onFocusNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setStack" scope="instance">
        <parameters>
          <parameter name="newStack" type="Array&lt;String&gt;" usage="required">
            <description>array of widget id's, starting from the top (outermost) widget</description>
          </parameter>
          <parameter name="by" type="String" usage="required">
            <description>&amp;quot;mouse&amp;quot; if the focus/touch was caused by a mouse down event</description>
          </parameter>
        </parameters>
      </method>
      <method name="byId" scope="instance">
        <parameters>
          <parameter name="id" type="String|dijit._Widget" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getUniqueId" scope="instance">
        <parameters>
          <parameter name="widgetType" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="findWidgets" scope="instance">
        <parameters>
          <parameter name="root" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyAll" scope="instance"/>
      <method name="byNode" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getEnclosingWidget" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_isElementShown" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
      </method>
      <method name="hasDefaultTabStop" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
      </method>
      <method name="isTabNavigable" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_getTabNavigable" scope="instance">
        <description>Finds the following descendants of the specified root node:
	* the first tab-navigable element in document order
	without a tabIndex or with tabIndex="0"
	* the last tab-navigable element in document order
	without a tabIndex or with tabIndex="0"
	* the first element in document order with the lowest
	positive tabIndex value
	* the last element in document order with the highest
	positive tabIndex value</description>
        <parameters>
          <parameter name="root" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstInTabbingOrder" scope="instance">
        <parameters>
          <parameter name="root" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="getLastInTabbingOrder" scope="instance">
        <parameters>
          <parameter name="root" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="getViewport" scope="instance"/>
      <method name="placeOnScreen" scope="instance">
        <description>NOTE: node is assumed to be absolutely or relatively positioned.</description>
        <examples>
          <example>Try to place node's top right corner at (10,20).
	If that makes node go (partially) off screen, then try placing
	bottom left corner at (10,20).
		placeOnScreen(node, {x: 10, y: 20}, ["TR", "BL"])</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="pos" type="dijit.__Position" usage="required">
            <description>Object like {x: 10, y: 20}</description>
          </parameter>
          <parameter name="corners" type="Array&lt;String&gt;" usage="required">
            <description>Array of Strings representing order to try corners in, like [&amp;quot;TR&amp;quot;, &amp;quot;BL&amp;quot;].
	Possible values are:
	* &amp;quot;BL&amp;quot; - bottom left
	* &amp;quot;BR&amp;quot; - bottom right
	* &amp;quot;TL&amp;quot; - top left
	* &amp;quot;TR&amp;quot; - top right</description>
          </parameter>
          <parameter name="padding" type="dijit.__Position" usage="optional">
            <description>set padding to put some buffer around the element you want to position.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_place" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="choices" type="Array" usage="required">
            <description>Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
	Above example says to put the top-left corner of the node at (10,20)</description>
          </parameter>
          <parameter name="layoutNode" type="Function" usage="required">
            <description>aroundNodeCorner, nodeCorner, size)
	for things like tooltip, they are displayed differently (and have different dimensions)
	based on their orientation relative to the parent.   This adjusts the popup based on orientation.
	It also passes in the available size for the popup, which is useful for tooltips to
	tell them that their width is limited to a certain amount.   layoutNode() may return a value expressing
	how much the popup had to be modified to fit into the available space.   This is used to determine
	what the best placement is.</description>
          </parameter>
          <parameter name="aroundNodeCoords" type="Object" usage="required">
            <description>Size of aroundNode, ex: {w: 200, h: 50}</description>
          </parameter>
        </parameters>
      </method>
      <method name="placeOnScreenAroundNode" scope="instance">
        <description>Place node such that corner of node touches a corner of
	aroundNode, and that node is fully visible.</description>
        <examples>
          <example>	dijit.placeOnScreenAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
	This will try to position node such that node's top-left corner is at the same position
	as the bottom left corner of the aroundNode (ie, put node below
	aroundNode, with left edges aligned).  If that fails it will try to put
	the bottom-right corner of node where the top right corner of aroundNode is
	(ie, put node above aroundNode, with right edges aligned)</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required">
            <description>Ordered list of pairs of corners to try matching up.
	Each pair of corners is represented as a key/value in the hash,
	where the key corresponds to the aroundNode's corner, and
	the value corresponds to the node's corner:
		{ aroundNodeCorner1: nodeCorner1, aroundNodeCorner2: nodeCorner2, ...}
	The following strings are used to represent the four corners:
	* &amp;quot;BL&amp;quot; - bottom left
	* &amp;quot;BR&amp;quot; - bottom right
	* &amp;quot;TL&amp;quot; - top left
	* &amp;quot;TR&amp;quot; - top right</description>
          </parameter>
          <parameter name="layoutNode" type="Function" usage="optional">
            <description>Function(node, aroundNodeCorner, nodeCorner)
	For things like tooltip, they are displayed differently (and have different dimensions)
	based on their orientation relative to the parent.   This adjusts the popup based on orientation.</description>
          </parameter>
        </parameters>
      </method>
      <method name="placeOnScreenAroundRectangle" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundRect" type="dijit.__Rectangle" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_placeOnScreenAroundRect" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="x" type="Number" usage="required"/>
          <parameter name="y" type="Number" usage="required"/>
          <parameter name="width" type="Number" usage="required"/>
          <parameter name="height" type="Number" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="placeOnScreenAroundElement" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundElement" type="Object" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="getPopupAroundAlignment" scope="instance">
        <parameters>
          <parameter name="position" type="Array" usage="required">
            <description>String[] This variable controls the position of the drop down.
	It's an array of strings with the following values:
	* before: places drop down to the left of the target node/widget, or to the right in
	the case of RTL scripts like Hebrew and Arabic
	* after: places drop down to the right of the target node/widget, or to the left in
	the case of RTL scripts like Hebrew and Arabic
	* above: drop down goes above target node
	* below: drop down goes below target node
	The list is positions is tried, in order, until a position is found where the drop down fits
	within the viewport.</description>
          </parameter>
          <parameter name="leftToRight" type="Boolean" usage="required">
            <description>Whether the popup will be displaying in leftToRight mode.</description>
          </parameter>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="pos" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="hasWaiRole" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="optional"/>
        </parameters>
        <return-description>True if elem has the specific role attribute and false if not.
	For backwards compatibility if role parameter not provided,
	returns true if has a role</return-description>
      </method>
      <method name="getWaiRole" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
        <return-description>The role of elem or an empty string if elem
	does not have a role.</return-description>
      </method>
      <method name="setWaiRole" scope="instance">
        <description>Replace existing role attribute with new role.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeWaiRole" scope="instance">
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="hasWaiState" scope="instance">
        <description>Checks for an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
        <return-description>true if elem has a value for the given state and
	false if it does not.</return-description>
      </method>
      <method name="getWaiState" scope="instance">
        <description>Checks for an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
        <return-description>The value of the requested state on elem
	or an empty string if elem has no value for state.</return-description>
      </method>
      <method name="setWaiState" scope="instance">
        <description>Sets an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeWaiState" scope="instance">
        <description>Sets an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getDocumentWindow" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectInputText" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="start" type="Number" usage="optional"/>
          <parameter name="stop" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_dialogStack" scope="instance" type="Array"/>
      <property name="_masterTT" scope="instance" type="Object"/>
      <property name="_Calendar" scope="instance" type="Object"/>
      <property name="_lastKeyDownNode" scope="instance" type="Object"/>
      <property name="_curFocus" scope="instance" type="DomNode">
        <description>Currently focused item on screen</description>
      </property>
      <property name="_prevFocus" scope="instance" type="DomNode">
        <description>Previously focused item on screen</description>
      </property>
      <property name="_activeStack" scope="instance" type="Array&lt;dijit._Widget&gt;">
        <description>List of currently active widgets (focused widget and it's ancestors)</description>
      </property>
      <property name="defaultDuration" scope="instance" type="Integer">
        <description>The default animation speed (in ms) to use for all Dijit
	transitional animations, unless otherwise specified
	on a per-instance basis. Defaults to 200, overrided by
	&lt;code&gt;djConfig.defaultDuration&lt;/code&gt;</description>
      </property>
      <property name="placementRegistry" scope="instance" type="Object"/>
      <property name="_frames" scope="instance" type="Object"/>
      <property name="dijit-all" scope="instance" type="Object">
        <description>A rollup that includes every dijit. You probably don't need this.</description>
      </property>
      <property name="dijit" scope="instance" type="Object">
        <description>A roll-up for common dijit methods</description>
      </property>
      <property name="demos" scope="instance" type="Object">
        <description>Home of the official dijit demo code</description>
      </property>
      <property name="robot" scope="instance" type="Object"/>
      <property name="robotx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Calendar" superclass="dijit._Widget">
    <description>A simple GUI for choosing a date in the context of a monthly calendar.
	This widget can't be used in a form because it doesn't serialize the date to an
	`&lt;input&gt;` field.  For a form element, use dijit.form.DateTextBox instead.
	Note that the parser takes all dates attributes passed in the
	[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
	so that they are serializable and locale-independent.</description>
    <methods>
      <method name="_isValidDate" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Set the current date and update the UI.  If the date is disabled, the value will
	not change, but the display will change to the corresponding month.</description>
        <parameters>
          <parameter name="value" type="Date|Number" usage="required">
            <description>Either a Date or the number of seconds since 1970.</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateGrid" scope="instance"/>
      <method name="goToToday" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_adjustDisplay" scope="instance">
        <parameters>
          <parameter name="part" type="String" usage="required">
            <description>&amp;quot;month&amp;quot; or &amp;quot;year&amp;quot;</description>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <description>Number of months or years</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setCurrentFocusAttr" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="forceFocus" type="Boolean" usage="required">
            <description>If true, will focus() the cell even if calendar itself doesn't have focus</description>
          </parameter>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="_onMonthSelect" scope="instance">
        <parameters>
          <parameter name="newMonth" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseOver" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseOut" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="handleKey" scope="instance">
        <description>Called from _onKeyPress() to handle keypress on a stand alone Calendar,
	and also from `dijit.form._DateTimeTextBox` to pass a keypress event
	from the `dijit.form.DateTextBox` to be handled in this widget</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-description>False if the key was recognized as a navigation key,
	to indicate that the event was handled by Calendar and shouldn't be propogated</return-description>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onValueSelected" scope="instance">
        <description>Formerly used by `dijit.form._DateTimeTextBox` (and thus `dijit.form.DateTextBox`)
	to get notification when the user has clicked a date.  Now onExecute() (above) is used.</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_isSelectedDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getClassForDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Date">
        <description>The currently selected Date, initially set to invalid date to indicate no selection.
	TODO: for 2.0 make this a string (ISO format) rather than a Date</description>
      </property>
      <property name="datePackage" scope="instance-prototype" type="String">
        <description>JavaScript namespace to find Calendar routines.  Uses Gregorian Calendar routines
	at dojo.date by default.</description>
      </property>
      <property name="dayWidth" scope="instance" type="String">
        <description>How to represent the days of the week in the calendar header. See dojo.date.locale</description>
      </property>
      <property name="tabIndex" scope="instance" type="Integer">
        <description>Order fields are traversed when user hits the tab key</description>
      </property>
      <property name="currentFocus" scope="instance" type="Date">
        <description>Date object containing the currently focused date, or the date which would be focused
	if the calendar itself was focused.   Also indicates which year and month to display,
	i.e. the current &amp;quot;page&amp;quot; the calendar is on.</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_currentNode" scope="instance" type="Object"/>
      <property name="dateClassObj" scope="instance" type="Object"/>
      <property name="dateFuncObj" scope="instance" type="Object"/>
      <property name="dateLocaleModule" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Calendar.cssStateNodes">
    <properties>
      <property name="decrementMonth" scope="instance" type="String"/>
      <property name="incrementMonth" scope="instance" type="String"/>
      <property name="previousYearLabelNode" scope="instance" type="String"/>
      <property name="nextYearLabelNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.Calendar.monthDropDownButton.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.Calendar.monthDropDownButton">
    <properties>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Calendar._MonthDropDown" superclass="dijit._Widget">
    <methods>
      <method name="_setMonthsAttr" scope="instance">
        <parameters>
          <parameter name="months" type="Array&lt;String&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="month" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onMenuHover" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="months" scope="instance" type="Array&lt;String&gt;">
        <description>List of names of months, possibly w/some undefined entries for Hebrew leap months
	(ex: [&amp;quot;January&amp;quot;, &amp;quot;February&amp;quot;, undefined, &amp;quot;April&amp;quot;, ...])</description>
      </property>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.Calendar._MonthDropDown.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.CheckedMenuItem" superclass="dijit.MenuItem">
    <methods>
      <method name="_setCheckedAttr" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="checked" scope="instance" type="Boolean">
        <description>Our checked state</description>
      </property>
    </properties>
  </class>
  <class type="dijit.ColorPalette" superclass="dijit._Widget">
    <description>Grid showing various colors, so the user can pick a certain color.
	Can be used standalone, or as a popup.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._PaletteMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._PaletteMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="palette" scope="instance" type="String">
        <description>Size of grid, either &amp;quot;7x10&amp;quot; or &amp;quot;3x4&amp;quot;.</description>
      </property>
      <property name="templateString" scope="instance" type="String">
        <description>The template of this widget.</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="dyeClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.ColorPalette._palettes">
    <properties>
      <property name="7x10" scope="instance" type="Array"/>
      <property name="3x4" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.ColorPalette._imagePaths">
    <properties>
      <property name="7x10" scope="instance" type="Object"/>
      <property name="3x4" scope="instance" type="Object"/>
      <property name="7x10-rtl" scope="instance" type="Object"/>
      <property name="3x4-rtl" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Color" superclass="dojo.Color">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
          <parameter name="blankGif" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.Color" scope="instance"/>
    </mixins>
    <properties>
      <property name="_alias" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Declaration" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="_noScript" scope="instance" type="Boolean">
        <description>Flag to parser to leave alone the script tags contained inside of me</description>
      </property>
      <property name="stopParser" scope="instance" type="Boolean">
        <description>Flag to parser to not try and parse widgets declared inside of me</description>
      </property>
      <property name="widgetClass" scope="instance" type="String">
        <description>Name of class being declared, ex: &amp;quot;acme.myWidget&amp;quot;</description>
      </property>
      <property name="mixins" scope="instance" type="Array&lt;String&gt;">
        <description>List containing the prototype for this widget, and also any mixins,
	ex: [&amp;quot;dijit._Widget&amp;quot;, &amp;quot;dijit._Container&amp;quot;]</description>
      </property>
    </properties>
  </class>
  <class type="dijit.Declaration.defaults">
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_skipNodeCache" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._DialogBase" superclass="dijit._Templated">
    <description>Pops up a modal dialog window, blocking access to the screen
	and also graying out the screen Dialog is extended from
	ContentPane so it supports all the same parameters (href, etc.)</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onLoad" scope="instance"/>
      <method name="_endDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setup" scope="instance"/>
      <method name="_size" scope="instance"/>
      <method name="_position" scope="instance"/>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="just let it go"/>
        </return-types>
      </method>
      <method name="show" scope="instance">
        <return-description>dojo.Deferred
	Deferred object that resolves when the display animation is complete</return-description>
      </method>
      <method name="hide" scope="instance">
        <return-description>dojo.Deferred
	Deferred object that resolves when the hide animation is complete</return-description>
      </method>
      <method name="layout" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormMixin.prototype" scope="instance"/>
      <mixin type="dijit._DialogMixin.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit.form._FormMixin" scope="instance"/>
      <mixin type="dijit._DialogMixin" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="open" scope="instance" type="Boolean">
        <description>True if Dialog is currently displayed on screen.</description>
      </property>
      <property name="duration" scope="instance" type="Integer">
        <description>The time in milliseconds it takes the dialog to fade in and out</description>
      </property>
      <property name="refocus" scope="instance" type="Boolean">
        <description>A Toggle to modify the default focus behavior of a Dialog, which
	is to re-focus the element which had focus before being opened.
	False will disable refocusing. Default: true</description>
      </property>
      <property name="autofocus" scope="instance" type="Boolean">
        <description>A Toggle to modify the default focus behavior of a Dialog, which
	is to focus on the first dialog element after opening the dialog.
	False will disable autofocusing. Default: true</description>
      </property>
      <property name="_firstFocusItem" scope="instance" type="DomNode">
        <description>The pointer to the first focusable node in the dialog.
	Set by &lt;code&gt;dijit._DialogMixin._getFocusItems&lt;/code&gt;.</description>
      </property>
      <property name="_lastFocusItem" scope="instance" type="DomNode">
        <description>The pointer to which node has focus prior to our dialog.
	Set by &lt;code&gt;dijit._DialogMixin._getFocusItems&lt;/code&gt;.</description>
      </property>
      <property name="doLayout" scope="instance" type="Boolean">
        <description>Don't change this parameter from the default value.
	This ContentPane parameter doesn't make sense for Dialog, since Dialog
	is never a child of a layout container, nor can you specify the size of
	Dialog in order to control the size of an inner widget.</description>
      </property>
      <property name="draggable" scope="instance" type="Boolean">
        <description>Toggles the moveable aspect of the Dialog. If true, Dialog
	can be dragged by it's title. If false it will remain centered
	in the viewport.</description>
      </property>
      <property name="aria-describedby" scope="instance" type="String">
        <description>Allows the user to add an aria-describedby attribute onto the dialog.   The value should
	be the id of the container element of text that describes the dialog purpose (usually
	the first text in the dialog).
	&amp;lt;div dojoType=&amp;quot;dijit.Dialog&amp;quot; aria-describedby=&amp;quot;intro&amp;quot; .....&amp;gt;
	&amp;lt;div id=&amp;quot;intro&amp;quot;&amp;gt;Introductory text&amp;lt;/div&amp;gt;
	&amp;lt;div&amp;gt;rest of dialog contents&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;</description>
      </property>
      <property name="_modalconnects" scope="instance" type="Array"/>
      <property name="_relativePosition" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_moveable" scope="instance" type="Object"/>
      <property name="_dndListener" scope="instance" type="Object"/>
      <property name="underlayAttrs" scope="instance" type="Object"/>
      <property name="_singleChildOriginalStyle" scope="instance" type="Object"/>
      <property name="_alreadyInitialized" scope="instance" type="Object"/>
      <property name="_fadeInDeferred" scope="instance" type="Object"/>
      <property name="_fadeOutDeferred" scope="instance" type="Object"/>
      <property name="_scrollConnected" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit._DialogBase.cssStateNodes">
    <properties>
      <property name="closeButtonNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._DialogBase._singleChild.domNode.style">
    <properties>
      <property name="cssText" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Dialog" superclass="dijit.layout.ContentPane">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._DialogBase.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._DialogBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._DialogLevelManager">
    <methods>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="dialog" type="dijit._Widget" usage="required"/>
          <parameter name="underlayAttrs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="dialog" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="isTop" scope="instance">
        <parameters>
          <parameter name="dialog" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.DialogUnderlay" superclass="dijit._Widget">
    <description>A component used to block input behind a `dijit.Dialog`. Only a single
	instance of this widget is created by `dijit.Dialog`, and saved as
	a reference to be shared between all Dialogs as `dijit._underlay`
	The underlay itself can be styled based on and id:
		#myDialog_underlay { background-color:red; }
	In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
	suffixed with _underlay.</description>
    <methods>
      <method name="_setDialogIdAttr" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setClassAttr" scope="instance">
        <parameters>
          <parameter name="clazz" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="layout" scope="instance">
        <description>Sets the background to the size of the viewport (rather than the size
	of the document) since we need to cover the whole browser window, even
	if the document is only a few lines long.</description>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="dialogId" scope="instance" type="String">
        <description>Id of the dialog.... DialogUnderlay's id is based on this id</description>
      </property>
      <property name="class" scope="instance" type="String">
        <description>This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay</description>
      </property>
      <property name="bgIframe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.attributeMap">
    <properties>
      <property name="id" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.node">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.domNode"/>
  <class type="dijit.DialogUnderlay.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.DialogUnderlay.node.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.Editor" superclass="dijit._editor.RichText">
    <description>This widget provides basic WYSIWYG editing features, based on the browser's
	underlying rich text editing capability, accompanied by a toolbar (`dijit.Toolbar`).
	A plugin model is available to extend the editor's capabilities as well as the
	the options available in the toolbar.  Content generation may vary across
	browsers, and clipboard operations may have different results, to name
	a few limitations.  Note: this widget should not be used with the HTML
	&amp;lt;TEXTAREA&amp;gt; tag -- see dijit._editor.RichText for details.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="addPlugin" scope="instance">
        <parameters>
          <parameter name="plugin" type="String|Object" usage="required">
            <description>String, args object or plugin instance
	args:
	This object will be passed to the plugin constructor</description>
          </parameter>
          <parameter name="index" type="Integer" usage="optional">
            <description>Used when creating an instance from
	something already in this.plugins. Ensures that the new
	instance is assigned to this.plugins at that index.</description>
          </parameter>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="_onIEMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeActivate" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeDeactivate" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="beginEditing" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="execCommand" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToBookmark" scope="instance">
        <parameters>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_changeToStep" scope="instance">
        <parameters>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="undo" scope="instance"/>
      <method name="redo" scope="instance"/>
      <method name="endEditing" scope="instance">
        <parameters>
          <parameter name="ignore_caret" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBookmark" scope="instance"/>
      <method name="_beginEditing" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_endEditing" scope="instance">
        <parameters>
          <parameter name="ignore_caret" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_saveSelection" scope="instance"/>
      <method name="_restoreSelection" scope="instance"/>
      <method name="onClick" scope="instance"/>
      <method name="replaceValue" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setStateClass" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor.RichText" scope="instance"/>
    </mixins>
    <properties>
      <property name="plugins" scope="instance-prototype" type="Array&lt;Object&gt;">
        <description>A list of plugin names (as strings) or instances (as objects)
	for this widget.
	When declared in markup, it might look like:
		plugins=&amp;quot;['bold',{name:'dijit._editor.plugins.FontChoice', command:'fontName', generic:true}]&amp;quot;</description>
      </property>
      <property name="extraPlugins" scope="instance" type="Array&lt;Object&gt;">
        <description>A list of extra plugin names which will be appended to plugins array
	the following 3 functions are required to make the editor play nice under a layout widget, see #4070</description>
      </property>
      <property name="setValueDeferred" scope="instance" type="Object"/>
      <property name="_steps" scope="instance" type="Array"/>
      <property name="_undoedSteps" scope="instance" type="Array"/>
      <property name="commands" scope="instance" type="Object"/>
      <property name="toolbar" scope="instance" type="Object"/>
      <property name="_plugins" scope="instance-prototype" type="Array"/>
      <property name="_layoutMode" scope="instance" type="Object"/>
      <property name="customUndo" scope="instance" type="Boolean">
        <description>Whether we shall use custom undo/redo support instead of the native
	browser support. By default, we now use custom undo.  It works better
	than native browser support and provides a consistent behavior across
	browsers with a minimal performance hit.  We already had the hit on
	the slowest browser, IE, anyway.</description>
      </property>
      <property name="editActionInterval" scope="instance" type="Integer">
        <description>When using customUndo, not every keystroke will be saved as a step.
	Instead typing (including delete) will be grouped together: after
	a user stops typing for editActionInterval seconds, a step will be
	saved; if a user resume typing within editActionInterval seconds,
	the timeout will be restarted. By default, editActionInterval is 3
	seconds.</description>
      </property>
      <property name="_inEditing" scope="instance" type="bool"/>
      <property name="_editTimer" scope="instance" type="Object"/>
      <property name="_undoRedoActive" scope="instance" type="Object"/>
      <property name="_savedSelection" scope="instance" type="Object"/>
      <property name="_editInterval" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.Editor.editingArea.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.Editor.iframe.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.Editor.document"/>
  <class type="dijit.Editor.document.body">
    <properties>
      <property name="clientWidth" scope="instance" type="Object"/>
      <property name="clientHeight" scope="instance" type="Object"/>
      <property name="clientLeft" scope="instance" type="Object"/>
      <property name="offsetWidth" scope="instance" type="Object"/>
      <property name="offsetHeight" scope="instance" type="Object"/>
      <property name="offsetLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor">
    <methods>
      <method name="escapeXml" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="noSingleQuotes" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getNodeHtml" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getChildrenHtml" scope="instance">
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="html" scope="instance" type="Object"/>
      <property name="range" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
          <parameter name="node" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="tf" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateState" scope="instance">
        <description>This is called on meaningful events in the editor, such as change of selection
	or caret position (but not simple typing of alphanumeric keys).   It gives the
	plugin a chance to update the CSS of its button.
	For example, the "bold" plugin will highlight/unhighlight the bold button depending on whether the
	characters next to the caret are bold or not.
	Only makes sense when `useDefaultCommand` is true, as it calls Editor.queryCommandEnabled(`command`).</description>
      </method>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required"/>
        </parameters>
      </method>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="dijit.Toolbar" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <description>Sets named properties on a plugin which may potentially be handled by a
	setter in the plugin.
	For example, if the plugin has a properties "foo"
	and "bar" and a method named "_setFooAttr", calling:
		plugin.set("foo", "Howdy!");
	would be equivalent to writing:
		plugin._setFooAttr("Howdy!");
	and:
		plugin.set("bar", 3);
	would be equivalent to writing:
		plugin.bar = 3;
	set() may also be called with a hash of name/value pairs, ex:
		plugin.set({
			foo: "Howdy",
			bar: 3
		})
	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)</description>
        <parameters>
          <parameter name="name" type="attribute" usage="required">
            <description>The property to set.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to set in the property.</description>
          </parameter>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <description>Get a named property from a plugin. The property may
	potentially be retrieved via a getter method. If no getter is defined, this
	just retrieves the object's property.
	For example, if the plugin has a properties "foo"
	and "bar" and a method named "_getFooAttr", calling:
		plugin.get("foo");
	would be equivalent to writing:
		plugin._getFooAttr();
	and:
		plugin.get("bar");
	would be equivalent to writing:
		plugin.bar;</description>
        <parameters>
          <parameter name="name" type="The" usage="required">
            <description>property to get.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttrNames" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="editor" scope="instance" type="dijit.Editor">
        <description>Points to the parent editor</description>
      </property>
      <property name="iconClassPrefix" scope="instance" type="String">
        <description>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;</description>
      </property>
      <property name="button" scope="instance" type="dijit._Widget">
        <description>Pointer to &lt;code&gt;dijit.form.Button&lt;/code&gt; or other widget (ex: &lt;code&gt;dijit.form.FilteringSelect&lt;/code&gt;)
	that is added to the toolbar to control this plugin.
	If not specified, will be created on initialization according to &lt;code&gt;buttonClass&lt;/code&gt;</description>
      </property>
      <property name="command" scope="instance" type="String">
        <description>String like &amp;quot;insertUnorderedList&amp;quot;, &amp;quot;outdent&amp;quot;, &amp;quot;justifyCenter&amp;quot;, etc. that represents an editor command.
	Passed to editor.execCommand() if &lt;code&gt;useDefaultCommand&lt;/code&gt; is true.</description>
      </property>
      <property name="useDefaultCommand" scope="instance" type="Boolean">
        <description>If true, this plugin executes by calling Editor.execCommand() with the argument specified in &lt;code&gt;command&lt;/code&gt;.</description>
      </property>
      <property name="buttonClass" scope="instance" type="Widget">
        <description>Class
	Class of widget (ex: dijit.form.Button or dijit.form.FilteringSelect)
	that is added to the toolbar to control this plugin.
	This is used to instantiate the button, unless &lt;code&gt;button&lt;/code&gt; itself is specified directly.</description>
      </property>
      <property name="disabled" scope="instance" type="Boolean">
        <description>Flag to indicate if this plugin has been disabled and should do nothing
	helps control button state, among other things.  Set via the setter api.</description>
      </property>
      <property name="enabled" scope="instance" type="Object"/>
      <property name="checked" scope="instance" type="Object"/>
      <property name="_attrPairNames" scope="instance-prototype" type="Object"/>
      <property name="params" scope="instance" type="Object"/>
      <property name="_connects" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.InlineEditBox" superclass="dijit._Widget">
    <description>Behavior for an existing node (`&lt;p&gt;`, `&lt;div&gt;`, `&lt;span&gt;`, etc.) so that
	when you click it, an editor shows up in place of the original
	text.  Optionally, Save and Cancel button are displayed below the edit widget.
	When Save is clicked, the text is pulled from the edit
	widget and redisplayed and the edit widget is again hidden.
	By default a plain Textarea widget is used as the editor (or for
	inline values a TextBox), but you can specify an editor such as
	dijit.Editor (for editing HTML) or a Slider (for adjusting a number).
	An edit widget must support the following API to be used:
	- displayedValue or value as initialization parameter,
	and available through set('displayedValue') / set('value')
	- void focus()
	- DOM-node focusNode = node containing editable text</description>
    <methods>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOver" scope="instance"/>
      <method name="_onMouseOut" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="edit" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_showText" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required">
            <description>Focus on the display mode text</description>
          </parameter>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="cancel" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="editing" scope="instance" type="Boolean">
        <description>Is the node currently in edit mode?</description>
      </property>
      <property name="autoSave" scope="instance" type="Boolean">
        <description>Changing the value automatically saves it; don't have to push save button
	(and save button isn't even displayed)</description>
      </property>
      <property name="buttonSave" scope="instance" type="String">
        <description>Save button label</description>
      </property>
      <property name="buttonCancel" scope="instance" type="String">
        <description>Cancel button label</description>
      </property>
      <property name="renderAsHtml" scope="instance" type="Boolean">
        <description>Set this to true if the specified Editor's value should be interpreted as HTML
	rather than plain text (ex: &lt;code&gt;dijit.Editor&lt;/code&gt;)</description>
      </property>
      <property name="editor" scope="instance" type="String|Function">
        <description>Class name (or reference to the Class) for Editor widget</description>
      </property>
      <property name="editorWrapper" scope="instance" type="String|Function">
        <description>Class name (or reference to the Class) for widget that wraps the editor widget, displaying save/cancel
	buttons.</description>
      </property>
      <property name="editorParams" scope="instance-prototype" type="Object">
        <description>Set of parameters for editor, like {required: true}</description>
      </property>
      <property name="disabled" scope="instance" type="Boolean">
        <description>If true, clicking the InlineEditBox to edit it will have no effect.</description>
      </property>
      <property name="width" scope="instance" type="String">
        <description>Width of editor.  By default it's width=100% (ie, block mode).</description>
      </property>
      <property name="value" scope="instance" type="String">
        <description>The display value of the widget in read-only mode</description>
      </property>
      <property name="noValueIndicator" scope="instance" type="String">
        <description>The text that gets displayed when there is no value (so that the user has a place to click to edit)</description>
      </property>
      <property name="_savedPosition" scope="instance" type="Object"/>
      <property name="_savedOpacity" scope="instance" type="Object"/>
      <property name="_savedTabIndex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.InlineEditBox.displayNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.InlineEditBox.wrapperWidget">
    <properties>
      <property name="editWidget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._InlineEditor" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_onIntermediateChange" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="getValue" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <description>For autoSave widgets, if Esc/Enter, call cancel/save.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_onChange" scope="instance"/>
      <method name="enableSave" scope="instance"/>
      <method name="focus" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="messages" scope="instance" type="Object"/>
      <property name="sourceStyle" scope="instance" type="Object"/>
      <property name="editWidget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._InlineEditor.inlineEditBox">
    <properties>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._InlineEditor.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MenuBase" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="onExecute" scope="instance"/>
      <method name="onCancel" scope="instance">
        <parameters>
          <parameter name="closeAll" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToPopup" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onPopupHover" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onItemHover" scope="instance">
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="_onChildBlur" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onItemUnhover" scope="instance">
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="_stopPopupTimer" scope="instance"/>
      <method name="_stopPendingCloseTimer" scope="instance">
        <parameters>
          <parameter name="popup" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_stopFocusTimer" scope="instance"/>
      <method name="_getTopMenu" scope="instance"/>
      <method name="onItemClick" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_openPopup" scope="instance">
        <return-types>
          <return-type type="the focused child lost focus since the timer was started"/>
        </return-types>
      </method>
      <method name="_markActive" scope="instance"/>
      <method name="onOpen" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_markInactive" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="_closeChild" scope="instance"/>
      <method name="_onItemFocus" scope="instance">
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_cleanUp" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._KeyNavContainer.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._KeyNavContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="parentMenu" scope="instance" type="Widget">
        <description>pointer to menu that displayed me</description>
      </property>
      <property name="popupDelay" scope="instance" type="Integer">
        <description>number of milliseconds before hovering (without clicking) causes the popup to automatically open.</description>
      </property>
      <property name="hover_timer" scope="instance" type="Object"/>
      <property name="_hoveredChild" scope="instance" type="Object"/>
      <property name="_focus_timer" scope="instance" type="Object"/>
      <property name="isActive" scope="instance" type="bool"/>
      <property name="isShowingNow" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit._MenuBase.currentPopup"/>
  <class type="dijit._MenuBase.currentPopup.parentMenu">
    <properties>
      <property name="focusedChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MenuBase.focusedChild"/>
  <class type="dijit._MenuBase.focusedChild.popup">
    <properties>
      <property name="parentMenu" scope="instance" type="Object"/>
      <property name="from_item" scope="instance" type="Object"/>
      <property name="_focus_timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Menu" superclass="dijit._MenuBase">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_iframeContentWindow" scope="instance">
        <parameters>
          <parameter name="iframe_el" type="HTMLIFrameElement" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Window"/>
        </return-types>
      </method>
      <method name="_iframeContentDocument" scope="instance">
        <parameters>
          <parameter name="iframe_el" type="HTMLIFrameElement" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="HTMLDocument"/>
        </return-types>
      </method>
      <method name="bindDomNode" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="unBindDomNode" scope="instance">
        <parameters>
          <parameter name="nodeName" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_scheduleOpen" scope="instance">
        <parameters>
          <parameter name="target" type="DomNode" usage="optional"/>
          <parameter name="iframe" type="DomNode" usage="optional"/>
          <parameter name="coords" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_openMyself" scope="instance">
        <parameters>
          <parameter name="args" type="This" usage="required">
            <description>is an Object containing:
	* target:
	The node that is being clicked
	* iframe:
	If an &amp;lt;iframe&amp;gt; is being clicked, iframe points to that iframe
	* coords:
	Put menu at specified x/y position in viewport, or if iframe is
	specified, then relative to iframe.
	_openMyself() formerly took the event object, and since various code references
	evt.target (after connecting to _openMyself()), using an Object for parameters
	(so that old code still works).</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="getPlaceholders" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="optional">
            <description>Label to search for - if not specified, then all placeholders
	are returned</description>
          </parameter>
        </parameters>
        <return-description>An array of placeholders that match the given label</return-description>
        <return-types>
          <return-type type="Array&lt;dojox.widget.PlaceholderMenuItem&gt;"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._MenuBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="targetNodeIds" scope="instance" type="Array&lt;String&gt;">
        <description>Array of dom node ids of nodes to attach to.
	Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.</description>
      </property>
      <property name="contextMenuForWindow" scope="instance" type="Boolean">
        <description>If true, right clicking anywhere on the window will cause this context menu to open.
	If false, must specify targetNodeIds.</description>
      </property>
      <property name="leftClickToOpen" scope="instance" type="Boolean">
        <description>If true, menu will open on left click instead of right click, similiar to a file menu.</description>
      </property>
      <property name="refocus" scope="instance" type="Boolean">
        <description>When this menu closes, re-focus the element which had focus before it was opened.</description>
      </property>
      <property name="_openSubMenuKey" scope="instance" type="Object"/>
      <property name="_closeSubMenuKey" scope="instance" type="Object"/>
      <property name="_openTimer" scope="instance" type="Object"/>
      <property name="_bindings" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.MenuBar" superclass="dijit._MenuBase">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="focusChild" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onItemClick" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._MenuBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_isMenuBar" scope="instance" type="Boolean">
        <description>This is a MenuBar widget, not a (vertical) Menu widget.</description>
      </property>
      <property name="_orient" scope="instance" type="Object"/>
      <property name="focusedChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo">
    <methods>
      <method name="attr" scope="instance">
        <description>Handles normalized getting and setting of attributes on DOM
	Nodes. If 2 arguments are passed, and a the second argumnt is a
	string, acts as a getter.
	If a third argument is passed, or if the second argument is a
	map of attributes, acts as a setter.
	When passing functions as values, note that they will not be
	directly assigned to slots on the node, but rather the default
	behavior will be removed and the new behavior will be added
	using `dojo.connect()`, meaning that event handler properties
	will be normalized and that some caveats with regards to
	non-standard behaviors for onsubmit apply. Namely that you
	should cancel form submission using `dojo.stopEvent()` on the
	passed event object instead of returning a boolean value from
	the handler itself.</description>
        <examples>
          <example>	// get the current value of the "foo" attribute on a node
		dojo.attr(dojo.byId("nodeId"), "foo");
		// or we can just pass the id:
		dojo.attr("nodeId", "foo");</example>
          <example>	// use attr() to set the tab index
		dojo.attr("nodeId", "tabIndex", 3);</example>
          <example>Set multiple values at once, including event handlers:
		dojo.attr("formId", {
			"foo": "bar",
			"tabIndex": -1,
			"method": "POST",
			"onsubmit": function(e){
				// stop submitting the form. Note that the IE behavior
				// of returning true or false will have no effect here
				// since our handler is connect()ed to the built-in
				// onsubmit behavior and so we need to use
				// dojo.stopEvent() to ensure that the submission
				// doesn't proceed.
				dojo.stopEvent(e);
				// submit the form with Ajax
				dojo.xhrPost({ form: "formId" });
			}
		});</example>
          <example>Style is s special case: Only set with an object hash of styles
		dojo.attr("someNode",{
			id:"bar",
			style:{
				width:"200px", height:"100px", color:"#000"
			}
		});</example>
          <example>Again, only set style as an object hash of styles:
		var obj = { color:"#fff", backgroundColor:"#000" };
		dojo.attr("someNode", "style", obj);
		// though shorter to use `dojo.style()` in this case:
		dojo.style("someNode", obj);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to the element to get or set the attribute on</description>
          </parameter>
          <parameter name="name" type="String|Object" usage="required">
            <description>the name of the attribute to get or set.</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>The value to set for the attribute</description>
          </parameter>
        </parameters>
        <return-description>when used as a getter, the value of the requested attribute
	or null if that attribute does not have a specified or
	default value;
	when used as a setter, the DOM node</return-description>
        <return-types>
          <return-type type="DomNode"/>
          <return-type type="Anything"/>
        </return-types>
      </method>
      <method name="hasAttr" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to the element to check</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>the name of the attribute</description>
          </parameter>
        </parameters>
        <return-description>true if the requested attribute is specified on the
	given element, and false otherwise</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="style" scope="instance">
        <description>Getting the style value uses the computed style for the node, so the value
	will be a calculated value, not just the immediate node.style value.
	Also when getting values, use specific style names,
	like "borderBottomWidth" instead of "border" since compound values like
	"border" are not necessarily reflected as expected.
	If you want to get node dimensions, use `dojo.marginBox()`,
	`dojo.contentBox()` or `dojo.position()`.</description>
        <examples>
          <example>Passing only an ID or node returns the computed style object of
	the node:
		dojo.style("thinger");</example>
          <example>Passing a node and a style property returns the current
	normalized, computed value for that property:
		dojo.style("thinger", "opacity"); // 1 by default</example>
          <example>Passing a node, a style property, and a value changes the
	current display of the node and returns the new computed value
		dojo.style("thinger", "opacity", 0.5); // == 0.5</example>
          <example>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		dojo.style("thinger", {
			"opacity": 0.5,
			"border": "3px solid black",
			"height": "300px"
		});</example>
          <example>When the CSS style property is hyphenated, the JavaScript property is camelCased.
	font-size becomes fontSize, and so on.
		dojo.style("thinger",{
			fontSize:"14pt",
			letterSpacing:"1.2em"
		});</example>
          <example>dojo.NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
	dojo.style() on every element of the list. See: `dojo.query()` and `dojo.NodeList()`
		dojo.query(".someClassName").style("visibility","hidden");
		// or
		dojo.query("#baz &gt; div").style({
			opacity:0.75,
			fontSize:"13pt"
		});</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to node to get/set style for</description>
          </parameter>
          <parameter name="style" type="String|Object" usage="optional">
            <description>the style property to set in DOM-accessor format
	(&amp;quot;borderWidth&amp;quot;, not &amp;quot;border-width&amp;quot;) or an object with key/value
	pairs suitable for setting each property.</description>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <description>If passed, sets value on the node for style, handling
	cross-browser concerns.  When setting a pixel value,
	be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
	Otherwise, in some cases, some browsers will not apply the style.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_nodeData" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Anything"/>
          <return-type type="Nothing"/>
        </return-types>
      </method>
      <method name="_removeNodeData" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>The node reference to remove data from</description>
          </parameter>
          <parameter name="key" type="String" usage="optional">
            <description>If omitted, remove all data in this dataset.
	If passed, remove only the passed &lt;code&gt;key&lt;/code&gt; in the associated dataset</description>
          </parameter>
        </parameters>
      </method>
      <method name="_gcNodeData" scope="instance">
        <description>super expensive: GC all data in the data for nodes that no longer exist in the dom.
	MUCH safer to do this yourself, manually, on a per-node basis (via `NodeList.removeData()`)
	provided as a stop-gap for exceptionally large/complex applications with constantly changing
	content regions (eg: a dijit.layout.ContentPane with replacing data)
	There is NO automatic GC going on. If you dojo.destroy() a node, you should _removeNodeData
	prior to destruction.</description>
      </method>
      <method name="blendColors" scope="instance">
        <parameters>
          <parameter name="start" type="dojo.Color" usage="required"/>
          <parameter name="end" type="dojo.Color" usage="required"/>
          <parameter name="weight" type="Number" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromRgb" scope="instance">
        <description>this function can handle all 4 CSS3 Color Module formats: rgb,
	rgba, hsl, hsla, including rgb(a) with percentage values.</description>
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromHex" scope="instance">
        <examples>
          <example> var thing = dojo.colorFromHex("#ededed"); // grey, longhand</example>
          <example> var thing = dojo.colorFromHex("#000"); // black, shorthand</example>
        </examples>
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromArray" scope="instance">
        <examples>
          <example> var myColor = dojo.colorFromArray([237,237,237,0.5]); // grey, 50% alpha</example>
        </examples>
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromString" scope="instance">
        <description>Acceptable input values for str may include arrays of any form
	accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
	rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
	10, 50)"</description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
      </method>
      <method name="when" scope="instance">
        <examples>
          <example>	function printFirstAndList(items){
			dojo.when(findFirst(items), console.log);
			dojo.when(findLast(items), console.log);
		}
		function findFirst(items){
			return dojo.when(items, function(items){
				return items[0];
			});
		}
		function findLast(items){
			return dojo.when(items, function(items){
				return items[items.length];
			});
		}
	And now all three of his functions can be used sync or async.
		printFirstAndLast([1,2,3,4]) will work just as well as
		printFirstAndLast(dojo.xhrGet(...));</example>
        </examples>
        <parameters>
          <parameter name="promiseOrValue" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="optional"/>
          <parameter name="errback" type="Function" usage="optional"/>
          <parameter name="progressHandler" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="_xhrObj" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadUri" scope="instance">
        <description>Wanted to override getText(), but it is used by
	the widget code in too many, synchronous ways right now.</description>
        <parameters>
          <parameter name="uri" type="String" usage="required">
            <description>a uri which points at the script to be loaded</description>
          </parameter>
          <parameter name="cb" type="Function" usage="required">
            <description>a callback function to process the result of evaluating the script
	as an expression, typically used by the resource bundle loader to
	load JSON-style resources</description>
          </parameter>
          <parameter name="currentIsXDomain" type="boolean" usage="required"/>
          <parameter name="module" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_isDocumentOk" scope="instance">
        <parameters>
          <parameter name="http" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getText" scope="instance">
        <parameters>
          <parameter name="uri" type="URI" usage="required">
            <description>A relative or absolute uri.</description>
          </parameter>
          <parameter name="fail_ok" type="Boolean" usage="required">
            <description>Default false. If fail_ok and loading fails, return null
	instead of throwing.</description>
          </parameter>
        </parameters>
        <return-description>The response text. null is returned when there is a
	failure and failure is okay (an exception otherwise)</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="windowUnloaded" scope="instance"/>
      <method name="addOnWindowUnload" scope="instance">
        <examples>
          <example>	dojo.addOnWindowUnload(functionPointer)
		dojo.addOnWindowUnload(object, "functionName")
		dojo.addOnWindowUnload(object, function(){ /* ... */});</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object" usage="optional"/>
          <parameter name="functionName" type="String|Function" usage="optional"/>
        </parameters>
      </method>
      <method name="pushContext" scope="instance">
        <description>dojo.pushContext treats contexts as a stack. The
	auto-detected contexts which are initially provided using
	dojo.setContext() require authors to keep state in order to
	"return" to a previous context, whereas the
	dojo.pushContext and dojo.popContext methods provide a more
	natural way to augment blocks of code to ensure that they
	execute in a different window or frame without issue. If
	called without any arguments, the default context (the
	context when Dojo is first loaded) is instead pushed into
	the stack. If only a single string is passed, a node in the
	intitial context's document is looked up and its
	contextWindow and contextDocument properties are used as
	the context to push. This means that iframes can be given
	an ID and code can be executed in the scope of the iframe's
	document in subsequent calls easily.</description>
        <parameters>
          <parameter name="g" type="Object|String" usage="optional">
            <description>The global context. If a string, the id of the frame to
	search for a context and document.</description>
          </parameter>
          <parameter name="d" type="MDocumentElement" usage="optional">
            <description>The document element to execute subsequent code with.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="popContext" scope="instance"/>
      <method name="_inContext" scope="instance">
        <parameters>
          <parameter name="g" type="Object" usage="required"/>
          <parameter name="d" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadInit" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="byId" scope="instance">
        <examples>
          <example>Look up a node by ID:
		var n = dojo.byId("foo");</example>
          <example>Check if a node exists, and use it.
		var n = dojo.byId("bar");
		if(n){ doStuff() ... }</example>
          <example>Allow string or DomNode references to be passed to a custom function:
		var foo = function(nodeOrId){
			nodeOrId = dojo.byId(nodeOrId);
			// ... more stuff
		}</example>
        </examples>
        <parameters>
          <parameter name="id" type="String|DOMNode" usage="required">
            <description>A string to match an HTML id attribute or a reference to a DOM Node</description>
          </parameter>
          <parameter name="doc" type="Document" usage="required">
            <description>Document to work in. Defaults to the current value of
	dojo.doc.  Can be used to retrieve
	node references from other documents.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="assume it's a node"/>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="_isLocalUrl" scope="instance">
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="exit" scope="instance">
        <parameters>
          <parameter name="exitcode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="body" scope="instance">
        <examples>
          <example>	dojo.body().appendChild(dojo.doc.createElement('div'));</example>
        </examples>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_spidermonkeyCurrentFile" scope="instance">
        <parameters>
          <parameter name="depth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moduleHasPrefix" scope="instance">
        <parameters>
          <parameter name="module" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getModulePrefix" scope="instance">
        <parameters>
          <parameter name="module" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_loadPath" scope="instance">
        <description>Loads and interprets the script located at relpath, which is
	relative to the script root directory.  If the script is found but
	its interpretation causes a runtime exception, that exception is
	not caught by us, so the caller will see it.  We return a true
	value if and only if the script is found.</description>
        <parameters>
          <parameter name="relpath" type="String" usage="required">
            <description>A relative path to a script (no leading '/', and typically ending
	in '.js').</description>
          </parameter>
          <parameter name="module" type="String" usage="optional">
            <description>A module whose existance to check for after loading a path.  Can be
	used to determine success or failure of the load.</description>
          </parameter>
          <parameter name="cb" type="Function" usage="optional">
            <description>a callback function to pass the result of evaluating the script</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_loadUriAndCheck" scope="instance">
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="cb" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loaded" scope="instance"/>
      <method name="unloaded" scope="instance"/>
      <method name="_onto" scope="instance">
        <parameters>
          <parameter name="arr" type="Object" usage="required"/>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ready" scope="instance"/>
      <method name="addOnLoad" scope="instance">
        <description>Registers a function to be triggered after the DOM has finished
	loading and `dojo.require` modules have loaded. Widgets declared in markup
	have been instantiated if `djConfig.parseOnLoad` is true when this fires.
	Images and CSS files may or may not have finished downloading when
	the specified function is called.  (Note that widgets' CSS and HTML
	code is guaranteed to be downloaded before said widgets are
	instantiated, though including css resouces BEFORE any script elements
	is highly recommended).</description>
        <examples>
          <example>Register an anonymous function to run when everything is ready
		dojo.addOnLoad(function(){ doStuff(); });</example>
          <example>Register a function to run when everything is ready by pointer:
		var init = function(){ doStuff(); }
		dojo.addOnLoad(init);</example>
          <example>Register a function to run scoped to `object`, either by name or anonymously:
		dojo.addOnLoad(object, "functionName");
		dojo.addOnLoad(object, function(){ doStuff(); });</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="functionName" type="String|Function" usage="optional"/>
        </parameters>
      </method>
      <method name="_modulesLoaded" scope="instance"/>
      <method name="_callLoaded" scope="instance"/>
      <method name="_getModuleSymbols" scope="instance">
        <parameters>
          <parameter name="modulename" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="loadInit" scope="instance">
        <description>This function is mainly a marker for the xdomain loader to know parts of
	code that needs be executed outside the function wrappper that is placed around modules.
	The init function could be executed more than once, and it should make no assumptions
	on what is loaded, or what modules are available. Only the functionality in Dojo Base
	is allowed to be used. Avoid using this method. For a valid use case,
	see the source for dojox.gfx.</description>
        <parameters>
          <parameter name="init" type="Function" usage="required">
            <description>a function reference. Executed immediately.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_loadModule" scope="instance"/>
      <method name="require" scope="instance">
        <description>Modules are loaded via dojo.require by using one of two loaders: the normal loader
	and the xdomain loader. The xdomain loader is used when dojo was built with a
	custom build that specified loader=xdomain and the module lives on a modulePath
	that is a whole URL, with protocol and a domain. The versions of Dojo that are on
	the Google and AOL CDNs use the xdomain loader.
	If the module is loaded via the xdomain loader, it is an asynchronous load, since
	the module is added via a dynamically created script tag. This
	means that dojo.require() can return before the module has loaded. However, this
	should only happen in the case where you do dojo.require calls in the top-level
	HTML page, or if you purposely avoid the loader checking for dojo.require
	dependencies in your module by using a syntax like dojo["require"] to load the module.
	Sometimes it is useful to not have the loader detect the dojo.require calls in the
	module so that you can dynamically load the modules as a result of an action on the
	page, instead of right at module load time.
	Also, for script blocks in an HTML page, the loader does not pre-process them, so
	it does not know to download the modules before the dojo.require calls occur.
	So, in those two cases, when you want on-the-fly module loading or for script blocks
	in the HTML page, special care must be taken if the dojo.required code is loaded
	asynchronously. To make sure you can execute code that depends on the dojo.required
	modules, be sure to add the code that depends on the modules in a dojo.addOnLoad()
	callback. dojo.addOnLoad waits for all outstanding modules to finish loading before
	executing.
	This type of syntax works with both xdomain and normal loaders, so it is good
	practice to always use this idiom for on-the-fly code loading and in HTML script
	blocks. If at some point you change loaders and where the code is loaded from,
	it will all still work.
	More on how dojo.require
	`dojo.require("A.B")` first checks to see if symbol A.B is
	defined. If it is, it is simply returned (nothing to do).
	If it is not defined, it will look for `A/B.js` in the script root
	directory.
	`dojo.require` throws an exception if it cannot find a file
	to load, or if the symbol `A.B` is not defined after loading.
	It returns the object `A.B`, but note the caveats above about on-the-fly loading and
	HTML script blocks when the xdomain loader is loading a module.
	`dojo.require()` does nothing about importing symbols into
	the current namespace.  It is presumed that the caller will
	take care of that.</description>
        <examples>
          <example>To use dojo.require in conjunction with dojo.ready:
		dojo.require("foo");
		dojo.require("bar");
		dojo.addOnLoad(function(){
			//you can now safely do something with foo and bar
		});</example>
          <example>For example, to import all symbols into a local block, you might write:
		with (dojo.require("A.B")) {
			...
		}
	And to import just the leaf symbol to a local variable:
		var B = dojo.require("A.B");
		...</example>
        </examples>
        <parameters>
          <parameter name="moduleName" type="String" usage="required">
            <description>module name to load, using periods for separators,
	e.g. &amp;quot;dojo.date.locale&amp;quot;.  Module paths are de-referenced by dojo's
	internal mapping of locations to names and are disambiguated by
	longest prefix. See &lt;code&gt;dojo.registerModulePath()&lt;/code&gt; for details on
	registering new modules.</description>
          </parameter>
          <parameter name="omitModuleCheck" type="Boolean" usage="optional">
            <description>if &lt;code&gt;true&lt;/code&gt;, omitModuleCheck skips the step of ensuring that the
	loaded file actually defines the symbol it is referenced by.
	For example if it called as &lt;code&gt;dojo.require(&amp;quot;a.b.c&amp;quot;)&lt;/code&gt; and the
	file located at &lt;code&gt;a/b/c.js&lt;/code&gt; does not define an object &lt;code&gt;a.b.c&lt;/code&gt;,
	and exception will be throws whereas no exception is raised
	when called as &lt;code&gt;dojo.require(&amp;quot;a.b.c&amp;quot;, true)&lt;/code&gt;</description>
          </parameter>
        </parameters>
        <return-description>the required namespace object</return-description>
      </method>
      <method name="provide" scope="instance">
        <description>Each javascript source file is called a resource.  When a
	resource is loaded by the browser, `dojo.provide()` registers
	that it has been loaded.
	Each javascript source file must have at least one
	`dojo.provide()` call at the top of the file, corresponding to
	the file name.  For example, `js/dojo/foo.js` must have
	`dojo.provide("dojo.foo");` before any calls to
	`dojo.require()` are made.
	For backwards compatibility reasons, in addition to registering
	the resource, `dojo.provide()` also ensures that the javascript
	object for the module exists.  For example,
	`dojo.provide("dojox.data.FlickrStore")`, in addition to
	registering that `FlickrStore.js` is a resource for the
	`dojox.data` module, will ensure that the `dojox.data`
	javascript object exists, so that calls like
	`dojo.data.foo = function(){ ... }` don't fail.
	In the case of a build where multiple javascript source files
	are combined into one bigger file (similar to a .lib or .jar
	file), that file may contain multiple dojo.provide() calls, to
	note that it includes multiple resources.</description>
        <examples>
          <example>Safely create a `my` object, and make dojo.require("my.CustomModule") work
		dojo.provide("my.CustomModule");</example>
        </examples>
        <parameters>
          <parameter name="resourceName" type="String" usage="required">
            <description>A dot-sperated string identifying a resource.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="platformRequire" scope="instance">
        <description>This method takes a "map" of arrays which one can use to
	optionally load dojo modules. The map is indexed by the
	possible dojo.name_ values, with two additional values:
	"default" and "common". The items in the "default" array will
	be loaded if none of the other items have been choosen based on
	dojo.name_, set by your host environment. The items in the
	"common" array will *always* be loaded, regardless of which
	list is chosen.</description>
        <examples>
          <example>	dojo.platformRequire({
			browser: [
				"foo.sample", // simple module
				"foo.test",
				["foo.bar.baz", true] // skip object check in _loadModule (dojo.require)
			],
			default: [ "foo.sample._base" ],
			common: [ "important.module.common" ]
		});</example>
        </examples>
        <parameters>
          <parameter name="modMap" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="requireIf" scope="instance">
        <examples>
          <example>	dojo.requireIf(dojo.isBrowser, "my.special.Module");</example>
        </examples>
        <parameters>
          <parameter name="condition" type="Boolean" usage="required"/>
          <parameter name="resourceName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="registerModulePath" scope="instance">
        <description>An unregistered module is given the default path of ../[module],
	relative to Dojo root. For example, module acme is mapped to
	../acme.  If you want to use a different module name, use
	dojo.registerModulePath.</description>
        <examples>
          <example>If your dojo.js is located at this location in the web root:
		/myapp/js/dojo/dojo/dojo.js
	and your modules are located at:
		/myapp/js/foo/bar.js
		/myapp/js/foo/baz.js
		/myapp/js/foo/thud/xyzzy.js
	Your application can tell Dojo to locate the "foo" namespace by calling:
		dojo.registerModulePath("foo", "../../foo");
	At which point you can then use dojo.require() to load the
	modules (assuming they provide() the same things which are
	required). The full code might be:
		&lt;script type="text/javascript"
			src="/myapp/js/dojo/dojo/dojo.js"&gt;&lt;/script&gt;
		&lt;script type="text/javascript"&gt;
			dojo.registerModulePath("foo", "../../foo");
			dojo.require("foo.bar");
			dojo.require("foo.baz");
			dojo.require("foo.thud.xyzzy");
		&lt;/script&gt;</example>
        </examples>
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="prefix" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="requireLocalization" scope="instance">
        <description>Load translated resource bundles provided underneath the "nls"
	directory within a package.  Translated resources may be located in
	different packages throughout the source tree.
	Each directory is named for a locale as specified by RFC 3066,
	(http://www.ietf.org/rfc/rfc3066.txt), normalized in lowercase.
	Note that the two bundles in the example do not define all the
	same variants.  For a given locale, bundles will be loaded for
	that locale and all more general locales above it, including a
	fallback at the root directory.  For example, a declaration for
	the "de-at" locale will first load `nls/de-at/bundleone.js`,
	then `nls/de/bundleone.js` and finally `nls/bundleone.js`.  The
	data will be flattened into a single Object so that lookups
	will follow this cascading pattern.  An optional build step can
	preload the bundles to avoid data redundancy and the multiple
	network hits normally required to load these resources.</description>
        <examples>
          <example>A particular widget may define one or more resource bundles,
	structured in a program as follows, where moduleName is
	mycode.mywidget and bundleNames available include bundleone and
	bundletwo:
			...
		mycode/
			mywidget/
				nls/
					bundleone.js (the fallback translation, English in this example)
					bundletwo.js (also a fallback translation)
					de/
						bundleone.js
						bundletwo.js
					de-at/
						bundleone.js
					en/
						(empty; use the fallback translation)
					en-us/
						bundleone.js
					en-gb/
						bundleone.js
					es/
						bundleone.js
						bundletwo.js
					  ...etc
					...</example>
        </examples>
        <parameters>
          <parameter name="moduleName" type="String" usage="required">
            <description>name of the package containing the &amp;quot;nls&amp;quot; directory in which the
	bundle is found</description>
          </parameter>
          <parameter name="bundleName" type="String" usage="required">
            <description>bundle name, i.e. the filename without the '.js' suffix. Using &amp;quot;nls&amp;quot; as a
	a bundle name is not supported, since &amp;quot;nls&amp;quot; is the name of the folder
	that holds bundles. Using &amp;quot;nls&amp;quot; as the bundle name will cause problems
	with the custom build.</description>
          </parameter>
          <parameter name="locale" type="String" usage="optional">
            <description>the locale to load (optional)  By default, the browser's user
	locale as defined by dojo.locale</description>
          </parameter>
          <parameter name="availableFlatLocales" type="String" usage="optional">
            <description>A comma-separated list of the available, flattened locales for this
	bundle. This argument should only be set by the build process.</description>
          </parameter>
        </parameters>
      </method>
      <method name="moduleUrl" scope="instance">
        <examples>
          <example>	var pngPath = dojo.moduleUrl("acme","images/small.png");
		console.dir(pngPath); // list the object properties
		// create an image and set it's source to pngPath's value:
		var img = document.createElement("img");
		// NOTE: we assign the string representation of the url object
		img.src = pngPath.toString();
		// add our image to the document
		dojo.body().appendChild(img);</example>
          <example>you may de-reference as far as you like down the package
	hierarchy.  This is sometimes handy to avoid lenghty relative
	urls or for building portable sub-packages. In this example,
	the `acme.widget` and `acme.util` directories may be located
	under different roots (see `dojo.registerModulePath`) but the
	the modules which reference them can be unaware of their
	relative locations on the filesystem:
		// somewhere in a configuration block
		dojo.registerModulePath("acme.widget", "../../acme/widget");
		dojo.registerModulePath("acme.util", "../../util");
		// ...
		// code in a module using acme resources
		var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
		var dataPath = dojo.moduleUrl("acme.util","resources/data.json");</example>
        </examples>
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="url" type="dojo._Url|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Url"/>
        </return-types>
      </method>
      <method name="_xdDebugFileLoaded" scope="instance">
        <parameters>
          <parameter name="resourceName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xdReset" scope="instance"/>
      <method name="_xdClearInterval" scope="instance"/>
      <method name="_xdCreateResource" scope="instance">
        <parameters>
          <parameter name="contents" type="String" usage="required"/>
          <parameter name="resourceName" type="String" usage="required"/>
          <parameter name="resourcePath" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_xdExtractLoadInits" scope="instance">
        <parameters>
          <parameter name="fileContents" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_xdIsXDomainPath" scope="instance">
        <parameters>
          <parameter name="relpath" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_xdResourceLoaded" scope="instance">
        <parameters>
          <parameter name="res" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xdLoadFlattenedBundle" scope="instance">
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="bundleData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xdInitExtraLocales" scope="instance"/>
      <method name="xdRequireLocalization" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="fLocales" type="Object" usage="required"/>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="availableFlatLocales" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_xdUnpackDependency" scope="instance">
        <parameters>
          <parameter name="dep" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_xdWalkReqs" scope="instance"/>
      <method name="_xdEvalReqs" scope="instance">
        <parameters>
          <parameter name="reqChain" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_xdWatchInFlight" scope="instance"/>
      <method name="_xdNotifyLoaded" scope="instance"/>
      <method name="indexOf" scope="instance">
        <description>This method corresponds to the JavaScript 1.6 Array.indexOf method, with one difference: when
	run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
	1.6's indexOf skips the holes in the sparse array.
	For details on this method, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf</description>
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="fromIndex" type="Integer" usage="optional"/>
          <parameter name="findLast" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="lastIndexOf" scope="instance">
        <description>This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with one difference: when
	run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
	1.6's lastIndexOf skips the holes in the sparse array.
	For details on this method, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf</description>
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="fromIndex" type="Integer" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach</description>
        <examples>
          <example>	// log out all members of the array:
		dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			function(item){
				console.log(item);
			}
		);</example>
          <example>	// log out the members and their indexes
		dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			function(item, idx, arr){
				console.log(item, "at index:", idx);
			}
		);</example>
          <example>	// use a scoped object member as the callback
		var obj = {
			prefix: "logged via obj.callback:",
			callback: function(item){
				console.log(this.prefix, item);
			}
		};
		// specifying the scope function executes the callback in that scope
		dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			obj.callback,
			obj
		);
		// alternately, we can accomplish the same thing with dojo.hitch()
		dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			dojo.hitch(obj, "callback")
		);</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <description>the array to iterate over. If a string, operates on individual characters.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function is invoked with three arguments: item, index, and array</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
      </method>
      <method name="every" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every</description>
        <examples>
          <example>	// returns false
		dojo.every([1, 2, 3, 4], function(item){ return item&gt;1; });</example>
          <example>	// returns true
		dojo.every([1, 2, 3, 4], function(item){ return item&gt;0; });</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <description>the array to iterate on. If a string, operates on individual characters.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function is invoked with three arguments: item, index,
	and array and returns true if the condition is met.</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some</description>
        <examples>
          <example>	// is true
		dojo.some([1, 2, 3, 4], function(item){ return item&gt;1; });</example>
          <example>	// is false
		dojo.some([1, 2, 3, 4], function(item){ return item&lt;1; });</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <description>the array to iterate over. If a string, operates on individual characters.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function is invoked with three arguments: item, index,
	and array and returns true if the condition is met.</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map</description>
        <examples>
          <example>	// returns [2, 3, 4, 5]
		dojo.map([1, 2, 3, 4], function(item){ return item+1 });</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <description>the array to iterate on. If a string, operates on
	individual characters.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function is invoked with three arguments, (item, index,
	array),  and returns a value</description>
          </parameter>
          <parameter name="thisObject" type="Function" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <description>This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter</description>
        <examples>
          <example>	// returns [2, 3, 4]
		dojo.filter([1, 2, 3, 4], function(item){ return item&gt;1; });</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array" usage="required">
            <description>the array to iterate over.</description>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <description>a function that is invoked with three arguments (item,
	index, array). The return of this function is expected to
	be a boolean which determines whether the passed-in item
	will be included in the returned array.</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>may be used to scope the call to callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="connect" scope="instance">
        <description>Connects listeners to actions, so that after event fires, a
	listener is called with the same arguments passed to the original
	function.
	Since `dojo.connect` allows the source of events to be either a
	"regular" JavaScript function or a DOM event, it provides a uniform
	interface for listening to all the types of events that an
	application is likely to deal with though a single, unified
	interface. DOM programmers may want to think of it as
	"addEventListener for everything and anything".
	When setting up a connection, the `event` parameter must be a
	string that is the name of the method/event to be listened for. If
	`obj` is null, `dojo.global` is assumed, meaning that connections
	to global methods are supported but also that you may inadvertently
	connect to a global by passing an incorrect object name or invalid
	reference.
	`dojo.connect` generally is forgiving. If you pass the name of a
	function or method that does not yet exist on `obj`, connect will
	not fail, but will instead set up a stub method. Similarly, null
	arguments may simply be omitted such that fewer than 4 arguments
	may be required to set up a connection See the examples for details.
	The return value is a handle that is needed to
	remove this connection with `dojo.disconnect`.</description>
        <examples>
          <example>When obj.onchange(), do ui.update():
		dojo.connect(obj, "onchange", ui, "update");
		dojo.connect(obj, "onchange", ui, ui.update); // same</example>
          <example>Using return value for disconnect:
		var link = dojo.connect(obj, "onchange", ui, "update");
		...
		dojo.disconnect(link);</example>
          <example>When onglobalevent executes, watcher.handler is invoked:
		dojo.connect(null, "onglobalevent", watcher, "handler");</example>
          <example>When ob.onCustomEvent executes, customEventHandler is invoked:
		dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
		dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same</example>
          <example>When ob.onCustomEvent executes, customEventHandler is invoked
	with the same scope (this):
		dojo.connect(ob, "onCustomEvent", null, customEventHandler);
		dojo.connect(ob, "onCustomEvent", customEventHandler); // same</example>
          <example>When globalEvent executes, globalHandler is invoked
	with the same scope (this):
		dojo.connect(null, "globalEvent", null, globalHandler);
		dojo.connect("globalEvent", globalHandler); // same</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required">
            <description>The source object for the event function.
	Defaults to &lt;code&gt;dojo.global&lt;/code&gt; if null.
	If obj is a DOM node, the connection is delegated
	to the DOM event manager (unless dontFix is true).</description>
          </parameter>
          <parameter name="event" type="String" usage="required">
            <description>name of the event function in obj.
	I.e. identifies a property &lt;code&gt;obj[event]&lt;/code&gt;.</description>
          </parameter>
          <parameter name="context" type="Object|null" usage="required">
            <description>The object that method will receive as &amp;quot;this&amp;quot;.
	If context is null and method is a function, then method
	inherits the context of event.
	If method is a string then context must be the source
	object object for method (context[method]). If context is null,
	dojo.global is used.</description>
          </parameter>
          <parameter name="method" type="String|Function" usage="required">
            <description>A function reference, or name of a function in context.
	The function identified by method fires after event does.
	method receives the same arguments as the event.
	See context argument comments for information on method's scope.</description>
          </parameter>
          <parameter name="dontFix" type="Boolean" usage="optional">
            <description>If obj is a DOM node, set dontFix to true to prevent delegation
	of this connection to the DOM event manager.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_connect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="dontFix" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Handle"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <description>Removes the connection between event and the method referenced by handle.</description>
        <parameters>
          <parameter name="handle" type="Handle" usage="required">
            <description>the return value of the dojo.connect call that created the connection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_disconnect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="handle" type="Object" usage="required"/>
          <parameter name="listener" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectPublisher" scope="instance">
        <examples>
          <example>	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");</example>
        </examples>
        <parameters>
          <parameter name="topic" type="String" usage="required">
            <description>The name of the topic to publish.</description>
          </parameter>
          <parameter name="obj" type="Object|null" usage="required">
            <description>The source object for the event function. Defaults to dojo.global
	if null.</description>
          </parameter>
          <parameter name="event" type="String" usage="required">
            <description>The name of the event function in obj.
	I.e. identifies a property obj[event].</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Handle"/>
        </return-types>
      </method>
      <method name="declare" scope="instance">
        <description>Create a constructor using a compact notation for inheritance and
	prototype extension.
	Mixin ancestors provide a type of multiple inheritance.
	Prototypes of mixin ancestors are copied to the new class:
	changes to mixin prototypes will not affect classes to which
	they have been mixed in.
	Ancestors can be compound classes created by this version of
	dojo.declare. In complex cases all base classes are going to be
	linearized according to C3 MRO algorithm
	(see http://www.python.org/download/releases/2.3/mro/ for more
	details).
	"className" is cached in "declaredClass" property of the new class,
	if it was supplied. The immediate super class will be cached in
	"superclass" property of the new class.
	Methods in "props" will be copied and modified: "nom" property
	(the declared name of the method) will be added to all copied
	functions to help identify them for the internal machinery. Be
	very careful, while reusing methods: if you use the same
	function under different names, it can produce errors in some
	cases.
	It is possible to use constructors created "manually" (without
	dojo.declare) as bases. They will be called as usual during the
	creation of an instance, their methods will be chained, and even
	called by "this.inherited()".
	Special property "-chains-" governs how to chain methods. It is
	a dictionary, which uses method names as keys, and hint strings
	as values. If a hint string is "after", this method will be
	called after methods of its base classes. If a hint string is
	"before", this method will be called before methods of its base
	classes.
	If "constructor" is not mentioned in "-chains-" property, it will
	be chained using the legacy mode: using "after" chaining,
	calling preamble() method before each constructor, if available,
	and calling postscript() after all constructors were executed.
	If the hint is "after", it is chained as a regular method, but
	postscript() will be called after the chain of constructors.
	"constructor" cannot be chained "before", but it allows
	a special hint string: "manual", which means that constructors
	are not going to be chained in any way, and programmer will call
	them manually using this.inherited(). In the latter case
	postscript() will be called after the construction.
	All chaining hints are "inherited" from base classes and
	potentially can be overridden. Be very careful when overriding
	hints! Make sure that all chained methods can work in a proposed
	manner of chaining.
	Once a method was chained, it is impossible to unchain it. The
	only exception is "constructor". You don't need to define a
	method in order to supply a chaining hint.
	If a method is chained, it cannot use this.inherited() because
	all other methods in the hierarchy will be called automatically.
	Usually constructors and initializers of any kind are chained
	using "after" and destructors of any kind are chained as
	"before". Note that chaining assumes that chained methods do not
	return any value: any returned value will be discarded.</description>
        <examples>
          <example>	dojo.declare("my.classes.bar", my.classes.foo, {
			// properties to be added to the class prototype
			someValue: 2,
			// initialization function
			constructor: function(){
				this.myComplicatedObject = new ReallyComplicatedObject();
			},
			// other functions
			someMethod: function(){
				doStuff();
			}
		});</example>
          <example>	var MyBase = dojo.declare(null, {
			// constructor, properties, and methods go here
			// ...
		});
		var MyClass1 = dojo.declare(MyBase, {
			// constructor, properties, and methods go here
			// ...
		});
		var MyClass2 = dojo.declare(MyBase, {
			// constructor, properties, and methods go here
			// ...
		});
		var MyDiamond = dojo.declare([MyClass1, MyClass2], {
			// constructor, properties, and methods go here
			// ...
		});</example>
          <example>	var F = function(){ console.log("raw constructor"); };
		F.prototype.method = function(){
			console.log("raw method");
		};
		var A = dojo.declare(F, {
			constructor: function(){
				console.log("A.constructor");
			},
			method: function(){
				console.log("before calling F.method...");
				this.inherited(arguments);
				console.log("...back in A");
			}
		});
		new A().method();
		// will print:
		// raw constructor
		// A.constructor
		// before calling F.method...
		// raw method
		// ...back in A</example>
          <example>	var A = dojo.declare(null, {
			"-chains-": {
				destroy: "before"
			}
		});
		var B = dojo.declare(A, {
			constructor: function(){
				console.log("B.constructor");
			},
			destroy: function(){
				console.log("B.destroy");
			}
		});
		var C = dojo.declare(B, {
			constructor: function(){
				console.log("C.constructor");
			},
			destroy: function(){
				console.log("C.destroy");
			}
		});
		new C().destroy();
		// prints:
		// B.constructor
		// C.constructor
		// C.destroy
		// B.destroy</example>
          <example>	var A = dojo.declare(null, {
			"-chains-": {
				constructor: "manual"
			}
		});
		var B = dojo.declare(A, {
			constructor: function(){
				// ...
				// call the base constructor with new parameters
				this.inherited(arguments, [1, 2, 3]);
				// ...
			}
		});</example>
          <example>	var A = dojo.declare(null, {
			"-chains-": {
				m1: "before"
			},
			m1: function(){
				console.log("A.m1");
			},
			m2: function(){
				console.log("A.m2");
			}
		});
		var B = dojo.declare(A, {
			"-chains-": {
				m2: "after"
			},
			m1: function(){
				console.log("B.m1");
			},
			m2: function(){
				console.log("B.m2");
			}
		});
		var x = new B();
		x.m1();
		// prints:
		// B.m1
		// A.m1
		x.m2();
		// prints:
		// A.m2
		// B.m2</example>
        </examples>
        <parameters>
          <parameter name="className" type="String" usage="optional">
            <description>The optional name of the constructor (loosely, a &amp;quot;class&amp;quot;)
	stored in the &amp;quot;declaredClass&amp;quot; property in the created prototype.
	It will be used as a global name for a created constructor.</description>
          </parameter>
          <parameter name="superclass" type="Function|Array&lt;Function&gt;" usage="required">
            <description>May be null, a Function, or an Array of Functions. This argument
	specifies a list of bases (the left-most one is the most deepest
	base).</description>
          </parameter>
          <parameter name="props" type="Object" usage="required">
            <description>An object whose properties are copied to the created prototype.
	Add an instance-initialization function by making it a property
	named &amp;quot;constructor&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-description>New constructor function.</return-description>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="safeMixin" scope="instance">
        <description>This function is used to mix in properties like dojo._mixin does,
	but it skips a constructor property and decorates functions like
	dojo.declare does.
	It is meant to be used with classes and objects produced with
	dojo.declare. Functions mixed in with dojo.safeMixin can use
	this.inherited() like normal methods.
	This function is used to implement extend() method of a constructor
	produced with dojo.declare().</description>
        <examples>
          <example>	var A = dojo.declare(null, {
			m1: function(){
				console.log("A.m1");
			},
			m2: function(){
				console.log("A.m2");
			}
		});
		var B = dojo.declare(A, {
			m1: function(){
				this.inherited(arguments);
				console.log("B.m1");
			}
		});
		B.extend({
			m2: function(){
				this.inherited(arguments);
				console.log("B.m2");
			}
		});
		var x = new B();
		dojo.safeMixin(x, {
			m1: function(){
				this.inherited(arguments);
				console.log("X.m1");
			},
			m2: function(){
				this.inherited(arguments);
				console.log("X.m2");
			}
		});
		x.m2();
		// prints:
		// A.m1
		// B.m1
		// X.m1</example>
        </examples>
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <description>Target object to accept new properties.</description>
          </parameter>
          <parameter name="source" type="Object" usage="required">
            <description>Source object for new properties.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fixEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>native event object</description>
          </parameter>
          <parameter name="sender" type="DOMNode" usage="required">
            <description>node to treat as &amp;quot;currentTarget&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="stopEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event object. If omitted, window.event is used on IE.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isCopyKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event object to examine</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_ieDispatcher" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getIeDispatcher" scope="instance">
        <return-types>
          <return-type type="function"/>
        </return-types>
      </method>
      <method name="_fade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeIn" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__FadeArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeOut" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__FadeArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_defaultEasing" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="animateProperty" scope="instance">
        <description>The standard animation doesn't know what to do with something like
	rect(...). This class identifies complex properties by they being a
	string and having parenthesis. If so, that property is made into a
	dojox.fx._Complex object and the getValue() is obtained from
	there.</description>
        <examples>
          <example>A simple animation that changes the width of the specified node.
		dojo.animateProperty({
			node: "nodeId",
			properties: { width: 400 },
		}).play();
	Dojo figures out the start value for the width and converts the
	integer specified for the width to the more expressive but
	verbose form `{ width: { end: '400', units: 'px' } }` which you
	can also specify directly. Defaults to 'px' if ommitted.</example>
          <example>Animate width, height, and padding over 2 seconds... the
	pedantic way:
		dojo.animateProperty({ node: node, duration:2000,
			properties: {
				width: { start: '200', end: '400', units:"px" },
				height: { start:'200', end: '400', units:"px" },
				paddingTop: { start:'5', end:'50', units:"px" }
			}
		}).play();
	Note 'paddingTop' is used over 'padding-top'. Multi-name CSS properties
	are written using "mixed case", as the hyphen is illegal as an object key.</example>
          <example>Plug in a different easing function and register a callback for
	when the animation ends. Easing functions accept values between
	zero and one and return a value on that basis. In this case, an
	exponential-in curve.
		dojo.animateProperty({
			node: "nodeId",
			// dojo figures out the start value
			properties: { width: { end: 400 } },
			easing: function(n){
				return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
			},
			onEnd: function(node){
				// called when the animation finishes. The animation
				// target is passed to this function
			}
		}).play(500); // delay playing half a second</example>
          <example>Like all `dojo.Animation`s, animateProperty returns a handle to the
	Animation instance, which fires the events common to Dojo FX. Use `dojo.connect`
	to access these events outside of the Animation definiton:
		var anim = dojo.animateProperty({
			node:"someId",
			properties:{
				width:400, height:500
			}
		});
		dojo.connect(anim,"onEnd", function(){
			console.log("animation ended");
		});
		// play the animation now:
		anim.play();</example>
          <example>Each property can be a function whose return value is substituted along.
	Additionally, each measurement (eg: start, end) can be a function. The node
	reference is passed direcly to callbacks.
		dojo.animateProperty({
			node:"mine",
			properties:{
				height:function(node){
					// shrink this node by 50%
					return dojo.position(node).h / 2
				},
				width:{
					start:function(node){ return 100; },
					end:function(node){ return 200; }
				}
			}
		}).play();</example>
          <example>	var ani = dojo.animateProperty({
			node:dojo.byId("myDiv"),
			duration:600,
			properties:{
				clip:{start:'rect(0px 50px 50px 0px)', end:'rect(10px 30px 30px 10px)'}
			}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="dojo.__AnimArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="anim" scope="instance">
        <description>`dojo.anim` is a simpler (but somewhat less powerful) version
	of `dojo.animateProperty`.  It uses defaults for many basic properties
	and allows for positional parameters to be used in place of the
	packed "property bag" which is used for other Dojo animation
	methods.
	The `dojo.Animation` object returned from `dojo.anim` will be
	already playing when it is returned from this function, so
	calling play() on it again is (usually) a no-op.</description>
        <examples>
          <example>Fade out a node
		dojo.anim("id", { opacity: 0 });</example>
          <example>Fade out a node over a full second
		dojo.anim("id", { opacity: 0 }, 1000);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>a DOM node or the id of a node to animate CSS properties on</description>
          </parameter>
          <parameter name="properties" type="Object" usage="required"/>
          <parameter name="duration" type="Integer" usage="optional">
            <description>The number of milliseconds over which the animation
	should run. Defaults to the global animation default duration
	(350ms).</description>
          </parameter>
          <parameter name="easing" type="Function" usage="optional">
            <description>An easing function over which to calculate acceleration
	and deceleration of the animation through its duration.
	A default easing algorithm is provided, but you may
	plug in any you wish. A large selection of easing algorithms
	are available in &lt;code&gt;dojo.fx.easing&lt;/code&gt;.</description>
          </parameter>
          <parameter name="onEnd" type="Function" usage="optional">
            <description>A function to be called when the animation finishes
	running.</description>
          </parameter>
          <parameter name="delay" type="Integer" usage="optional">
            <description>The number of milliseconds to delay beginning the
	animation by. The default is 0.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_destroyElement" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <description>Removes a node from its parent, clobbering it and all of its
	children. Function only works with DomNodes, and returns nothing.</description>
        <examples>
          <example>Destroy a node byId:
		dojo.destroy("someId");</example>
          <example>Destroy all nodes in a list by reference:
		dojo.query(".someNode").forEach(dojo.destroy);</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>A String ID or DomNode reference of the element to be destroyed</description>
          </parameter>
        </parameters>
      </method>
      <method name="isDescendant" scope="instance">
        <examples>
          <example>Test is node id="bar" is a descendant of node id="foo"
		if(dojo.isDescendant("bar", "foo")){ ... }</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>string id or node reference to test</description>
          </parameter>
          <parameter name="ancestor" type="DomNode|String" usage="required">
            <description>string id or node reference of potential parent to test against</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setSelectable" scope="instance">
        <examples>
          <example>Make the node id="bar" unselectable
		dojo.setSelectable("bar");</example>
          <example>Make the node id="bar" selectable
		dojo.setSelectable("bar", true);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to node</description>
          </parameter>
          <parameter name="selectable" type="Boolean" usage="required">
            <description>state to put the node in. false indicates unselectable, true
	allows selection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="place" scope="instance">
        <examples>
          <example>Place a node by string id as the last child of another node by string id:
		dojo.place("someNode", "anotherNode");</example>
          <example>Place a node by string id before another node by string id
		dojo.place("someNode", "anotherNode", "before");</example>
          <example>Create a Node, and place it in the body element (last child):
		dojo.place("&lt;div&gt;&lt;/div&gt;", dojo.body());</example>
          <example>Put a new LI as the first child of a list by id:
		dojo.place("&lt;li&gt;&lt;/li&gt;", "someUl", "first");</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>id or node reference, or HTML fragment starting with &amp;quot;&amp;lt;&amp;quot; to place relative to refNode</description>
          </parameter>
          <parameter name="refNode" type="String|DomNode" usage="required">
            <description>id or node reference to use as basis for placement</description>
          </parameter>
          <parameter name="position" type="String|Number" usage="optional">
            <description>string noting the position of node relative to refNode or a
	number indicating the location in the childNodes collection of refNode.
	Accepted string values are:
		* before
		* after
		* replace
		* only
		* first
		* last
	&amp;quot;first&amp;quot; and &amp;quot;last&amp;quot; indicate positions as children of refNode, &amp;quot;replace&amp;quot; replaces refNode,
	&amp;quot;only&amp;quot; replaces all children.  position defaults to &amp;quot;last&amp;quot; if not specified</description>
          </parameter>
        </parameters>
        <return-description>DomNode
	Returned values is the first argument resolved to a DOM node.
	.place() is also a method of `dojo.NodeList`, allowing `dojo.query` node lookups.</return-description>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="getComputedStyle" scope="instance">
        <description>Gets a "computed style" object which can be used to gather
	information about the current state of the rendered node.
	Note that this may behave differently on different browsers.
	Values may have different formats and value encodings across
	browsers.
	Note also that this method is expensive.  Wherever possible,
	reuse the returned object.
	Use the dojo.style() method for more consistent (pixelized)
	return values.</description>
        <examples>
          <example>	dojo.getComputedStyle(dojo.byId('foo')).borderWidth;</example>
          <example>Reusing the returned object, avoiding multiple lookups:
		var cs = dojo.getComputedStyle(dojo.byId("someNode"));
		var w = cs.width, h = cs.height;</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>A reference to a DOM node. Does NOT support taking an
	ID string for speed reasons.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="CSS2Properties"/>
        </return-types>
      </method>
      <method name="_toPixelValue" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="avalue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getOpacity" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>a reference to a DOM node. Does NOT support taking an
	ID string for speed reasons.</description>
          </parameter>
        </parameters>
        <return-description>Number between 0 and 1</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_setOpacity" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>a reference to a DOM node. Does NOT support taking an
	ID string for performance reasons.</description>
          </parameter>
          <parameter name="opacity" type="Number" usage="required">
            <description>A Number between 0 and 1. 0 specifies transparent.</description>
          </parameter>
        </parameters>
        <return-description>Number between 0 and 1</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_getPadExtents" scope="instance">
        <description>Returns an object with `w`, `h`, `l`, `t` properties:
			l/t = left/top padding (respectively)
			w = the total of the left and right padding
			h = the total of the top and bottom padding
	If 'node' has position, l/t forms the origin for child nodes.
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBorderExtents" scope="instance">
        <description>* l/t = the sum of left/top border (respectively)
	* w = the sum of the left and right border
	* h = the sum of the top and bottom border
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPadBorderExtents" scope="instance">
        <description>* l/t = the sum of left/top padding and left/top border (respectively)
	* w = the sum of the left and right padding and border
	* h = the sum of the top and bottom padding and border
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginExtents" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginBox" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginSize" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getContentBox" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBorderBox" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setBox" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>DOM Node reference. Id string not supported for performance
	reasons.</description>
          </parameter>
          <parameter name="l" type="Number" usage="optional">
            <description>left offset from parent.</description>
          </parameter>
          <parameter name="t" type="Number" usage="optional">
            <description>top offset from parent.</description>
          </parameter>
          <parameter name="w" type="Number" usage="optional">
            <description>width in current box model.</description>
          </parameter>
          <parameter name="h" type="Number" usage="optional">
            <description>width in current box model.</description>
          </parameter>
          <parameter name="u" type="String" usage="optional">
            <description>unit measure to use for other measures. Defaults to &amp;quot;px&amp;quot;.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isButtonTag" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_usesBorderBox" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_setContentSize" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="widthPx" type="Number" usage="required"/>
          <parameter name="heightPx" type="Number" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMarginBox" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="leftPx" type="Number" usage="optional"/>
          <parameter name="topPx" type="Number" usage="optional"/>
          <parameter name="widthPx" type="Number" usage="optional"/>
          <parameter name="heightPx" type="Number" usage="optional"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="marginBox" scope="instance">
        <description>Getter/setter for the margin-box of node.
	Returns an object in the expected format of box (regardless
	if box is passed). The object might look like:
	`{ l: 50, t: 200, w: 300: h: 150 }`
	for a node offset from its parent 50px to the left, 200px from
	the top with a margin width of 300px and a margin-height of
	150px.</description>
        <examples>
          <example>Retrieve the marginbox of a passed node
		var box = dojo.marginBox("someNodeId");
		console.dir(box);</example>
          <example>Set a node's marginbox to the size of another node
		var box = dojo.marginBox("someNodeId");
		dojo.marginBox("someOtherNode", box);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to DOM Node to get/set box for</description>
          </parameter>
          <parameter name="box" type="Object" usage="optional">
            <description>If passed, denotes that dojo.marginBox() should
	update/set the margin box for node. Box is an object in the
	above format. All properties are optional if passed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="contentBox" scope="instance">
        <description>Returns an object in the expected format of box (regardless if box is passed).
	The object might look like:
	`{ l: 50, t: 200, w: 300: h: 150 }`
	for a node offset from its parent 50px to the left, 200px from
	the top with a content width of 300px and a content-height of
	150px. Note that the content box may have a much larger border
	or margin box, depending on the box model currently in use and
	CSS values set/inherited for node.
	While the getter will return top and left values, the
	setter only accepts setting the width and height.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to DOM Node to get/set box for</description>
          </parameter>
          <parameter name="box" type="Object" usage="optional">
            <description>If passed, denotes that dojo.contentBox() should
	update/set the content box for node. Box is an object in the
	above format, but only w (width) and h (height) are supported.
	All properties are optional if passed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_docScroll" scope="instance"/>
      <method name="_isBodyLtr" scope="instance"/>
      <method name="_getIeDocumentElementOffset" scope="instance">
        <description>The following values in IE contain an offset:
			event.clientX
			event.clientY
			node.getBoundingClientRect().left
			node.getBoundingClientRect().top
	But other position related values do not contain this offset,
	such as node.offsetLeft, node.offsetTop, node.style.left and
	node.style.top. The offset is always (2, 2) in LTR direction.
	When the body is in RTL direction, the offset counts the width
	of left scroll bar's width.  This function computes the actual
	offset.</description>
      </method>
      <method name="_fixIeBiDiScrollLeft" scope="instance">
        <parameters>
          <parameter name="scrollLeft" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_abs" scope="instance"/>
      <method name="position" scope="instance">
        <description>Returns an object of the form:
	{ x: 100, y: 300, w: 20, h: 15 }
	If includeScroll==true, the x and y values will include any
	document offsets that may affect the position relative to the
	viewport.
	Uses the border-box model (inclusive of border and padding but
	not margin).  Does not act as a setter.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="includeScroll" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="coords" scope="instance">
        <description>Returns an object that measures margin-box (w)idth/(h)eight
	and absolute position x/y of the border-box. Also returned
	is computed (l)eft and (t)op values in pixels from the
	node's offsetParent as returned from marginBox().
	Return value will be in the form:
				{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }
	Does not act as a setter. If includeScroll is passed, the x and
	y params are affected as one would expect in dojo.position().</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="includeScroll" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="removeAttr" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to the element to remove the attribute from</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>the name of the attribute to remove</description>
          </parameter>
        </parameters>
      </method>
      <method name="getNodeProp" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>id or reference to the element to remove the attribute from</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>the name of the attribute</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Anything"/>
        </return-types>
      </method>
      <method name="create" scope="instance">
        <description>A DOM Element creation function. A shorthand method for creating a node or
	a fragment, and allowing for a convenient optional attribute setting step,
	as well as an optional DOM placement reference.
	Attributes are set by passing the optional object through `dojo.attr`.
	See `dojo.attr` for noted caveats and nuances, and API if applicable.
	Placement is done via `dojo.place`, assuming the new node to be the action
	node, passing along the optional reference node and position.</description>
        <examples>
          <example>Create a DIV:
		var n = dojo.create("div");</example>
          <example>Create a DIV with content:
		var n = dojo.create("div", { innerHTML:"&lt;p&gt;hi&lt;/p&gt;" });</example>
          <example>Place a new DIV in the BODY, with no attributes set
		var n = dojo.create("div", null, dojo.body());</example>
          <example>Create an UL, and populate it with LI's. Place the list as the first-child of a
	node with id="someId":
		var ul = dojo.create("ul", null, "someId", "first");
		var items = ["one", "two", "three", "four"];
		dojo.forEach(items, function(data){
			dojo.create("li", { innerHTML: data }, ul);
		});</example>
          <example>Create an anchor, with an href. Place in BODY:
		dojo.create("a", { href:"foo.html", title:"Goto FOO!" }, dojo.body());</example>
          <example>Create a `dojo.NodeList()` from a new element (for syntatic sugar):
		dojo.query(dojo.create('div'))
			.addClass("newDiv")
			.onclick(function(e){ console.log('clicked', e.target) })
			.place("#someNode"); // redundant, but cleaner.</example>
        </examples>
        <parameters>
          <parameter name="tag" type="String|DomNode" usage="required">
            <description>A string of the element to create (eg: &amp;quot;div&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;li&amp;quot;, &amp;quot;script&amp;quot;, &amp;quot;br&amp;quot;),
	or an existing DOM node to process.</description>
          </parameter>
          <parameter name="attrs" type="Object" usage="required">
            <description>An object-hash of attributes to set on the newly created node.
	Can be null, if you don't want to set any attributes/styles.
	See: &lt;code&gt;dojo.attr&lt;/code&gt; for a description of available attributes.</description>
          </parameter>
          <parameter name="refNode" type="String|DomNode" usage="optional">
            <description>Optional reference node. Used by &lt;code&gt;dojo.place&lt;/code&gt; to place the newly created
	node somewhere in the dom relative to refNode. Can be a DomNode reference
	or String ID of a node.</description>
          </parameter>
          <parameter name="pos" type="String" usage="optional">
            <description>Optional positional reference. Defaults to &amp;quot;last&amp;quot; by way of &lt;code&gt;dojo.place&lt;/code&gt;,
	though can be set to &amp;quot;first&amp;quot;,&amp;quot;after&amp;quot;,&amp;quot;before&amp;quot;,&amp;quot;last&amp;quot;, &amp;quot;replace&amp;quot; or &amp;quot;only&amp;quot;
	to further control the placement of the new node relative to the refNode.
	'refNode' is required if a 'pos' is specified.</description>
          </parameter>
        </parameters>
        <return-description>DomNode</return-description>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="empty" scope="instance">
        <examples>
          <example>Destroy node's children byId:
		dojo.empty("someId");</example>
          <example>Destroy all nodes' children in a list by reference:
		dojo.query(".someNode").forEach(dojo.empty);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>a reference to a DOM node or an id.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_toDom" scope="instance">
        <examples>
          <example>Create a table row:
		var tr = dojo._toDom("&lt;tr&gt;&lt;td&gt;First!&lt;/td&gt;&lt;/tr&gt;");</example>
        </examples>
        <parameters>
          <parameter name="frag" type="String" usage="required">
            <description>the HTML fragment</description>
          </parameter>
          <parameter name="doc" type="DocumentNode" usage="optional">
            <description>optional document to use when creating DOM nodes, defaults to
	dojo.doc if not specified.</description>
          </parameter>
        </parameters>
        <return-description>DocumentFragment</return-description>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="hasClass" scope="instance">
        <examples>
          <example>Do something if a node with id="someNode" has class="aSillyClassName" present
		if(dojo.hasClass("someNode","aSillyClassName")){ ... }</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>String ID or DomNode reference to check the class for.</description>
          </parameter>
          <parameter name="classStr" type="String" usage="required">
            <description>A string class name to look for.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="addClass" scope="instance">
        <examples>
          <example>Add a class to some node:
		dojo.addClass("someNode", "anewClass");</example>
          <example>Add two classes at once:
		dojo.addClass("someNode", "firstClass secondClass");</example>
          <example>Add two classes at once (using array):
		dojo.addClass("someNode", ["firstClass", "secondClass"]);</example>
          <example>Available in `dojo.NodeList` for multiple additions
		dojo.query("ul &gt; li").addClass("firstLevel");</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>String ID or DomNode reference to add a class string too</description>
          </parameter>
          <parameter name="classStr" type="String|Array" usage="required">
            <description>A String class name to add, or several space-separated class names,
	or an array of class names.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeClass" scope="instance">
        <examples>
          <example>Remove a class from some node:
		dojo.removeClass("someNode", "firstClass");</example>
          <example>Remove two classes from some node:
		dojo.removeClass("someNode", "firstClass secondClass");</example>
          <example>Remove two classes from some node (using array):
		dojo.removeClass("someNode", ["firstClass", "secondClass"]);</example>
          <example>Remove all classes from some node:
		dojo.removeClass("someNode");</example>
          <example>Available in `dojo.NodeList()` for multiple removal
		dojo.query(".foo").removeClass("foo");</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>String ID or DomNode reference to remove the class from.</description>
          </parameter>
          <parameter name="classStr" type="String|Array" usage="optional">
            <description>An optional String class name to remove, or several space-separated
	class names, or an array of class names. If omitted, all class names
	will be deleted.</description>
          </parameter>
        </parameters>
      </method>
      <method name="replaceClass" scope="instance">
        <examples>
          <example>	dojo.replaceClass("someNode", "add1 add2", "remove1 remove2");</example>
          <example>Replace all classes with addMe
		dojo.replaceClass("someNode", "addMe");</example>
          <example>Available in `dojo.NodeList()` for multiple toggles
		dojo.query(".findMe").replaceClass("addMe", "removeMe");</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>String ID or DomNode reference to remove the class from.</description>
          </parameter>
          <parameter name="addClassStr" type="String|Array" usage="required">
            <description>A String class name to add, or several space-separated class names,
	or an array of class names.</description>
          </parameter>
          <parameter name="removeClassStr" type="String|Array" usage="optional">
            <description>A String class name to remove, or several space-separated class names,
	or an array of class names.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toggleClass" scope="instance">
        <examples>
          <example>	dojo.toggleClass("someNode", "hovered");</example>
          <example>Forcefully add a class
		dojo.toggleClass("someNode", "hovered", true);</example>
          <example>Available in `dojo.NodeList()` for multiple toggles
		dojo.query(".toggleMe").toggleClass("toggleMe");</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="classStr" type="String|Array" usage="required"/>
          <parameter name="condition" type="Boolean" usage="optional">
            <description>If passed, true means to add the class, false means to remove.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fromJson" scope="instance">
        <description>Throws for invalid JSON strings, but it does not use a strict JSON parser. It
	delegates to eval().  The content passed to this method must therefore come
	from a trusted source.</description>
        <parameters>
          <parameter name="json" type="String" usage="required">
            <description>a string literal of a JSON item, for instance:
	&lt;code&gt;'{ &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 1, { &amp;quot;baz&amp;quot;: &amp;quot;thud&amp;quot; } ] }'&lt;/code&gt;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_escapeString" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="toJson" scope="instance">
        <description>Returns a [JSON](http://json.org) serialization of an object.
	Note that this doesn't check for infinite recursion, so don't do that!</description>
        <examples>
          <example>simple serialization of a trivial object
		var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);</example>
          <example>a custom serializer for an objects of a particular class:
		dojo.declare("Furby", null, {
			furbies: "are strange",
			furbyCount: 10,
			__json__: function(){
			},
		});</example>
        </examples>
        <parameters>
          <parameter name="it" type="Object" usage="required">
            <description>an object to be serialized. Objects may define their own
	serialization via a special &amp;quot;__json__&amp;quot; or &amp;quot;json&amp;quot; function
	property. If a specialized serializer has been defined, it will
	be used as a fallback.</description>
          </parameter>
          <parameter name="prettyPrint" type="Boolean" usage="optional">
            <description>if true, we indent objects and arrays to make the output prettier.
	The variable &lt;code&gt;dojo.toJsonIndentStr&lt;/code&gt; is used as the indent string --
	to use something other than the default (tab), change that variable
	before calling dojo.toJson().</description>
          </parameter>
          <parameter name="_indentStr" type="String" usage="optional">
            <description>private variable for recursive calls when pretty printing, do not use.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="isString" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isArray" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isFunction" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isObject" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isArrayLike" scope="instance">
        <description>Doesn't strongly test for "arrayness".  Instead, settles for "isn't
	a string or number and has a length property". Arguments objects
	and DOM collections will return true when passed to
	dojo.isArrayLike(), but will return false when passed to
	dojo.isArray().</description>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-description>If it walks like a duck and quacks like a duck, return `true`</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isAlien" scope="instance">
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="extend" scope="instance">
        <parameters>
          <parameter name="constructor" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_hitchArgs" scope="instance">
        <parameters>
          <parameter name="scope" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="hitch" scope="instance">
        <examples>
          <example>	dojo.hitch(foo, "bar")();
	runs foo.bar() in the scope of foo</example>
          <example>	dojo.hitch(foo, myFunction);
	returns a function that runs myFunction in the scope of foo</example>
          <example>Expansion on the default positional arguments passed along from
	hitch. Passed args are mixed first, additional args after.
		var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
		var fn = dojo.hitch(foo, "bar", 1, 2);
		fn(3); // logs "1, 2, 3"</example>
          <example>	var foo = { bar: 2 };
		dojo.hitch(foo, function(){ this.bar = 10; })();
	execute an anonymous function in scope of foo</example>
        </examples>
        <parameters>
          <parameter name="scope" type="Object" usage="required">
            <description>The scope to use when method executes. If method is a string,
	scope is also the object containing method.</description>
          </parameter>
          <parameter name="method" type="Function|String" usage="required">
            <description>A function to be hitched to scope, or the name of the method in
	scope to be hitched.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="delegate" scope="instance">
        <description>This is a small implementaton of the Boodman/Crockford delegation
	pattern in JavaScript. An intermediate object constructor mediates
	the prototype chain for the returned object, using it to delegate
	down to obj for property lookup when object-local lookup fails.
	This can be thought of similarly to ES4's "wrap", save that it does
	not act on types but rather on pure objects.</description>
        <examples>
          <example>	var foo = { bar: "baz" };
		var thinger = dojo.delegate(foo, { thud: "xyzzy"});
		thinger.bar == "baz"; // delegated to foo
		foo.thud == undefined; // by definition
		thinger.thud == "xyzzy"; // mixed in from props
		foo.bar = "thonk";
		thinger.bar == "thonk"; // still delegated to foo's bar</example>
        </examples>
        <parameters>
          <parameter name="obj" type="The" usage="required">
            <description>object to delegate to for properties not found directly on the
	return object or in props.</description>
          </parameter>
          <parameter name="props" type="an" usage="required">
            <description>object containing properties to assign to the returned object</description>
          </parameter>
        </parameters>
        <return-description>an Object of anonymous type</return-description>
      </method>
      <method name="_toArray" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <description>the object to &amp;quot;arrayify&amp;quot;. We expect the object to have, at a
	minimum, a length property which corresponds to integer-indexed
	properties.</description>
          </parameter>
          <parameter name="offset" type="Number" usage="optional">
            <description>the location in obj to start iterating from. Defaults to 0.
	Optional.</description>
          </parameter>
          <parameter name="startWith" type="Array" usage="optional">
            <description>An array to pack with the properties of obj. If provided,
	properties in obj are appended at the end of startWith and
	startWith is the returned array.</description>
          </parameter>
        </parameters>
      </method>
      <method name="partial" scope="instance">
        <description>Calling dojo.partial is the functional equivalent of calling:
		dojo.hitch(null, funcName, ...);</description>
        <parameters>
          <parameter name="method" type="Function|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="o" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="anything"/>
          <return-type type="Node"/>
          <return-type type="Date"/>
          <return-type type="RegExp"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="trim" scope="instance">
        <description>This version of trim() was selected for inclusion into the base due
	to its compact size and relatively good performance
	(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
	Uses String.prototype.trim instead, if available.
	The fastest but longest version of this function is located at
	dojo.string.trim()</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>String to be trimmed</description>
          </parameter>
        </parameters>
        <return-description>String
	Returns the trimmed string</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="replace" scope="instance">
        <examples>
          <example>	// uses a dictionary for substitutions:
		dojo.replace("Hello, {name.first} {name.last} AKA {nick}!",
		  {
		    nick: "Bob",
		    name: {
		      first:  "Robert",
		      middle: "X",
		      last:   "Cringely"
		    }
		  });
		// returns: Hello, Robert Cringely AKA Bob!</example>
          <example>	// uses an array for substitutions:
		dojo.replace("Hello, {0} {2}!",
		  ["Robert", "X", "Cringely"]);
		// returns: Hello, Robert Cringely!</example>
          <example>	// uses a function for substitutions:
		function sum(a){
		  var t = 0;
		  dojo.forEach(a, function(x){ t += x; });
		  return t;
		}
		dojo.replace(
		  "{count} payments averaging {avg} USD per payment.",
		  dojo.hitch(
		    { payments: [11, 16, 12] },
		    function(_, key){
		      switch(key){
		        case "count": return this.payments.length;
		        case "min":   return Math.min.apply(Math, this.payments);
		        case "max":   return Math.max.apply(Math, this.payments);
		        case "sum":   return sum(this.payments);
		        case "avg":   return sum(this.payments) / this.payments.length;
		      }
		    }
		  )
		);
		// prints: 3 payments averaging 13 USD per payment.</example>
          <example>	// uses an alternative PHP-like pattern for substitutions:
		dojo.replace("Hello, ${0} ${2}!",
		  ["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
		// returns: Hello, Robert Cringely!</example>
        </examples>
        <parameters>
          <parameter name="tmpl" type="String" usage="required">
            <description>String to be used as a template.</description>
          </parameter>
          <parameter name="map" type="Object|Function" usage="required">
            <description>If an object, it is used as a dictionary to look up substitutions.
	If a function, it is called for every substitution with following
	parameters: a whole match, a name, an offset, and the whole template
	string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
	for more details).</description>
          </parameter>
          <parameter name="pattern" type="RegEx" usage="optional">
            <description>Optional regular expression objects that overrides the default pattern.
	Must be global and match one item. The default is: /\{([^\}]+)\}/g,
	which matches patterns like that: &amp;quot;{xxx}&amp;quot;, where &amp;quot;xxx&amp;quot; is any sequence
	of characters, which doesn't include &amp;quot;}&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-description>String
	Returns the substituted string.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="setContext" scope="instance">
        <parameters>
          <parameter name="globalObject" type="Object" usage="required"/>
          <parameter name="globalDocument" type="DocumentElement" usage="required"/>
        </parameters>
      </method>
      <method name="withGlobal" scope="instance">
        <description>Invoke callback with globalObject as dojo.global and
	globalObject.document as dojo.doc. If provided, globalObject
	will be executed in the context of object thisObject
	When callback() returns or throws an error, the dojo.global
	and dojo.doc will be restored to its previous state.</description>
        <parameters>
          <parameter name="globalObject" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
          <parameter name="cbArguments" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="withDoc" scope="instance">
        <description>Invoke callback with documentObject as dojo.doc. If provided,
	callback will be executed in the context of object thisObject
	When callback() returns or throws an error, the dojo.doc will
	be restored to its previous state.</description>
        <parameters>
          <parameter name="documentObject" type="DocumentElement" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
          <parameter name="cbArguments" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="fieldToObject" scope="instance">
        <description>Returns the value encoded in a form field as
	as a string or an array of strings. Disabled form elements
	and unchecked radio and checkboxes are skipped.	Multi-select
	elements are returned as an array of string values.</description>
        <parameters>
          <parameter name="inputNode" type="DOMNode|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formToObject" scope="instance">
        <description>Returns the values encoded in an HTML form as
	string properties in an object which it then returns. Disabled form
	elements, buttons, and other non-value form elements are skipped.
	Multi-select elements are returned as an array of string values.</description>
        <examples>
          <example>This form:
		&lt;form id="test_form"&gt;
			&lt;input type="text" name="blah" value="blah"&gt;
			&lt;input type="text" name="no_value" value="blah" disabled&gt;
			&lt;input type="button" name="no_value2" value="blah"&gt;
			&lt;select type="select" multiple name="multi" size="5"&gt;
				&lt;option value="blah"&gt;blah&lt;/option&gt;
				&lt;option value="thud" selected&gt;thud&lt;/option&gt;
				&lt;option value="thonk" selected&gt;thonk&lt;/option&gt;
			&lt;/select&gt;
		&lt;/form&gt;
	yields this object structure as the result of a call to
	formToObject():
		{
			blah: "blah",
			multi: [
				"thud",
				"thonk"
			]
		};</example>
        </examples>
        <parameters>
          <parameter name="formNode" type="DOMNode|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="objectToQuery" scope="instance">
        <examples>
          <example>this object:
		{
			blah: "blah",
			multi: [
				"thud",
				"thonk"
			]
		};
	yields the following query string:
		"blah=blah&amp;multi=thud&amp;multi=thonk"</example>
        </examples>
        <parameters>
          <parameter name="map" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="formToQuery" scope="instance">
        <parameters>
          <parameter name="formNode" type="DOMNode|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="formToJson" scope="instance">
        <parameters>
          <parameter name="formNode" type="DOMNode|String" usage="required"/>
          <parameter name="prettyPrint" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="queryToObject" scope="instance">
        <examples>
          <example>This string:
			"foo=bar&amp;foo=baz&amp;thinger=%20spaces%20=blah&amp;zonk=blarg&amp;"
	results in this object structure:
			{
				foo: [ "bar", "baz" ],
				thinger: " spaces =blah",
				zonk: "blarg"
			}
	Note that spaces and other urlencoded entities are correctly
	handled.</example>
        </examples>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_ioSetArgs" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__IoArgs" usage="required">
            <description>The args object passed into the public io call. Recognized properties on
	the args object are:</description>
          </parameter>
          <parameter name="canceller" type="Function" usage="required">
            <description>The canceller function used for the Deferred object. The function
	will receive one argument, the Deferred object that is related to the
	canceller.</description>
          </parameter>
          <parameter name="okHandler" type="Function" usage="required">
            <description>The first OK callback to be registered with Deferred. It has the opportunity
	to transform the OK response. It will receive one argument -- the Deferred
	object returned from this function.</description>
          </parameter>
          <parameter name="errHandler" type="Function" usage="required">
            <description>The first error callback to be registered with Deferred. It has the opportunity
	to do cleanup on an error. It will receive two arguments: error (the
	Error object) and dfd, the Deferred object returned from this function.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_ioCancelAll" scope="instance"/>
      <method name="_ioNotifyStart" scope="instance">
        <description>Used by IO transports. An IO transport should
	call this method before making the network connection.</description>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_ioWatch" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required">
            <description>The Deferred object to watch.</description>
          </parameter>
          <parameter name="validCheck" type="Function" usage="required">
            <description>Function used to check if the IO request is still valid. Gets the dfd
	object as its only argument.</description>
          </parameter>
          <parameter name="ioCheck" type="Function" usage="required">
            <description>Function used to check if basic IO call worked. Gets the dfd
	object as its only argument.</description>
          </parameter>
          <parameter name="resHandle" type="Function" usage="required">
            <description>Function used to process response. Gets the dfd
	object as its only argument.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_ioAddQueryToUrl" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required"/>
        </parameters>
      </method>
      <method name="xhr" scope="instance">
        <description>Sends an HTTP request with the given method.
	See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
	for those HTTP methods. There are also methods for "raw" PUT and POST methods
	via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>HTTP method to be used, such as GET, POST, PUT, DELETE.  Should be uppercase.</description>
          </parameter>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
          <parameter name="hasBody" type="Boolean" usage="optional">
            <description>If the request has an HTTP body, then pass true for hasBody.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrGet" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="rawXhrPost" scope="instance"/>
      <method name="xhrPost" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="rawXhrPut" scope="instance"/>
      <method name="xhrPut" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrDelete" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="deprecated" scope="instance">
        <parameters>
          <parameter name="behaviour" type="String" usage="required"/>
          <parameter name="extra" type="String" usage="optional">
            <description>Text to append to the message.</description>
          </parameter>
          <parameter name="removal" type="String" usage="optional">
            <description>Text to indicate when in the future the behavior will be removed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="experimental" scope="instance">
        <description>This can be used to mark a function, file, or module as
	experimental.  Experimental code is not ready to be used, and the
	APIs are subject to change without notice.  Experimental code may be
	completed deleted without going through the normal deprecation
	process.</description>
        <examples>
          <example>	dojo.experimental("dojo.data.Result");</example>
          <example>	dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");</example>
        </examples>
        <parameters>
          <parameter name="moduleName" type="String" usage="required">
            <description>The name of a module, or the name of a module file or a specific
	function</description>
          </parameter>
          <parameter name="extra" type="String" usage="optional">
            <description>some additional message for the user</description>
          </parameter>
        </parameters>
      </method>
      <method name="__backArgs" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hash" scope="instance">
        <description>Handles getting and setting of location.hash.
	- If no arguments are passed, acts as a getter.
	- If a string is passed, acts as a setter.</description>
        <parameters>
          <parameter name="hash" type="String" usage="optional">
            <description>the hash is set - #string.</description>
          </parameter>
          <parameter name="replace" type="Boolean" usage="optional">
            <description>If true, updates the hash value in the current history
	state instead of creating a new history state.</description>
          </parameter>
        </parameters>
        <return-description>when used as a getter, returns the current hash string.
	when used as a setter, returns the new hash string.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_nodeDataCache" scope="instance" type="Object">
        <description>An alias to the private dataCache for NodeList-data. NEVER USE THIS!
	This private is only exposed for the benefit of unit testing, and is
	removed during the build process.</description>
      </property>
      <property name="NodeList-data" scope="instance" type="Object"/>
      <property name="NodeList-fx" scope="instance" type="Object">
        <description>Adds dojo.fx animation support to dojo.query()</description>
      </property>
      <property name="NodeList-html" scope="instance" type="Object">
        <description>Adds a chainable html method to dojo.query() / Nodelist instances for setting/replacing node content</description>
      </property>
      <property name="NodeList-manipulate" scope="instance" type="Object">
        <description>Adds a chainable methods to dojo.query() / Nodelist instances for manipulating HTML
	and DOM nodes and their properties.</description>
      </property>
      <property name="NodeList-traverse" scope="instance" type="Object">
        <description>Adds a chainable methods to dojo.query() / Nodelist instances for traversing the DOM</description>
      </property>
      <property name="_NodeListCtor" scope="instance" type="Object"/>
      <property name="isBrowser" scope="instance" type="Object"/>
      <property name="_name" scope="instance" type="String"/>
      <property name="baseUrl" scope="instance" type="String">
        <description>The root relative path to dojo.js (as a string)</description>
      </property>
      <property name="isMozilla" scope="instance" type="Object"/>
      <property name="isMoz" scope="instance" type="Object"/>
      <property name="isFF" scope="instance" type="Object"/>
      <property name="isQuirks" scope="instance" type="bool"/>
      <property name="locale" scope="instance" type="Object"/>
      <property name="_windowUnloaders" scope="instance" type="Array"/>
      <property name="_defaultContext" scope="instance" type="Array"/>
      <property name="_initFired" scope="instance" type="bool"/>
      <property name="isRhino" scope="instance" type="Object"/>
      <property name="_timeouts" scope="instance" type="Array"/>
      <property name="isSpidermonkey" scope="instance" type="Object">
        <description>Detect spidermonkey</description>
      </property>
      <property name="_loadedModules" scope="instance" type="Object"/>
      <property name="_inFlightCount" scope="instance" type="Number"/>
      <property name="_hasResource" scope="instance" type="Object"/>
      <property name="_loadedUrls" scope="instance" type="Array"/>
      <property name="_postLoad" scope="instance" type="bool"/>
      <property name="_loaders" scope="instance" type="Array"/>
      <property name="_unloaders" scope="instance" type="Array"/>
      <property name="_loadNotifying" scope="instance" type="bool"/>
      <property name="_global_omit_module_check" scope="instance" type="bool"/>
      <property name="requireAfterIf" scope="instance" type="Object"/>
      <property name="nonDebugProvide" scope="instance" type="Object"/>
      <property name="_xdDebugScopeChecked" scope="instance" type="Object"/>
      <property name="_isXDomain" scope="instance" type="bool"/>
      <property name="_xdInFlight" scope="instance" type="Object"/>
      <property name="_xdOrderedReqs" scope="instance" type="Array"/>
      <property name="_xdDepMap" scope="instance" type="Object"/>
      <property name="_xdContents" scope="instance" type="Array"/>
      <property name="_xdTimer" scope="instance" type="Number"/>
      <property name="_xdCharSet" scope="instance" type="String"/>
      <property name="_xdStartTime" scope="instance" type="Object"/>
      <property name="_headElement" scope="instance" type="Object"/>
      <property name="_xdReqLoc" scope="instance" type="Object"/>
      <property name="_xdBundleMap" scope="instance" type="Object"/>
      <property name="_xdRealRequireLocalization" scope="instance" type="Object"/>
      <property name="_topics" scope="instance" type="Object"/>
      <property name="subscribe" scope="instance" type="Object"/>
      <property name="unsubscribe" scope="instance" type="Object"/>
      <property name="publish" scope="instance" type="Object"/>
      <property name="_mixin" scope="instance" type="Object"/>
      <property name="_ieListenersName" scope="instance" type="String"/>
      <property name="_Animation" scope="instance" type="Object"/>
      <property name="boxModel" scope="instance" type="String"/>
      <property name="toJsonIndentStr" scope="instance" type="String"/>
      <property name="_delegate" scope="instance" type="Object"/>
      <property name="_bodyLtr" scope="instance" type="Object"/>
      <property name="_blockAsync" scope="instance" type="bool"/>
      <property name="jaxer" scope="instance" type="Object"/>
      <property name="robot" scope="instance" type="Object"/>
      <property name="robotx" scope="instance" type="Object"/>
      <property name="tests" scope="instance" type="Object">
        <description>D.O.H. Test files for Dojo unit testing.</description>
      </property>
      <property name="isIE" scope="instance" type="Object"/>
      <property name="isOpera" scope="instance" type="Object"/>
      <property name="uacss" scope="instance" type="Object"/>
      <property name="isWebKit" scope="instance" type="bool"/>
      <property name="isBB" scope="instance" type="Object"/>
      <property name="_oldConnect" scope="instance" type="Object"/>
      <property name="_defaultXhr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MenuBarItemMixin">
    <methods/>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.MenuBarItem" superclass="dijit.MenuItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._MenuBarItemMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
      <mixin type="dijit._MenuBarItemMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.MenuItem" superclass="dijit._Widget">
    <methods>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_onHover" scope="instance"/>
      <method name="_onUnhover" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="_onFocus" scope="instance"/>
      <method name="_setSelected" scope="instance">
        <parameters>
          <parameter name="selected" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setAccelKeyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String">
        <description>Menu text</description>
      </property>
      <property name="iconClass" scope="instance" type="String">
        <description>Class to apply to DOMNode to make it display an icon.</description>
      </property>
      <property name="accelKey" scope="instance" type="String">
        <description>Text for the accelerator (shortcut) key combination.
	Note that although Menu can display accelerator keys there
	is no infrastructure to actually catch and execute these
	accelerators.</description>
      </property>
      <property name="disabled" scope="instance" type="Boolean">
        <description>If true, the menu item is disabled.
	If false, the menu item is enabled.</description>
      </property>
    </properties>
  </class>
  <class type="dijit.MenuItem.accelKeyNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.MenuItem.accelKeyNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.MenuSeparator" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="isFocusable" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.PopupMenuBarItem" superclass="dijit.PopupMenuItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._MenuBarItemMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.PopupMenuItem" scope="instance"/>
      <mixin type="dijit._MenuBarItemMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.PopupMenuItem" superclass="dijit.MenuItem">
    <methods>
      <method name="_fillContent" scope="instance">
        <description>srcNodeRefinnerHTML contains both the menu item text and a popup widget
	The first part holds the menu item text and the second part is the popup</description>
        <examples>
          <example>	&lt;div dojoType="dijit.PopupMenuItem"&gt;
			&lt;span&gt;pick me&lt;/span&gt;
			&lt;popup&gt; ... &lt;/popup&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="startup" scope="instance"/>
      <method name="destroyDescendants" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="dropDownContainer" scope="instance" type="Object"/>
      <property name="popup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.PopupMenuItem.popup.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.ProgressBar" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="update" scope="instance">
        <examples>
          <example>	myProgressBar.update({'indeterminate': true});
		myProgressBar.update({'progress': 80});
		myProgressBar.update({'indeterminate': true, label:"Loading ..." })</example>
        </examples>
        <parameters>
          <parameter name="attributes" type="Object" usage="optional">
            <description>May provide progress and/or maximum properties on this parameter;
	see attribute specs for details.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setLabelAttr" scope="instance">
        <parameters>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setIndeterminateAttr" scope="instance">
        <parameters>
          <parameter name="indeterminate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="report" scope="instance">
        <parameters>
          <parameter name="percent" type="float" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="progress" scope="instance" type="String">
        <description>(Percentage or Number)
	Number or percentage indicating amount of task completed.
	Deprecated.   Use &amp;quot;value&amp;quot; instead.</description>
      </property>
      <property name="value" scope="instance" type="String">
        <description>(Percentage or Number)
	Number or percentage indicating amount of task completed.
	With &amp;quot;%&amp;quot;: percentage value, 0% &amp;lt;= progress &amp;lt;= 100%, or
	without &amp;quot;%&amp;quot;: absolute value, 0 &amp;lt;= progress &amp;lt;= maximum.
	Infinity means that the progress bar is indeterminate.</description>
      </property>
      <property name="maximum" scope="instance" type="Float">
        <description>Max sample number</description>
      </property>
      <property name="places" scope="instance" type="Number">
        <description>Number of places to show in values; 0 by default</description>
      </property>
      <property name="indeterminate" scope="instance" type="Boolean">
        <description>If false: show progress value (number or percentage).
	If true: show that a process is underway but that the amount completed is unknown.
	Deprecated.   Use &amp;quot;value&amp;quot; instead.</description>
      </property>
      <property name="label" scope="instance" type="String">
        <description>Label on progress bar.   Defaults to percentage for determinate progress bar and
	blank for indeterminate progress bar.</description>
      </property>
      <property name="name" scope="instance" type="String">
        <description>this is the field name (for a form) if set. This needs to be set if you want to use
	this widget in a dijit.form.Form widget (such as dijit.Dialog)</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_indeterminateHighContrastImagePath" scope="instance" type="dojo._URL">
        <description>URL to image to use for indeterminate progress bar when display is in high contrast mode</description>
      </property>
      <property name="internalProgress" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ProgressBar.labelNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.ProgressBar.internalProgress.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.TitlePane" superclass="dijit.layout.ContentPane">
    <description>An accessible container with a title Heading, and a content
	section that slides open and closed. TitlePane is an extension to
	`dijit.layout.ContentPane`, providing all the useful content-control aspects from it.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setOpenAttr" scope="instance">
        <parameters>
          <parameter name="open" type="Boolean" usage="required">
            <description>True if you want to open the pane, false if you want to close it.</description>
          </parameter>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setToggleableAttr" scope="instance">
        <parameters>
          <parameter name="canToggle" type="Boolean" usage="required">
            <description>True to allow user to open/close pane by clicking title bar.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setContentAttr" scope="instance">
        <parameters>
          <parameter name="content" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="instance"/>
      <method name="_setCss" scope="instance"/>
      <method name="_onTitleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTitleClick" scope="instance"/>
      <method name="setTitle" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_dxfindParent" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String">
        <description>Title of the pane</description>
      </property>
      <property name="open" scope="instance" type="Boolean">
        <description>Whether pane is opened or closed.</description>
      </property>
      <property name="toggleable" scope="instance" type="Boolean">
        <description>Whether pane can be opened or closed by clicking the title bar.</description>
      </property>
      <property name="tabIndex" scope="instance" type="String">
        <description>Tabindex setting for the title (so users can tab to the title then
	use space/enter to open/close the title pane)</description>
      </property>
      <property name="duration" scope="instance" type="Integer">
        <description>Time in milliseconds to fade in/fade out</description>
      </property>
      <property name="baseClass" scope="instance" type="String">
        <description>The root className to be placed on this widget's domNode.</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="hideNode" scope="instance" type="Object"/>
      <property name="wipeNode" scope="instance" type="Object"/>
      <property name="_wipeIn" scope="instance" type="Object"/>
      <property name="_wipeOut" scope="instance" type="Object"/>
      <property name="titleBarNode" scope="instance" type="Object"/>
      <property name="_titleBarClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.TitlePane.hideNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.TitlePane.wipeNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TitlePane.arrowNodeInner">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Toolbar" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._KeyNavContainer.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._KeyNavContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.ToolbarSeparator" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="isFocusable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="innerHTML" type="String" usage="required"/>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="position" type="Array&lt;String&gt;" usage="optional"/>
          <parameter name="rtl" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="orient" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundCorner" type="String" usage="required"/>
          <parameter name="tooltipCorner" type="String" usage="required"/>
          <parameter name="spaceAvailable" type="Object" usage="required"/>
          <parameter name="aroundNodeCoords" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onShow" scope="instance"/>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="aroundNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHide" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="duration" scope="instance" type="Integer">
        <description>Milliseconds to fade in/fade out</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="bgIframe" scope="instance" type="Object"/>
      <property name="fadeIn" scope="instance" type="Object"/>
      <property name="fadeOut" scope="instance" type="Object"/>
      <property name="_onDeck" scope="instance" type="Object"/>
      <property name="isShowingNow" scope="instance" type="bool"/>
      <property name="aroundNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.domNode">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.connectorNode.style">
    <properties>
      <property name="top" scope="instance" type="String"/>
      <property name="bottom" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.domNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="filter" scope="instance" type="String"/>
      <property name="cssText" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.containerNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._MasterTooltip.connectorNode">
    <properties>
      <property name="offsetHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Tooltip" superclass="dijit._Widget">
    <methods>
      <method name="_setConnectIdAttr" scope="instance">
        <parameters>
          <parameter name="newId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="addTarget" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNODE" usage="required">
            <description>|| String</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeTarget" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNODE" usage="required">
            <description>|| String</description>
          </parameter>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_onTargetMouseEnter" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTargetMouseLeave" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTargetFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTargetBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHover" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onUnHover" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="instance">
        <parameters>
          <parameter name="target" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance"/>
      <method name="onShow" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="position" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHide" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="String">
        <description>Text to display in the tooltip.
	Specified as innerHTML when creating the widget from markup.</description>
      </property>
      <property name="showDelay" scope="instance" type="Integer">
        <description>Number of milliseconds to wait after hovering over/focusing on the object, before
	the tooltip is displayed.</description>
      </property>
      <property name="connectId" scope="instance" type="String|Array&lt;String&gt;">
        <description>Id of domNode(s) to attach the tooltip to.
	When user hovers over specified dom node, the tooltip will appear.</description>
      </property>
      <property name="position" scope="instance" type="Array&lt;String&gt;">
        <description>See description of &lt;code&gt;dijit.Tooltip.defaultPosition&lt;/code&gt; for details on position parameter.</description>
      </property>
      <property name="_connections" scope="instance" type="Object"/>
      <property name="_connectIds" scope="instance" type="Object"/>
      <property name="_focus" scope="instance" type="bool"/>
      <property name="_showTimer" scope="instance" type="Object"/>
      <property name="_connectNode" scope="instance" type="Object"/>
      <property name="defaultPosition" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.TooltipDialog" superclass="dijit.layout.ContentPane">
    <methods>
      <method name="_setTitleAttr" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="orient" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundCorner" type="String" usage="required"/>
          <parameter name="corner" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="onOpen" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance"/>
      <method name="_onKey" scope="instance">
        <description>Keep keyboard focus in dialog; close dialog on escape key</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit.form._FormMixin.prototype" scope="instance"/>
      <mixin type="dijit._DialogMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit.form._FormMixin" scope="instance"/>
      <mixin type="dijit._DialogMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String">
        <description>Description of tooltip dialog (required for a11y)</description>
      </property>
      <property name="doLayout" scope="instance" type="Boolean">
        <description>Don't change this parameter from the default value.
	This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
	is never a child of a layout container, nor can you specify the size of
	TooltipDialog in order to control the size of an inner widget.</description>
      </property>
      <property name="autofocus" scope="instance" type="Boolean">
        <description>A Toggle to modify the default focus behavior of a Dialog, which
	is to focus on the first dialog element after opening the dialog.
	False will disable autofocusing. Default: true</description>
      </property>
      <property name="baseClass" scope="instance" type="String">
        <description>The root className to use for the various states of this widget</description>
      </property>
      <property name="_firstFocusItem" scope="instance" type="[readonly]">
        <description>DomNode
	The pointer to the first focusable node in the dialog.
	Set by &lt;code&gt;dijit._DialogMixin._getFocusItems&lt;/code&gt;.</description>
      </property>
      <property name="_lastFocusItem" scope="instance" type="[readonly]">
        <description>DomNode
	The pointer to which node has focus prior to our dialog.
	Set by &lt;code&gt;dijit._DialogMixin._getFocusItems&lt;/code&gt;.</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_currentOrientClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.TooltipDialog.containerNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TreeNode" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="_setIndentAttr" scope="instance">
        <description>0 for top level nodes, 1 for their children, 2 for their
	grandchildren, etc.</description>
        <parameters>
          <parameter name="indent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markProcessing" scope="instance"/>
      <method name="unmarkProcessing" scope="instance"/>
      <method name="_updateItemClasses" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_applyClassAndStyle" scope="instance">
        <parameters>
          <parameter name="item" type="The" usage="required">
            <description>data item.</description>
          </parameter>
          <parameter name="lower" type="The" usage="required">
            <description>lower case attribute to use, e.g. 'icon', 'label' or 'row'.</description>
          </parameter>
          <parameter name="upper" type="The" usage="required">
            <description>upper case attribute to use, e.g. 'Icon', 'Label' or 'Row'.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateLayout" scope="instance"/>
      <method name="_setExpando" scope="instance">
        <parameters>
          <parameter name="processing" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="expand" scope="instance">
        <return-description>Deferred that fires when expansion is complete</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="collapse" scope="instance"/>
      <method name="setChildItems" scope="instance">
        <parameters>
          <parameter name="items" type="Array&lt;Object&gt;" usage="required"/>
        </parameters>
        <return-description>Deferred object that fires after all previously opened children
	have been expanded again (or fires instantly if there are no such children).</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="getTreePath" scope="instance"/>
      <method name="getIdentity" scope="instance"/>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="node" type="treeNode" usage="required"/>
        </parameters>
      </method>
      <method name="makeExpandable" scope="instance"/>
      <method name="_onLabelFocus" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSelected" scope="instance">
        <description>In particular, setting a node as selected involves setting tabIndex
	so that when user tabs to the tree, focus will go to that node (only).</description>
        <parameters>
          <parameter name="selected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusable" scope="instance">
        <description>In particular, setting a node as selected involves setting tabIndex
	so that when user tabs to the tree, focus will go to that node (only).</description>
        <parameters>
          <parameter name="selected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseEnter" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseLeave" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="item" scope="instance" type="dojo.data.Item">
        <description>the dojo.data entry this tree represents</description>
      </property>
      <property name="isTreeNode" scope="instance" type="Boolean">
        <description>Indicates that this is a TreeNode.   Used by &lt;code&gt;dijit.Tree&lt;/code&gt; only,
	should not be accessed directly.</description>
      </property>
      <property name="label" scope="instance" type="String">
        <description>Text of this tree node</description>
      </property>
      <property name="isExpandable" scope="instance" type="Boolean">
        <description>This node has children, so show the expando node (+ sign)</description>
      </property>
      <property name="isExpanded" scope="instance" type="Boolean">
        <description>This node is currently expanded (ie, opened)</description>
      </property>
      <property name="state" scope="instance" type="String">
        <description>Dynamic loading-related stuff.
	When an empty folder node appears, it is &amp;quot;UNCHECKED&amp;quot; first,
	then after dojo.data query it becomes &amp;quot;LOADING&amp;quot; and, finally &amp;quot;LOADED&amp;quot;</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_expandDeferred" scope="instance" type="Object"/>
      <property name="_wipeOut" scope="instance" type="Object"/>
      <property name="indent" scope="instance" type="Integer">
        <description>Levels from this node to the root node</description>
      </property>
    </properties>
  </class>
  <class type="dijit._TreeNode.cssStateNodes">
    <properties>
      <property name="rowNode" scope="instance" type="String"/>
      <property name="labelNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._TreeNode.tree">
    <properties>
      <property name="model" scope="instance" type="Object"/>
      <property name="lastFocused" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TreeNode.expandoNodeText">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Tree" superclass="dijit._Widget">
    <methods>
      <method name="onDndDrop" scope="instance"/>
      <method name="itemCreator" scope="instance">
        <description>For each node in nodes[], which came from source, create a hash of name/value
	pairs to be passed to Tree.model.newItem().  Returns array of those hashes.</description>
        <parameters>
          <parameter name="nodes" type="Array&lt;DomNode&gt;" usage="required">
            <description>The DOMNodes dragged from the source container</description>
          </parameter>
          <parameter name="target" type="DomNode" usage="required">
            <description>The target TreeNode.rowNode</description>
          </parameter>
          <parameter name="source" type="dojo.dnd.Source" usage="required">
            <description>The source container the nodes were dragged from, perhaps another Tree or a plain dojo.dnd.Source</description>
          </parameter>
        </parameters>
        <return-description>Object[]
	Array of name/value hashes for each new item to be added to the Tree, like:
		[
			{ id: 123, label: "apple", foo: "bar" },
			{ id: 456, label: "pear", zaz: "bam" }
		]</return-description>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="dijit.tree._dndSource" usage="required">
            <description>The source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array&lt;DOMNode&gt;" usage="required">
            <description>Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
	source is a dijit.Tree.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="checkItemAcceptance" scope="instance">
        <description>In the base case, this is called to check if target can become a child of source.
	When betweenThreshold is set, position="before" or "after" means that we
	are asking if the source node can be dropped before/after the target node.</description>
        <parameters>
          <parameter name="target" type="DOMNode" usage="required">
            <description>The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
	Use dijit.getEnclosingWidget(target) to get the TreeNode.</description>
          </parameter>
          <parameter name="source" type="dijit.tree.dndSource" usage="required">
            <description>The (set of) nodes we are dropping</description>
          </parameter>
          <parameter name="position" type="String" usage="required">
            <description>&amp;quot;over&amp;quot;, &amp;quot;before&amp;quot;, or &amp;quot;after&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_publish" scope="instance">
        <parameters>
          <parameter name="topicName" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_store2model" scope="instance"/>
      <method name="onLoad" scope="instance">
        <description>If persist == true the loading may encompass many levels of fetches
	from the data store, each asynchronous.   Waits for all to finish.</description>
      </method>
      <method name="_load" scope="instance"/>
      <method name="getNodesByItem" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required">
            <description>or id</description>
          </parameter>
        </parameters>
        <return-description>Array of tree nodes that refer to passed item</return-description>
      </method>
      <method name="_setSelectedItemAttr" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required">
            <description>or id</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setSelectedItemsAttr" scope="instance">
        <parameters>
          <parameter name="items" type="dojo.data.Items" usage="required">
            <description>or ids</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setPathAttr" scope="instance">
        <parameters>
          <parameter name="path" type="Array&lt;Item&gt;" usage="required">
            <description>|| String[]</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setPathsAttr" scope="instance">
        <parameters>
          <parameter name="paths" type="Array&lt;Array&lt;Item&gt;&gt;" usage="required">
            <description>Array of arrays of items or item id's</description>
          </parameter>
        </parameters>
        <return-description>Deferred to indicate when the set is complete</return-description>
      </method>
      <method name="_setSelectedNodeAttr" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedNodesAttr" scope="instance">
        <parameters>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getItemChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="Function(items))" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getIconClass" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelClass" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getRowClass" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getIconStyle" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
        <return-description>Object suitable for input to dojo.style() like {backgroundImage: "url(...)"}</return-description>
      </method>
      <method name="getLabelStyle" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
        <return-description>Object suitable for input to dojo.style() like {color: "red", background: "green"}</return-description>
      </method>
      <method name="getRowStyle" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
        <return-description>Object suitable for input to dojo.style() like {background-color: "#bbb"}</return-description>
      </method>
      <method name="getTooltip" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onEnterKey" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDownArrow" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUpArrow" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRightArrow" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLeftArrow" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHomeKey" scope="instance"/>
      <method name="_onEndKey" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLetterKeyNav" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required">
            <description>Like { node: TreeNode, key: 'a' } where key is the key the user pressed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isExpandoNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="nodeWidget" type="TreeNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="nodeWidget" type="TreeNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onExpandoClick" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onDblClick" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getNextNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_TreeNode"/>
        </return-types>
      </method>
      <method name="_getRootOrFirstNode" scope="instance"/>
      <method name="_collapseNode" scope="instance">
        <parameters>
          <parameter name="node" type="_TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="_expandNode" scope="instance">
        <parameters>
          <parameter name="node" type="_TreeNode" usage="required"/>
          <parameter name="recursive" type="Boolean" usage="optional">
            <description>Internal flag used when _expandNode() calls itself, don't set.</description>
          </parameter>
        </parameters>
        <return-description>Deferred that fires when the node is loaded and opened and (if persist=true) all it's descendants
	that were previously opened too</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="focusNode" scope="instance">
        <parameters>
          <parameter name="node" type="_tree.Node" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeFocus" scope="instance">
        <description>It marks that the current node is the selected one, and the previously
	selected node no longer is.</description>
        <parameters>
          <parameter name="node" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeMouseEnter" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeMouseLeave" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChange" scope="instance">
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChildrenChange" scope="instance">
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="Array&lt;dojo.data.Item&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="_initState" scope="instance"/>
      <method name="_state" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="expanded" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_saveState" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="destroyRecursive" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createTreeNode" scope="instance">
        <description>Developers can override this method to define their own TreeNode class;
	However it will probably be removed in a future release in favor of a way
	of just specifying a widget for the label, rather than one that contains
	the children too.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="String|dojo.data.Store">
        <description>Deprecated.  Use &amp;quot;model&amp;quot; parameter instead.
	The store to get data to display in the tree.</description>
      </property>
      <property name="model" scope="instance" type="dijit.Tree.model">
        <description>Interface to read tree data, get notifications of changes to tree data,
	and for handling drop operations (i.e drag and drop onto the tree)</description>
      </property>
      <property name="query" scope="instance" type="anything">
        <description>Deprecated.  User should specify query to the model directly instead.
	Specifies datastore query to return the root item or top items for the tree.</description>
      </property>
      <property name="label" scope="instance" type="String">
        <description>Deprecated.  Use dijit.tree.ForestStoreModel directly instead.
	Used in conjunction with query parameter.
	If a query is specified (rather than a root node id), and a label is also specified,
	then a fake root node is created and displayed, with this label.</description>
      </property>
      <property name="showRoot" scope="instance" type="Boolean">
        <description>Should the root node be displayed, or hidden?</description>
      </property>
      <property name="childrenAttr" scope="instance" type="Array&lt;String&gt;">
        <description>Deprecated.   This information should be specified in the model.
	One ore more attributes that holds children of a tree node</description>
      </property>
      <property name="paths" scope="instance" type="Array&lt;Array&lt;String&gt;&gt;">
        <description>or Item[][]
	Full paths from rootNode to selected nodes expressed as array of items or array of ids.
	Since setting the paths may be asynchronous (because ofwaiting on dojo.data), set(&amp;quot;paths&amp;quot;, ...)
	returns a Deferred to indicate when the set is complete.</description>
      </property>
      <property name="path" scope="instance" type="Array&lt;String&gt;">
        <description>or Item[]
	Backward compatible singular variant of paths.</description>
      </property>
      <property name="selectedItems" scope="instance" type="Array&lt;Item&gt;">
        <description>The currently selected items in this tree.
	This property can only be set (via set('selectedItems', ...)) when that item is already
	visible in the tree.   (I.e. the tree has already been expanded to show that node.)
	Should generally use &lt;code&gt;paths&lt;/code&gt; attribute to set the selected items instead.</description>
      </property>
      <property name="selectedItem" scope="instance" type="Item">
        <description>Backward compatible singular variant of selectedItems.</description>
      </property>
      <property name="openOnClick" scope="instance" type="Boolean">
        <description>If true, clicking a folder node's label will open it, rather than calling onClick()</description>
      </property>
      <property name="openOnDblClick" scope="instance" type="Boolean">
        <description>If true, double-clicking a folder node's label will open it, rather than calling onDblClick()</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="persist" scope="instance" type="Boolean">
        <description>Enables/disables use of cookies for state saving.</description>
      </property>
      <property name="autoExpand" scope="instance" type="Boolean">
        <description>Fully expand the tree on load.   Overrides &lt;code&gt;persist&lt;/code&gt;.</description>
      </property>
      <property name="dndController" scope="instance" type="String">
        <description>Class name to use as as the dnd controller.  Specifying this class enables DnD.
	Generally you should specify this as &amp;quot;dijit.tree.dndSource&amp;quot;.
	Default of &amp;quot;dijit.tree._dndSelector&amp;quot; handles selection only (no actual DnD).</description>
      </property>
      <property name="dndParams" scope="instance" type="Array"/>
      <property name="dragThreshold" scope="instance" type="Integer">
        <description>Number of pixels mouse moves before it's considered the start of a drag operation</description>
      </property>
      <property name="betweenThreshold" scope="instance" type="Integer">
        <description>Set to a positive value to allow drag and drop &amp;quot;between&amp;quot; nodes.
	If during DnD mouse is over a (target) node but less than betweenThreshold
	pixels from the bottom edge, dropping the the dragged node will make it
	the next sibling of the target node, rather than the child.
	Similarly, if mouse is over a target node but less that betweenThreshold
	pixels from the top edge, dropping the dragged node will make it
	the target node's previous sibling rather than the target node's child.</description>
      </property>
      <property name="_nodePixelIndent" scope="instance" type="Integer">
        <description>Number of pixels to indent tree nodes (relative to parent node).
	Default is 19 but can be overridden by setting CSS class dijitTreeIndent
	and calling resize() or startup() on tree after it's in the DOM.</description>
      </property>
      <property name="tree" scope="instance" type="Object"/>
      <property name="_itemNodesMap" scope="instance" type="Object"/>
      <property name="cookieName" scope="instance" type="String"/>
      <property name="_loadDeferred" scope="instance" type="Object"/>
      <property name="_v10Compat" scope="instance" type="Object"/>
      <property name="_keyHandlerMap" scope="instance" type="Object"/>
      <property name="multiCharSearchDuration" scope="instance" type="Number">
        <description>If multiple characters are typed where each keystroke happens within
	multiCharSearchDuration of the previous keystroke,
	search for nodes matching all the keystrokes.
	For example, typing &amp;quot;ab&amp;quot; will search for entries starting with
	&amp;quot;ab&amp;quot; unless the delay between &amp;quot;a&amp;quot; and &amp;quot;b&amp;quot; is greater than multiCharSearchDuration.</description>
      </property>
      <property name="_curSearch" scope="instance" type="Object"/>
      <property name="lastFocused" scope="instance" type="Object"/>
      <property name="_openedItemIds" scope="instance" type="Object"/>
      <property name="rootNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Contained">
    <methods>
      <method name="getParent" scope="instance"/>
      <method name="_getSibling" scope="instance">
        <parameters>
          <parameter name="which" type="String" usage="required">
            <description>Either &amp;quot;next&amp;quot; or &amp;quot;previous&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getPreviousSibling" scope="instance">
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getNextSibling" scope="instance">
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getIndexInParent" scope="instance">
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dijit._Container">
    <description>Use this mixin for widgets that needs to know about and
	keep track of their widget children. Suitable for widgets like BorderContainer
	and TabContainer which contain (only) a set of child widgets.
	It's not suitable for widgets like ContentPane
	which contains mixed HTML (plain DOM nodes in addition to widgets),
	and where contained widgets are not necessarily directly below
	this.containerNode.   In that case calls like addChild(node, position)
	wouldn't make sense.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <description>Inserts specified child widget's dom node as a child of this widget's
	container node, and possibly does other processing (such as layout).</description>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Widget" usage="required">
            <description>or int</description>
          </parameter>
        </parameters>
      </method>
      <method name="hasChildren" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getSiblingOfChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="dir" type="int" usage="required">
            <description>if 1, get the next sibling
	if -1, get the previous sibling</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getIndexOfChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="startup" scope="instance"/>
    </methods>
    <properties>
      <property name="isContainer" scope="instance" type="Boolean">
        <description>Indicates that this widget acts as a &amp;quot;parent&amp;quot; to the descendant widgets.
	When the parent is started it will call startup() on the child widgets.
	See also &lt;code&gt;isLayoutContainer&lt;/code&gt;.</description>
      </property>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._CssStateMixin">
    <description>By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
	maintain CSS classes on the widget root node (this.domNode) depending on hover,
	active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
	dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
	It also sets CSS like dijitButtonDisabled based on widget semantic state.
	By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
	within the widget).</description>
    <methods>
      <method name="_applyAttributes" scope="instance"/>
      <method name="_cssMouseEvent" scope="instance">
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setStateClass" scope="instance">
        <description>In the case where a widget has multiple
	states, it sets the class based on all possible
	combinations.  For example, an invalid form widget that is being hovered
	will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
	The widget may have one or more of the following states, determined
	by this.state, this.checked, this.valid, and this.selected:
	- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
	- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
	- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
	- Selected - ex: currently selected tab will have this.selected==true
	In addition, it may have one or more of the following states,
	based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
	- Disabled	- if the widget is disabled
	- Active		- if the mouse (or space/enter key?) is being pressed down
	- Focused		- if the widget has focus
	- Hover		- if the mouse is over the widget</description>
      </method>
      <method name="_trackMouseState" scope="instance">
        <description>Given class=foo, will set the following CSS class on the node
	- fooActive: if the user is currently pressing down the mouse button while over the node
	- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
	- fooFocus: if the node is focused
	Note that it won't set any classes if the widget is disabled.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>Should be a sub-node of the widget, not the top node (this.domNode), since the top node
	is handled specially and automatically just by mixing in this class.</description>
          </parameter>
          <parameter name="clazz" type="String" usage="required">
            <description>CSS class name (ex: dijitSliderUpArrow).</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cssStateNodes" scope="instance" type="Object">
        <description>List of sub-nodes within the widget that need CSS classes applied on mouse hover/press and focus
	.
	Each entry in the hash is a an attachpoint names (like &amp;quot;upArrowButton&amp;quot;) mapped to a CSS class names
	(like &amp;quot;dijitUpArrowButton&amp;quot;). Example:
			{
				&amp;quot;upArrowButton&amp;quot;: &amp;quot;dijitUpArrowButton&amp;quot;,
				&amp;quot;downArrowButton&amp;quot;: &amp;quot;dijitDownArrowButton&amp;quot;
			}
	The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
	is hovered, etc.</description>
      </property>
      <property name="hovering" scope="instance" type="Boolean">
        <description>True if cursor is over this widget</description>
      </property>
      <property name="active" scope="instance" type="Boolean">
        <description>True if mouse was pressed while over this widget, and hasn't been released yet</description>
      </property>
      <property name="_mouseDown" scope="instance" type="Object"/>
      <property name="_stateClasses" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._CssStateMixin.stateNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._DialogMixin">
    <methods>
      <method name="execute" scope="instance">
        <description>After the user has pressed the submit button, the Dialog
	first calls onExecute() to notify the container to hide the
	dialog and restore focus to wherever it used to be.
	*Then* this method is called.
	type:
	callback</description>
        <parameters>
          <parameter name="formContents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance">
        <description>Developer shouldn't override or connect to this method;
	it's a private communication device between the TooltipDialog
	and the thing that opened it (ex: `dijit.form.DropDownButton`)
	type:
	protected</description>
      </method>
      <method name="onExecute" scope="instance">
        <description>Developer shouldn't override or connect to this method;
	it's a private communication device between the TooltipDialog
	and the thing that opened it (ex: `dijit.form.DropDownButton`)
	type:
	protected</description>
      </method>
      <method name="_onSubmit" scope="instance"/>
      <method name="_getFocusItems" scope="instance"/>
    </methods>
    <properties>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_firstFocusItem" scope="instance" type="Object"/>
      <property name="_lastFocusItem" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._HasDropDown">
    <methods>
      <method name="_onDropDownMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDropDownMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
      <method name="_onDropDownClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="isLoaded" scope="instance"/>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="loadCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="toggleDropDown" scope="instance"/>
      <method name="openDropDown" scope="instance">
        <return-description>return value of dijit.popup.open()</return-description>
      </method>
      <method name="closeDropDown" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required">
            <description>If true, refocuses the button widget</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_buttonNode" scope="instance" type="DomNode">
        <description>The button/icon/node to click to display the drop down.
	Can be set via a dojoAttachPoint assignment.
	If missing, then either focusNode or domNode (if focusNode is also missing) will be used.</description>
      </property>
      <property name="_arrowWrapperNode" scope="instance" type="DomNode">
        <description>Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
	on where the drop down is set to be positioned.
	Can be set via a dojoAttachPoint assignment.
	If missing, then _buttonNode will be used.</description>
      </property>
      <property name="_popupStateNode" scope="instance" type="DomNode">
        <description>The node to set the popupActive class on.
	Can be set via a dojoAttachPoint assignment.
	If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.</description>
      </property>
      <property name="_aroundNode" scope="instance" type="DomNode">
        <description>The node to display the popup around.
	Can be set via a dojoAttachPoint assignment.
	If missing, then domNode will be used.</description>
      </property>
      <property name="autoWidth" scope="instance" type="Boolean">
        <description>Set to true to make the drop down at least as wide as this
	widget.  Set to false if the drop down should just be its
	default width</description>
      </property>
      <property name="forceWidth" scope="instance" type="Boolean">
        <description>Set to true to make the drop down exactly as wide as this
	widget.  Overrides autoWidth.</description>
      </property>
      <property name="maxHeight" scope="instance" type="Integer">
        <description>The max height for our dropdown.
	Any dropdown taller than this will have scrollbars.
	Set to 0 for no max height, or -1 to limit height to available space in viewport</description>
      </property>
      <property name="_stopClickEvents" scope="instance" type="Boolean">
        <description>When set to false, the click events will not be stopped, in
	case you want to use them in your subwidget</description>
      </property>
      <property name="_docHandler" scope="instance" type="Object"/>
      <property name="_preparedNode" scope="instance" type="Object"/>
      <property name="_explicitDDWidth" scope="instance" type="Object"/>
      <property name="_explicitDDHeight" scope="instance" type="Object"/>
      <property name="_opened" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit._HasDropDown.dropDownPosition">
    <properties>
      <property name="0" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._HasDropDown.dropDown">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._KeyNavContainer" superclass="dijit._Container">
    <description>To use this mixin, call connectKeyNavHandlers() in
	postCreate() and call startupKeyNavChildren() in startup().
	It provides normalized keyboard and focusing code for Container
	widgets.</description>
    <methods>
      <method name="connectKeyNavHandlers" scope="instance">
        <parameters>
          <parameter name="prevKeyCodes" type="Array&lt;dojo.keys&gt;" usage="required"/>
          <parameter name="nextKeyCodes" type="Array&lt;dojo.keys&gt;" usage="required">
            <description>Key codes for navigating to the next child.</description>
          </parameter>
        </parameters>
      </method>
      <method name="startupKeyNavChildren" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="focusFirstChild" scope="instance"/>
      <method name="focusLastChild" scope="instance"/>
      <method name="focusNext" scope="instance"/>
      <method name="focusPrev" scope="instance"/>
      <method name="focusChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required">
            <description>Reference to container's child widget</description>
          </parameter>
          <parameter name="last" type="Boolean" usage="required">
            <description>If true and if widget has multiple focusable nodes, focus the
	last one instead of the first one</description>
          </parameter>
        </parameters>
      </method>
      <method name="_startupChild" scope="instance">
        <description>Sets tabIndex=-1 on each child, so that the tab key will
	leave the container rather than visiting each child.</description>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onContainerFocus" scope="instance">
        <description>Initially the container itself has a tabIndex, but when it gets
	focus, switch focus to first child...</description>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onContainerKeypress" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onChildBlur" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_getFirstFocusableChild" scope="instance">
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="_getLastFocusableChild" scope="instance">
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="_getNextFocusableChild" scope="instance">
        <parameters>
          <parameter name="child" type="Widget" usage="required">
            <description>The current widget</description>
          </parameter>
          <parameter name="dir" type="Integer" usage="required">
            <description>* 1 = after
	* -1 = before</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="focusedChild" scope="instance" type="Widget">
        <description>The currently focused child widget, or null if there isn't one</description>
      </property>
      <property name="tabIndex" scope="instance" type="Integer">
        <description>Tab index of the container; same as HTML tabIndex attribute.
	Note then when user tabs into the container, focus is immediately
	moved to the first item in the container.</description>
      </property>
      <property name="_keyNavCodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._PaletteMixin" superclass="dijit._CssStateMixin">
    <description>A mixin for a grid showing various entities, so the user can pick a certain entity.</description>
    <methods>
      <method name="_preparePalette" scope="instance">
        <parameters>
          <parameter name="choices" type="Array&lt;Array&lt;String&gt;&gt;" usage="required">
            <description>id's for each cell of the palette, used to create Dye JS object for each cell</description>
          </parameter>
          <parameter name="titles" type="Array&lt;String&gt;" usage="required">
            <description>Localized tooltip for each cell</description>
          </parameter>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="_onCellClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setCurrent" scope="instance">
        <description>At any point in time there's exactly one
	cell with tabIndex != -1.   If focus is inside the palette then
	focus is on that cell.
	After calling this method, arrow key handlers and mouse click handlers
	should focus the cell in a setTimeout().</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>value of the cell to select</description>
          </parameter>
          <parameter name="priorityChange" type="Optional" usage="required">
            <description>parameter used to tell the select whether or not to fire
	onChange event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>Value corresponding to cell.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_navigateByKey" scope="instance">
        <parameters>
          <parameter name="increment" type="How" usage="required">
            <description>much the key is navigated.</description>
          </parameter>
          <parameter name="typeCount" type="How" usage="required">
            <description>many times typematic has fired.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getDye" scope="instance">
        <parameters>
          <parameter name="cell" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultTimeout" scope="instance" type="Number">
        <description>Number of milliseconds before a held key or button becomes typematic</description>
      </property>
      <property name="timeoutChangeRate" scope="instance" type="Number">
        <description>Fraction of time used to change the typematic timer between events
	1.0 means that each typematic event fires at defaultTimeout intervals
	&amp;lt; 1.0 means that each typematic event fires at an increasing faster rate</description>
      </property>
      <property name="value" scope="instance" type="String">
        <description>Currently selected color/emoticon/etc.</description>
      </property>
      <property name="_selectedCell" scope="instance" type="Integer">
        <description>Index of the currently selected cell. Initially, none selected</description>
      </property>
      <property name="_currentFocus" scope="instance" type="DomNode">
        <description>The currently focused cell (if the palette itself has focus), or otherwise
	the cell to be focused when the palette itself gets focus.
	Different from value, which represents the selected (i.e. clicked) cell.</description>
      </property>
      <property name="_xDim" scope="instance" type="Integer">
        <description>This is the number of cells horizontally across.</description>
      </property>
      <property name="_yDim" scope="instance" type="Integer">
        <description>This is the number of cells vertically down.</description>
      </property>
      <property name="tabIndex" scope="instance" type="String">
        <description>Widget tab index.</description>
      </property>
      <property name="cellClass" scope="instance" type="String">
        <description>CSS class applied to each cell in the palette</description>
      </property>
      <property name="dyeClass" scope="instance" type="String">
        <description>Name of javascript class for Object created for each cell of the palette.
	dyeClass should implements dijit.Dye interface</description>
      </property>
      <property name="_cells" scope="instance" type="Array"/>
      <property name="_blankGif" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.Dye">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <description>For example color hex value, emoticon ascii value etc, entity hex value.</description>
      </method>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DomNode" usage="required">
            <description>The surrounding cell</description>
          </parameter>
          <parameter name="blankGif" type="String" usage="required">
            <description>URL for blank cell image</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit._Widget" superclass="dijit._WidgetBase">
    <methods>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDblClick" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="event" type="key" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="event" type="key" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="event" type="key" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseLeave" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseEnter" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <description>Event</description>
          </parameter>
        </parameters>
      </method>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="optional"/>
          <parameter name="srcNodeRef" type="DomNode|String" usage="optional"/>
        </parameters>
      </method>
      <method name="_onConnect" scope="instance">
        <parameters>
          <parameter name="event" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="isFocusable" scope="instance"/>
      <method name="onFocus" scope="instance"/>
      <method name="onBlur" scope="instance"/>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="setAttribute" scope="instance">
        <parameters>
          <parameter name="attr" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="instance">
        <description>This method is deprecated, use get() or set() directly.</description>
        <parameters>
          <parameter name="name" type="String|Object" usage="required">
            <description>The property to get or set. If an object is passed here and not
	a string, its keys are used as names of attributes to be set
	and the value of the object as values to set in the widget.</description>
          </parameter>
          <parameter name="value" type="Object" usage="optional">
            <description>Optional. If provided, attr() operates as a setter. If omitted,
	the current value of the named property is returned.</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance">
        <description>Provide widget-specific analog to dojo.connect, except with the
	implicit use of this widget as the target object.
	This version of connect also provides a special "ondijitclick"
	event which triggers on a click or space or enter keyup.
	Events connected with `this.connect` are disconnected upon
	destruction.</description>
        <examples>
          <example>	var btn = new dijit.form.Button();
		// when foo.bar() is called, call the listener we're going to
		// provide in the scope of btn
		btn.connect(foo, "bar", function(){
			console.debug(this.toString());
		});</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required"/>
          <parameter name="event" type="String|Function" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
        <return-description>A handle that can be passed to `disconnect` in order to disconnect before
	the widget is destroyed.</return-description>
        <return-types>
          <return-type type="_Widget.Handle"/>
        </return-types>
      </method>
      <method name="_onShow" scope="instance"/>
      <method name="onShow" scope="instance"/>
      <method name="onHide" scope="instance"/>
      <method name="onClose" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="dojoAttachEvent" scope="instance" type="String"/>
      <property name="dojoAttachPoint" scope="instance" type="String"/>
      <property name="waiRole" scope="instance" type="String"/>
      <property name="waiState" scope="instance" type="String"/>
      <property name="focused" scope="instance" type="Boolean">
        <description>This widget or a widget it contains has focus, or is &amp;quot;active&amp;quot; because
	it was recently clicked.</description>
      </property>
      <property name="nodesWithKeyClick" scope="instance" type="Array&lt;String&gt;">
        <description>List of nodes that correctly handle click events via native browser support,
	and don't need dijit's help</description>
      </property>
      <property name="region" scope="instance" type="String">
        <description>Parameter for children of &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt;.
	Values: &amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;, &amp;quot;leading&amp;quot;, &amp;quot;trailing&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;center&amp;quot;.
	See the &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt; description for details.</description>
      </property>
      <property name="layoutPriority" scope="instance" type="Number">
        <description>Parameter for children of &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt;.
	Children with a higher layoutPriority will be placed closer to the BorderContainer center,
	between children with a lower layoutPriority.</description>
      </property>
      <property name="splitter" scope="instance" type="Boolean">
        <description>Parameter for child of &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt; where region != &amp;quot;center&amp;quot;.
	If true, enables user to resize the widget by putting a draggable splitter between
	this widget and the region=center widget.</description>
      </property>
      <property name="minSize" scope="instance" type="Number">
        <description>Parameter for children of &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt;.
	Specifies a minimum size (in pixels) for this widget when resized by a splitter.</description>
      </property>
      <property name="maxSize" scope="instance" type="Number">
        <description>Parameter for children of &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt;.
	Specifies a maximum size (in pixels) for this widget when resized by a splitter.</description>
      </property>
      <property name="layoutAlign" scope="instance" type="String">
        <description>&amp;quot;none&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;bottom&amp;quot;, &amp;quot;top&amp;quot;, and &amp;quot;client&amp;quot;.
	See the LayoutContainer description for details on this parameter.</description>
      </property>
      <property name="sizeMin" scope="instance" type="Integer">
        <description>Deprecated.  Parameter for children of &lt;code&gt;dijit.layout.SplitContainer&lt;/code&gt;.
	Minimum size (width or height) of a child of a SplitContainer.
	The value is relative to other children's sizeShare properties.</description>
      </property>
      <property name="sizeShare" scope="instance" type="Integer">
        <description>Deprecated.  Parameter for children of &lt;code&gt;dijit.layout.SplitContainer&lt;/code&gt;.
	Size (width or height) of a child of a SplitContainer.
	The value is relative to other children's sizeShare properties.
	For example, if there are two children and each has sizeShare=10, then
	each takes up 50% of the available space.</description>
      </property>
      <property name="selected" scope="instance" type="Boolean">
        <description>Parameter for children of &lt;code&gt;dijit.layout.StackContainer&lt;/code&gt; or subclasses.
	Specifies that this widget should be the initially displayed pane.
	Note: to change the selected child use &lt;code&gt;dijit.layout.StackContainer.selectChild&lt;/code&gt;</description>
      </property>
      <property name="closable" scope="instance" type="Boolean">
        <description>Parameter for children of &lt;code&gt;dijit.layout.StackContainer&lt;/code&gt; or subclasses.
	True if user can close (destroy) this child, such as (for example) clicking the X on the tab.</description>
      </property>
      <property name="iconClass" scope="instance" type="String">
        <description>Parameter for children of &lt;code&gt;dijit.layout.StackContainer&lt;/code&gt; or subclasses.
	CSS Class specifying icon to use in label associated with this pane.</description>
      </property>
      <property name="showTitle" scope="instance" type="Boolean">
        <description>Parameter for children of &lt;code&gt;dijit.layout.StackContainer&lt;/code&gt; or subclasses.
	When true, display title of this widget as tab label etc., rather than just using
	icon specified in iconClass</description>
      </property>
      <property name="observer" scope="instance" type="String"/>
      <property name="column" scope="instance" type="String">
        <description>Column of the grid to place the widget.
	Defined only if dojo.require(&amp;quot;dojox.layout.GridContainerLite&amp;quot;) is done.</description>
      </property>
      <property name="dragRestriction" scope="instance" type="Boolean">
        <description>If true, the widget can not be draggable.
	Defined only if dojo.require(&amp;quot;dojox.layout.GridContainerLite&amp;quot;) is done.</description>
      </property>
      <property name="slideFrom" scope="instance" type="String">
        <description>A parameter needed by RadioGroupSlide only. An optional paramter to force
	the ContentPane to slide in from a set direction. Defaults
	to &amp;quot;random&amp;quot;, or specify one of &amp;quot;top&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;bottom&amp;quot;
	to slideFrom top, left, right, or bottom.</description>
      </property>
      <property name="label" scope="instance" type="String">
        <description>The label to display for a given widget</description>
      </property>
      <property name="title" scope="instance" type="String">
        <description>The label to display for a given widget.  This is interchangeable
	with the 'label' parameter, as some widgets already have a use
	for the 'label', and this can be used instead to avoid conflicts.</description>
      </property>
      <property name="spanLabel" scope="instance" type="Boolean">
        <description>Setting spanLabel to true makes the widget take up both the
	label and value cells. Defaults to false.</description>
      </property>
      <property name="colspan" scope="instance" type="Number">
        <description>The number of columns this widget should span.</description>
      </property>
      <property name="toggleSplitterOpen" scope="instance" type="Boolean"/>
      <property name="toggleSplitterClosedThreshold" scope="instance" type="String">
        <description>a css size value (e.g. &amp;quot;100px&amp;quot;)</description>
      </property>
      <property name="toggleSplitterOpenSize" scope="instance" type="String"/>
      <property name="dndType" scope="instance" type="String">
        <description>Defines a type of widget.</description>
      </property>
    </properties>
  </class>
  <class type="dijit._Templated">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_stringRepl" scope="instance">
        <parameters>
          <parameter name="tmpl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_attachTemplateNodes" scope="instance">
        <description>Map widget properties and functions to the handlers specified in
	the dom node and it's descendants. This function iterates over all
	nodes and looks for these properties:
	* dojoAttachPoint
	* dojoAttachEvent
	* waiRole
	* waiState</description>
        <parameters>
          <parameter name="rootNode" type="DomNode|Array[Widgets]" usage="required">
            <description>the node to search for properties. All children will be searched.</description>
          </parameter>
          <parameter name="getAttrFunc" type="Function" usage="optional">
            <description>a function which will be used to obtain property for a given
	DomNode/Widget</description>
          </parameter>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="destroyRendering" scope="instance"/>
      <method name="getCachedTemplate" scope="instance">
        <parameters>
          <parameter name="templatePath" type="String|dojo.uri.Uri" usage="required">
            <description>The URL to get the template from.</description>
          </parameter>
          <parameter name="templateString" type="String" usage="optional">
            <description>a string to use in lieu of fetching the template from a URL. Takes precedence
	over templatePath</description>
          </parameter>
          <parameter name="alwaysUseString" type="Object" usage="required"/>
        </parameters>
        <return-description>Mixed
	Either string (if there are ${} variables that need to be replaced) or just
	a DOM tree (if the node can be cloned directly)</return-description>
        <return-types>
          <return-type type="String"/>
          <return-type type="Node"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>A string that represents the widget template. Pre-empts the
	templatePath. In builds that have their strings &amp;quot;interned&amp;quot;, the
	templatePath is converted to an inline templateString, thereby
	preventing a synchronous network call.
	Use in conjunction with dojo.cache() to load from a file.</description>
      </property>
      <property name="templatePath" scope="instance" type="String">
        <description>Path to template (HTML file) for this widget relative to dojo.baseUrl.
	Deprecated: use templateString with dojo.cache() instead.</description>
      </property>
      <property name="widgetsInTemplate" scope="instance" type="Boolean">
        <description>Should we parse the template to find widgets that might be
	declared in markup inside it?  False by default.</description>
      </property>
      <property name="_skipNodeCache" scope="instance" type="bool"/>
      <property name="_earlyTemplatedStartup" scope="instance" type="Boolean">
        <description>A fallback to preserve the 1.0 - 1.3 behavior of children in
	templates having their startup called before the parent widget
	fires postCreate. Defaults to 'false', causing child widgets to
	have their .startup() called immediately before a parent widget
	.startup(), but always after the parent .postCreate(). Set to
	'true' to re-enable to previous, arguably broken, behavior.</description>
      </property>
      <property name="_attachPoints" scope="instance-prototype" type="Array&lt;String&gt;">
        <description>List of widget attribute names associated with dojoAttachPoint=... in the
	template, ex: [&amp;quot;containerNode&amp;quot;, &amp;quot;labelNode&amp;quot;]</description>
      </property>
      <property name="_attachEvents" scope="instance-prototype" type="Array&lt;Handle&gt;">
        <description>List of connections associated with dojoAttachEvent=... in the
	template</description>
      </property>
      <property name="declaredClass" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_startupWidgets" scope="instance" type="Object"/>
      <property name="_supportingWidgets" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_templateCache" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TimePicker" superclass="dijit._Widget">
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="val" type="Date" usage="required">
            <description>The current value</description>
          </parameter>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>Set the value of the TimePicker.
	Redraws the TimePicker around the new date.</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setFilterStringAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getFilteredNodes" scope="instance">
        <parameters>
          <parameter name="start" type="number" usage="required"/>
          <parameter name="maxNum" type="number" usage="required"/>
          <parameter name="before" type="Boolean" usage="required"/>
          <parameter name="lastNode" type="DOMnode" usage="required"/>
        </parameters>
      </method>
      <method name="_showText" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_buttonMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_createOption" scope="instance">
        <parameters>
          <parameter name="index" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onOptionSelected" scope="instance">
        <parameters>
          <parameter name="tgt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="time" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightOption" scope="instance">
        <parameters>
          <parameter name="node" type="node" usage="required"/>
          <parameter name="highlight" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onmouseover" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onmouseout" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onArrowUp" scope="instance">
        <description>Removes the bottom time and add one to the top</description>
        <parameters>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="typematic end"/>
        </return-types>
      </method>
      <method name="_onArrowDown" scope="instance">
        <description>Remove the top time and add one to the bottom</description>
        <parameters>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="typematic end"/>
        </return-types>
      </method>
      <method name="handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="true means don't call stopEvent()"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String">
        <description>The root className to use for the various states of this widget</description>
      </property>
      <property name="clickableIncrement" scope="instance" type="String">
        <description>ISO-8601 string representing the amount by which
	every clickable element in the time picker increases.
	Set in local time, without a time zone.
	Example: &lt;code&gt;T00:15:00&lt;/code&gt; creates 15 minute increments
	Must divide dijit._TimePicker.visibleIncrement evenly</description>
      </property>
      <property name="visibleIncrement" scope="instance" type="String">
        <description>ISO-8601 string representing the amount by which
	every element with a visible time in the time picker increases.
	Set in local time, without a time zone.
	Example: &lt;code&gt;T01:00:00&lt;/code&gt; creates text in every 1 hour increment</description>
      </property>
      <property name="visibleRange" scope="instance" type="String">
        <description>ISO-8601 string representing the range of this TimePicker.
	The TimePicker will only display times in this range.
	Example: &lt;code&gt;T05:00:00&lt;/code&gt; displays 5 hours of options</description>
      </property>
      <property name="value" scope="instance" type="String">
        <description>Date to display.
	Defaults to current time and date.
	Can be a Date object or an ISO-8601 string.
	If you specify the GMT time zone (&lt;code&gt;-01:00&lt;/code&gt;),
	the time will be converted to the local time in the local time zone.
	Otherwise, the time is considered to be in the local time zone.
	If you specify the date and isDate is true, the date is used.
	Example: if your local time zone is &lt;code&gt;GMT -05:00&lt;/code&gt;,
	&lt;code&gt;T10:00:00&lt;/code&gt; becomes &lt;code&gt;T10:00:00-05:00&lt;/code&gt; (considered to be local time),
	&lt;code&gt;T10:00:00-01:00&lt;/code&gt; becomes &lt;code&gt;T06:00:00-05:00&lt;/code&gt; (4 hour difference),
	&lt;code&gt;T10:00:00Z&lt;/code&gt; becomes &lt;code&gt;T05:00:00-05:00&lt;/code&gt; (5 hour difference between Zulu and local time)
	&lt;code&gt;yyyy-mm-ddThh:mm:ss&lt;/code&gt; is the format to set the date and time
	Example: &lt;code&gt;2007-06-01T09:00:00&lt;/code&gt;</description>
      </property>
      <property name="_visibleIncrement" scope="instance" type="Number"/>
      <property name="_clickableIncrement" scope="instance" type="Number"/>
      <property name="_totalIncrements" scope="instance" type="Number"/>
      <property name="constraints" scope="instance-prototype" type="dijit._TimePicker.__Constraints">
        <description>Specifies valid range of times (start time, end time)</description>
      </property>
      <property name="filterString" scope="instance" type="string">
        <description>The string to filter by</description>
      </property>
      <property name="_clickableIncrementDate" scope="instance" type="Object"/>
      <property name="_visibleIncrementDate" scope="instance" type="Object"/>
      <property name="_visibleRangeDate" scope="instance" type="Object"/>
      <property name="_refDate" scope="instance" type="Object"/>
      <property name="_maxIncrement" scope="instance" type="Number"/>
      <property name="_highlighted_option" scope="instance" type="Object"/>
      <property name="_keyboardSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._TimePicker.__Constraints" superclass="dojo.date.locale.__FormatOptions">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.date.locale.__FormatOptions" scope="instance"/>
    </mixins>
    <properties>
      <property name="clickableIncrement" scope="instance" type="String">
        <description>See &lt;code&gt;dijit._TimePicker.clickableIncrement&lt;/code&gt;</description>
      </property>
      <property name="visibleIncrement" scope="instance" type="String">
        <description>See &lt;code&gt;dijit._TimePicker.visibleIncrement&lt;/code&gt;</description>
      </property>
      <property name="visibleRange" scope="instance" type="String">
        <description>See &lt;code&gt;dijit._TimePicker.visibleRange&lt;/code&gt;</description>
      </property>
    </properties>
  </class>
  <class type="dijit._TimePicker.timeMenu">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._TimePicker.timeMenu.childNodes.0">
    <properties>
      <property name="index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._Widget._deferredConnects">
    <properties>
      <property name="onClick" scope="instance" type="String"/>
      <property name="onDblClick" scope="instance" type="String"/>
      <property name="onKeyDown" scope="instance" type="String"/>
      <property name="onKeyPress" scope="instance" type="String"/>
      <property name="onKeyUp" scope="instance" type="String"/>
      <property name="onMouseMove" scope="instance" type="String"/>
      <property name="onMouseDown" scope="instance" type="String"/>
      <property name="onMouseOut" scope="instance" type="String"/>
      <property name="onMouseOver" scope="instance" type="String"/>
      <property name="onMouseLeave" scope="instance" type="String"/>
      <property name="onMouseEnter" scope="instance" type="String"/>
      <property name="onMouseUp" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._WidgetBase" superclass="dojo.Stateful">
    <methods>
      <method name="create" scope="instance">
        <description>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
	etc.), some of which of you'll want to override. See http://docs.dojocampus.org/dijit/_Widget
	for a discussion of the widget creation lifecycle.
	Of course, adventurous developers could override create entirely, but this should
	only be done as a last resort.</description>
        <parameters>
          <parameter name="params" type="Object" usage="optional">
            <description>Hash of initialization parameters for widget, including
	scalar values (like title, duration etc.) and functions,
	typically callbacks like onClick.</description>
          </parameter>
          <parameter name="srcNodeRef" type="DomNode|String" usage="optional">
            <description>If a srcNodeRef (DOM node) is specified:
	- use srcNodeRef.innerHTML as my contents
	- if this is a behavioral widget then apply behavior
	to that srcNodeRef
	- otherwise, replace srcNodeRef with my generated DOM
	tree</description>
          </parameter>
        </parameters>
      </method>
      <method name="_applyAttributes" scope="instance">
        <description>Skips over blank/false attribute values, unless they were explicitly specified
	as parameters to the widget, since those are the default anyway,
	and setting tabIndex="" is different than not setting tabIndex at all.
	It processes the attributes in the attribute map first, and then
	it goes through and processes the attributes for the _setXXXAttr
	functions that have been specified</description>
      </method>
      <method name="_getSetterAttributes" scope="instance">
        <return-types>
          <return-type type="Array&lt;String&gt;"/>
        </return-types>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance">
        <description>Most widgets will mixin `dijit._Templated`, which implements this
	method.</description>
      </method>
      <method name="postCreate" scope="instance">
        <description>Called after the DOM fragment has been created, but not necessarily
	added to the document.  Do not include any operations which rely on
	node dimensions or placement.</description>
      </method>
      <method name="startup" scope="instance">
        <description>Called after a widget and its children have been created and added to the page,
	and all related widgets have finished their create() cycle, up through postCreate().
	This is useful for composite widgets that need to control or layout sub-widgets.
	Many layout widgets can use this as a wiring phase.</description>
      </method>
      <method name="destroyRecursive" scope="instance">
        <description>This is the generic "destructor" function that all widget users
	should call to cleanly discard with a widget. Once a widget is
	destroyed, it is removed from the manager object.</description>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional">
            <description>If true, this method will leave the original DOM structure
	alone of descendant Widgets. Note: This will NOT work with
	dijit._Templated widgets.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required">
            <description>If true, this method will leave the original DOM structure alone.
	Note: This will not yet work with _Templated widgets</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroyRendering" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional">
            <description>If true, this method will leave the original DOM structure alone
	during tear-down. Note: this will not work with _Templated
	widgets yet.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional">
            <description>If true, the preserveDom attribute is passed to all descendant
	widget's .destroy() method. Not for use with _Templated
	widgets.</description>
          </parameter>
        </parameters>
      </method>
      <method name="uninitialize" scope="instance"/>
      <method name="_setClassAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setStyleAttr" scope="instance">
        <description>Determines which node to set the style on based on style setting
	in attributeMap.</description>
        <parameters>
          <parameter name="value" type="String|Object" usage="required"/>
        </parameters>
      </method>
      <method name="_attrToDom" scope="instance">
        <parameters>
          <parameter name="attr" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <description>Get a named property from a widget. The property may
	potentially be retrieved via a getter method. If no getter is defined, this
	just retrieves the object's property.
	For example, if the widget has a properties "foo"
	and "bar" and a method named "_getFooAttr", calling:
		myWidget.get("foo");
	would be equivalent to writing:
		widget._getFooAttr();
	and:
		myWidget.get("bar");
	would be equivalent to writing:
		widget.bar;</description>
        <parameters>
          <parameter name="name" type="The" usage="required">
            <description>property to get.</description>
          </parameter>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <description>Sets named properties on a widget which may potentially be handled by a
	setter in the widget.
	For example, if the widget has a properties "foo"
	and "bar" and a method named "_setFooAttr", calling:
		myWidget.set("foo", "Howdy!");
	would be equivalent to writing:
		widget._setFooAttr("Howdy!");
	and:
		myWidget.set("bar", 3);
	would be equivalent to writing:
		widget.bar = 3;
	set() may also be called with a hash of name/value pairs, ex:
		myWidget.set({
			foo: "Howdy",
			bar: 3
		})
	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)</description>
        <parameters>
          <parameter name="name" type="The" usage="required">
            <description>property to set.</description>
          </parameter>
          <parameter name="value" type="The" usage="required">
            <description>value to set in the property.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getAttrNames" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <description>When a widget is cast to a string, this method will be used to generate the
	output. Currently, it does not implement any sort of reversible
	serialization.</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getDescendants" scope="instance">
        <return-types>
          <return-type type="Array&lt;dijit._Widget&gt;"/>
        </return-types>
      </method>
      <method name="getChildren" scope="instance">
        <return-types>
          <return-type type="Array&lt;dijit._Widget&gt;"/>
        </return-types>
      </method>
      <method name="connect" scope="instance">
        <description>Provide widget-specific analog to dojo.connect, except with the
	implicit use of this widget as the target object.
	Events connected with `this.connect` are disconnected upon
	destruction.</description>
        <examples>
          <example>	var btn = new dijit.form.Button();
		// when foo.bar() is called, call the listener we're going to
		// provide in the scope of btn
		btn.connect(foo, "bar", function(){
			console.debug(this.toString());
		});</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required"/>
          <parameter name="event" type="String|Function" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
        <return-description>A handle that can be passed to `disconnect` in order to disconnect before
	the widget is destroyed.</return-description>
        <return-types>
          <return-type type="_Widget.Handle"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <parameters>
          <parameter name="handles" type="_Widget.Handle" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <description>Provide widget-specific analog to dojo.subscribe, except with the
	implicit use of this widget as the target object.</description>
        <examples>
          <example>	var btn = new dijit.form.Button();
		// when /my/topic is published, this button changes its label to
		 // be the parameter of the topic.
		btn.subscribe("/my/topic", function(v){
			this.set("label", v);
		});</example>
        </examples>
        <parameters>
          <parameter name="topic" type="String" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isLeftToRight" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="placeAt" scope="instance">
        <description>A convenience function provided in all _Widgets, providing a simple
	shorthand mechanism to put an existing (or newly created) Widget
	somewhere in the dom, and allow chaining.</description>
        <examples>
          <example> 	// create a Button with no srcNodeRef, and place it in the body:
	 	var button = new dijit.form.Button({ label:"click" }).placeAt(dojo.body());
	 	// now, 'button' is still the widget reference to the newly created button
	 	dojo.connect(button, "onClick", function(e){ console.log('click'); });</example>
          <example>	// create a button out of a node with id="src" and append it to id="wrapper":
	 	var button = new dijit.form.Button({},"src").placeAt("wrapper");</example>
          <example>	// place a new button as the first element of some div
		var button = new dijit.form.Button({ label:"click" }).placeAt("wrapper","first");</example>
          <example>	// create a contentpane and add it to a TabContainer
		var tc = dijit.byId("myTabs");
		new dijit.layout.ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)</example>
        </examples>
        <parameters>
          <parameter name="reference" type="String|DomNode|_Widget" usage="required">
            <description>The String id of a domNode, a domNode reference, or a reference to a Widget posessing
	an addChild method.</description>
          </parameter>
          <parameter name="position" type="String|Int" usage="optional">
            <description>If passed a string or domNode reference, the position argument
	accepts a string just as dojo.place does, one of: &amp;quot;first&amp;quot;, &amp;quot;last&amp;quot;,
	&amp;quot;before&amp;quot;, or &amp;quot;after&amp;quot;.
	If passed a _Widget reference, and that widget reference has an &amp;quot;.addChild&amp;quot; method,
	it will be called passing this widget instance into that method, supplying the optional
	position index passed.</description>
          </parameter>
        </parameters>
        <return-description>dijit._Widget
	Provides a useful return of the newly created dijit._Widget instance so you
	can "chain" this function by instantiating, placing, then saving the return value
	to a variable.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.Stateful" scope="instance"/>
    </mixins>
    <properties>
      <property name="id" scope="instance" type="String">
        <description>A unique, opaque ID string that can be assigned by users or by the
	system. If the developer passes an ID which is known not to be
	unique, the specified ID is ignored and the system-generated ID is
	used instead.</description>
      </property>
      <property name="lang" scope="instance" type="String">
        <description>Rarely used.  Overrides the default Dojo locale used to render this widget,
	as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
	Value must be among the list of locales specified during by the Dojo bootstrap,
	formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).</description>
      </property>
      <property name="dir" scope="instance" type="String">
        <description>Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
	attribute. Either left-to-right &amp;quot;ltr&amp;quot; or right-to-left &amp;quot;rtl&amp;quot;.  If undefined, widgets renders in page's
	default direction.</description>
      </property>
      <property name="class" scope="instance" type="String">
        <description>HTML class attribute</description>
      </property>
      <property name="style" scope="instance" type="String|Object">
        <description>HTML style attributes as cssText string or name/value hash</description>
      </property>
      <property name="title" scope="instance" type="String">
        <description>HTML title attribute.
	For form widgets this specifies a tooltip to display when hovering over
	the widget (just like the native HTML title attribute).
	For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
	etc., it's used to specify the tab label, accordion pane title, etc.</description>
      </property>
      <property name="tooltip" scope="instance" type="String">
        <description>When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
	this specifies the tooltip to appear when the mouse is hovered over that text.</description>
      </property>
      <property name="baseClass" scope="instance" type="String">
        <description>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
	widget state.</description>
      </property>
      <property name="srcNodeRef" scope="instance" type="DomNode">
        <description>pointer to original DOM node</description>
      </property>
      <property name="domNode" scope="instance" type="DomNode">
        <description>This is our visible representation of the widget! Other DOM
	Nodes may by assigned to other properties, usually through the
	template system's dojoAttachPoint syntax, but the domNode
	property is the canonical &amp;quot;top level&amp;quot; node in widget UI.</description>
      </property>
      <property name="containerNode" scope="instance" type="DomNode">
        <description>Designates where children of the source DOM node will be placed.
	&amp;quot;Children&amp;quot; in this case refers to both DOM nodes and widgets.
	For example, for myWidget:
		&amp;lt;div dojoType=myWidget&amp;gt;
			&amp;lt;b&amp;gt; here's a plain DOM node
			&amp;lt;span dojoType=subWidget&amp;gt;and a widget&amp;lt;/span&amp;gt;
			&amp;lt;i&amp;gt; and another plain DOM node &amp;lt;/i&amp;gt;
		&amp;lt;/div&amp;gt;
	containerNode would point to:
			&amp;lt;b&amp;gt; here's a plain DOM node
			&amp;lt;span dojoType=subWidget&amp;gt;and a widget&amp;lt;/span&amp;gt;
			&amp;lt;i&amp;gt; and another plain DOM node &amp;lt;/i&amp;gt;
	In templated widgets, &amp;quot;containerNode&amp;quot; is set via a
	dojoAttachPoint assignment.
	containerNode must be defined for any widget that accepts innerHTML
	(like ContentPane or BorderContainer or even Button), and conversely
	is null for widgets that don't, like TextBox.</description>
      </property>
      <property name="_started" scope="instance" type="Boolean">
        <description>startup() has completed.</description>
      </property>
      <property name="_blankGif" scope="instance" type="String">
        <description>Path to a blank 1x1 image.
	Used by &amp;lt;img&amp;gt; nodes in templates that really get their image via CSS background-image.</description>
      </property>
      <property name="_connects" scope="instance" type="Array"/>
      <property name="_subscribes" scope="instance" type="Array"/>
      <property name="params" scope="instance" type="Object"/>
      <property name="_created" scope="instance" type="Object"/>
      <property name="_beingDestroyed" scope="instance" type="Object"/>
      <property name="_destroyed" scope="instance" type="Object"/>
      <property name="_attrPairNames" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._WidgetBase.attributeMap">
    <properties>
      <property name="id" scope="instance" type="String"/>
      <property name="dir" scope="instance" type="String"/>
      <property name="lang" scope="instance" type="String"/>
      <property name="class" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="title" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._WidgetBase.constructor">
    <properties>
      <property name="_setterAttrs" scope="instance" type="Array"/>
      <property name="prototype" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._base">
    <properties>
      <property name="focus" scope="instance" type="Object"/>
      <property name="manager" scope="instance" type="Object"/>
      <property name="place" scope="instance" type="Object"/>
      <property name="popup" scope="instance" type="Object"/>
      <property name="scroll" scope="instance" type="Object"/>
      <property name="sniff" scope="instance" type="Object"/>
      <property name="typematic" scope="instance" type="Object"/>
      <property name="wai" scope="instance" type="Object"/>
      <property name="window" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.WidgetSet">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required">
            <description>Any dijit._Widget subclass.</description>
          </parameter>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="forEach" scope="instance">
        <examples>
          <example>Using the default `dijit.registry` instance:
		dijit.registry.forEach(function(widget){
			console.log(widget.declaredClass);
		});</example>
        </examples>
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <description>A callback function to run for each item. Is passed the widget, the index
	in the iteration, and the full hash, similar to &lt;code&gt;dojo.forEach&lt;/code&gt;.</description>
          </parameter>
          <parameter name="thisObj" type="Object" usage="optional">
            <description>An optional scope parameter</description>
          </parameter>
        </parameters>
        <return-description>Returns self, in order to allow for further chaining.</return-description>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <examples>
          <example>Arbitrary: select the odd widgets in this list
		dijit.registry.filter(function(w, i){
			return i % 2 == 0;
		}).forEach(function(w){ /* odd ones */ });</example>
        </examples>
        <parameters>
          <parameter name="filter" type="Function" usage="required">
            <description>Callback function to test truthiness. Is passed the widget
	reference and the pseudo-index in the object.</description>
          </parameter>
          <parameter name="thisObj" type="Object" usage="optional">
            <description>Option scope to use for the filter function.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="byId" scope="instance">
        <examples>
          <example>Test if an id is in a particular WidgetSet
	 var ws = new dijit.WidgetSet();
	 ws.add(dijit.byId("bar"));
	 var t = ws.byId("bar") // returns a widget
	 var x = ws.byId("foo"); // returns undefined</example>
        </examples>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="byClass" scope="instance">
        <examples>
          <example>Find all `dijit.TitlePane`s in a page:
		dijit.registry.byClass("dijit.TitlePane").forEach(function(tp){ tp.close(); });</example>
        </examples>
        <parameters>
          <parameter name="cls" type="String" usage="required">
            <description>The Class to scan for. Full dot-notated string.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="toArray" scope="instance">
        <examples>
          <example>Work with the widget .domNodes in a real Array
		dojo.map(dijit.registry.toArray(), function(w){ return w.domNode; });</example>
        </examples>
        <return-types>
          <return-type type="Array&lt;dijit._Widget&gt;"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <examples>
          <example>	var nodes = dijit.registry.map(function(w){ return w.domNode; });</example>
        </examples>
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
          <parameter name="thisObj" type="Object" usage="optional"/>
        </parameters>
        <return-description>A new array of the returned values.</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="every" scope="instance">
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <description>A callback function run for every widget in this list. Exits loop
	when the first false return is encountered.</description>
          </parameter>
          <parameter name="thisObj" type="Object" usage="optional">
            <description>Optional scope parameter to use for the callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="instance">
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <description>A callback function run for every widget in this list. Exits loop
	when the first true return is encountered.</description>
          </parameter>
          <parameter name="thisObj" type="Object" usage="optional">
            <description>Optional scope parameter to use for the callback</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_hash" scope="instance" type="Object"/>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.registry">
    <description>Is an instance of `dijit.WidgetSet`</description>
    <properties>
      <property name="_hash" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.__Position">
    <methods/>
    <properties>
      <property name="y" scope="instance" type="Integer">
        <description>vertical coordinate in pixels, relative to document body</description>
      </property>
    </properties>
  </class>
  <class type="thix">
    <properties>
      <property name="x" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.__Rectangle">
    <methods/>
    <properties>
      <property name="x" scope="instance" type="Integer">
        <description>horizontal offset in pixels, relative to document body</description>
      </property>
      <property name="y" scope="instance" type="Integer">
        <description>vertical offset in pixels, relative to document body</description>
      </property>
      <property name="width" scope="instance" type="Integer">
        <description>width in pixels</description>
      </property>
      <property name="height" scope="instance" type="Integer">
        <description>height in pixels</description>
      </property>
    </properties>
  </class>
  <class type="dijit.BackgroundIframe">
    <description>new dijit.BackgroundIframe(node)
	Makes a background iframe as a child of node, that fills
	area (and position) of node</description>
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="iframe" scope="instance" type="Object"/>
      <property name="_conn" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.BackgroundIframe.destroy">
    <methods/>
    <properties>
      <property name="_conn" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.popup">
    <methods>
      <method name="_createWrapper" scope="instance">
        <parameters>
          <parameter name="widget" type="Widget" usage="required">
            <description>|| DomNode</description>
          </parameter>
        </parameters>
      </method>
      <method name="moveOffScreen" scope="instance">
        <parameters>
          <parameter name="widget" type="Widget" usage="required">
            <description>|| DomNode</description>
          </parameter>
        </parameters>
      </method>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_stack" scope="instance" type="Array&lt;dijit._Widget&gt;">
        <description>Stack of currently popped up widgets.
	(someone opened _stack[0], and then it opened _stack[1], etc.)</description>
      </property>
      <property name="_beginZIndex" scope="instance" type="Number">
        <description>Z-index of the first popup.   (If first popup opens other
	popups they get a higher z-index.)</description>
      </property>
      <property name="_idGen" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.popup.__OpenArgs">
    <methods>
      <method name="onCancel" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="onExecute" scope="instance"/>
    </methods>
    <properties>
      <property name="popup" scope="instance" type="Widget">
        <description>widget to display</description>
      </property>
      <property name="parent" scope="instance" type="Widget">
        <description>the button etc. that is displaying this popup</description>
      </property>
      <property name="around" scope="instance" type="DomNode">
        <description>DOM node (typically a button); place popup relative to this node.  (Specify this *or* &amp;quot;x&amp;quot; and &amp;quot;y&amp;quot; parameters.)</description>
      </property>
      <property name="x" scope="instance" type="Integer">
        <description>Absolute horizontal position (in pixels) to place node at.  (Specify this *or* &amp;quot;around&amp;quot; parameter.)</description>
      </property>
      <property name="y" scope="instance" type="Integer">
        <description>Absolute vertical position (in pixels) to place node at.  (Specify this *or* &amp;quot;around&amp;quot; parameter.)</description>
      </property>
      <property name="orient" scope="instance" type="Object|String">
        <description>When the around parameter is specified, orient should be an
	ordered list of tuples of the form (around-node-corner, popup-node-corner).
	dijit.popup.open() tries to position the popup according to each tuple in the list, in order,
	until the popup appears fully within the viewport.
	The default value is {BL:'TL', TL:'BL'}, which represents a list of two tuples:
	1. (BL, TL)
	2. (TL, BL)
	where BL means &amp;quot;bottom left&amp;quot; and &amp;quot;TL&amp;quot; means &amp;quot;top left&amp;quot;.
	So by default, it first tries putting the popup below the around node, left-aligning them,
	and then tries to put it above the around node, still left-aligning them.   Note that the
	default is horizontally reversed when in RTL mode.
	When an (x,y) position is specified rather than an around node, orient is either
	&amp;quot;R&amp;quot; or &amp;quot;L&amp;quot;.  R (for right) means that it tries to put the popup to the right of the mouse,
	specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
	fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
	and the top-right corner.</description>
      </property>
      <property name="padding" scope="instance" type="dijit.__Position">
        <description>adding a buffer around the opening position. This is only useful when around is not set.</description>
      </property>
    </properties>
  </class>
  <class type="dijit.popup.getTopPopup">
    <methods/>
    <properties>
      <property name="_stack" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.popup.open">
    <methods/>
    <properties>
      <property name="_stack" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.popup.close">
    <methods/>
    <properties>
      <property name="_stack" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.typematic">
    <methods>
      <method name="addKeyListener" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="keyObject" type="Object" usage="required">
            <description>an object defining the key to listen for:
	charOrCode:
	the printable character (string) or keyCode (number) to listen for.
	keyCode:
	(deprecated - use charOrCode) the keyCode (number) to listen for (implies charCode = 0).
	charCode:
	(deprecated - use charOrCode) the charCode (number) to listen for.
	ctrlKey:
	desired ctrl key state to initiate the callback sequence:
	- pressed (true)
	- released (false)
	- either (unspecified)
	altKey:
	same as ctrlKey but for the alt key
	shiftKey:
	same as ctrlKey but for the shift key</description>
          </parameter>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
          <parameter name="minDelay" type="Number" usage="optional"/>
        </parameters>
        <return-description>an array of dojo.connect handles</return-description>
      </method>
      <method name="addMouseListener" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
          <parameter name="minDelay" type="Number" usage="optional"/>
        </parameters>
        <return-description>an array of dojo.connect handles</return-description>
      </method>
      <method name="addListener" scope="instance">
        <parameters>
          <parameter name="mouseNode" type="Node" usage="required">
            <description>the DOM node object to listen on for mouse events.</description>
          </parameter>
          <parameter name="keyNode" type="Node" usage="required">
            <description>the DOM node object to listen on for key events.</description>
          </parameter>
          <parameter name="keyObject" type="Object" usage="required"/>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
          <parameter name="minDelay" type="Number" usage="optional"/>
        </parameters>
        <return-description>an array of dojo.connect handles</return-description>
      </method>
    </methods>
  </class>
  <class type="dijit.typematic._fireEventAndReload">
    <methods/>
    <properties>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="_currentTimeout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.typematic.trigger">
    <methods/>
    <properties>
      <property name="_initialDelay" scope="instance" type="Number"/>
      <property name="_subsequentDelay" scope="instance" type="Number"/>
      <property name="_minDelay" scope="instance" type="Number"/>
      <property name="_obj" scope="instance" type="Object"/>
      <property name="_evt" scope="instance" type="Object"/>
      <property name="_node" scope="instance" type="Object"/>
      <property name="_currentTimeout" scope="instance" type="Number"/>
      <property name="_count" scope="instance" type="Number"/>
      <property name="_callback" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.typematic.stop">
    <methods/>
    <properties>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="_obj" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.wai">
    <methods>
      <method name="onload" scope="instance"/>
    </methods>
  </class>
  <class type="dijit._editor.RichText" superclass="dijit._Widget">
    <description>dijit._editor.RichText is the core of dijit.Editor, which provides basic
	WYSIWYG editing features. It also encapsulates the differences
	of different js engines for various browsers.  Do not use this widget
	with an HTML &amp;lt;TEXTAREA&amp;gt; tag, since the browser unescapes XML escape characters,
	like &amp;lt;.  This can have unexpected behavior and lead to security issues
	such as scripting attacks.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>dijit._editor.RichText is the core of dijit.Editor, which provides basic
	WYSIWYG editing features. It also encapsulates the differences
	of different js engines for various browsers.  Do not use this widget
	with an HTML &amp;lt;TEXTAREA&amp;gt; tag, since the browser unescapes XML escape characters,
	like &amp;lt;.  This can have unexpected behavior and lead to security issues
	such as scripting attacks.</description>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="setupDefaultShortcuts" scope="instance">
        <description>Overwrite this to setup your own handlers. The default
	implementation does not use Editor commands, but directly
	executes the builtin commands within the underlying browser
	support.</description>
      </method>
      <method name="_localizeEditorCommands" scope="instance"/>
      <method name="open" scope="instance">
        <description>Sets up the editing area asynchronously. This will result in
	the creation and replacement with an iframe.</description>
        <parameters>
          <parameter name="element" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_getIframeDocTxt" scope="instance"/>
      <method name="_applyEditingAreaStyleSheets" scope="instance"/>
      <method name="addStyleSheet" scope="instance">
        <parameters>
          <parameter name="uri" type="dojo._Url" usage="required">
            <description>A dojo.uri.Uri pointing to the url of the external css file</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeStyleSheet" scope="instance">
        <parameters>
          <parameter name="uri" type="dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="this method requires init to be complete"/>
          <return-type type="! _disabledOK"/>
        </return-types>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>Editor contents should be set to this value</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisableSpellCheckAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addKeyHandler" scope="instance">
        <description>The key argument should be in lowercase if it is a letter character</description>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="ctrl" type="Boolean" usage="required"/>
          <parameter name="shift" type="Boolean" usage="required"/>
          <parameter name="handler" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPressed" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onIEMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="blur" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="onDisplayChanged" scope="instance">
        <description>If you don't want to have update too often,
	onNormalizedDisplayChanged should be used instead</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onNormalizedDisplayChanged" scope="instance">
        <description>If something needs to happen immediately after a
	user change, please use onDisplayChanged instead.</description>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="newContent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeCommand" scope="instance">
        <parameters>
          <parameter name="cmd" type="String" usage="required"/>
          <parameter name="argument" type="Anything" usage="optional"/>
        </parameters>
      </method>
      <method name="queryCommandAvailable" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required">
            <description>The command to test for</description>
          </parameter>
        </parameters>
      </method>
      <method name="_queryCommandAvailable" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="execCommand" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required">
            <description>The command to execute</description>
          </parameter>
          <parameter name="argument" type="An" usage="required">
            <description>optional argument to the command</description>
          </parameter>
        </parameters>
      </method>
      <method name="queryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="command" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandState" scope="instance">
        <parameters>
          <parameter name="command" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandValue" scope="instance">
        <parameters>
          <parameter name="command" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_sCall" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="placeCursorAtStart" scope="instance"/>
      <method name="placeCursorAtEnd" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="nonDestructive" type="Boolean" usage="optional">
            <description>defaults to false. Should the post-filtering be run over a copy
	of the live DOM? Most users should pass &amp;quot;true&amp;quot; here unless they
	*really* know that none of the installed filters are going to
	mess up the editing session.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="replaceValue" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preFilterContent" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preDomFilterContent" scope="instance">
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_postFilterContent" scope="instance">
        <description>post-filtering allows plug-ins and users to specify any number
	of transforms over the editor's content, enabling many common
	use-cases such as transforming absolute to relative URLs (and
	vice-versa), ensuring conformance with a particular DTD, etc.
	The filters are registered in the contentDomPostFilters and
	contentPostFilters arrays. Each item in the
	contentDomPostFilters array is a function which takes a DOM
	Node or array of nodes as its only argument and returns the
	same. It is then passed down the chain for further filtering.
	The contentPostFilters array behaves the same way, except each
	member operates on strings. Together, the DOM and string-based
	filtering allow the full range of post-processing that should
	be necessaray to enable even the most agressive of post-editing
	conversions to take place.
	If nonDestructive is set to "true", the nodes are cloned before
	filtering proceeds to avoid potentially destructive transforms
	to the content which may still needed to be edited further.
	Once DOM filtering has taken place, the serialized version of
	the DOM which is passed is run through each of the
	contentPostFilters functions.</description>
        <parameters>
          <parameter name="dom" type="DomNode|Array&lt;DomNode&gt;|String" usage="optional">
            <description>a node, set of nodes, which to filter using each of the current
	members of the contentDomPostFilters and contentPostFilters arrays.</description>
          </parameter>
          <parameter name="nonDestructive" type="Boolean" usage="optional">
            <description>defaults to &amp;quot;false&amp;quot;. If true, ensures that filtering happens on
	a clone of the passed-in content and not the actual node
	itself.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_saveContent" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="escapeXml" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="noSingleQuotes" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getNodeHtml" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getNodeChildrenHtml" scope="instance">
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="save" type="Boolean" usage="optional">
            <description>Whether or not to save the changes. If false, the changes are discarded.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_removeMozBogus" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_removeWebkitBogus" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_normalizeFontStyle" scope="instance">
        <description>Moz can not handle strong/em tags correctly, so to help
	mozilla and also to normalize output, convert them to 'b' and 'i'.
	Note the IE generates 'strong' and 'em' rather than 'b' and 'i'</description>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preFixUrlAttributes" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_inserthorizontalruleImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_unlinkImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_hilitecolorImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_backcolorImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_forecolorImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <description>to the exec command, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_inserthtmlImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="The" usage="required">
            <description>content to insert, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_boldImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required">
            <description>used, operates by selection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_italicImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required">
            <description>used, operates by selection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_underlineImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required">
            <description>used, operates by selection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_strikethroughImpl" scope="instance">
        <parameters>
          <parameter name="argument" type="Not" usage="required">
            <description>used, operates by selection.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getHeaderHeight" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="getFooterHeight" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_getNodeChildrenHeight" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to process the children of;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_isNodeEmpty" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to check.</description>
          </parameter>
          <parameter name="startOffset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeStartingRangeFromRange" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to remove from the starting range.</description>
          </parameter>
          <parameter name="range" type="The" usage="required">
            <description>range to adapt.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_adaptIESelection" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="inheritWidth" scope="instance" type="Boolean">
        <description>whether to inherit the parent's width or simply use 100%</description>
      </property>
      <property name="focusOnLoad" scope="instance" type="Boolean">
        <description>Focus into this widget when the page is loaded</description>
      </property>
      <property name="name" scope="instance" type="String">
        <description>Specifies the name of a (hidden) &amp;lt;textarea&amp;gt; node on the page that's used to save
	the editor content on page leave.   Used to restore editor contents after navigating
	to a new page and then hitting the back button.</description>
      </property>
      <property name="styleSheets" scope="instance" type="String">
        <description>semicolon (&amp;quot;;&amp;quot;) separated list of css files for the editing area</description>
      </property>
      <property name="height" scope="instance" type="String">
        <description>Set height to fix the editor at a specific height, with scrolling.
	By default, this is 300px.  If you want to have the editor always
	resizes to accommodate the content, use AlwaysShowToolbar plugin
	and set height=&amp;quot;&amp;quot;.  If this editor is used within a layout widget,
	set height=&amp;quot;100%&amp;quot;.</description>
      </property>
      <property name="minHeight" scope="instance" type="String">
        <description>The minimum height that the editor should have.</description>
      </property>
      <property name="isClosed" scope="instance" type="Boolean"/>
      <property name="isLoaded" scope="instance" type="Boolean"/>
      <property name="_SEPARATOR" scope="instance" type="String">
        <description>Used to concat contents from multiple editors into a single string,
	so they can be saved into a single &amp;lt;textarea&amp;gt; node.  See &amp;quot;name&amp;quot; attribute.</description>
      </property>
      <property name="_NAME_CONTENT_SEP" scope="instance" type="String">
        <description>USed to separate name from content.  Just a colon isn't safe.</description>
      </property>
      <property name="onLoadDeferred" scope="instance-prototype" type="dojo.Deferred">
        <description>Deferred which is fired when the editor finishes loading.
	Call myEditor.onLoadDeferred.then(callback) it to be informed
	when the rich-text area initialization is finalized.</description>
      </property>
      <property name="isTabIndent" scope="instance" type="Boolean">
        <description>Make tab key and shift-tab indent and outdent rather than navigating.
	Caution: sing this makes web pages inaccessible to users unable to use a mouse.</description>
      </property>
      <property name="disableSpellCheck" scope="instance" type="Boolean">
        <description>When true, disables the browser's native spell checking, if supported.
	Works only in Firefox.</description>
      </property>
      <property name="contentPreFilters" scope="instance-prototype" type="Array&lt;Function(String)&gt;">
        <description>Pre content filter function register array.
	these filters will be executed before the actual
	editing area gets the html content.</description>
      </property>
      <property name="contentPostFilters" scope="instance-prototype" type="Array"/>
      <property name="events" scope="instance-prototype" type="Array&lt;String&gt;">
        <description>events which should be connected to the underlying editing area
	onClick handled specially</description>
      </property>
      <property name="captureEvents" scope="instance" type="Array&lt;String&gt;">
        <description>Events which should be connected to the underlying editing
	area, events in this array will be addListener with
	capture=true.
	TODO: looking at the code I don't see any distinction between events and captureEvents,
	so get rid of this for 2.0 if not sooner</description>
      </property>
      <property name="_editorCommandsLocalized" scope="instance" type="Object"/>
      <property name="_oldHeight" scope="instance" type="Object"/>
      <property name="_oldWidth" scope="instance" type="Object"/>
      <property name="value" scope="instance-prototype" type="Object"/>
      <property name="header" scope="instance" type="Object"/>
      <property name="editingArea" scope="instance" type="Object"/>
      <property name="footer" scope="instance" type="Object"/>
      <property name="editorObject" scope="instance" type="Object"/>
      <property name="_iframeSrc" scope="instance" type="Object"/>
      <property name="_local2NativeFormatNames" scope="instance" type="Object"/>
      <property name="_native2LocalFormatNames" scope="instance" type="Object"/>
      <property name="_cursorToStart" scope="instance" type="Object"/>
      <property name="editingAreaStyleSheets" scope="instance-prototype" type="Array"/>
      <property name="disabled" scope="instance" type="Boolean">
        <description>The editor is disabled; the text cannot be changed.</description>
      </property>
      <property name="_disabledOK" scope="instance" type="Object"/>
      <property name="_iframeRegHandle" scope="instance" type="Object"/>
      <property name="tabStop" scope="instance" type="Object"/>
      <property name="focusNode" scope="instance" type="Object"/>
      <property name="_webkitListener" scope="instance" type="Object"/>
      <property name="_onKeyHitch" scope="instance" type="Object"/>
      <property name="updateInterval" scope="instance" type="Number"/>
      <property name="_updateTimer" scope="instance" type="Object"/>
      <property name="_updateHandler" scope="instance" type="Object"/>
      <property name="_qcaCache" scope="instance" type="Object"/>
      <property name="__overflow" scope="instance" type="Object"/>
      <property name="contentDomPreFilters" scope="instance" type="Array"/>
      <property name="contentDomPostFilters" scope="instance" type="Array"/>
      <property name="_keyHandlers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText._mozSettingProps">
    <properties>
      <property name="styleWithCSS" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.editNode">
    <properties>
      <property name="unselectable" scope="instance" type="String"/>
      <property name="contentEditable" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.document">
    <properties>
      <property name="designMode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.window">
    <properties>
      <property name="__registeredWindow" scope="instance" type="Object"/>
      <property name="_frameElement" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.iframe">
    <properties>
      <property name="onfocus" scope="instance" type="Object"/>
      <property name="_loadFunc" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.editNode.style">
    <properties>
      <property name="zoom" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.textarea">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.textarea.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="overflow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.RichText.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor._Plugin.button.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins"/>
  <class type="dijit._editor.plugins.AlwaysShowToolbar" superclass="dijit._editor._Plugin">
    <description>Specify this in extraPlugins (or plugins) parameter and also set
	height to "".</description>
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enable" scope="instance">
        <parameters>
          <parameter name="d" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateHeight" scope="instance">
        <return-types>
          <return-type type="prevent setting height to 0"/>
        </return-types>
      </method>
      <method name="globalOnScrollHandler" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_handleScroll" scope="instance" type="Boolean">
        <description>Enables/disables the handler for scroll events</description>
      </property>
      <property name="_lastHeight" scope="instance" type="Integer">
        <description>Height in px of the editor at the last time we did sizing</description>
      </property>
      <property name="_scrollSetUp" scope="instance" type="Object"/>
      <property name="_scrollThreshold" scope="instance" type="Object"/>
      <property name="_IEOriginalPos" scope="instance" type="Object"/>
      <property name="_fixEnabled" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor"/>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor.header"/>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor.iframe.style">
    <properties>
      <property name="marginTop" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.AlwaysShowToolbar.editor.header.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
      <property name="position" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="zIndex" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.EnterKeyHandling" superclass="dijit._editor._Plugin">
    <description>This plugin has three modes:
	* blockModeForEnter=BR
	* blockModeForEnter=DIV
	* blockModeForEnter=P
	In blockModeForEnter=P, the ENTER key starts a new
	paragraph, and shift-ENTER starts a new line in the current paragraph.
	For example, the input:
		first paragraph &lt;shift-ENTER&gt;
		second line of first paragraph &lt;ENTER&gt;
		second paragraph
	will generate:
		&lt;p&gt;
			first paragraph
			&lt;br/&gt;
			second line of first paragraph
		&lt;/p&gt;
		&lt;p&gt;
			second paragraph
		&lt;/p&gt;
	In BR and DIV mode, the ENTER key conceptually goes to a new line in the
	current paragraph, and users conceptually create a new paragraph by pressing ENTER twice.
	For example, if the user enters text into an editor like this:
			one &lt;ENTER&gt;
			two &lt;ENTER&gt;
			three &lt;ENTER&gt;
			&lt;ENTER&gt;
			four &lt;ENTER&gt;
			five &lt;ENTER&gt;
			six &lt;ENTER&gt;
	It will appear on the screen as two 'paragraphs' of three lines each.  Markupwise, this generates:
	BR:
			one&lt;br/&gt;
			two&lt;br/&gt;
			three&lt;br/&gt;
			&lt;br/&gt;
			four&lt;br/&gt;
			five&lt;br/&gt;
			six&lt;br/&gt;
	DIV:
			&lt;div&gt;one&lt;/div&gt;
			&lt;div&gt;two&lt;/div&gt;
			&lt;div&gt;three&lt;/div&gt;
			&lt;div&gt;&amp;nbsp;&lt;/div&gt;
			&lt;div&gt;four&lt;/div&gt;
			&lt;div&gt;five&lt;/div&gt;
			&lt;div&gt;six&lt;/div&gt;</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPressed" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleEnterKey" scope="instance">
        <description>Manually handle enter key event to make the behavior consistent across
	all supported browsers. See class description for details.</description>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="let browser handle"/>
        </return-types>
      </method>
      <method name="_adjustNodeAndOffset" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to check.</description>
          </parameter>
          <parameter name="offset" type="Int" usage="required">
            <description>The position to find within the text node</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeTrailingBr" scope="instance">
        <parameters>
          <parameter name="container" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="blockNodeForEnter" scope="instance" type="String">
        <description>This property decides the behavior of Enter key. It can be either P,
	DIV, BR, or empty (which means disable this feature). Anything else
	will trigger errors.  The default is 'BR'
	See class description for more details.</description>
      </property>
      <property name="_checkListLater" scope="instance" type="bool"/>
      <property name="bogusHtmlContent" scope="instance" type="String">
        <description>HTML to stick into a new empty block</description>
      </property>
      <property name="blockNodes" scope="instance" type="Regex">
        <description>Regex for testing if a given tag is a block level (display:block) tag</description>
      </property>
      <property name="_pressedEnterInBlock" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.EnterKeyHandling.editor">
    <properties>
      <property name="customUndo" scope="instance" type="Object"/>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins._FontDropDown" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object|String" usage="required">
            <description>The value to set in the select.</description>
          </parameter>
          <parameter name="priorityChange" type="Optional" usage="required">
            <description>parameter used to tell the select whether or not to fire
	onChange event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="String">
        <description>The label to apply to this particular FontDropDown.</description>
      </property>
      <property name="widgetsInTemplate" scope="instance" type="boolean">
        <description>Over-ride denoting the template has widgets to parse.</description>
      </property>
      <property name="plainText" scope="instance" type="boolean">
        <description>Flag to indicate that the returned label should be plain text
	instead of an example.</description>
      </property>
      <property name="templateString" scope="instance" type="String">
        <description>The template used to construct the labeled dropdown.</description>
      </property>
      <property name="strings" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="selectId" scope="instance" type="String"/>
      <property name="disabled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins._FontDropDown.select">
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="_lastValueReported" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins._FontNameDropDown" superclass="dijit._editor.plugins._FontDropDown">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The 'insert value' associated with a name</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>The text name of the value</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor.plugins._FontDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="generic" scope="instance" type="Boolean">
        <description>Use generic (web standard) font names</description>
      </property>
      <property name="command" scope="instance" type="String">
        <description>The editor 'command' implemented by this plugin.</description>
      </property>
      <property name="values" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins._FontSizeDropDown" superclass="dijit._editor.plugins._FontDropDown">
    <methods>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The 'insert value' associated with a name</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>The text name of the value</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor.plugins._FontDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="command" scope="instance" type="String">
        <description>The editor 'command' implemented by this plugin.</description>
      </property>
      <property name="values" scope="instance" type="Array&lt;Number&gt;">
        <description>The HTML font size values supported by this plugin
	sizes according to the old HTML FONT SIZE</description>
      </property>
    </properties>
  </class>
  <class type="dijit._editor.plugins._FormatBlockDropDown" superclass="dijit._editor.plugins._FontDropDown">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The 'insert value' associated with a name</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>The text name of the value</description>
          </parameter>
        </parameters>
      </method>
      <method name="_execCommand" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
          <parameter name="command" type="Object" usage="required"/>
          <parameter name="choice" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeFormat" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
          <parameter name="node" type="The" usage="required">
            <description>block format node to remove (and leave the contents behind)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor.plugins._FontDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="command" scope="instance" type="String">
        <description>The editor 'command' implemented by this plugin.</description>
      </property>
      <property name="values" scope="instance" type="Array">
        <description>The HTML format tags supported by this plugin</description>
      </property>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FontChoice" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* fontName
			Provides a drop down to select from a list of font names
	* fontSize
			Provides a drop down to select from a list of font sizes
	* formatBlock
			Provides a drop down to select from a list of block styles
	which can easily be added to an editor by including one or more of the above commands
	in the `plugins` attribute as follows:
		plugins="['fontName','fontSize',...]"
	It is possible to override the default dropdown list by providing an Array for the `custom` property when
	instantiating this plugin, e.g.
		plugins="[{name:'dijit._editor.plugins.FontChoice', command:'fontName', custom:['Verdana','Myriad','Garamond']},...]"
	Alternatively, for `fontName` only, `generic:true` may be specified to provide a dropdown with
	[CSS generic font families](http://www.w3.org/TR/REC-CSS2/fonts.html#generic-font-families)
	Note that the editor is often unable to properly handle font styling information defined outside
	the context of the current editor instance, such as pre-populated HTML.</description>
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="instance" type="booleam">
        <description>Override _Plugin.useDefaultCommand...
	processing is handled by this plugin, not by dijit.Editor.</description>
      </property>
      <property name="editor" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="command" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FontChoice.params">
    <properties>
      <property name="values" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FullScreen" superclass="dijit._editor._Plugin">
    <methods>
      <method name="toggle" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_containFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The key event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_resizeEditor" scope="instance"/>
      <method name="_getAltViewNode" scope="instance"/>
      <method name="_setFullScreen" scope="instance">
        <parameters>
          <parameter name="full" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="zIndex" scope="instance" type="Number">
        <description>zIndex value used for overlaying the full page.
	default is 500.</description>
      </property>
      <property name="_origState" scope="instance" type="Object">
        <description>The original view state of the editor.</description>
      </property>
      <property name="_origiFrameState" scope="instance" type="Object">
        <description>The original view state of the iframe of the editor.</description>
      </property>
      <property name="_resizeHandle" scope="instance" type="Object">
        <description>Connection point used for handling resize when window resizes.</description>
      </property>
      <property name="isFullscreen" scope="instance" type="boolean">
        <description>Read-Only variable used to denote of the editor is in fullscreen mode or not.</description>
      </property>
      <property name="button" scope="instance" type="Object"/>
      <property name="_editorResizeHolder" scope="instance" type="Object"/>
      <property name="_oldOverflow" scope="instance" type="String"/>
      <property name="_oldBodyParentOverflow" scope="instance" type="String"/>
      <property name="_resizeHandle2" scope="instance" type="Object"/>
      <property name="_rst" scope="instance" type="Object"/>
      <property name="_resizer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FullScreen.editor">
    <methods>
      <method name="resize" scope="instance"/>
    </methods>
    <properties>
      <property name="_fullscreen_oldOnKeyDown" scope="instance" type="Object"/>
      <property name="onKeyDown" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="iframe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.FullScreen.editor.toolbar">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.LinkDialog" superclass="dijit._editor._Plugin">
    <description>The command provided by this plugin is:
	* createLink</description>
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="_checkAndFixInput" scope="instance"/>
      <method name="_connectTagEvents" scope="instance"/>
      <method name="_isValid" scope="instance"/>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="staticPanel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_checkValues" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Content being set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onCloseDialog" scope="instance"/>
      <method name="_getCurrentValues" scope="instance">
        <parameters>
          <parameter name="a" type="The" usage="required">
            <description>anchor/link to process for data for the dropdown.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_onOpenDialog" scope="instance"/>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The double-click event.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="urlRegExp" scope="instance" type="String">
        <description>Used for validating input as correct URL.  While file:// urls are not terribly
	useful, they are technically valid.</description>
      </property>
      <property name="emailRegExp" scope="instance" type="String">
        <description>Used for validating input as correct email address.  Taken from dojox.validate
	host.</description>
      </property>
      <property name="htmlTemplate" scope="instance" type="String">
        <description>String used for templating the HTML to insert at the desired point.</description>
      </property>
      <property name="tag" scope="instance" type="String">
        <description>Tag used for the link type.</description>
      </property>
      <property name="_hostRxp" scope="instance" type="Object"/>
      <property name="_userAtRxp" scope="instance" type="Object"/>
      <property name="linkDialogTemplate" scope="instance" type="String">
        <description>Template for contents of TooltipDialog to pick URL</description>
      </property>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="_uniqueId" scope="instance" type="Object"/>
      <property name="_textInput" scope="instance" type="Object"/>
      <property name="_setButton" scope="instance" type="Object"/>
      <property name="_urlRegExp" scope="instance" type="Object"/>
      <property name="_emailRegExp" scope="instance" type="Object"/>
      <property name="_delayedCheck" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.LinkDialog._urlInput">
    <properties>
      <property name="isValid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ImgLinkDialog" superclass="dijit._editor.plugins.LinkDialog">
    <description>The command provided by this plugin is:
	* insertImage</description>
    <methods>
      <method name="_getCurrentValues" scope="instance">
        <parameters>
          <parameter name="img" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_isValid" scope="instance"/>
      <method name="_connectTagEvents" scope="instance"/>
      <method name="_selectTag" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The mousedown event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_checkValues" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Content being set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The double-click event.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor.plugins.LinkDialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="linkDialogTemplate" scope="instance" type="String">
        <description>Over-ride for template since img dialog doesn't need target that anchor tags may.</description>
      </property>
      <property name="htmlTemplate" scope="instance" type="String">
        <description>String used for templating the &amp;lt;img&amp;gt; HTML to insert at the desired point.</description>
      </property>
      <property name="tag" scope="instance" type="String">
        <description>Tag used for the link type (img).</description>
      </property>
    </properties>
  </class>
  <class type="dijit._editor.plugins.NewPage" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required">
            <description>Object The editor object to attach the newPage capability to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="_newPage" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="content" scope="instance" type="String">
        <description>The default content to insert into the editor as the new page.
	The default is the &amp;lt;br&amp;gt; tag, a single blank line.</description>
      </property>
      <property name="editor" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.Print" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required">
            <description>Object The editor object to attach the print capability to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="_print" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="button" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.Print.editor">
    <properties>
      <property name="iframe" scope="instance" type="Object"/>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.TabIndent" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="command" scope="instance" type="String"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.TextColor" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* foreColor - sets the text color
	* hiliteColor - sets the background color</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="updateState" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="useDefaultCommand" scope="instance" type="Boolean">
        <description>False as we do not use the default editor command/click behavior.</description>
      </property>
      <property name="editor" scope="instance" type="Object"/>
      <property name="command" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ToggleDir" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="_setRtl" scope="instance">
        <parameters>
          <parameter name="rtl" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="command" scope="instance" type="String"/>
      <property name="buttonClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ViewSource" superclass="dijit._editor._Plugin">
    <methods>
      <method name="toggle" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required">
            <description>Object The editor object to attach the print capability to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_showSource" scope="instance">
        <parameters>
          <parameter name="source" type="boolean" usage="required">
            <description>Boolean value indicating if it should be in source mode or not.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="_resize" scope="instance"/>
      <method name="_createSourceView" scope="instance"/>
      <method name="_stripScripts" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The HTML to filter</description>
          </parameter>
        </parameters>
      </method>
      <method name="_stripComments" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The HTML to filter</description>
          </parameter>
        </parameters>
      </method>
      <method name="_stripIFrames" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The HTML to filter</description>
          </parameter>
        </parameters>
      </method>
      <method name="_filter" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The HTML to filter</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSourceAreaCaret" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="stripScripts" scope="instance" type="Boolean">
        <description>Boolean flag used to indicate if script tags should be stripped from the document.
	Defaults to true.</description>
      </property>
      <property name="stripComments" scope="instance" type="Boolean">
        <description>Boolean flag used to indicate if iframe tags should be stripped from the document.
	Defaults to true.</description>
      </property>
      <property name="stripIFrames" scope="instance" type="Object"/>
      <property name="readOnly" scope="instance" type="Boolean">
        <description>Boolean flag used to indicate if the source view should be readonly or not.
	Cannot be changed after initialization of the plugin.
	Defaults to false.</description>
      </property>
      <property name="_vsFocused" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_ieFixNode" scope="instance" type="Object"/>
      <property name="_sourceShown" scope="instance" type="Object"/>
      <property name="_pluginList" scope="instance" type="Array"/>
      <property name="_resizeHandle" scope="instance" type="Object"/>
      <property name="_readOnly" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ViewSource.editor">
    <methods>
      <method name="queryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
    </methods>
    <properties>
      <property name="_plugins" scope="instance" type="Object"/>
      <property name="_sourceQueryCommandEnabled" scope="instance" type="Object"/>
      <property name="__oldGetValue" scope="instance" type="Object"/>
      <property name="getValue" scope="instance" type="Object"/>
      <property name="_viewsource_oldFocus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ViewSource._fsPlugin">
    <methods>
      <method name="_getAltViewNode" scope="instance"/>
    </methods>
    <properties>
      <property name="_viewsource_getAltViewNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit._editor.plugins.ViewSource.sourceArea">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range">
    <methods>
      <method name="getIndex" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="parent" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getNode" scope="instance">
        <parameters>
          <parameter name="index" type="Array" usage="required"/>
          <parameter name="parent" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="terminate dojo.every"/>
          <return-type type="carry on the every loop"/>
        </return-types>
      </method>
      <method name="getCommonAncestor" scope="instance">
        <parameters>
          <parameter name="n1" type="Object" usage="required"/>
          <parameter name="n2" type="Object" usage="required"/>
          <parameter name="root" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAncestor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="regex" type="RegEx" usage="optional"/>
          <parameter name="root" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="getBlockAncestor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="regex" type="RegEx" usage="optional"/>
          <parameter name="root" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="atBeginningOfContainer" scope="instance">
        <parameters>
          <parameter name="container" type="DomNode" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="offset" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="atEndOfContainer" scope="instance">
        <parameters>
          <parameter name="container" type="DomNode" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="offset" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="adjacentNoneTextNode" scope="instance">
        <parameters>
          <parameter name="startnode" type="Object" usage="required"/>
          <parameter name="next" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="win" type="Window" usage="optional"/>
        </parameters>
      </method>
      <method name="getSelection" scope="instance">
        <parameters>
          <parameter name="win" type="Window" usage="required"/>
          <parameter name="ignoreUpdate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="BlockTagNames" scope="instance" type="RegExp"/>
      <property name="_w3c" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range.W3CRange">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_updateInternal" scope="instance"/>
      <method name="setStart" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEnd" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStartAfter" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStartBefore" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEndAfter" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEndBefore" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPoint" scope="instance">
        <parameters>
          <parameter name="what" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
          <parameter name="ext" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getIERange" scope="instance"/>
      <method name="getBookmark" scope="instance">
        <parameters>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_select" scope="instance"/>
      <method name="deleteContents" scope="instance"/>
      <method name="cloneRange" scope="instance"/>
      <method name="detach" scope="instance"/>
    </methods>
    <properties>
      <property name="commonAncestorContainer" scope="instance-prototype" type="Object"/>
      <property name="collapsed" scope="instance-prototype" type="Object"/>
      <property name="startContainer" scope="instance-prototype" type="Object"/>
      <property name="startOffset" scope="instance-prototype" type="Number"/>
      <property name="endContainer" scope="instance-prototype" type="Object"/>
      <property name="endOffset" scope="instance-prototype" type="Number"/>
      <property name="_body" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range.ie">
    <methods>
      <method name="decomposeControlRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getEndPoint" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEndPoint" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="container" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decomposeTextRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRange" scope="instance">
        <parameters>
          <parameter name="range" type="Object" usage="required"/>
          <parameter name="startContainer" type="Object" usage="required"/>
          <parameter name="startOffset" type="Object" usage="required"/>
          <parameter name="endContainer" type="Object" usage="required"/>
          <parameter name="endOffset" type="Object" usage="required"/>
          <parameter name="collapsed" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cachedSelection" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.range.ie.selection">
    <methods>
      <method name="addRange" scope="instance">
        <parameters>
          <parameter name="r" type="Object" usage="required"/>
          <parameter name="internal" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="removeAllRanges" scope="instance"/>
      <method name="getRangeAt" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCurrentSelection" scope="instance"/>
    </methods>
    <properties>
      <property name="_ranges" scope="instance" type="Array"/>
      <property name="rangeCount" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit._editor.selection">
    <methods>
      <method name="getType" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getSelectedText" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getSelectedHtml" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getSelectedElement" scope="instance"/>
      <method name="getParentElement" scope="instance"/>
      <method name="hasAncestorElement" scope="instance">
        <parameters>
          <parameter name="tagName" type="String" usage="required">
            <description>The tag name to determine if it has an ancestor of.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getAncestorElement" scope="instance">
        <parameters>
          <parameter name="tagName" type="String" usage="required">
            <description>The tag name to determine if it has an ancestor of.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="isTag" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to inspect.</description>
          </parameter>
          <parameter name="tags" type="Array&lt;String&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getParentOfType" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to inspect.</description>
          </parameter>
          <parameter name="tags" type="Array&lt;String&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="collapse" scope="instance">
        <parameters>
          <parameter name="beginning" type="Boolean" usage="required">
            <description>Boolean to indicate whether to collapse the cursor to the beginning of the selection or end.</description>
          </parameter>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <return-types>
          <return-type type="Selection"/>
        </return-types>
      </method>
      <method name="selectElementChildren" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required">
            <description>DOMNode The element you wish to select the children content of.</description>
          </parameter>
          <parameter name="nochangefocus" type="Boolean" usage="optional">
            <description>Boolean to indicate if the foxus should change or not.</description>
          </parameter>
        </parameters>
      </method>
      <method name="selectElement" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required">
            <description>DOMNode The element to select.</description>
          </parameter>
          <parameter name="nochangefocus" type="Boolean" usage="optional">
            <description>Boolean indicating if the focus should be changed.  IE only.</description>
          </parameter>
        </parameters>
      </method>
      <method name="inSelection" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dijit._tree">
    <properties>
      <property name="dndSource" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form">
    <properties>
      <property name="Slider" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Button" superclass="dijit.form._FormWidget">
    <description>Buttons can display a label, an icon, or both.
	A label should always be specified (through innerHTML) or the label
	attribute.  It can be hidden via showLabel=false.</description>
    <methods>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="user click actions"/>
        </return-types>
      </method>
      <method name="_onButtonClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setShowLabelAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_clicked" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setLabelAttr" scope="instance">
        <description>Set the label (text) of the button; takes an HTML string.</description>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setIconClassAttr" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="HTML">
        <description>String
	Text to display in button.
	If the label is hidden (showLabel=false) then and no title has
	been specified, then label is also set as title attribute of icon.</description>
      </property>
      <property name="showLabel" scope="instance" type="Boolean">
        <description>Set this to true to hide the label text and display only the icon.
	(If showLabel=false then iconClass must be specified.)
	Especially useful for toolbars.
	If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
	The exception case is for computers in high-contrast mode, where the label
	will still be displayed, since the icon doesn't appear.</description>
      </property>
      <property name="iconClass" scope="instance" type="String">
        <description>Class to apply to DOMNode in button to make it display an icon</description>
      </property>
      <property name="type" scope="instance" type="String">
        <description>Defines the type of button.  &amp;quot;button&amp;quot;, &amp;quot;submit&amp;quot;, or &amp;quot;reset&amp;quot;.</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Button.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Button.titleNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.DropDownButton" superclass="dijit.form.Button">
    <methods>
      <method name="_fillContent" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="isLoaded" scope="instance"/>
      <method name="loadDropDown" scope="instance"/>
      <method name="isFocusable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="dropDownContainer" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboButton" superclass="dijit.form.DropDownButton">
    <methods>
      <method name="_onButtonKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onArrowKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="position" type="String" usage="required">
            <description>&amp;quot;start&amp;quot; or &amp;quot;end&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.DropDownButton" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="optionsTitle" scope="instance" type="String">
        <description>Text that describes the options menu (accessibility)</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_focusedNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboButton.cssStateNodes">
    <properties>
      <property name="buttonNode" scope="instance" type="String"/>
      <property name="titleNode" scope="instance" type="String"/>
      <property name="_popupStateNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.ToggleButton" superclass="dijit.form.Button">
    <methods>
      <method name="_clicked" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setCheckedAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="setChecked" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="checked" scope="instance" type="Boolean">
        <description>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.
	In markup, specified as &amp;quot;checked='checked'&amp;quot; or just &amp;quot;checked&amp;quot;.
	True if the button is depressed, or the checkbox is checked,
	or the radio button is selected, etc.</description>
      </property>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.form.CheckBox" superclass="dijit.form.ToggleButton">
    <description>User interacts with real html inputs.
	On onclick (which occurs by mouse click, space-bar, or
	using the arrow keys to switch the selected radio button),
	we update the state of the checkbox/radio.
	There are two modes:
	1. High contrast mode
	2. Normal mode
	In case 1, the regular html inputs are shown and used by the user.
	In case 2, the regular html inputs are invisible but still used by
	the user. They are turned quasi-invisible and overlay the background-image.</description>
    <methods>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>During initialization, just saves as attribute to the &lt;input type=checkbox&gt;.
	After initialization,
	when passed a boolean, controls whether or not the CheckBox is checked.
	If passed a string, changes the value attribute of the CheckBox (the one
	specified as "value" when the CheckBox was constructed (ex: &lt;input
	dojoType="dijit.CheckBox" value="chicken"&gt;)</description>
        <parameters>
          <parameter name="newValue" type="String|Boolean" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance">
        <description>If the CheckBox is checked, returns the value attribute.
	Otherwise returns false.</description>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_onFocus" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ToggleButton" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String">
        <description>type attribute on &amp;lt;input&amp;gt; node.
	Overrides &lt;code&gt;dijit.form.Button.type&lt;/code&gt;.  Users should not change this value.</description>
      </property>
      <property name="value" scope="instance" type="String">
        <description>As an initialization parameter, equivalent to value field on normal checkbox
	(if checked, the value is passed as the value when form is submitted).
	However, get('value') will return either the string or false depending on
	whether or not the checkbox is checked.
	set('value', string) will check the checkbox and change the value to the
	specified string
	set('value', boolean) will change the checked state.</description>
      </property>
      <property name="readOnly" scope="instance" type="Boolean">
        <description>Should this widget respond to user input?
	In markup, this is specified as &amp;quot;readOnly&amp;quot;.
	Similar to disabled except readOnly form values are submitted.</description>
      </property>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_setLabelAttr" scope="instance" type="Object"/>
      <property name="checkedAttrSetting" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.form.RadioButton" superclass="dijit.form.CheckBox">
    <methods>
      <method name="_setCheckedAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_clicked" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.CheckBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxDataStore" superclass="dojo.data.util.simpleFetch">
    <description>Provides a store for inlined data like:
		&lt;select&gt;
			&lt;option value="AL"&gt;Alabama&lt;/option&gt;
			...
	Actually. just implements the subset of dojo.data.Read/Notification
	needed for ComboBox and FilteringSelect to work.
	Note that an item is just a pointer to the &lt;option&gt; DomNode.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="root" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| args || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <description>Given arguments like:
			{identity: "CA", onItem: function(item){...}
	Call `onItem()` with the DOM node `&lt;option value="CA"&gt;California&lt;/option&gt;`</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchSelectedItem" scope="instance"/>
    </methods>
  </class>
  <class type="dijit.form.ComboBoxMixin" superclass="dijit._HasDropDown">
    <description>All widgets that mix in dijit.form.ComboBoxMixin must extend `dijit.form._FormValueWidget`.</description>
    <methods>
      <method name="_getCaretPos" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setCaretPos" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="location" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_abortQuery" scope="instance"/>
      <method name="_onInput" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="throw out weird key combinations and spurious events"/>
        </return-types>
      </method>
      <method name="_autoCompleteText" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_openResultList" scope="instance">
        <description>1. generates drop-down list and calls _showResultList() to display it
	2. if this result list is from user pressing "more choices"/"previous choices"
	then tell screen reader to announce new option</description>
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showResultList" scope="instance"/>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="isLoaded" scope="instance"/>
      <method name="closeDropDown" scope="instance"/>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="_setItemAttr" scope="instance">
        <description>Users shouldn't call this function; they should be calling
	set('item', value)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_announceOption" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_selectOption" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearchAll" scope="instance"/>
      <method name="_startSearchFromInput" scope="instance"/>
      <method name="_getQueryString" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearch" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setMaxOptions" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueField" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_setHasDownArrowAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMenuLabelFromItem" scope="instance">
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="doHighlight" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="find" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_escapeHtml" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="reset" scope="instance"/>
      <method name="labelFunc" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="store" type="dojo.data.store" usage="required"/>
        </parameters>
        <return-description>The label that the ComboBox should display</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="item" scope="instance" type="Object">
        <description>This is the item returned by the dojo.data.store implementation that
	provides the data for this ComboBox, it's the currently selected item.</description>
      </property>
      <property name="pageSize" scope="instance" type="Integer">
        <description>Argument to data provider.
	Specifies number of search results per page (before hitting &amp;quot;next&amp;quot; button)</description>
      </property>
      <property name="store" scope="instance" type="Object">
        <description>Reference to data provider object used by this ComboBox</description>
      </property>
      <property name="fetchProperties" scope="instance-prototype" type="Object">
        <description>Mixin to the dojo.data store's fetch.
	For example, to set the sort order of the ComboBox menu, pass:
		{ sort: [{attribute:&amp;quot;name&amp;quot;,descending: true}] }
	To override the default queryOptions so that deep=false, do:
		{ queryOptions: {ignoreCase: true, deep: false} }</description>
      </property>
      <property name="query" scope="instance-prototype" type="Object">
        <description>A query that can be passed to 'store' to initially filter the items,
	before doing further filtering based on &lt;code&gt;searchAttr&lt;/code&gt; and the key.
	Any reference to the &lt;code&gt;searchAttr&lt;/code&gt; is ignored.</description>
      </property>
      <property name="autoComplete" scope="instance" type="Boolean">
        <description>If user types in a partial string, and then tab out of the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; box,
	automatically copy the first entry displayed in the drop down list to
	the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; field</description>
      </property>
      <property name="highlightMatch" scope="instance" type="String">
        <description>One of: &amp;quot;first&amp;quot;, &amp;quot;all&amp;quot; or &amp;quot;none&amp;quot;.
	If the ComboBox/FilteringSelect opens with the search results and the searched
	string can be found, it will be highlighted.  If set to &amp;quot;all&amp;quot;
	then will probably want to change &lt;code&gt;queryExpr&lt;/code&gt; parameter to '*${0}*'
	Highlighting is only performed when &lt;code&gt;labelType&lt;/code&gt; is &amp;quot;text&amp;quot;, so as to not
	interfere with any HTML markup an HTML label might contain.</description>
      </property>
      <property name="searchDelay" scope="instance" type="Integer">
        <description>Delay in milliseconds between when user types something and we start
	searching based on that value</description>
      </property>
      <property name="searchAttr" scope="instance" type="String">
        <description>Search for items in the data store where this attribute (in the item)
	matches what the user typed</description>
      </property>
      <property name="labelAttr" scope="instance" type="String">
        <description>The entries in the drop down list come from this attribute in the
	dojo.data items.
	If not specified, the searchAttr attribute is used instead.</description>
      </property>
      <property name="labelType" scope="instance" type="String">
        <description>Specifies how to interpret the labelAttr in the data store items.
	Can be &amp;quot;html&amp;quot; or &amp;quot;text&amp;quot;.</description>
      </property>
      <property name="queryExpr" scope="instance" type="String">
        <description>This specifies what query ComboBox/FilteringSelect sends to the data store,
	based on what the user has typed.  Changing this expression will modify
	whether the drop down shows only exact matches, a &amp;quot;starting with&amp;quot; match,
	etc.  Use it in conjunction with highlightMatch.
	dojo.data query expression pattern.
	&lt;code&gt;${0}&lt;/code&gt; will be substituted for the user text.
	&lt;code&gt;*&lt;/code&gt; is used for wildcards.
	&lt;code&gt;${0}*&lt;/code&gt; means &amp;quot;starts with&amp;quot;, &lt;code&gt;*${0}*&lt;/code&gt; means &amp;quot;contains&amp;quot;, &lt;code&gt;${0}&lt;/code&gt; means &amp;quot;is&amp;quot;</description>
      </property>
      <property name="ignoreCase" scope="instance" type="Boolean">
        <description>Set true if the ComboBox/FilteringSelect should ignore case when matching possible items</description>
      </property>
      <property name="hasDownArrow" scope="instance" type="Boolean">
        <description>Set this textbox to have a down arrow button, to display the drop down list.
	Defaults to true.</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="dropDownClass" scope="instance" type="String">
        <description>Name of the dropdown widget class used to select a date/time.
	Subclasses should specify this.</description>
      </property>
      <property name="maxHeight" scope="instance" type="Number"/>
      <property name="searchTimer" scope="instance" type="Object"/>
      <property name="_fetchHandle" scope="instance" type="Object"/>
      <property name="_prev_key_backspace" scope="instance" type="Object"/>
      <property name="_lastQuery" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="String"/>
      <property name="_lastInput" scope="instance" type="Object"/>
      <property name="_maxOptions" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBoxMixin.cssStateNodes">
    <properties>
      <property name="_buttonNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBoxMixin.focusNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBoxMixin.dropDown">
    <properties>
      <property name="_highlighted_option" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBoxMixin._helperSpan">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBoxMixin._buttonNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPage" scope="instance">
        <parameters>
          <parameter name="direction" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance"/>
      <method name="_createOption" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="labelFunc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createOptions" scope="instance">
        <parameters>
          <parameter name="results" type="Array" usage="required">
            <description>of dojo.data items</description>
          </parameter>
          <parameter name="dataObject" type="dojo.data" usage="required">
            <description>store</description>
          </parameter>
          <parameter name="labelFunc" type="Function" usage="required">
            <description>to produce a label in the drop down list from a dojo.data item</description>
          </parameter>
        </parameters>
      </method>
      <method name="clearResultList" scope="instance"/>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOver" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOut" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_focusOptionNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_blurOptionNode" scope="instance"/>
      <method name="_highlightNextOption" scope="instance"/>
      <method name="highlightFirstOption" scope="instance"/>
      <method name="highlightLastOption" scope="instance"/>
      <method name="_highlightPrevOption" scope="instance"/>
      <method name="_page" scope="instance">
        <parameters>
          <parameter name="up" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="pageUp" scope="instance"/>
      <method name="pageDown" scope="instance"/>
      <method name="getHighlightedOption" scope="instance"/>
      <method name="handleKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_messages" scope="instance" type="Object">
        <description>Holds &amp;quot;next&amp;quot; and &amp;quot;previous&amp;quot; text for paging buttons on drop down</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.previousButton">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.nextButton">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.previousButton.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.nextButton.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.domNode">
    <properties>
      <property name="lastChild" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu._highlighted_option">
    <properties>
      <property name="nextSibling" scope="instance" type="Object"/>
      <property name="previousSibling" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._ComboBoxMenu.domNode.firstChild">
    <properties>
      <property name="nextSibling" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.ComboBox" superclass="dijit.form.ValidationTextBox">
    <description>The drop down box's values are populated from an class called
	a data provider, which returns a list of values based on the characters
	that the user has typed into the input box.
	If OPTION tags are used as the data provider via markup,
	then the OPTION tag's child text node is used as the widget value
	when selected.  The OPTION tag's value attribute is ignored.
	To set the default value when using OPTION tags, specify the selected
	attribute on 1 of the child OPTION tags.
	Some of the options to the ComboBox are actually arguments to the data
	provider.</description>
    <methods>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the select.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
      <mixin type="dijit.form.ComboBoxMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._ComboBoxDataStore.root">
    <properties>
      <property name="selectedIndex" scope="instance" type="Object"/>
      <property name="firstChild" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.CurrencyTextBox" superclass="dijit.form.NumberTextBox">
    <description>CurrencyTextBox is similar to `dijit.form.NumberTextBox` but has a few
	extra features related to currency:
	1. After specifying the currency type (american dollars, euros, etc.) it automatically
	sets parse/format options such as how many decimal places to show.
	2. The currency mark (dollar sign, euro mark, etc.) is displayed when the field is blurred
	but erased during editing, so that the user can just enter a plain number.</description>
    <methods>
      <method name="regExpGen" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.NumberTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="currency" scope="instance" type="String">
        <description>the [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like &amp;quot;USD&amp;quot;</description>
      </property>
      <property name="constraints" scope="instance" type="dijit.form.CurrencyTextBox.__Constraints">
        <description>Despite the name, this parameter specifies both constraints on the input
	(including minimum/maximum allowed values) as well as
	formatting options.  See &lt;code&gt;dijit.form.CurrencyTextBox.__Constraints&lt;/code&gt; for details.</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_formatter" scope="instance" type="Object"/>
      <property name="_parser" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.CurrencyTextBox.__Constraints" superclass="dijit.form.NumberTextBox.__Constraints">
    <description>Follows the pattern of `dijit.form.NumberTextBox.constraints`.
	In general developers won't need to set this parameter</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.currency.__FormatOptions.prototype" scope="instance"/>
      <mixin type="dojo.currency.__ParseOptions.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.NumberTextBox.__Constraints" scope="instance"/>
      <mixin type="dojo.currency.__FormatOptions" scope="instance"/>
      <mixin type="dojo.currency.__ParseOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.DateTextBox" superclass="dijit.form._DateTimeTextBox">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.form._DateTimeTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="popupClass" scope="instance" type="String"/>
      <property name="_selector" scope="instance" type="String"/>
      <property name="value" scope="instance" type="Date">
        <description>The value of this widget as a JavaScript Date object, with only year/month/day specified.
	If specified in markup, use the format specified in &lt;code&gt;dojo.date.stamp.fromISOString&lt;/code&gt;.
	set(&amp;quot;value&amp;quot;, ...) accepts either a Date object or a string.
	value.toString()=&amp;quot;NaN&amp;quot;</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form.FilteringSelect" superclass="dijit.form.MappedTextBox">
    <description>An enhanced version of the HTML SELECT tag, populated dynamically. It works
	very nicely with very large data sets because it can load and page data as needed.
	It also resembles ComboBox, but does not allow values outside of the provided ones.
	If OPTION tags are used as the data provider via markup, then the
	OPTION tag's child text node is used as the displayed value when selected
	while the OPTION tag's value attribute is used as the widget value on form submit.
	To set the default value when using OPTION tags, specify the selected
	attribute on 1 of the child OPTION tags.
	Similar features:
	- There is a drop down list of possible values.
	- You can only enter a value from the drop down list.  (You can't
	enter an arbitrary value.)
	- The value submitted with the form is the hidden value (ex: CA),
	not the displayed value a.k.a. label (ex: California)
	Enhancements over plain HTML version:
	- If you type in some text then it will filter down the list of
	possible values in the drop down list.
	- List can be specified either as a static list or via a javascript
	function (that can get the list from a server)</description>
    <methods>
      <method name="_isValidSubset" scope="instance"/>
      <method name="isValid" scope="instance">
        <return-types>
          <return-type type="#5974"/>
        </return-types>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="_callbackSetLabel" scope="instance">
        <parameters>
          <parameter name="result" type="Array" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_openResultList" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_getValueField" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the select.
	Also sets the label to the corresponding value by reverse lookup.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setItemAttr" scope="instance">
        <description>Users shouldn't call this function; they should be calling
	set('item', value)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getDisplayQueryString" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplayedValueAttr" scope="instance">
        <description>Sets textbox to display label. Also performs reverse lookup
	to set the hidden value.
	Doesn't work as expected when the FilteringSelect has a custom labelFunc(), since in that case
	it's impossible to do a reverse lookup (from label --&gt; item) without a full data store scan.
	App must call set("displayedValue", ...) with the intended item.searchAttr, rather than
	labelFunc(item).</description>
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="undo" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.MappedTextBox" scope="instance"/>
      <mixin type="dijit.form.ComboBoxMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="required" scope="instance" type="Boolean">
        <description>True (default) if user is required to enter a value into this field.</description>
      </property>
      <property name="_lastDisplayedValue" scope="instance" type="String"/>
      <property name="_lastQuery" scope="instance" type="Object"/>
      <property name="_fetchHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.FilteringSelect.valueNode">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.FilteringSelect.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Form" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="execute" scope="instance">
        <parameters>
          <parameter name="formContents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onExecute" scope="instance"/>
      <method name="_setEncTypeAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="reset" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
      <method name="onReset" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_onReset" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSubmit" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSubmit" scope="instance">
        <description>This method is intended to be over-ridden, but by default it checks and
	returns the validity of form elements. When the `submit`
	method is called programmatically, the return value from
	`onSubmit` is used to compute whether or not submission
	should proceed</description>
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="submit" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit.form._FormMixin.prototype" scope="instance"/>
      <mixin type="dijit.layout._ContentPaneResizeMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit.form._FormMixin" scope="instance"/>
      <mixin type="dijit.layout._ContentPaneResizeMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>Name of form for scripting.</description>
      </property>
      <property name="action" scope="instance" type="String">
        <description>Server-side form handler.</description>
      </property>
      <property name="method" scope="instance" type="String">
        <description>HTTP method used to submit the form, either &amp;quot;GET&amp;quot; or &amp;quot;POST&amp;quot;.</description>
      </property>
      <property name="encType" scope="instance" type="String">
        <description>Encoding type for the form, ex: application/x-www-form-urlencoded.</description>
      </property>
      <property name="accept-charset" scope="instance" type="String">
        <description>List of supported charsets.</description>
      </property>
      <property name="accept" scope="instance" type="String">
        <description>List of MIME types for file upload.</description>
      </property>
      <property name="target" scope="instance" type="String">
        <description>Target frame for the document to be opened in.</description>
      </property>
      <property name="templateString" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="nameAttrSetting" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Form.domNode">
    <properties>
      <property name="encoding" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRule" superclass="dijit._Widget">
    <methods>
      <method name="_genHTML" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="ndx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="count" scope="instance" type="Integer">
        <description>Number of hash marks to generate</description>
      </property>
      <property name="container" scope="instance" type="String">
        <description>For HorizontalSlider, this is either &amp;quot;topDecoration&amp;quot; or &amp;quot;bottomDecoration&amp;quot;,
	and indicates whether this rule goes above or below the slider.</description>
      </property>
      <property name="ruleStyle" scope="instance" type="String">
        <description>CSS style to apply to individual hash marks</description>
      </property>
      <property name="_positionPrefix" scope="instance" type="String"/>
      <property name="_positionSuffix" scope="instance" type="String"/>
      <property name="_suffix" scope="instance" type="String"/>
      <property name="_isHorizontal" scope="instance" type="Boolean">
        <description>VerticalRule will override this...</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRule.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRuleLabels" superclass="dijit.form.HorizontalRule">
    <methods>
      <method name="_calcPosition" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_genHTML" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="ndx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabels" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalRule" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="labelStyle" scope="instance" type="String">
        <description>CSS style to apply to individual text labels</description>
      </property>
      <property name="labels" scope="instance" type="Array&lt;String&gt;">
        <description>Array of text labels to render - evenly spaced from left-to-right or bottom-to-top.
	Alternately, minimum and maximum can be specified, to get numeric labels.</description>
      </property>
      <property name="numericMargin" scope="instance" type="Integer">
        <description>Number of generated numeric labels that should be rendered as '' on the ends when labels[] are not specified</description>
      </property>
      <property name="minimum" scope="instance" type="Number"/>
      <property name="maximum" scope="instance" type="Number"/>
      <property name="_positionPrefix" scope="instance" type="String"/>
      <property name="_labelPrefix" scope="instance" type="String"/>
      <property name="_suffix" scope="instance" type="String"/>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRuleLabels.constraints">
    <properties>
      <property name="pattern" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalRuleLabels.srcNodeRef">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="_onKeyUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandleClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isReversed" scope="instance"/>
      <method name="_onBarClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPixelValue" scope="instance">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_bumpValue" scope="instance">
        <parameters>
          <parameter name="signedChange" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_onClkBumper" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClkIncBumper" scope="instance"/>
      <method name="_onClkDecBumper" scope="instance"/>
      <method name="decrement" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="increment" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="_typematicCallback" scope="instance">
        <parameters>
          <parameter name="count" type="Number" usage="required"/>
          <parameter name="button" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Number"/>
      <property name="showButtons" scope="instance" type="Boolean">
        <description>Show increment/decrement buttons at the ends of the slider?</description>
      </property>
      <property name="minimum" scope="instance" type="Integer">
        <description>The minimum value the slider can be set to.</description>
      </property>
      <property name="maximum" scope="instance" type="Integer">
        <description>The maximum value the slider can be set to.</description>
      </property>
      <property name="discreteValues" scope="instance" type="Integer">
        <description>If specified, indicates that the slider handle has only 'discreteValues' possible positions,
	and that after dragging the handle, it will snap to the nearest possible position.
	Thus, the slider has only 'discreteValues' possible values.
	For example, if minimum=10, maxiumum=30, and discreteValues=3, then the slider handle has
	three possible positions, representing values 10, 20, or 30.
	If discreteValues is not specified or if it's value is higher than the number of pixels
	in the slider bar, then the slider handle can be moved freely, and the slider's value will be
	computed/reported based on pixel position (in this case it will likely be fractional,
	such as 123.456789).</description>
      </property>
      <property name="pageIncrement" scope="instance" type="Integer">
        <description>If discreteValues is also specified, this indicates the amount of clicks (ie, snap positions)
	that the slider handle is moved via pageup/pagedown keys.
	If discreteValues is not specified, it indicates the number of pixels.</description>
      </property>
      <property name="clickSelect" scope="instance" type="Boolean">
        <description>If clicking the slider bar changes the value or not</description>
      </property>
      <property name="slideDuration" scope="instance" type="Number">
        <description>The time in ms to take to animate the slider handle from 0% to 100%,
	when clicking the slider bar to make the handle move.</description>
      </property>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_mousePixelCoord" scope="instance" type="String"/>
      <property name="_pixelCount" scope="instance" type="String"/>
      <property name="_startingPixelCoord" scope="instance" type="String"/>
      <property name="_startingPixelCount" scope="instance" type="String"/>
      <property name="_handleOffsetCoord" scope="instance" type="String"/>
      <property name="_progressPixelSize" scope="instance" type="String"/>
      <property name="_inProgressAnim" scope="instance" type="Object"/>
      <property name="_movable" scope="instance" type="Object"/>
      <property name="_supportingWidgets" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider.cssStateNodes">
    <properties>
      <property name="incrementButton" scope="instance" type="String"/>
      <property name="decrementButton" scope="instance" type="String"/>
      <property name="focusNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider.valueNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider.incrementButton.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.HorizontalSlider.decrementButton.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form._SliderMover" superclass="dojo.dnd.Mover">
    <methods>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Mover" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._SliderMover.widget">
    <properties>
      <property name="_abspos" scope="instance" type="Object"/>
      <property name="_setPixelValue_" scope="instance" type="Object"/>
      <property name="_isReversed_" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.MappedTextBox" superclass="dijit.form.ValidationTextBox">
    <description>The visible display may
	be locale-dependent and interactive.  The value sent to the server is stored in a hidden
	input field which uses the `name` attribute declared by the original widget.  That value sent
	to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
	locale-neutral.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="val" type="anything" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="validate" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="reset" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="nameAttrSetting" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.MultiSelect" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="addSelected" scope="instance">
        <examples>
          <example>	// move all the selected values from "bar" to "foo"
	 	dijit.byId("foo").addSelected(dijit.byId("bar"));</example>
        </examples>
        <parameters>
          <parameter name="select" type="dijit.form.MultiSelect" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getValueAttr" scope="instance">
        <description>Returns an array of the selected options' values.</description>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>Set the value(s) of this Select based on passed values</description>
        <parameters>
          <parameter name="values" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="invertSelection" scope="instance">
        <parameters>
          <parameter name="onChange" type="Boolean" usage="required">
            <description>If null, onChange is not fired.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onChange" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="size" scope="instance" type="Number">
        <description>Number of elements to display on a page
	NOTE: may be removed in version 2.0, since elements may have variable height;
	set the size via style=&amp;quot;...&amp;quot; or CSS class names instead.
	for Form</description>
      </property>
      <property name="templateString" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
      <property name="multiple" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.NumberSpinner" superclass="dijit.form._Spinner">
    <description>A `dijit.form.NumberTextBox` extension to provide keyboard accessible value selection
	as well as icons for spinning direction. When using the keyboard, the typematic rules
	apply, meaning holding the key will gradually increase or decrease the value and
	accelerate.</description>
    <methods>
      <method name="adjust" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.NumberTextBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._Spinner" scope="instance"/>
      <mixin type="dijit.form.NumberTextBoxMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.NumberSpinner.constraints">
    <properties>
      <property name="min" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.NumberTextBox" superclass="dijit.form.RangeBoundTextBox">
    <description>NumberTextBox is a textbox for entering and displaying numbers, supporting
	the following main features:
	1. Enforce minimum/maximum allowed values (as well as enforcing that the user types
	a number rather than a random string)
	2. NLS support (altering roles of comma and dot as "thousands-separator" and "decimal-point"
	depending on locale).
	3. Separate modes for editing the value and displaying it, specifically that
	the thousands separator character (typically comma) disappears when editing
	but reappears after the field is blurred.
	4. Formatting and constraints regarding the number of places (digits after the decimal point)
	allowed on input, and number of places displayed when blurred (see `constraints` parameter).</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.form.NumberTextBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox" scope="instance"/>
      <mixin type="dijit.form.NumberTextBoxMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.NumberTextBox.__Constraints" superclass="dijit.form.RangeBoundTextBox.__Constraints">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.number.__FormatOptions.prototype" scope="instance"/>
      <mixin type="dojo.number.__ParseOptions.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox.__Constraints" scope="instance"/>
      <mixin type="dojo.number.__FormatOptions" scope="instance"/>
      <mixin type="dojo.number.__ParseOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.NumberTextBoxMixin">
    <methods>
      <method name="_formatter" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>The number to be converted into a string.</description>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional">
            <description>Formatting options</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance"/>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="constraints" type="dojo.number.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="_parser" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>String representing a number</description>
          </parameter>
          <parameter name="constraints" type="dojo.number.__ParseOptions" usage="required">
            <description>Formatting options</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.number.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="_getDisplayedValueAttr" scope="instance"/>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="set('value', null"/>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="undefined) should fire onChange(NaN)"/>
        </return-types>
      </method>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="formattedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance">
        <return-types>
          <return-type type="return exponential Number or undefined for random text (may not be possible to do with the above RegExp check)"/>
          <return-type type="gibberish"/>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="valid exponential number in range"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="regExpGen" scope="instance" type="Object"/>
      <property name="constraints" scope="instance" type="dijit.form.NumberTextBox.__Constraints">
        <description>Despite the name, this parameter specifies both constraints on the input
	(including minimum/maximum allowed values) as well as
	formatting options like places (the number of digits to display after
	the decimal point).  See &lt;code&gt;dijit.form.NumberTextBox.__Constraints&lt;/code&gt; for details.</description>
      </property>
      <property name="value" scope="instance" type="Number">
        <description>The value of this NumberTextBox as a Javascript Number (i.e., not a String).
	If the displayed value is blank, the value is NaN, and if the user types in
	an gibberish value (like &amp;quot;hello world&amp;quot;), the value is undefined
	(i.e. get('value') returns undefined).
	Symmetrically, set('value', NaN) will clear the displayed value,
	whereas set('value', undefined) will have no effect.</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form.NumberTextBoxMixin.editOptions">
    <properties>
      <property name="pattern" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.NumberTextBoxMixin.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.RangeBoundTextBox" superclass="dijit.form.MappedTextBox">
    <methods>
      <method name="rangeCheck" scope="instance">
        <parameters>
          <parameter name="primitive" type="Number" usage="required"/>
          <parameter name="constraints" type="dijit.form.RangeBoundTextBox.__Constraints" usage="required"/>
        </parameters>
      </method>
      <method name="isInRange" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_isDefinitelyOutOfRange" scope="instance"/>
      <method name="_isValidSubset" scope="instance"/>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getErrorMessage" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.MappedTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="rangeMessage" scope="instance" type="String">
        <description>The message to display if value is out-of-range</description>
      </property>
      <property name="constraints" scope="instance" type="dijit.form.RangeBoundTextBox.__Constraints"/>
      <property name="messages" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._SelectMenu" superclass="dijit.Menu">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="mb" type="Object" usage="required">
            <description>The margin box to set this dropdown to.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Menu" scope="instance"/>
    </mixins>
    <properties>
      <property name="menuTableNode" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._SelectMenu.menuTableNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.Select" superclass="dijit.form._FormSelectWidget">
    <methods>
      <method name="_fillContent" scope="instance"/>
      <method name="_getMenuItemForOption" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_addOptionItem" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_getChildren" scope="instance"/>
      <method name="_loadChildren" scope="instance">
        <parameters>
          <parameter name="loadMenuItems" type="Boolean" usage="required">
            <description>actually loads the child menu items - we only do this when we are
	populating for showing the dropdown.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplay" scope="instance">
        <parameters>
          <parameter name="newDisplay" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="validate" scope="instance">
        <description>Show missing or invalid messages if appropriate, and highlight textbox field.
	Used when a select is initially set to no value and the user is required to
	set the value.</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="handle value is null or undefined"/>
        </return-types>
      </method>
      <method name="reset" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setStyleAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String|Object" usage="required"/>
        </parameters>
      </method>
      <method name="isLoaded" scope="instance"/>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="loadCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="closeDropDown" scope="instance"/>
      <method name="uninitialize" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._FormSelectWidget" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object">
        <description>Add in our style to be applied to the focus node</description>
      </property>
      <property name="required" scope="instance" type="Boolean">
        <description>Can be true or false, default is false.</description>
      </property>
      <property name="state" scope="instance" type="String">
        <description>Shows current state (ie, validation result) of input (Normal, Warning, or Error)</description>
      </property>
      <property name="message" scope="instance" type="String">
        <description>Currently displayed error/prompt message</description>
      </property>
      <property name="tooltipPosition" scope="instance" type="Array&lt;String&gt;">
        <description>See description of dijit.Tooltip.defaultPosition for details on this parameter.</description>
      </property>
      <property name="emptyLabel" scope="instance" type="string">
        <description>What to display in an &amp;quot;empty&amp;quot; dropdown</description>
      </property>
      <property name="_isLoaded" scope="instance" type="Boolean">
        <description>Whether or not we have been loaded</description>
      </property>
      <property name="_childrenLoaded" scope="instance" type="Boolean">
        <description>Whether or not our children have been loaded</description>
      </property>
      <property name="value" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="_missingMsg" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Select.srcNodeRef">
    <properties>
      <property name="selectedIndex" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.form.Select.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.Select.dropDown.menuTableNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.SimpleTextarea" superclass="dijit.form.TextBox">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onInput" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.TextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="rows" scope="instance" type="Number">
        <description>The number of characters per line.</description>
      </property>
      <property name="cols" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="_previousValue" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.SimpleTextarea.textbox">
    <properties>
      <property name="selectionStart" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.TextBox" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setPlaceHolderAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updatePlaceHolder" scope="instance"/>
      <method name="_getValueAttr" scope="instance">
        <description>For `dijit.form.TextBox` this basically returns the value of the &lt;input&gt;.
	For `dijit.form.MappedTextBox` subclasses, which have both
	a "displayed value" and a separate "submit value",
	This treats the "displayed value" as the master value, computing the
	submit value from it via this.parse().</description>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget to "value" which can be of
	any type as determined by the widget.</description>
        <parameters>
          <parameter name="value" type="The" usage="required">
            <description>visual element value is also set to a corresponding,
	but not necessarily the same, value.</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="optional">
            <description>If true, an onChange event is fired immediately instead of
	waiting for the next blur event.</description>
          </parameter>
          <parameter name="formattedValue" type="String" usage="optional">
            <description>If specified, used to set the visual element value,
	otherwise a computed visual value is used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getDisplayedValue" scope="instance"/>
      <method name="_getDisplayedValueAttr" scope="instance">
        <description>Returns the displayed value (what the user sees on the screen),
	after filtering (ie, trimming spaces etc.).
	For some subclasses of TextBox (like ComboBox), the displayed value
	is different from the serialized value that's actually
	sent to the server (see dijit.form.ValidationTextBox.serialize)</description>
      </method>
      <method name="setDisplayedValue" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplayedValueAttr" scope="instance">
        <description>Sets the value of the visual element to the string "value".
	The widget value is also set to a corresponding,
	but not necessarily the same, value.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="_onInput" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="filter" scope="instance">
        <description>For MappedTextBox subclasses, this is called twice
	- once with the display value
	- once the value as set/returned by set('value', ...)
	and get('value'), ex: a Number for NumberTextBox.
	In the latter case it does corrections like converting null to NaN.  In
	the former case the NumberTextBox.filter() method calls this.inherited()
	to execute standard trimming code in TextBox.filter().
	TODO: break this into two methods in 2.0</description>
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="by" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="trim" scope="instance" type="Boolean">
        <description>Removes leading and trailing whitespace if true.  Default is false.</description>
      </property>
      <property name="uppercase" scope="instance" type="Boolean">
        <description>Converts all characters to uppercase if true.  Default is false.</description>
      </property>
      <property name="lowercase" scope="instance" type="Boolean">
        <description>Converts all characters to lowercase if true.  Default is false.</description>
      </property>
      <property name="propercase" scope="instance" type="Boolean">
        <description>Converts the first character of each word to uppercase if true.</description>
      </property>
      <property name="maxLength" scope="instance" type="String">
        <description>HTML INPUT tag maxLength declaration.</description>
      </property>
      <property name="selectOnClick" scope="instance" type="Boolean">
        <description>If true, all text will be selected when focused with mouse</description>
      </property>
      <property name="placeHolder" scope="instance" type="String">
        <description>Defines a hint to help users fill out the input field (as defined in HTML 5).
	This should only contain plain text (no html markup).
	allows IE to disallow focus, but Firefox cannot be disabled for mousedown events</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_singleNodeTemplate" scope="instance" type="String"/>
      <property name="_buttonInputDisabled" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="displayedValue" scope="instance" type="String">
        <description>For subclasses like ComboBox where the displayed value
	(ex: Kentucky) and the serialized value (ex: KY) are different,
	this represents the displayed value.
	Setting 'displayedValue' through set('displayedValue', ...)
	updates 'value', and vice-versa.  Otherwise 'value' is updated
	from 'displayedValue' periodically, like onBlur etc.
	TODO: move declaration to MappedTextBox?
	Problem is that ComboBox references displayedValue,
	for benefit of FilteringSelect.
	if the textbox is blank, what value should be reported</description>
      </property>
      <property name="_blankValue" scope="instance" type="String"/>
      <property name="_selectOnClickHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.TextBox._phspan">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.TextBox._phspan.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.TextBox.textbox">
    <properties>
      <property name="value" scope="instance" type="String"/>
      <property name="selectionStart" scope="instance" type="Object"/>
      <property name="selectionEnd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea" superclass="dijit.form.SimpleTextarea">
    <description>A textarea that dynamically expands/contracts (changing it's height) as
	the user types, to display all the text without requiring a scroll bar.
	Takes nearly all the parameters (name, value, etc.) that a vanilla textarea takes.
	Rows is not supported since this widget adjusts the height.</description>
    <methods>
      <method name="_getHeight" scope="instance">
        <parameters>
          <parameter name="textarea" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_estimateHeight" scope="instance">
        <parameters>
          <parameter name="textarea" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onInput" scope="instance"/>
      <method name="_shrink" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="_setValueAttr" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.SimpleTextarea" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="cols" scope="instance" type="String"/>
      <property name="_previousNewlines" scope="instance" type="Number"/>
      <property name="_strictMode" scope="instance" type="bool"/>
      <property name="_needsHelpShrinking" scope="instance" type="Object"/>
      <property name="_busyResizing" scope="instance" type="bool"/>
      <property name="_setTimeoutHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea.textbox.style">
    <properties>
      <property name="maxHeight" scope="instance" type="String"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="paddingBottom" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.Textarea.textbox">
    <properties>
      <property name="value" scope="instance" type="String"/>
      <property name="scrollHeight" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.form.TimeTextBox" superclass="dijit.form._DateTimeTextBox">
    <methods>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._DateTimeTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="popupClass" scope="instance" type="String"/>
      <property name="_selector" scope="instance" type="String"/>
      <property name="constraints" scope="instance" type="dijit.form.TimeTextBox.__Constraints"/>
      <property name="value" scope="instance" type="Date">
        <description>The value of this widget as a JavaScript Date object.  Note that the date portion implies time zone and daylight savings rules.
	Example:
		new dijit.form.TimeTextBox({value: dojo.date.stamp.fromISOString(&amp;quot;T12:59:59&amp;quot;, new Date())})
	When passed to the parser in markup, must be specified according to locale-independent
	&lt;code&gt;dojo.date.stamp.fromISOString&lt;/code&gt; format.
	Example:
		&amp;lt;input dojotype='dijit.form.TimeTextBox' value='T12:34:00'&amp;gt;
	value.toString()=&amp;quot;NaN&amp;quot;
	FIXME: in markup, you have no control over daylight savings</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form.TimeTextBox.__Constraints" superclass="dijit.form._DateTimeTextBox.__Constraints">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._TimePicker.__Constraints.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form._DateTimeTextBox.__Constraints" scope="instance"/>
      <mixin type="dijit._TimePicker.__Constraints" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form.ValidationTextBox" superclass="dijit.form.TextBox">
    <methods>
      <method name="regExpGen" scope="instance">
        <parameters>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setValueAttr" scope="instance"/>
      <method name="validator" scope="instance">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
      </method>
      <method name="_isValidSubset" scope="instance"/>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getErrorMessage" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getPromptMessage" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="validate" scope="instance">
        <description>Show missing or invalid messages if appropriate, and highlight textbox field.</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="displayMessage" scope="instance">
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_computePartialRE" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setRequiredAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setMessageAttr" scope="instance">
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.TextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="required" scope="instance" type="Boolean">
        <description>User is required to enter data into this field.</description>
      </property>
      <property name="promptMessage" scope="instance" type="String">
        <description>If defined, display this hint string immediately on focus to the textbox, if empty.
	Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
	Think of this like a tooltip that tells the user what to do, not an error message
	that tells the user what they've done wrong.
	Message disappears when user starts typing.</description>
      </property>
      <property name="invalidMessage" scope="instance" type="String">
        <description>The message to display if value is invalid.
	The translated string value is read from the message file by default.
	Set to &amp;quot;&amp;quot; to use the promptMessage instead.</description>
      </property>
      <property name="missingMessage" scope="instance" type="String">
        <description>The message to display if value is empty and the field is required.
	The translated string value is read from the message file by default.
	Set to &amp;quot;&amp;quot; to use the invalidMessage instead.</description>
      </property>
      <property name="message" scope="instance" type="String">
        <description>Currently error/prompt message.
	When using the default tooltip implementation, this will only be
	displayed when the field is focused.</description>
      </property>
      <property name="constraints" scope="instance-prototype" type="dijit.form.ValidationTextBox.__Constraints">
        <description>user-defined object needed to pass parameters to the validator functions</description>
      </property>
      <property name="regExp" scope="instance" type="String">
        <description>regular expression string used to validate the input
	Do not specify both regExp and regExpGen</description>
      </property>
      <property name="state" scope="instance" type="String">
        <description>Shows current state (ie, validation result) of input (&amp;quot;&amp;quot;=Normal, Incomplete, or Error)</description>
      </property>
      <property name="tooltipPosition" scope="instance" type="Array&lt;String&gt;">
        <description>See description of &lt;code&gt;dijit.Tooltip.defaultPosition&lt;/code&gt; for details on this parameter.</description>
      </property>
      <property name="_maskValidSubsetError" scope="instance" type="Object"/>
      <property name="disabled" scope="instance" type="Object"/>
      <property name="_partialre" scope="instance" type="String"/>
      <property name="messages" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.MappedTextBox.valueNode">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form.ValidationTextBox.__Constraints">
    <methods/>
    <properties>
      <property name="locale" scope="instance" type="String">
        <description>locale used for validation, picks up value from this widget's lang attribute</description>
      </property>
      <property name="_flags_" scope="instance" type="anything">
        <description>various flags passed to regExpGen function</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form.RangeBoundTextBox.__Constraints">
    <methods/>
    <properties>
      <property name="min" scope="instance" type="Number">
        <description>Minimum signed value.  Default is -Infinity</description>
      </property>
      <property name="max" scope="instance" type="Number">
        <description>Maximum signed value.  Default is +Infinity</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form.VerticalRule" superclass="dijit.form.HorizontalRule">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalRule" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_positionPrefix" scope="instance" type="String"/>
      <property name="container" scope="instance" type="String">
        <description>This is either &amp;quot;leftDecoration&amp;quot; or &amp;quot;rightDecoration&amp;quot;,
	to indicate whether this rule goes to the left or to the right of the slider.
	Note that on RTL system, &amp;quot;leftDecoration&amp;quot; would actually go to the right, and vice-versa.</description>
      </property>
      <property name="_isHorizontal" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.form.VerticalRuleLabels" superclass="dijit.form.HorizontalRuleLabels">
    <methods>
      <method name="_calcPosition" scope="instance">
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalRuleLabels" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_positionPrefix" scope="instance" type="String"/>
      <property name="_labelPrefix" scope="instance" type="String"/>
      <property name="_isHorizontal" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.form.VerticalSlider" superclass="dijit.form.HorizontalSlider">
    <methods>
      <method name="_isReversed" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalSlider" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_mousePixelCoord" scope="instance" type="String"/>
      <property name="_pixelCount" scope="instance" type="String"/>
      <property name="_startingPixelCoord" scope="instance" type="String"/>
      <property name="_startingPixelCount" scope="instance" type="String"/>
      <property name="_handleOffsetCoord" scope="instance" type="String"/>
      <property name="_progressPixelSize" scope="instance" type="String"/>
      <property name="_descending" scope="instance" type="Boolean">
        <description>Specifies if the slider values go from high-on-top (true), or low-on-top (false)
	TODO: expose this in 1.2 - the css progress/remaining bar classes need to be reversed</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form._DateTimeTextBox" superclass="dijit.form.RangeBoundTextBox">
    <methods>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="val1" type="Date" usage="required"/>
          <parameter name="val2" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="val" type="anything" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_setConstraintsAttr" scope="instance">
        <parameters>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isInvalidDate" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Date|String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="formattedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="attr" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDropDownDefaultValueAttr" scope="instance">
        <parameters>
          <parameter name="val" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="openDropDown" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_getDisplayedValueAttr" scope="instance"/>
      <method name="_setDisplayedValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="hasDownArrow" scope="instance" type="Boolean">
        <description>Set this textbox to display a down arrow button, to open the drop down list.</description>
      </property>
      <property name="openOnClick" scope="instance" type="Boolean">
        <description>Set to true to open drop down upon clicking anywhere on the textbox.</description>
      </property>
      <property name="constraints" scope="instance" type="dijit.form._DateTimeTextBox.__Constraints">
        <description>Despite the name, this parameter specifies both constraints on the input
	(including starting/ending dates/times allowed) as well as
	formatting options like whether the date is displayed in long (ex: December 25, 2005)
	or short (ex: 12/25/2005) format.  See &lt;code&gt;dijit.form._DateTimeTextBox.__Constraints&lt;/code&gt; for details.</description>
      </property>
      <property name="regExpGen" scope="instance" type="Object"/>
      <property name="datePackage" scope="instance-prototype" type="String">
        <description>JavaScript namespace to find calendar routines.	 Uses Gregorian calendar routines
	at dojo.date, by default.</description>
      </property>
      <property name="forceWidth" scope="instance" type="Object"/>
      <property name="dropDownDefaultValue" scope="instance" type="Date">
        <description>The default value to focus in the popupClass widget when the textbox value is empty.</description>
      </property>
      <property name="value" scope="instance-prototype" type="Date">
        <description>The value of this widget as a JavaScript Date object.  Use get(&amp;quot;value&amp;quot;) / set(&amp;quot;value&amp;quot;, val) to manipulate.
	When passed to the parser in markup, must be specified according to &lt;code&gt;dojo.date.stamp.fromISOString&lt;/code&gt;
	value.toString()=&amp;quot;NaN&amp;quot;</description>
      </property>
      <property name="_blankValue" scope="instance" type="Object"/>
      <property name="popupClass" scope="instance" type="String">
        <description>Name of the popup widget class used to select a date/time.
	Subclasses should specify this.
	default is no popup = text only</description>
      </property>
      <property name="_selector" scope="instance" type="String">
        <description>Specifies constraints.selector passed to dojo.date functions, should be either
	&amp;quot;date&amp;quot; or &amp;quot;time&amp;quot;.
	Subclass must specify this.</description>
      </property>
      <property name="_buttonNode" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="dateClassObj" scope="instance" type="Object"/>
      <property name="dateLocaleModule" scope="instance" type="Object"/>
      <property name="_invalidDate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._DateTimeTextBox.__Constraints" superclass="dijit.form.RangeBoundTextBox.__Constraints">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.date.locale.__FormatOptions.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox.__Constraints" scope="instance"/>
      <mixin type="dojo.date.locale.__FormatOptions" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._DateTimeTextBox._buttonNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.form._FormMixin">
    <description>Can extract all the form widgets
	values and combine them into a single javascript object, or alternately
	take such an object and set the values for all the contained
	form widgets</description>
    <methods>
      <method name="reset" scope="instance"/>
      <method name="validate" scope="instance"/>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance"/>
      <method name="_getValueAttr" scope="instance"/>
      <method name="isValid" scope="instance"/>
      <method name="onValidStateChange" scope="instance">
        <parameters>
          <parameter name="isValid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getState" scope="instance"/>
      <method name="disconnectChildren" scope="instance"/>
      <method name="connectChildren" scope="instance">
        <parameters>
          <parameter name="inStartup" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="state" scope="instance" type="String">
        <description>Will be &amp;quot;Error&amp;quot; if one or more of the child widgets has an invalid value,
	&amp;quot;Incomplete&amp;quot; if not all of the required child widgets are filled in.  Otherwise, &amp;quot;&amp;quot;,
	which indicates that the form is ready to be submitted.</description>
      </property>
      <property name="_descendants" scope="instance" type="Object"/>
      <property name="_childConnections" scope="instance" type="Array"/>
      <property name="_childWatches" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.form._FormSelectWidget" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="onFetch" scope="instance"/>
      <method name="getOptions" scope="instance">
        <parameters>
          <parameter name="valueOrIdx" type="anything" usage="required">
            <description>If passed in as a string, that string is used to look up the option
	in the array of options - based on the value property.
	(See dijit.form.__SelectOption).
	If passed in a number, then the option with the given index (0-based)
	within this select will be returned.
	If passed in a dijit.form.__SelectOption, the same option will be
	returned if and only if it exists within this select.
	If passed an array, then an array will be returned with each element
	in the array being looked up.
	If not passed a value, then all options will be returned</description>
          </parameter>
        </parameters>
        <return-description>The option corresponding with the given value or index.  null
	is returned if any of the following are true:
	- A string value is passed in which doesn't exist
	- An index is passed in which is outside the bounds of the array of options
	- A dijit.form.__SelectOption is passed in which is not a part of the select</return-description>
        <return-types>
          <return-type type="Array&lt;dijit.form.__SelectOption&gt;"/>
          <return-type type="dijit.form.__SelectOption"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="addOption" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption|Array&lt;dijit.form.__SelectOption&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="removeOption" scope="instance">
        <parameters>
          <parameter name="valueOrIdx" type="String|dijit.form.__SelectOption|Number|Array" usage="required"/>
        </parameters>
      </method>
      <method name="updateOption" scope="instance">
        <parameters>
          <parameter name="newOption" type="dijit.form.__SelectOption|Array&lt;dijit.form.__SelectOption&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="dojo.data.api.Identity" usage="required">
            <description>The store you would like to use - it MUST implement Identity,
	and MAY implement Notification.</description>
          </parameter>
          <parameter name="selectedValue" type="anything" usage="optional">
            <description>The value that this widget should set itself to *after* the store
	has been loaded</description>
          </parameter>
          <parameter name="fetchArgs" type="Object" usage="optional">
            <description>The arguments that will be passed to the store's fetch() function</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.data.api.Identity"/>
        </return-types>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_getDisplayedValueAttr" scope="instance"/>
      <method name="_loadChildren" scope="instance"/>
      <method name="_updateSelection" scope="instance"/>
      <method name="_getValueFromOpts" scope="instance"/>
      <method name="_onNewItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_onDeleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_getOptionObjForItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit.form.__SelectOption"/>
        </return-types>
      </method>
      <method name="_addOptionForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_fillContent" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_addOptionItem" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_removeOptionItem" scope="instance">
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplay" scope="instance">
        <parameters>
          <parameter name="newDisplay" type="String" usage="required">
            <description>or String[]</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getChildren" scope="instance"/>
      <method name="_getSelectedOptionsAttr" scope="instance"/>
      <method name="_pseudoLoadChildren" scope="instance">
        <parameters>
          <parameter name="items" type="Array&lt;item&gt;" usage="required">
            <description>An array of items that will be loaded, when needed</description>
          </parameter>
        </parameters>
      </method>
      <method name="onSetStore" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="multiple" scope="instance" type="Boolean">
        <description>Whether or not we are multi-valued</description>
      </property>
      <property name="store" scope="instance" type="dojo.data.api.Identity">
        <description>A store which, at the very least impelements dojo.data.api.Identity
	to use for getting our list of options - rather than reading them
	from the &amp;lt;option&amp;gt; html tags.</description>
      </property>
      <property name="query" scope="instance" type="object">
        <description>A query to use when fetching items from our store</description>
      </property>
      <property name="queryOptions" scope="instance" type="object">
        <description>Query options to use when fetching from the store</description>
      </property>
      <property name="sortByLabel" scope="instance" type="Boolean">
        <description>Flag to sort the options returned from a store by the label of
	the store.</description>
      </property>
      <property name="loadChildrenOnOpen" scope="instance" type="Boolean">
        <description>By default loadChildren is called when the items are fetched from the
	store.  This property allows delaying loadChildren (and the creation
	of the options/menuitems) until the user clicks the button to open the
	dropdown.</description>
      </property>
      <property name="_notifyConnections" scope="instance" type="Array"/>
      <property name="_onChangeActive" scope="instance" type="bool"/>
      <property name="_loadingStore" scope="instance" type="Object"/>
      <property name="_pendingValue" scope="instance" type="Object"/>
      <property name="_oValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._FormSelectWidget.options">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form.__SelectOption">
    <methods/>
    <properties>
      <property name="value" scope="instance" type="String">
        <description>The value of the option.  Setting to empty (or missing) will
	place a separator at that location</description>
      </property>
      <property name="label" scope="instance" type="String">
        <description>The label for our option.  It can contain html tags.</description>
      </property>
      <property name="selected" scope="instance" type="Boolean">
        <description>Whether or not we are a selected option</description>
      </property>
      <property name="disabled" scope="instance" type="Boolean">
        <description>Whether or not this specific option is disabled</description>
      </property>
    </properties>
  </class>
  <class type="dijit.form._FormWidget" superclass="dijit._Widget">
    <description>Represents a single HTML element.
	All these widgets should have these attributes just like native HTML input elements.
	You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	They also share some common methods.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isFocusable" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="val1" type="anything" usage="required"/>
          <parameter name="val2" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="anything" usage="required">
            <description>the new value</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="optional">
            <description>For a slider, for example, dragging the slider is priorityChange==false,
	but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
	onChange is only called form priorityChange=true events.</description>
          </parameter>
        </parameters>
      </method>
      <method name="create" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>Name used when submitting form; same as &amp;quot;name&amp;quot; attribute or plain HTML elements</description>
      </property>
      <property name="alt" scope="instance" type="String">
        <description>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.</description>
      </property>
      <property name="value" scope="instance" type="String">
        <description>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.</description>
      </property>
      <property name="type" scope="instance" type="String">
        <description>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.</description>
      </property>
      <property name="tabIndex" scope="instance" type="Integer">
        <description>Order fields are traversed when user hits the tab key</description>
      </property>
      <property name="disabled" scope="instance" type="Boolean">
        <description>Should this widget respond to user input?
	In markup, this is specified as &amp;quot;disabled='disabled'&amp;quot;, or just &amp;quot;disabled&amp;quot;.</description>
      </property>
      <property name="intermediateChanges" scope="instance" type="Boolean">
        <description>Fires onChange for each value change or only on demand</description>
      </property>
      <property name="scrollOnFocus" scope="instance" type="Boolean">
        <description>On focus, should this widget scroll into view?</description>
      </property>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="nameAttrSetting" scope="instance" type="Object"/>
      <property name="_onChangeActive" scope="instance" type="Boolean">
        <description>Indicates that changes to the value should call onChange() callback.
	This is false during widget initialization, to avoid calling onChange()
	when the initial value is set.</description>
      </property>
      <property name="_resetValue" scope="instance" type="Object"/>
      <property name="_lastValueReported" scope="instance" type="Object"/>
      <property name="_pendingOnChange" scope="instance" type="bool"/>
      <property name="_onChangeHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._FormValueWidget" superclass="dijit.form._FormWidget">
    <description>Each _FormValueWidget represents a single input value, and has a (possibly hidden) &lt;input&gt; element,
	to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	works as expected.</description>
    <methods>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget.
	If the value has changed, then fire onChange event, unless priorityChange
	is specified as null (or false?)</description>
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="undo" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_layoutHackIE7" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="readOnly" scope="instance" type="Boolean">
        <description>Should this widget respond to user input?
	In markup, this is specified as &amp;quot;readOnly&amp;quot;.
	Similar to disabled except readOnly form values are submitted.</description>
      </property>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_lastValueReported" scope="instance" type="Object"/>
      <property name="_resetValue" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.form._FormValueWidget.domNode">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._FormValueWidget.domNode.firstChild.style">
    <properties>
      <property name="filter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._Spinner" superclass="dijit.form.RangeBoundTextBox">
    <description>This class basically (conceptually) extends `dijit.form.ValidationTextBox`.
	It modifies the template to have up/down arrows, and provides related handling code.</description>
    <methods>
      <method name="adjust" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_arrowPressed" scope="instance">
        <parameters>
          <parameter name="nodePressed" type="Node" usage="required"/>
          <parameter name="direction" type="Number" usage="required"/>
          <parameter name="increment" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_arrowReleased" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_typematicCallback" scope="instance">
        <parameters>
          <parameter name="count" type="Number" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.RangeBoundTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultTimeout" scope="instance" type="Number">
        <description>Number of milliseconds before a held arrow key or up/down button becomes typematic</description>
      </property>
      <property name="minimumTimeout" scope="instance" type="Number">
        <description>minimum number of milliseconds that typematic event fires when held key or button is held</description>
      </property>
      <property name="timeoutChangeRate" scope="instance" type="Number">
        <description>Fraction of time used to change the typematic timer between events.
	1.0 means that each typematic event fires at defaultTimeout intervals.
	&amp;lt; 1.0 means that each typematic event fires at an increasing faster rate.</description>
      </property>
      <property name="smallDelta" scope="instance" type="Number">
        <description>Adjust the value by this much when spinning using the arrow keys/buttons</description>
      </property>
      <property name="largeDelta" scope="instance" type="Number">
        <description>Adjust the value by this much when spinning using the PgUp/Dn keys</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_wheelTimer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._Spinner.cssStateNodes">
    <properties>
      <property name="upArrowNode" scope="instance" type="String"/>
      <property name="downArrowNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout">
    <methods>
      <method name="marginBox2contentBox" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="mb" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layoutChildren" scope="instance">
        <parameters>
          <parameter name="container" type="DomNode" usage="required">
            <description>parent node</description>
          </parameter>
          <parameter name="dim" type="Object" usage="required">
            <description>{l, t, w, h} object specifying dimensions of container into which to place children</description>
          </parameter>
          <parameter name="children" type="Array&lt;Widget&gt;" usage="required">
            <description>an array of Widgets or at least objects containing:
	* domNode: pointer to DOM node to position
	* region or layoutAlign: position to place DOM node
	* resize(): (optional) method to set size of node
	* id: (optional) Id of widgets, referenced from resize object, below.</description>
          </parameter>
          <parameter name="changedRegionId" type="String" usage="optional">
            <description>If specified, the slider for the region with the specified id has been dragged, and thus
	the region's height or width should be adjusted according to changedRegionSize</description>
          </parameter>
          <parameter name="changedRegionSize" type="Number" usage="optional">
            <description>See changedRegionId.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.layout.AccordionContainer" superclass="dijit.layout.StackContainer">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="instance">
        <parameters>
          <parameter name="newWidget" type="dijit._Widget" usage="optional"/>
          <parameter name="oldWidget" type="dijit._Widget" usage="optional"/>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="If child has an href, promise that fires when the widget has finished loading"/>
        </return-types>
      </method>
      <method name="_onKeyPress" scope="instance">
        <description>This is called from a handler on AccordionContainer.domNode
	(setup in StackContainer), and is also called directly from
	the click handler for accordion labels</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="fromTitle" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="duration" scope="instance" type="Integer">
        <description>Amount of time (in ms) it takes to slide panes</description>
      </property>
      <property name="buttonWidget" scope="instance" type="String">
        <description>The name of the widget used to display the title of each pane</description>
      </property>
      <property name="_verticalSpace" scope="instance" type="Number">
        <description>Pixels of space available for the open pane
	(my content box size minus the cumulative size of all the title bars)</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="selectedChildWidget" scope="instance" type="Object"/>
      <property name="_contentBox" scope="instance" type="Object"/>
      <property name="_containerContentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionContainer.domNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionContainer.selectedChildWidget.containerNode"/>
  <class type="dijit.layout.AccordionContainer.selectedChildWidget.containerNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionContainer.selectedChildWidget._wrapperWidget">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionContainer._animation">
    <properties>
      <property name="onStop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._AccordionInnerContainer" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setSelectedAttr" scope="instance">
        <parameters>
          <parameter name="isSelected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="destroyDescendants" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="buttonWidget" scope="instance" type="String">
        <description>Name of class to use to instantiate title
	(Wish we didn't have a separate widget for just the title but maintaining it
	for backwards compatibility, is it worth it?)</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="isContainer" scope="instance" type="Object"/>
      <property name="isLayoutContainer" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_contentWidgetWatches" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.layout._AccordionInnerContainer.contentWidget">
    <properties>
      <property name="_buttonWidget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._AccordionButton" superclass="dijit._Widget">
    <methods>
      <method name="getParent" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="getTitleHeight" scope="instance">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_onTitleClick" scope="instance"/>
      <method name="_onTitleKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedAttr" scope="instance">
        <parameters>
          <parameter name="isSelected" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._CssStateMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._CssStateMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.AccordionPane" superclass="dijit.layout.ContentPane">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="onSelected" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit._Widget.prototype">
    <properties>
      <property name="maxSize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.BorderContainer" superclass="dijit.layout._LayoutWidget">
    <description>A BorderContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
	that contains a child widget marked region="center" and optionally children widgets marked
	region equal to "top", "bottom", "leading", "trailing", "left" or "right".
	Children along the edges will be laid out according to width or height dimensions and may
	include optional splitters (splitter="true") to make them resizable by the user.  The remaining
	space is designated for the center region.
	The outer size must be specified on the BorderContainer node.  Width must be specified for the sides
	and height for the top and bottom, respectively.  No dimensions should be specified on the center;
	it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
	"left" and "right" except that they will be reversed in right-to-left environments.
	For complex layouts, multiple children can be specified for a single region.   In this case, the
	layoutPriority flag on the children determines which child is closer to the edge (low layoutPriority)
	and which child is closer to the center (high layoutPriority).   layoutPriority can also be used
	instead of the design attribute to conrol layout precedence of horizontal vs. vertical panes.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance"/>
      <method name="getSplitter" scope="instance">
        <parameters>
          <parameter name="region" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="newSize" type="Object" usage="required"/>
          <parameter name="currentSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_layoutChildren" scope="instance">
        <description>With no arguments, measures the height of top/bottom panes, the width
	of left/right panes, and then sizes all panes accordingly.
	With changedRegion specified (as "left", "top", "bottom", or "right"),
	it changes that region's width/height to changedRegionSize and
	then resizes other regions that were affected.</description>
        <parameters>
          <parameter name="changedChildId" type="String" usage="optional">
            <description>Id of the child which should be resized because splitter was dragged.</description>
          </parameter>
          <parameter name="changedChildSize" type="Number" usage="optional">
            <description>The new width/height (in pixels) to make specified child</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroyRecursive" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="design" scope="instance" type="String">
        <description>Which design is used for the layout:
	- &amp;quot;headline&amp;quot; (default) where the top and bottom extend
	the full width of the container
	- &amp;quot;sidebar&amp;quot; where the left and right sides extend from top to bottom.</description>
      </property>
      <property name="gutters" scope="instance" type="Boolean">
        <description>Give each pane a border and margin.
	Margin determined by domNode.paddingLeft.
	When false, only resizable panes have a gutter (i.e. draggable splitter) for resizing.</description>
      </property>
      <property name="liveSplitters" scope="instance" type="Boolean">
        <description>Specifies whether splitters resize as you drag (true) or only upon mouseup (false)</description>
      </property>
      <property name="persist" scope="instance" type="Boolean">
        <description>Save splitter positions in a cookie.</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_splitterClass" scope="instance" type="String">
        <description>Optional hook to override the default Splitter widget used by BorderContainer</description>
      </property>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="cs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.BorderContainer.pe">
    <properties>
      <property name="r" scope="instance" type="Object"/>
      <property name="b" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._Splitter" superclass="dijit._Widget">
    <description>This is instantiated by `dijit.layout.BorderContainer`.  Users should not
	create it directly.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_computeMaxSize" scope="instance"/>
      <method name="_startDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_drag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="forceResize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stopDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupHandlers" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="container" scope="instance" type="dijit.layout.BorderContainer">
        <description>Pointer to the parent BorderContainer</description>
      </property>
      <property name="region" scope="instance" type="String">
        <description>Region of pane associated with this splitter.
	&amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;.</description>
      </property>
      <property name="live" scope="instance" type="Boolean">
        <description>If true, the child's size changes and the child widget is redrawn as you drag the splitter;
	otherwise, the size doesn't change until you drop the splitter (by mouse-up)</description>
      </property>
      <property name="templateString" scope="instance" type="String"/>
      <property name="horizontal" scope="instance" type="Object"/>
      <property name="_factor" scope="instance" type="Object"/>
      <property name="_cookieName" scope="instance" type="String"/>
      <property name="cover" scope="instance" type="Object"/>
      <property name="_resize" scope="instance" type="Object"/>
      <property name="fake" scope="instance" type="Object"/>
      <property name="_handlers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._Splitter.domNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._Splitter.child">
    <properties>
      <property name="minSize" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.layout._Gutter" superclass="dijit._Widget">
    <description>Instantiated by `dijit.layout.BorderContainer`.  Users should not
	create directly.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="horizontal" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ContentPane" superclass="dijit._Widget">
    <description>This widget embeds a document fragment in the page, specified
	either by uri, javascript generated markup or DOM reference.
	Any widgets within this content are instantiated and managed,
	but laid out according to the HTML structure.  Unlike IFRAME,
	ContentPane embeds a document fragment as would be found
	inside the BODY tag of a full HTML document.  It should not
	contain the HTML, HEAD, or BODY tags.
	For more advanced functionality with scripts and
	stylesheets, see dojox.layout.ContentPane.  This widget may be
	used stand alone or as a base class for other widgets.
	ContentPane is useful as a child of other layout containers
	such as BorderContainer or TabContainer, but note that those
	widgets can contain any widget as a child.</description>
    <methods>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="srcNodeRef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="setHref" scope="instance">
        <parameters>
          <parameter name="href" type="String|Uri" usage="required"/>
        </parameters>
      </method>
      <method name="_setHrefAttr" scope="instance">
        <description>Reset the (external defined) content of this pane and replace with new url
	Note: It delays the download until widget is shown if preload is false.</description>
        <parameters>
          <parameter name="href" type="String|Uri" usage="required">
            <description>url to the page you want to get, must be within the same domain as your mainpage</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="setContent" scope="instance">
        <parameters>
          <parameter name="data" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="_setContentAttr" scope="instance">
        <parameters>
          <parameter name="data" type="String|DomNode|Nodelist" usage="required">
            <description>the new Content may be String, DomNode or NodeList
	if data is a NodeList (or an array of nodes) nodes are copied
	so you can import nodes from another document implicitly</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_getContentAttr" scope="instance"/>
      <method name="cancel" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="destroyRecursive" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isShown" scope="instance">
        <description>If I am a child of a layout widget then it actually returns true if I've ever been visible,
	not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
	tree every call, and at least solves the performance problem on page load by deferring loading
	hidden ContentPanes until they are first shown</description>
        <return-types>
          <return-type type="for TitlePane, etc"/>
        </return-types>
      </method>
      <method name="_onShow" scope="instance">
        <description>For a plain ContentPane, this is called on initialization, from startup().
	If the ContentPane is a hidden pane of a TabContainer etc., then it's
	called whenever the pane is made visible.
	Does necessary processing, including href download and layout/resize of
	child widget(s)</description>
        <return-types>
          <return-type type="If child has an href, promise that fires when the load is complete"/>
        </return-types>
      </method>
      <method name="refresh" scope="instance">
        <description>1. cancels any currently in-flight requests
	2. posts "loading..." message
	3. sends XHR to download new data</description>
        <return-types>
          <return-type type="If child has an href, promise that fires when refresh is complete"/>
        </return-types>
      </method>
      <method name="_load" scope="instance"/>
      <method name="_onLoadHandler" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUnloadHandler" scope="instance"/>
      <method name="destroyDescendants" scope="instance"/>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="cont" type="String|DocumentFragment" usage="required"/>
          <parameter name="isFakeContent" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onError" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="consoleText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scheduleLayout" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onUnload" scope="instance"/>
      <method name="onDownloadStart" scope="instance">
        <description>The string returned by this function will be the html
	that tells the user we are loading something.
	Override with your own function if you want to change text.</description>
      </method>
      <method name="onContentError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloadError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloadEnd" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._ContentPaneResizeMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit.layout._ContentPaneResizeMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="href" scope="instance" type="String">
        <description>The href of the content that displays now.
	Set this at construction if you want to load data externally when the
	pane is shown.  (Set preload=true to load it immediately.)
	Changing href after creation doesn't have any effect; Use set('href', ...);</description>
      </property>
      <property name="content" scope="instance" type="String">
        <description>|| DomNode || NodeList || dijit._Widget
	The innerHTML of the ContentPane.
	Note that the initialization parameter / argument to set(&amp;quot;content&amp;quot;, ...)
	can be a String, DomNode, Nodelist, or _Widget.</description>
      </property>
      <property name="extractContent" scope="instance" type="Boolean">
        <description>Extract visible content from inside of &amp;lt;body&amp;gt; .... &amp;lt;/body&amp;gt;.
	I.e., strip &amp;lt;html&amp;gt; and &amp;lt;head&amp;gt; (and it's contents) from the href</description>
      </property>
      <property name="parseOnLoad" scope="instance" type="Boolean">
        <description>Parse content and create the widgets, if any.</description>
      </property>
      <property name="parserScope" scope="instance" type="String">
        <description>Flag passed to parser.  Root for attribute names to search for.   If scopeName is dojo,
	will search for data-dojo-type (or dojoType).  For backwards compatibility
	reasons defaults to dojo._scopeName (which is &amp;quot;dojo&amp;quot; except when
	multi-version support is used, when it will be something like dojo16, dojo20, etc.)</description>
      </property>
      <property name="preventCache" scope="instance" type="Boolean">
        <description>Prevent caching of data from href's by appending a timestamp to the href.</description>
      </property>
      <property name="preload" scope="instance" type="Boolean">
        <description>Force load of data on initialization even if pane is hidden.</description>
      </property>
      <property name="refreshOnShow" scope="instance" type="Boolean">
        <description>Refresh (re-download) content when pane goes from hidden to shown</description>
      </property>
      <property name="loadingMessage" scope="instance" type="String">
        <description>Message that shows while downloading</description>
      </property>
      <property name="errorMessage" scope="instance" type="String">
        <description>Message that shows if an error occurs</description>
      </property>
      <property name="isLoaded" scope="instance" type="Boolean">
        <description>True if the ContentPane has data in it, either specified
	during initialization (via href or inline content), or set
	via set('content', ...) / set('href', ...)
	False if it doesn't have any content, or if ContentPane is
	still in the process of downloading href.</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="ioArgs" scope="instance" type="Object">
        <description>Parameters to pass to xhrGet() request, for example:
		&amp;lt;div dojoType=&amp;quot;dijit.layout.ContentPane&amp;quot; href=&amp;quot;./bar&amp;quot; ioArgs=&amp;quot;{timeout: 500}&amp;quot;&amp;gt;</description>
      </property>
      <property name="isContainer" scope="instance" type="Boolean">
        <description>Indicates that this widget acts as a &amp;quot;parent&amp;quot; to the descendant widgets.
	When the parent is started it will call startup() on the child widgets.
	See also &lt;code&gt;isLayoutContainer&lt;/code&gt;.</description>
      </property>
      <property name="onLoadDeferred" scope="instance" type="dojo.Deferred">
        <description>This is the &lt;code&gt;dojo.Deferred&lt;/code&gt; returned by set('href', ...) and refresh().
	Calling onLoadDeferred.addCallback() or addErrback() registers your
	callback to be called only once, when the prior set('href', ...) call or
	the initial href parameter to the constructor finishes loading.
	This is different than an onLoad() handler which gets called any time any href
	or content is loaded.</description>
      </property>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="stopParser" scope="instance" type="Object"/>
      <property name="template" scope="instance" type="Boolean">
        <description>Flag from the parser that this ContentPane is inside a template
	so the contents are pre-parsed.
	(TODO: this declaration can be commented out in 2.0)</description>
      </property>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_hrefChanged" scope="instance" type="Object"/>
      <property name="_isDownloaded" scope="instance" type="bool"/>
      <property name="_resizeCalled" scope="instance" type="Object"/>
      <property name="_wasShown" scope="instance" type="Object"/>
      <property name="_xhrDfd" scope="instance" type="Object"/>
      <property name="_contentSetter" scope="instance" type="Object"/>
      <property name="_needLayout" scope="instance" type="Object"/>
      <property name="_changeSize" scope="instance" type="Object"/>
      <property name="_resultSize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ContentPane.domNode">
    <properties>
      <property name="title" scope="instance" type="String"/>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.LayoutContainer" superclass="dijit.layout._LayoutWidget">
    <description>Provides Delphi-style panel layout semantics.
	A LayoutContainer is a box with a specified size (like style="width: 500px; height: 500px;"),
	that contains children widgets marked with "layoutAlign" of "left", "right", "bottom", "top", and "client".
	It takes it's children marked as left/top/bottom/right, and lays them out along the edges of the box,
	and then it takes the child marked "client" and puts it into the remaining space in the middle.
	Left/right positioning is similar to CSS's "float: left" and "float: right",
	and top/bottom positioning would be similar to "float: top" and "float: bottom", if there were such
	CSS.
	Note that there can only be one client element, but there can be multiple left, right, top,
	or bottom elements.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.LinkPane" superclass="dijit.layout.ContentPane">
    <description>LinkPane is just a ContentPane that is declared in markup similarly
	to an anchor.  The anchor's body (the words between `&lt;a&gt;` and `&lt;/a&gt;`)
	become the title of the widget (used for TabContainer, AccordionContainer, etc.)</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController" superclass="dijit.layout.TabController">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="onStartup" scope="instance"/>
      <method name="onAddChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
          <parameter name="insertIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
          <parameter name="insertIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButtons" scope="instance"/>
      <method name="_getTabsWidth" scope="instance"/>
      <method name="_enableBtn" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getScroll" scope="instance"/>
      <method name="_convertToScrollLeft" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_getScrollBounds" scope="instance"/>
      <method name="_getScrollForSelectedTab" scope="instance"/>
      <method name="createSmoothScroll" scope="instance">
        <description>If an number argument is passed to the function, that horizontal
	pixel position is scrolled to.  Otherwise the currently selected
	tab is scrolled to.</description>
        <parameters>
          <parameter name="x" type="Integer" usage="optional">
            <description>An optional pixel value to scroll to, indicating distance from left.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="_getBtnNode" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The mouse click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="doSlideRight" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The mouse click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="doSlideLeft" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The mouse click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="doSlide" scope="instance">
        <parameters>
          <parameter name="direction" type="Number" usage="required">
            <description>If the direction is 1, the widget scrolls to the right, if it is
	-1, it scrolls to the left.</description>
          </parameter>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setButtonClass" scope="instance">
        <parameters>
          <parameter name="scroll" type="Number" usage="required">
            <description>Integer amount of horizontal scroll</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.TabController" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="useMenu" scope="instance" type="Boolean">
        <description>True if a menu should be used to select tabs when they are too
	wide to fit the TabContainer, false otherwise.</description>
      </property>
      <property name="useSlider" scope="instance" type="Boolean">
        <description>True if a slider should be used to select tabs when they are too
	wide to fit the TabContainer, false otherwise.</description>
      </property>
      <property name="tabStripClass" scope="instance" type="String">
        <description>The css class to apply to the tab strip, if it is visible.</description>
      </property>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_minScroll" scope="instance" type="Number">
        <description>The distance in pixels from the edge of the tab strip which,
	if a scroll animation is less than, forces the scroll to
	go all the way to the left/right.</description>
      </property>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_postStartup" scope="instance" type="Object"/>
      <property name="_selectedTab" scope="instance" type="Object"/>
      <property name="_btnWidth" scope="instance" type="Number"/>
      <property name="_buttons" scope="instance" type="Object"/>
      <property name="_dim" scope="instance" type="Object"/>
      <property name="_postResize" scope="instance" type="Object"/>
      <property name="_anim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController.scrollNode.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController._contentBox">
    <properties>
      <property name="h" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController._leftBtn">
    <properties>
      <property name="layoutAlign" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController._rightBtn">
    <properties>
      <property name="layoutAlign" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController._menuBtn">
    <properties>
      <property name="layoutAlign" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.ScrollingTabController.scrollNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._ScrollingTabControllerButtonMixin">
    <methods>
      <method name="isFocusable" scope="instance"/>
    </methods>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="tabIndex" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout._ScrollingTabControllerButton" superclass="dijit.form.Button">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit.layout._ScrollingTabControllerButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
      <mixin type="dijit.layout._ScrollingTabControllerButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.layout._ScrollingTabControllerMenuButton" superclass="dijit.form.Button">
    <methods>
      <method name="isLoaded" scope="instance"/>
      <method name="loadDropDown" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="closeDropDown" scope="instance">
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
      <mixin type="dijit.layout._ScrollingTabControllerButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
      <mixin type="dijit.layout._ScrollingTabControllerButtonMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="containerId" scope="instance" type="String"/>
      <property name="tabIndex" scope="instance" type="String"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer" superclass="dijit.layout._LayoutWidget">
    <description>A Container widget with sizing handles in-between each child.
	Contains multiple children widgets, all of which are displayed side by side
	(either horizontally or vertically); there's a bar between each of the children,
	and you can adjust the relative size of each child by dragging the bars.
	You must specify a size (width and height) for the SplitContainer.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onSizerMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addSizer" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required">
            <description>a widget to add</description>
          </parameter>
          <parameter name="insertIndex" type="Integer" usage="optional">
            <description>postion in the &amp;quot;stack&amp;quot; to add the child widget</description>
          </parameter>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="_movePanel" scope="instance">
        <parameters>
          <parameter name="panel" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveSlider" scope="instance">
        <parameters>
          <parameter name="slider" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_growPane" scope="instance">
        <parameters>
          <parameter name="growth" type="Object" usage="required"/>
          <parameter name="pane" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_checkSizes" scope="instance"/>
      <method name="beginSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changeSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="movePoint" scope="instance"/>
      <method name="legaliseSplitPoint" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSize" scope="instance"/>
      <method name="_showSizingLine" scope="instance"/>
      <method name="_hideSizingLine" scope="instance"/>
      <method name="_moveSizingLine" scope="instance"/>
      <method name="_getCookieName" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_restoreState" scope="instance"/>
      <method name="_saveState" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="activeSizing" scope="instance" type="Boolean">
        <description>If true, the children's size changes as you drag the bar;
	otherwise, the sizes don't change until you drop the bar (by mouse-up)</description>
      </property>
      <property name="sizerWidth" scope="instance" type="Integer">
        <description>Size in pixels of the bar between each child
	FIXME: this should be a CSS attribute (at 7 because css wants it to be 7 until we fix to css)</description>
      </property>
      <property name="orientation" scope="instance" type="String">
        <description>either 'horizontal' or vertical; indicates whether the children are
	arranged side-by-side or up/down.</description>
      </property>
      <property name="persist" scope="instance" type="Boolean">
        <description>Save splitter positions in a cookie</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="isHorizontal" scope="instance" type="bool"/>
      <property name="sizers" scope="instance" type="Array"/>
      <property name="virtualSizer" scope="instance" type="Object"/>
      <property name="paneWidth" scope="instance" type="Object"/>
      <property name="paneHeight" scope="instance" type="Object"/>
      <property name="isSizing" scope="instance" type="bool"/>
      <property name="sizingSplitter" scope="instance" type="Object"/>
      <property name="cover" scope="instance" type="Object"/>
      <property name="originPos" scope="instance" type="Object"/>
      <property name="startPoint" scope="instance" type="Object"/>
      <property name="lastPoint" scope="instance" type="String"/>
      <property name="screenToClientOffset" scope="instance" type="Number"/>
      <property name="dragOffset" scope="instance" type="Number"/>
      <property name="_ownconnects" scope="instance" type="Array"/>
      <property name="isDraggingLeft" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.domNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.cover.style">
    <properties>
      <property name="zIndex" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.sizingSplitter.style">
    <properties>
      <property name="zIndex" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.paneBefore">
    <properties>
      <property name="position" scope="instance" type="Object"/>
      <property name="sizeActual" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.paneAfter">
    <properties>
      <property name="position" scope="instance" type="String"/>
      <property name="sizeActual" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dijit.layout.SplitContainer.virtualSizer.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.StackContainer" superclass="dijit.layout._LayoutWidget">
    <description>A container for widgets (ContentPanes, for example) That displays
	only one Widget at a time.
	Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	Can be base class for container, Wizard, Show, etc.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="selectChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget|String" usage="required">
            <description>Reference to child widget or id of child widget</description>
          </parameter>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="If child has an href, promise that fires when the child's href finishes loading"/>
        </return-types>
      </method>
      <method name="_transition" scope="instance">
        <parameters>
          <parameter name="newWidget" type="dijit._Widget" usage="required"/>
          <parameter name="oldWidget" type="dijit._Widget" usage="required"/>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="If child has an href, promise that fires when the child's href finishes loading"/>
        </return-types>
      </method>
      <method name="_adjacent" scope="instance">
        <parameters>
          <parameter name="forward" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="forward" scope="instance"/>
      <method name="back" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
        <return-description>Promise that fires when page has finished showing, or true if there's no href</return-description>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="closeChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="doLayout" scope="instance" type="Boolean">
        <description>If true, change the size of my currently displayed child to match my size</description>
      </property>
      <property name="persist" scope="instance" type="Boolean">
        <description>Remembers the selected child across sessions</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="selectedChildWidget" scope="instance" type="dijit._Widget">
        <description>References the currently selected child widget, if any.
	Adjust selected child with selectChild() method.</description>
      </property>
      <property name="_hasBeenShown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout.StackController" superclass="dijit._Widget">
    <description>Monitors the specified StackContainer, and whenever a page is
	added, deleted, or selected, updates itself accordingly.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onStartup" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="onAddChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onButtonClick" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onCloseButtonClick" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="adjacent" scope="instance">
        <parameters>
          <parameter name="forward" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="onkeypress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onContainerKeyPress" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="containerId" scope="instance" type="String">
        <description>The id of the page container that I point to</description>
      </property>
      <property name="buttonWidget" scope="instance" type="String">
        <description>The name of the button widget to create to correspond to each page</description>
      </property>
      <property name="_currentChild" scope="instance" type="Object"/>
      <property name="pane2button" scope="instance" type="Object"/>
      <property name="pane2connects" scope="instance" type="Object"/>
      <property name="pane2watches" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._StackButton" superclass="dijit.form.ToggleButton">
    <description>The button-like or tab-like object you click to select or delete a page</description>
    <methods>
      <method name="buildRendering" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClickCloseButton" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ToggleButton" scope="instance"/>
    </mixins>
    <properties>
      <property name="tabIndex" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout.TabContainer" superclass="dijit.layout._TabContainerBase">
    <description>A TabContainer is a container that has multiple panes, but shows only
	one pane at a time.  There are a set of tabs corresponding to each pane,
	where each tab has the name (aka title) of the pane, and optionally a close button.</description>
    <methods>
      <method name="_makeController" scope="instance">
        <parameters>
          <parameter name="srcNode" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._TabContainerBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="useMenu" scope="instance" type="Boolean">
        <description>True if a menu should be used to select tabs when they are too
	wide to fit the TabContainer, false otherwise.</description>
      </property>
      <property name="useSlider" scope="instance" type="Boolean">
        <description>True if a slider should be used to select tabs when they are too
	wide to fit the TabContainer, false otherwise.</description>
      </property>
      <property name="controllerWidget" scope="instance" type="String">
        <description>An optional parameter to override the widget used to display the tab labels</description>
      </property>
    </properties>
  </class>
  <class type="dijit.layout.TabController" superclass="dijit.layout.StackController">
    <description>Lets the user select the currently shown pane in a TabContainer or StackContainer.
	TabController also monitors the TabContainer, and whenever a pane is
	added or deleted updates itself accordingly.</description>
    <methods>
      <method name="_rectifyRtlTabList" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackController" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="tabPosition" scope="instance" type="String">
        <description>Defines where tabs go relative to the content.
	&amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;, &amp;quot;left-h&amp;quot;, &amp;quot;right-h&amp;quot;</description>
      </property>
      <property name="buttonWidget" scope="instance" type="String">
        <description>The name of the tab widget to create to correspond to each page</description>
      </property>
    </properties>
  </class>
  <class type="dijit.layout._TabButton" superclass="dijit.layout._StackButton">
    <description>Contains the title of the pane, and optionally a close-button to destroy the pane.
	This is an internal widget and should not be instantiated directly.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setCloseButtonAttr" scope="instance">
        <parameters>
          <parameter name="disp" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setLabelAttr" scope="instance">
        <description>takes an HTML string.
	Inherited ToggleButton implementation will Set the label (text) of the button;
	Need to set the alt attribute of icon on tab buttons if no label displayed</description>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._StackButton" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String">
        <description>The CSS class applied to the domNode.</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="scrollOnFocus" scope="instance" type="bool"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_closeMenu" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._TabButton.cssStateNodes">
    <properties>
      <property name="closeNode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout._TabButton.closeNode.style">
    <properties>
      <property name="display" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._TabButton.iconNode">
    <properties>
      <property name="alt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._ContentPaneResizeMixin">
    <methods>
      <method name="_startChildren" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_checkIfSingleChild" scope="instance">
        <return-types>
          <return-type type="or a regexp for hidden elements like script"/>
          <return-type type="area"/>
          <return-type type="map"/>
          <return-type type="etc"/>
        </return-types>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_layout" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_layoutChildren" scope="instance"/>
    </methods>
    <properties>
      <property name="doLayout" scope="instance" type="Boolean">
        <description>- false - don't adjust size of children
	- true - if there is a single visible child widget, set it's size to
	however big the ContentPane is</description>
      </property>
      <property name="isLayoutContainer" scope="instance" type="Boolean">
        <description>Indicates that this widget will call resize() on it's child widgets
	when they become visible.</description>
      </property>
      <property name="_childOfLayoutWidget" scope="instance" type="Object"/>
      <property name="_needLayout" scope="instance" type="bool"/>
      <property name="_singleChild" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_contentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._LayoutWidget" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance">
        <description>Change size mode:
	When changeSize is specified, changes the marginBox of this widget
	and forces it to relayout its contents accordingly.
	changeSize may specify height, width, or both.
	If resultSize is specified it indicates the size the widget will
	become after changeSize has been applied.
	Notification mode:
	When changeSize is null, indicates that the caller has already changed
	the size of the widget, or perhaps it changed because the browser
	window was resized.  Tells widget to relayout its contents accordingly.
	If resultSize is also specified it indicates the size the widget has
	become.
	In either mode, this method also:
	1. Sets this._borderBox and this._contentBox to the new size of
	the widget.  Queries the current domNode size if necessary.
	2. Calls layout() to resize contents (and maybe adjust child widgets).</description>
        <parameters>
          <parameter name="changeSize" type="Object" usage="optional">
            <description>Sets the widget to this margin-box size and position.
	May include any/all of the following properties:
		{w: int, h: int, l: int, t: int}</description>
          </parameter>
          <parameter name="resultSize" type="Object" usage="optional">
            <description>The margin-box size of this widget after applying changeSize (if
	changeSize is specified).  If caller knows this size and
	passes it in, we don't need to query the browser to get the size.
		{w: int, h: int}</description>
          </parameter>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String">
        <description>This class name is applied to the widget's domNode
	and also may be used to generate names for sub nodes,
	for example dijitTabContainer-content.</description>
      </property>
      <property name="isLayoutContainer" scope="instance" type="Boolean">
        <description>Indicates that this widget is going to call resize() on its
	children widgets, setting their size, when they become visible.</description>
      </property>
      <property name="getParent" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_borderBox" scope="instance" type="Object"/>
      <property name="_contentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._LayoutWidget.domNode.style">
    <properties>
      <property name="top" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dijit.layout._TabContainerBase" superclass="dijit.layout.StackContainer">
    <description>A TabContainer is a container that has multiple panes, but shows only
	one pane at a time.  There are a set of tabs corresponding to each pane,
	where each tab has the name (aka title) of the pane, and optionally a close button.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="tab" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="tabPosition" scope="instance" type="String">
        <description>Defines where tabs go relative to tab content.
	&amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;, &amp;quot;left-h&amp;quot;, &amp;quot;right-h&amp;quot;</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="tabStrip" scope="instance" type="Boolean">
        <description>Defines whether the tablist gets an extra class for layouting, putting a border/shading
	around the set of tabs.   Not supported by claro theme.</description>
      </property>
      <property name="nested" scope="instance" type="Boolean">
        <description>If true, use styling for a TabContainer nested inside another TabContainer.
	For tundra etc., makes tabs look like links, and hides the outer
	border since the outer TabContainer already has a border.</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="selectedChildWidget" scope="instance" type="Object"/>
      <property name="_containerContentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._TabContainerBase.tablist">
    <properties>
      <property name="layoutAlign" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.layout._TabContainerBase.tablist.domNode"/>
  <class type="dijit.layout._TabContainerBase.tablist.domNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="doh.robot">
    <methods>
      <method name="_updateDocument" scope="instance"/>
      <method name="_resolveNode" scope="instance">
        <parameters>
          <parameter name="n" type="String|DOMNode|Function" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollIntoView" scope="instance">
        <parameters>
          <parameter name="n" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_position" scope="instance">
        <parameters>
          <parameter name="n" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_getWindowChain" scope="instance">
        <parameters>
          <parameter name="n" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="node" type="String|DOMNode|Function" usage="required">
            <description>The id of the node, or the node itself, to move the mouse to.
	If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
	This is useful if you need to move the mouse to an node that is not yet present.</description>
          </parameter>
          <parameter name="delay" type="Number" usage="required">
            <description>Delay, in milliseconds, to wait before firing.
	The delay is a delta with respect to the previous automation call.</description>
          </parameter>
        </parameters>
      </method>
      <method name="mouseMoveAt" scope="instance">
        <description>Moves the mouse over the specified node at the specified relative x,y offset.
	If you do not specify an offset, mouseMove will default to move to the middle of the node.
	Example: to move the mouse over a ComboBox's down arrow node, call doh.mouseMoveAt(dijit.byId('setvaluetest').downArrowNode);</description>
        <parameters>
          <parameter name="node" type="String|DOMNode|Function" usage="required">
            <description>The id of the node, or the node itself, to move the mouse to.
	If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
	This is useful if you need to move the mouse to an node that is not yet present.</description>
          </parameter>
          <parameter name="delay" type="Integer" usage="required">
            <description>Delay, in milliseconds, to wait before firing.
	The delay is a delta with respect to the previous automation call.
	For example, the following code ends after 600ms:
	doh.robot.mouseClick({left:true}, 100) // first call; wait 100ms
	doh.robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all</description>
          </parameter>
          <parameter name="duration" type="Integer" usage="required">
            <description>Approximate time Robot will spend moving the mouse
	The default is 100ms.</description>
          </parameter>
          <parameter name="offsetX" type="Number" usage="required">
            <description>x offset relative to the node, in pixels, to move the mouse. The default is half the node's width.</description>
          </parameter>
          <parameter name="offsetY" type="Number" usage="required">
            <description>y offset relative to the node, in pixels, to move the mouse. The default is half the node's height.</description>
          </parameter>
        </parameters>
      </method>
      <method name="initRobot" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>URL to open. Any of the test's dojo.doc calls (e.g. dojo.byId()), and any dijit.registry calls (e.g. dijit.byId()) will point to elements and widgets inside this application.</description>
          </parameter>
        </parameters>
      </method>
      <method name="waitForPageToLoad" scope="instance">
        <description>Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
	returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.
	Example:
	runTest:function(){
	return waitForPageLoad(function(){ doh.robot.keyPress(dojo.keys.ENTER, 500); });
	}</description>
        <parameters>
          <parameter name="submitActions" type="Function" usage="required">
            <description>The doh.robot will execute the actions the test passes into the submitActions argument (like clicking the submit button),
	expecting these actions to create a page change (like a form submit).
	After these actions execute and the resulting page loads, the next test will start.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_run" scope="instance">
        <parameters>
          <parameter name="frame" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="options">
    <properties>
      <property name="compress" scope="instance" type="bool"/>
      <property name="optimization" scope="instance" type="Number"/>
      <property name="silent" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.tree">
    <methods>
      <method name="_compareNodes" scope="instance">
        <parameters>
          <parameter name="n1" type="Object" usage="required"/>
          <parameter name="n2" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dijit.tree.ForestStoreModel" superclass="dijit.tree.TreeStoreModel">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="callback" type="Function(items))" usage="required"/>
          <parameter name="onError" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
          <parameter name="parent" type="Item" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="onNewRootItem" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pasteItem" scope="instance">
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="onAddToRoot" scope="instance">
        <examples>
          <example>	store.setValue(item, "root", true);</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="onLeaveRoot" scope="instance">
        <examples>
          <example>	store.unsetAttribute(item, "root");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_requeryTop" scope="instance"/>
      <method name="onNewItem" scope="instance">
        <description>Note that the default implementation requeries the top level items every time
	a new item is created, since any new item could be a top level item (even in
	addition to being a child of another item, since items can have multiple parents).
	If developers can detect which items are possible top level items (based on the item and the
	parentInfo parameters), they should override this method to only call _requeryTop() for top
	level items.  Often all top level items have parentInfo==null, but
	that will depend on which store you use and what your data is like.</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetItem" scope="instance">
        <description>Handles updates to an item's children by calling onChildrenChange(), and
	other updates to an item by calling onChange().
	Also, any change to any item re-executes the query for the tree's top-level items,
	since this modified item may have started/stopped matching the query for top level items.
	If possible, developers should override this function to only call _requeryTop() when
	the change to the item has caused it to stop/start being a top level item in the tree.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.tree.TreeStoreModel" scope="instance"/>
    </mixins>
    <properties>
      <property name="rootId" scope="instance" type="String">
        <description>ID of fabricated root item</description>
      </property>
      <property name="rootLabel" scope="instance" type="String">
        <description>Label of fabricated root item</description>
      </property>
      <property name="query" scope="instance" type="String">
        <description>Specifies the set of children of the root item.</description>
      </property>
    </properties>
  </class>
  <class type="dijit.tree.ForestStoreModel.root">
    <properties>
      <property name="children" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.tree.TreeStoreModel">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="getRoot" scope="instance">
        <parameters>
          <parameter name="onItem" type="Object" usage="required"/>
          <parameter name="onError" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="Function(items))" usage="required"/>
          <parameter name="onError" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="newItem" scope="instance">
        <description>Developers will need to override this method if new items get added
	to parents with multiple children attributes, in order to define which
	children attribute points to the new item.</description>
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
          <parameter name="parent" type="Item" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="pasteItem" scope="instance">
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="onChildrenChange" scope="instance">
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="Array&lt;dojo.data.Item&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <description>Note that there will also be an onChildrenChange() callback for the parent
	of this item.</description>
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="Array&lt;dojo.data.Item&gt;" usage="required"/>
        </parameters>
      </method>
      <method name="onNewItem" scope="instance">
        <description>If the new item is a child of an existing item,
	calls onChildrenChange() with the new list of children
	for that existing item.</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetItem" scope="instance">
        <description>Handles updates to an item's children by calling onChildrenChange(), and
	other updates to an item by calling onChange().
	See `onNewItem` for more details on handling updates to an item's children.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="store" scope="instance-prototype" type="dojo.data.Store">
        <description>Underlying store</description>
      </property>
      <property name="childrenAttrs" scope="instance" type="Array&lt;String&gt;">
        <description>One or more attribute names (attributes in the dojo.data item) that specify that item's children</description>
      </property>
      <property name="newItemIdAttr" scope="instance" type="String">
        <description>Name of attribute in the Object passed to newItem() that specifies the id.
	If newItemIdAttr is set then it's used when newItem() is called to see if an
	item with the same id already exists, and if so just links to the old item
	(so that the old item ends up with two parents).
	Setting this to null or &amp;quot;&amp;quot; will make every drop create a new item.</description>
      </property>
      <property name="labelAttr" scope="instance" type="String">
        <description>If specified, get label for tree node from this attribute, rather
	than by calling store.getLabel()</description>
      </property>
      <property name="root" scope="instance" type="dojo.data.Item">
        <description>Pointer to the root item (read only, not a parameter)</description>
      </property>
      <property name="query" scope="instance" type="anything">
        <description>Specifies datastore query to return the root item for the tree.
	Must only return a single item.   Alternately can just pass in pointer
	to root item.</description>
      </property>
      <property name="deferItemLoadingUntilExpand" scope="instance" type="Boolean">
        <description>Setting this to true will cause the TreeStoreModel to defer calling loadItem on nodes
	until they are expanded. This allows for lazying loading where only one
	loadItem (and generally one network call, consequently) per expansion
	(rather than one for each child).
	This relies on partial loading of the children items; each children item of a
	fully loaded item should contain the label and info about having children.</description>
      </property>
      <property name="connects" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.tree._dndContainer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="tree" type="Node" usage="required">
            <description>Node or node's id to build the container on</description>
          </parameter>
          <parameter name="params" type="dijit.tree.__SourceArgs" usage="required">
            <description>A dict of parameters, which gets mixed into the object</description>
          </parameter>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.dnd.Item"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="widget" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="widget" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_changeState" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>A name of the state to change</description>
          </parameter>
          <parameter name="newState" type="String" usage="required">
            <description>new state</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addItemClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A node</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>A variable suffix for a class name</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeItemClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A node</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>A variable suffix for a class name</description>
          </parameter>
        </parameters>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
    </methods>
    <properties>
      <property name="current" scope="instance-prototype" type="DomNode">
        <description>The currently hovered TreeNode.rowNode (which is the DOM node
	associated w/a given node in the tree, excluding it's descendants)</description>
      </property>
      <property name="node" scope="instance-prototype" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
      <property name="tree" scope="instance" type="Node">
        <description>Node or node's id to build the container on
	params: dijit.tree.__SourceArgs
	A dict of parameters, which gets mixed into the object</description>
      </property>
      <property name="map" scope="instance" type="Object"/>
      <property name="containerState" scope="instance" type="String"/>
      <property name="events" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.tree._dndSelector" superclass="dijit.tree._dndContainer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="tree" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelectedTreeNodes" scope="instance"/>
      <method name="selectNone" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="addTreeNode" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._TreeNode" usage="required">
            <description>Node node to add</description>
          </parameter>
          <parameter name="isAnchor" type="Boolean" usage="optional">
            <description>Whether the node should become anchor.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeTreeNode" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._TreeNode" usage="required">
            <description>Node node to remove</description>
          </parameter>
        </parameters>
      </method>
      <method name="isTreeNodeSelected" scope="instance">
        <parameters>
          <parameter name="node" type="dijit._TreeNode" usage="required">
            <description>Node the node to check whether it's in the current selection</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSelection" scope="instance">
        <parameters>
          <parameter name="newSelection" type="Array&lt;dijit._treeNode&gt;" usage="required">
            <description>Node[] list of tree nodes to make selected</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setDifference" scope="instance">
        <parameters>
          <parameter name="xs" type="Object" usage="required"/>
          <parameter name="ys" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSelectionProperties" scope="instance"/>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="ignore right-click"/>
        </return-types>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="userSelect" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="multi" type="Boolean" usage="required">
            <description>Indicates whether this is meant to be a multi-select action (e.g. ctrl-click)</description>
          </parameter>
          <parameter name="range" type="Boolean" usage="required">
            <description>Indicates whether this is meant to be a ranged action (e.g. shift-click)</description>
          </parameter>
        </parameters>
      </method>
      <method name="forInSelectedItems" scope="instance">
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.tree._dndContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="selection" scope="instance-prototype" type="Object">
        <description>DomNode&amp;gt;
	(id, DomNode) map for every TreeNode that's currently selected.
	The DOMNode is the TreeNode.rowNode.</description>
      </property>
      <property name="singular" scope="instance" type="Boolean">
        <description>Allows selection of only one element, if true.
	Tree hasn't been tested in singular=true mode, unclear if it works.</description>
      </property>
      <property name="anchor" scope="instance-prototype" type="Object"/>
      <property name="_doDeselect" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dijit.tree._dndSelector.current">
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.tree.dndSource" superclass="dijit.tree._dndSelector">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="tree" type="dijit.Tree" usage="required"/>
          <parameter name="params" type="dijit.tree.__SourceArgs" usage="required"/>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="dijit.tree.dndSource" usage="required">
            <description>The source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array&lt;DOMNode&gt;" usage="required">
            <description>Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
	source is a dijit.Tree.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="copyState" scope="instance">
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required">
            <description>The &amp;quot;copy&amp;quot; control key was pressed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_onDragMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmousemouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmousedown event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmouseup event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance"/>
      <method name="checkItemAcceptance" scope="instance">
        <description>In the base case, this is called to check if target can become a child of source.
	When betweenThreshold is set, position="before" or "after" means that we
	are asking if the source node can be dropped before/after the target node.</description>
        <parameters>
          <parameter name="target" type="DOMNode" usage="required">
            <description>The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
	Use dijit.getEnclosingWidget(target) to get the TreeNode.</description>
          </parameter>
          <parameter name="source" type="dijit.tree.dndSource" usage="required">
            <description>The (set of) nodes we are dropping</description>
          </parameter>
          <parameter name="position" type="String" usage="required">
            <description>&amp;quot;over&amp;quot;, &amp;quot;before&amp;quot;, or &amp;quot;after&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndSourceOver" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>The dijit.tree.dndSource / dojo.dnd.Source which has the mouse over it</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndStart" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>The dijit.tree.dndSource / dojo.dnd.Source which is providing the items</description>
          </parameter>
          <parameter name="nodes" type="Array&lt;DomNode&gt;" usage="required">
            <description>The list of transferred items, dndTreeNode nodes if dragging from a Tree</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>Copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="itemCreator" scope="instance">
        <description>For each node in nodes[], which came from source, create a hash of name/value
	pairs to be passed to Tree.model.newItem().  Returns array of those hashes.</description>
        <parameters>
          <parameter name="nodes" type="Array&lt;DomNode&gt;" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="source" type="dojo.dnd.Source" usage="required"/>
        </parameters>
        <return-description>Object[]
	Array of name/value hashes for each new item to be added to the Tree, like:
		[
			{ id: 123, label: "apple", foo: "bar" },
			{ id: 456, label: "pear", zaz: "bam" }
		]</return-description>
      </method>
      <method name="onDndDrop" scope="instance">
        <description>Updates data store items according to where node was dragged from and dropped
	to.   The tree will then respond to those data store updates and redraw itself.</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>The dijit.tree.dndSource / dojo.dnd.Source which is providing the items</description>
          </parameter>
          <parameter name="nodes" type="Array&lt;DomNode&gt;" usage="required">
            <description>The list of transferred items, dndTreeNode nodes if dragging from a Tree</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>Copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="_isParentChildDrop" scope="instance">
        <parameters>
          <parameter name="source" type="The" usage="required">
            <description>DragSource object.</description>
          </parameter>
          <parameter name="targetRow" type="The" usage="required">
            <description>tree row onto which the dragged nodes are being dropped.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="instance"/>
      <method name="_markDndStatus" scope="instance">
        <parameters>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.tree._dndSelector" scope="instance"/>
    </mixins>
    <properties>
      <property name="isSource" scope="instance-prototype" type="Boolean">
        <description>Can be used as a DnD source.</description>
      </property>
      <property name="accept" scope="instance-prototype" type="Array&lt;String&gt;">
        <description>List of accepted types (text strings) for the Tree; defaults to
	[&amp;quot;text&amp;quot;]</description>
      </property>
      <property name="copyOnly" scope="instance" type="Boolean">
        <description>Copy items, if true, use a state of Ctrl key otherwise</description>
      </property>
      <property name="dragThreshold" scope="instance" type="Number">
        <description>The move delay in pixels before detecting a drag; 5 by default</description>
      </property>
      <property name="betweenThreshold" scope="instance" type="Integer">
        <description>Distance from upper/lower edge of node to allow drop to reorder nodes</description>
      </property>
      <property name="targetAnchor" scope="instance-prototype" type="Object"/>
      <property name="current" scope="instance" type="Object"/>
      <property name="dropPosition" scope="instance-prototype" type="String"/>
      <property name="targetBox" scope="instance-prototype" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="mouseDown" scope="instance-prototype" type="bool"/>
      <property name="mouseButton" scope="instance" type="Object"/>
      <property name="_lastX" scope="instance-prototype" type="Number"/>
      <property name="_lastY" scope="instance-prototype" type="Number"/>
      <property name="isDragging" scope="instance-prototype" type="bool"/>
      <property name="sourceState" scope="instance" type="String"/>
      <property name="targetState" scope="instance" type="String"/>
      <property name="topics" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dijit.tree.dndSource.tree">
    <properties>
      <property name="model" scope="instance" type="Object"/>
      <property name="item" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.tree.__SourceArgs">
    <methods/>
    <properties>
      <property name="isSource" scope="instance" type="Boolean">
        <description>Can be used as a DnD source. Defaults to true.</description>
      </property>
      <property name="accept" scope="instance" type="Array&lt;String&gt;">
        <description>List of accepted types (text strings) for a target; defaults to
	[&amp;quot;text&amp;quot;, &amp;quot;treeNode&amp;quot;]</description>
      </property>
      <property name="autoSync" scope="instance" type="Object"/>
      <property name="copyOnly" scope="instance" type="Boolean">
        <description>Copy items, if true, use a state of Ctrl key otherwise,</description>
      </property>
      <property name="dragThreshold" scope="instance" type="Number">
        <description>The move delay in pixels before detecting a drag; 0 by default</description>
      </property>
      <property name="betweenThreshold" scope="instance" type="Integer">
        <description>Distance from upper/lower edge of node to allow drop to reorder nodes</description>
      </property>
    </properties>
  </class>
  <class type="dijit.tree.model">
    <description>Tree passes in values to the constructor to specify the callbacks.
	"item" is typically a dojo.data.Item but it's just a black box so
	it could be anything.
	This (like `dojo.data.api.Read`) is just documentation, and not meant to be used.</description>
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="getRoot" scope="instance">
        <parameters>
          <parameter name="onItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="Function(items))" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
          <parameter name="parent" type="Item" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="pasteItem" scope="instance">
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="onChildrenChange" scope="instance">
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="Array&lt;dojo.data.Item&gt;" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.AdapterRegistry">
    <description>Objects of this class keep list of arrays in the form [name, check,
	wrap, directReturn] that are used to determine what the contextual
	result of a set of checked arguments is. All check/wrap functions
	in this registry should be of the same arity.</description>
    <methods>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>a way to identify this matcher.</description>
          </parameter>
          <parameter name="check" type="Function" usage="required">
            <description>a function that arguments are passed to from the adapter's
	match() function.  The check function should return true if the
	given arguments are appropriate for the wrap function.</description>
          </parameter>
          <parameter name="wrap" type="Function" usage="required"/>
          <parameter name="directReturn" type="Boolean" usage="optional">
            <description>If directReturn is true, the value passed in for wrap will be
	returned instead of being called. Alternately, the
	AdapterRegistry can be set globally to &amp;quot;return not call&amp;quot; using
	the returnWrappers property. Either way, this behavior allows
	the registry to act as a &amp;quot;search&amp;quot; function instead of a
	function interception library.</description>
          </parameter>
          <parameter name="override" type="Boolean" usage="optional">
            <description>If override is given and true, the check function will be given
	highest priority. Otherwise, it will be the lowest priority
	adapter.</description>
          </parameter>
        </parameters>
      </method>
      <method name="match" scope="instance"/>
      <method name="unregister" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="pairs" scope="instance" type="Array"/>
      <property name="returnWrappers" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.DeferredList">
    <description>DeferredList takes an array of existing deferreds and returns a new deferred of its own
	this new deferred will typically have its callback fired when all of the deferreds in
	the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	fireOnOneErrback, will fire before all the deferreds as appropriate</description>
    <methods>
      <method name="gatherResults" scope="instance">
        <parameters>
          <parameter name="deferredList" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.NodeList">
    <description>dojo.NodeList instances provide many utilities that reflect
	core Dojo APIs for Array iteration and manipulation, DOM
	manipulation, and event handling. Instead of needing to dig up
	functions in the dojo.* namespace, NodeLists generally make the
	full power of Dojo available for DOM manipulation tasks in a
	simple, chainable way.</description>
    <methods>
      <method name="data" scope="instance">
        <description>Stash or get some arbirtrary data on/from these nodes. This private _data function is
	exposed publicly on `dojo.NodeList`, eg: as the result of a `dojo.query` call.
	DIFFERS from jQuery.data in that when used as a getter, the entire list is ALWAYS
	returned. EVEN WHEN THE LIST IS length == 1.
	A single-node version of this function is provided as `dojo._nodeData`, which follows
	the same signature, though expects a String ID or DomNode reference in the first
	position, before key/value arguments.
	node: String|DomNode
	The node to associate data with</description>
        <examples>
          <example>Set a key `bar` to some data, then retrieve it.
		dojo.query(".foo").data("bar", "touched");
		var touched = dojo.query(".foo").data("bar");
		if(touched[0] == "touched"){ alert('win'); }</example>
          <example>Get all the data items for a given node.
		var list = dojo.query(".foo").data();
		var first = list[0];</example>
          <example>Set the data to a complex hash. Overwrites existing keys with new value
		dojo.query(".foo").data({ bar:"baz", foo:"bar" });
	Then get some random key:
		dojo.query(".foo").data("foo"); // returns [`bar`]</example>
        </examples>
        <parameters>
          <parameter name="key" type="Object|String" usage="optional">
            <description>If an object, act as a setter and iterate over said object setting data items as defined.
	If a string, and &lt;code&gt;value&lt;/code&gt; present, set the data for defined &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;
	If a string, and &lt;code&gt;value&lt;/code&gt; absent, act as a getter, returning the data associated with said &lt;code&gt;key&lt;/code&gt;</description>
          </parameter>
          <parameter name="value" type="Anything" usage="optional">
            <description>The value to set for said &lt;code&gt;key&lt;/code&gt;, provided &lt;code&gt;key&lt;/code&gt; is a string (and not an object)</description>
          </parameter>
        </parameters>
        <return-description>Object|Anything|Nothing
	When used as a setter via `dojo.NodeList`, a NodeList instance is returned
	for further chaning. When used as a getter via `dojo.NodeList` an ARRAY
	of items is returned. The items in the array correspond to the elements
	in the original list. This is true even when the list length is 1, eg:
	when looking up a node by ID (#foo)</return-description>
      </method>
      <method name="removeData" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="optional">
            <description>If ommitted, clean all data for this node.
	If passed, remove the data item found at &lt;code&gt;key&lt;/code&gt;</description>
          </parameter>
        </parameters>
      </method>
      <method name="_anim" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wipeIn" scope="instance">
        <examples>
          <example>Fade in all tables with class "blah":
		dojo.query("table.blah").wipeIn().play();</example>
          <example>Utilizing `auto` to get the NodeList back:
		dojo.query(".titles").wipeIn({ auto:true }).onclick(someFunction);</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional dojo.Animation arguments to mix into this set with the addition of
	an &lt;code&gt;auto&lt;/code&gt; parameter.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wipeOut" scope="instance">
        <examples>
          <example>Wipe out all tables with class "blah":
		dojo.query("table.blah").wipeOut().play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional dojo.Animation arguments to mix into this set with the addition of
	an &lt;code&gt;auto&lt;/code&gt; parameter.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="slideTo" scope="instance">
        <examples>
          <example>	Move all tables with class "blah" to 300/300:
		dojo.query("table.blah").slideTo({
			left: 40,
			top: 50
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional dojo.Animation arguments to mix into this set with the addition of
	an &lt;code&gt;auto&lt;/code&gt; parameter.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="fadeIn" scope="instance">
        <examples>
          <example>Fade in all tables with class "blah":
		dojo.query("table.blah").fadeIn().play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional dojo.Animation arguments to mix into this set with the addition of
	an &lt;code&gt;auto&lt;/code&gt; parameter.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="fadeOut" scope="instance">
        <examples>
          <example>Fade out all elements with class "zork":
		dojo.query(".zork").fadeOut().play();</example>
          <example>Fade them on a delay and do something at the end:
		var fo = dojo.query(".zork").fadeOut();
		dojo.connect(fo, "onEnd", function(){ /*...*/ });
		fo.play();</example>
          <example>Using `auto`:
		dojo.query("li").fadeOut({ auto:true }).filter(filterFn).forEach(doit);</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional dojo.Animation arguments to mix into this set with the addition of
	an &lt;code&gt;auto&lt;/code&gt; parameter.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="animateProperty" scope="instance">
        <examples>
          <example>	dojo.query(".zork").animateProperty({
			duration: 500,
			properties: {
				color:		{ start: "black", end: "white" },
				left:		{ end: 300 }
			}
		}).play();</example>
          <example>	dojo.query(".grue").animateProperty({
			auto:true,
			properties: {
				height:240
			}
		}).onclick(handler);</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-description>dojo.Animation|dojo.NodeList
	A special args member `auto` can be passed to automatically play the animation.
	If args.auto is present, the original dojo.NodeList will be returned for further
	chaining. Otherwise the dojo.Animation instance is returned and must be .play()'ed</return-description>
        <return-types>
          <return-type type="dojo.Animation"/>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="anim" scope="instance">
        <examples>
          <example>Another way to fade out:
		dojo.query(".thinger").anim({ opacity: 0 });</example>
          <example>animate all elements with the "thigner" class to a width of 500
	pixels over half a second
		dojo.query(".thinger").anim({ width: 500 }, 700);</example>
        </examples>
        <parameters>
          <parameter name="properties" type="Object" usage="required">
            <description>the properties to animate. does NOT support the &lt;code&gt;auto&lt;/code&gt; parameter like other
	NodeList-fx methods.</description>
          </parameter>
          <parameter name="duration" type="Integer" usage="optional">
            <description>Optional. The time to run the animations for</description>
          </parameter>
          <parameter name="easing" type="Function" usage="optional">
            <description>Optional. The easing function to use.</description>
          </parameter>
          <parameter name="onEnd" type="Function" usage="optional">
            <description>A function to be called when the animation ends</description>
          </parameter>
          <parameter name="delay" type="Integer" usage="optional">
            <description>how long to delay playing the returned animation</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="html" scope="instance">
        <description>An alias for the "innerHTML" method, but only defined if there is not an existing
	"html" method on dojo.NodeList. Be careful if you are working in an environment
	where it is possible that dojo.NodeList-html could have been loaded, since its
	definition of "html" will take precedence. If you are not sure if dojo.NodeList-html
	could be loaded, use the "innerHTML" method.</description>
        <examples>
          <example> dojo.query(".thingList").html("&lt;li dojoType='dojo.dnd.Moveable'&gt;1&lt;/li&gt;&lt;li dojoType='dojo.dnd.Moveable'&gt;2&lt;/li&gt;&lt;li dojoType='dojo.dnd.Moveable'&gt;3&lt;/li&gt;",
	 {
	 	parseContent: true,
	 	onBegin: function(){
	 		this.content = this.content.replace(/([0-9])/g, this.id + ": $1");
	 		this.inherited("onBegin", arguments);
	 	}
	 }).removeClass("notdone").addClass("done");</example>
        </examples>
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="optional"/>
        </parameters>
        <return-description>if no value is passed, the result is String, the innerHTML of the first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="innerHTML" scope="instance">
        <description>This method is simpler than the dojo.NodeList.html() method provided by
	`dojo.NodeList-html`. This method just does proper innerHTML insertion of HTML fragments,
	and it allows for the innerHTML to be read for the first node in the node list.
	Since dojo.NodeList-html already took the "html" name, this method is called
	"innerHTML". However, if dojo.NodeList-html has not been loaded yet, this
	module will define an "html" method that can be used instead. Be careful if you
	are working in an environment where it is possible that dojo.NodeList-html could
	have been loaded, since its definition of "html" will take precedence.
	The nodes represented by the value argument will be cloned if more than one
	node is in this NodeList. The nodes in this NodeList are returned in the "set"
	usage of this method, not the HTML that was inserted.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;/div&gt;
	This code inserts &lt;p&gt;Hello World&lt;/p&gt; into both divs:
		dojo.query("div").innerHTML("&lt;p&gt;Hello World&lt;/p&gt;");</example>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	This code returns "&lt;p&gt;Hello Mars&lt;/p&gt;":
		var message = dojo.query("div").innerHTML();</example>
        </examples>
        <parameters>
          <parameter name="value" type="String|DOMNode|NodeList" usage="optional"/>
        </parameters>
        <return-description>if no value is passed, the result is String, the innerHTML of the first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="text" scope="instance">
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;/div&gt;
	This code inserts "Hello World" into both divs:
		dojo.query("div").text("Hello World");</example>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars &lt;span&gt;today&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	This code returns "Hello Mars today":
		var message = dojo.query("div").text();</example>
        </examples>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-description>if no value is passed, the result is String, the text value of the first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="append" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").append("&lt;span&gt;append&lt;/span&gt;");
	Results in this DOM structure:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;span&gt;append&lt;/span&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;span&gt;append&lt;/span&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="content" type="String|DOMNode|NodeList" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="appendTo" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;span&gt;append&lt;/span&gt;
		&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;Hello World&lt;/p&gt;
	Running this code:
		dojo.query("span").appendTo("p");
	Results in this DOM structure:
		&lt;p&gt;Hello Mars&lt;span&gt;append&lt;/span&gt;&lt;/p&gt;
		&lt;p&gt;Hello World&lt;span&gt;append&lt;/span&gt;&lt;/p&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="prepend" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <parameters>
          <parameter name="content" type="String|DOMNode|NodeList" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.
	assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").prepend("&lt;span&gt;prepend&lt;/span&gt;");
	Results in this DOM structure:
		&lt;div id="foo"&gt;&lt;span&gt;prepend&lt;/span&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;span&gt;prepend&lt;/span&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="prependTo" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;span&gt;prepend&lt;/span&gt;
		&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;Hello World&lt;/p&gt;
	Running this code:
		dojo.query("span").prependTo("p");
	Results in this DOM structure:
		&lt;p&gt;&lt;span&gt;prepend&lt;/span&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;&lt;span&gt;prepend&lt;/span&gt;Hello World&lt;/p&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="after" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").after("&lt;span&gt;after&lt;/span&gt;");
	Results in this DOM structure:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;&lt;span&gt;after&lt;/span&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;&lt;span&gt;after&lt;/span&gt;</example>
        </examples>
        <parameters>
          <parameter name="content" type="String|Element|NodeList" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="insertAfter" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;span&gt;after&lt;/span&gt;
		&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;Hello World&lt;/p&gt;
	Running this code:
		dojo.query("span").insertAfter("p");
	Results in this DOM structure:
		&lt;p&gt;Hello Mars&lt;/p&gt;&lt;span&gt;after&lt;/span&gt;
		&lt;p&gt;Hello World&lt;/p&gt;&lt;span&gt;after&lt;/span&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="before" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").before("&lt;span&gt;before&lt;/span&gt;");
	Results in this DOM structure:
		&lt;span&gt;before&lt;/span&gt;&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;span&gt;before&lt;/span&gt;&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="content" type="String|DOMNode|NodeList" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="insertBefore" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;span&gt;before&lt;/span&gt;
		&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;Hello World&lt;/p&gt;
	Running this code:
		dojo.query("span").insertBefore("p");
	Results in this DOM structure:
		&lt;span&gt;before&lt;/span&gt;&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;span&gt;before&lt;/span&gt;&lt;p&gt;Hello World&lt;/p&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="simpleFilter" type="String" usage="required">
            <description>single-expression CSS rule. For example, &amp;quot;.thinger&amp;quot; or
	&amp;quot;#someId[attrName='value']&amp;quot; but not &amp;quot;div &amp;gt; span&amp;quot;. In short,
	anything which does not invoke a descent to evaluate but
	can instead be used to test a single node is acceptable.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wrap" scope="instance">
        <description>html will be cloned if the NodeList has more than one
	element. Only DOM nodes are cloned, not any attached
	event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;b&gt;one&lt;/b&gt;
		&lt;b&gt;two&lt;/b&gt;
	Running this code:
		dojo.query("b").wrap("&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;");
	Results in this DOM structure:
		&lt;div&gt;&lt;span&gt;&lt;b&gt;one&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;
		&lt;div&gt;&lt;span&gt;&lt;b&gt;two&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="html" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes in the current NodeList will be returned,
	not the nodes from html argument.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wrapAll" scope="instance">
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").wrapAll('&lt;div class="allRed"&gt;&lt;/div&gt;');
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="allRed"&gt;
				&lt;div class="red"&gt;Red One&lt;/div&gt;
				&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="html" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes in the current NodeList will be returned,
	not the nodes from html argument.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wrapInner" scope="instance">
        <description>html will be cloned if the NodeList has more than one
	element. Only DOM nodes are cloned, not any attached
	event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").wrapInner('&lt;span class="special"&gt;&lt;/span&gt;');
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;&lt;span class="special"&gt;Red One&lt;/span&gt;&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;&lt;span class="special"&gt;Red Two&lt;/span&gt;&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="html" type="String|DOMNode" usage="required"/>
        </parameters>
        <return-description>dojo.NodeList, the nodes in the current NodeList will be returned,
	not the nodes from html argument.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="replaceWith" scope="instance">
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").replaceWith('&lt;div class="green"&gt;Green&lt;/div&gt;');
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="green"&gt;Green&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="green"&gt;Green&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="content" type="String|DOMNode|NodeList" usage="required"/>
        </parameters>
        <return-description>The nodes currently in this NodeList will be returned, not the replacing content.
	Note that the returned nodes have been removed from the DOM.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="replaceAll" scope="instance">
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").replaceAll(".blue");
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-description>The nodes currently in this NodeList will be returned, not the matched nodes
	from the query. The nodes currently in this NodeLIst could have
	been cloned, so the returned NodeList will include the cloned nodes.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <description>Only the DOM nodes are cloned, not any attached event handlers.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").clone().appendTo(".container");
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <return-description>dojo.NodeList, a cloned set of the original nodes.</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_buildArrayFromCallback" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_getUniqueAsNodeList" scope="instance">
        <parameters>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_getUniqueNodeListWithParent" scope="instance">
        <parameters>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_getRelatedUniqueNodes" scope="instance">
        <parameters>
          <parameter name="query" type="String" usage="optional"/>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="children" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".container").children();
	returns the four divs that are children of the container div.
	Running this code:
		dojo.query(".container").children(".red");
	returns the two divs that have the class "red".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, all immediate child elements for the nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="closest" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").closest(".container");
	returns the div with class "container".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required">
            <description>a CSS selector.</description>
          </parameter>
          <parameter name="root" type="String|DOMNode" usage="optional">
            <description>If specified, query is relative to &amp;quot;root&amp;quot; rather than document body.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, the closest parent that matches the query, including the current
	node in this dojo.NodeList if it matches the query.</return-description>
        <return-types>
          <return-type type="To make rhino strict checking happy"/>
        </return-types>
      </method>
      <method name="parent" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue first"&gt;&lt;span class="text"&gt;Blue One&lt;/span&gt;&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;&lt;span class="text"&gt;Blue Two&lt;/span&gt;&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".text").parent();
	returns the two divs with class "blue".
	Running this code:
		dojo.query(".text").parent(".first");
	returns the one div with class "blue" and "first".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, immediate parent elements for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="parents" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue first"&gt;&lt;span class="text"&gt;Blue One&lt;/span&gt;&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;&lt;span class="text"&gt;Blue Two&lt;/span&gt;&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".text").parents();
	returns the two divs with class "blue", the div with class "container",
		the body element and the html element.
	Running this code:
		dojo.query(".text").parents(".container");
	returns the one div with class "container".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, all parent elements for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="siblings" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".first").siblings();
	returns the two divs with class "red" and the other div
		with class "blue" that does not have "first".
	Running this code:
		dojo.query(".first").siblings(".red");
	returns the two div with class "red".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, all sibling elements for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="next" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue last"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".first").next();
	returns the div with class "red" and has innerHTML of "Red Two".
	Running this code:
		dojo.query(".last").next(".red");
	does not return any elements.</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, the next element for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="nextAll" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red next"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue next"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".first").nextAll();
	returns the two divs with class of "next".
	Running this code:
		dojo.query(".first").nextAll(".red");
	returns the one div with class "red" and innerHTML "Red Two".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, all sibling elements that come after the nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="prev" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".first").prev();
	returns the div with class "red" and has innerHTML of "Red One".
	Running this code:
		dojo.query(".first").prev(".blue");
	does not return any elements.</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, the previous element for nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="prevAll" scope="instance">
        <description>The returned nodes will be in reverse DOM order -- the first node in the list will
	be the node closest to the original node/NodeList.
	.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red prev"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue prev"&gt;Blue One&lt;/div&gt;
			&lt;div class="red second"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".second").prevAll();
	returns the two divs with class of "prev".
	Running this code:
		dojo.query(".first").prevAll(".red");
	returns the one div with class "red prev" and innerHTML "Red One".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <description>a CSS selector.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, all sibling elements that come before the nodes in this dojo.NodeList.</return-description>
      </method>
      <method name="andSelf" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red prev"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue prev"&gt;Blue One&lt;/div&gt;
			&lt;div class="red second"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".second").prevAll().andSelf();
	returns the two divs with class of "prev", as well as the div with class "second".</example>
        </examples>
        <return-description>dojo.NodeList</return-description>
      </method>
      <method name="first" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue last"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".blue").first();
	returns the div with class "blue" and "first".</example>
        </examples>
        <return-description>dojo.NodeList, with the first node in this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="last" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue last"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".blue").last();
	returns the last div with class "blue",</example>
        </examples>
        <return-description>dojo.NodeList, with the last node in this dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="even" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="interior red"&gt;Red One&lt;/div&gt;
			&lt;div class="interior blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="interior red"&gt;Red Two&lt;/div&gt;
			&lt;div class="interior blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".interior").even();
	returns the two divs with class "blue"</example>
        </examples>
        <return-description>dojo.NodeList, with the even nodes in this dojo.NodeList</return-description>
      </method>
      <method name="odd" scope="instance">
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="interior red"&gt;Red One&lt;/div&gt;
			&lt;div class="interior blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="interior red"&gt;Red Two&lt;/div&gt;
			&lt;div class="interior blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".interior").odd();
	returns the two divs with class "red"</example>
        </examples>
        <return-description>dojo.NodeList, with the odd nodes in this dojo.NodeList</return-description>
      </method>
      <method name="_normalize" scope="instance">
        <description>If content is an object, it can have special properties "template" and
	"parse". If "template" is defined, then the template value is run through
	dojo.string.substitute (if dojo.string.substitute has been dojo.required elsewhere),
	or if templateFunc is a function on the content, that function will be used to
	transform the template into a final string to be used for for passing to dojo._toDom.
	If content.parse is true, then it is remembered for later, for when the content
	nodes are inserted into the DOM. At that point, the nodes will be parsed for widgets
	(if dojo.parser has been dojo.required elsewhere).</description>
        <parameters>
          <parameter name="content" type="String|Element|Object|NodeList" usage="required"/>
          <parameter name="refNode" type="DOMNode" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_cloneNode" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_place" scope="instance">
        <description>Allows for cloning the nodes in the array, and for
	optionally parsing widgets, if ary._runParse is true.</description>
        <parameters>
          <parameter name="ary" type="Array" usage="required"/>
          <parameter name="refNode" type="DOMNode" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
          <parameter name="useClone" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="end" scope="instance">
        <description>Returns the `dojo.NodeList` that generated the current `dojo.NodeList`. If there
	is no parent dojo.NodeList, an empty dojo.NodeList is returned.</description>
        <examples>
          <example>	dojo.query("a")
			.filter(".disabled")
				// operate on the anchors that only have a disabled class
				.style("color", "grey")
			.end()
			// jump back to the list of anchors
			.style(...)</example>
        </examples>
      </method>
      <method name="slice" scope="instance">
        <description>This method behaves exactly like the Array.slice method
	with the caveat that it returns a dojo.NodeList and not a
	raw Array. For more details, see Mozilla's (slice
	documentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:slice]</description>
        <parameters>
          <parameter name="begin" type="Integer" usage="required">
            <description>Can be a positive or negative integer, with positive
	integers noting the offset to begin at, and negative
	integers denoting an offset from the end (i.e., to the left
	of the end)</description>
          </parameter>
          <parameter name="end" type="Integer" usage="optional">
            <description>Optional parameter to describe what position relative to
	the NodeList's zero index to end the slice at. Like begin,
	can be positive or negative.</description>
          </parameter>
        </parameters>
      </method>
      <method name="splice" scope="instance">
        <description>This method behaves exactly like the Array.splice method
	with the caveat that it returns a dojo.NodeList and not a
	raw Array. For more details, see Mozilla's (splice
	documentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:splice]
	For backwards compatibility, calling .end() on the spliced NodeList
	does not return the original NodeList -- splice alters the NodeList in place.</description>
        <parameters>
          <parameter name="index" type="Integer" usage="required">
            <description>begin can be a positive or negative integer, with positive
	integers noting the offset to begin at, and negative
	integers denoting an offset from the end (i.e., to the left
	of the end)</description>
          </parameter>
          <parameter name="howmany" type="Integer" usage="optional">
            <description>Optional parameter to describe what position relative to
	the NodeList's zero index to end the slice at. Like begin,
	can be positive or negative.</description>
          </parameter>
          <parameter name="item" type="Object" usage="optional">
            <description>Any number of optional parameters may be passed in to be
	spliced into the NodeList</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList</return-description>
      </method>
      <method name="indexOf" scope="instance">
        <description>For more details on the behavior of indexOf, see Mozilla's
	(indexOf
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:indexOf]</description>
        <parameters>
          <parameter name="value" type="Object" usage="required">
            <description>The value to search for.</description>
          </parameter>
          <parameter name="fromIndex" type="Integer" usage="optional">
            <description>The location to start searching from. Optional. Defaults to 0.</description>
          </parameter>
        </parameters>
        <return-description>Positive Integer or 0 for a match, -1 of not found.</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="lastIndexOf" scope="instance">
        <description>For more details on the behavior of lastIndexOf, see
	Mozilla's (lastIndexOf
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:lastIndexOf]</description>
        <parameters>
          <parameter name="value" type="Object" usage="required">
            <description>The value to search for.</description>
          </parameter>
          <parameter name="fromIndex" type="Integer" usage="optional">
            <description>The location to start searching from. Optional. Defaults to 0.</description>
          </parameter>
        </parameters>
        <return-description>Positive Integer or 0 for a match, -1 of not found.</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="every" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required">
            <description>the callback</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>the context</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required">
            <description>the callback</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>the context</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="concat" scope="instance">
        <description>This method behaves exactly like the Array.concat method
	with the caveat that it returns a `dojo.NodeList` and not a
	raw Array. For more details, see the (Array.concat
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:concat]</description>
        <parameters>
          <parameter name="item" type="Object" usage="optional">
            <description>Any number of optional parameters may be passed in to be
	spliced into the NodeList</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
          <parameter name="obj" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="thisObj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="coords" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="position" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="addClass" scope="instance">
        <parameters>
          <parameter name="className" type="String|Array" usage="required">
            <description>A String class name to add, or several space-separated class names,
	or an array of class names.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="removeClass" scope="instance">
        <parameters>
          <parameter name="className" type="String|Array" usage="optional">
            <description>An optional String class name to remove, or several space-separated
	class names, or an array of class names. If omitted, all class names
	will be deleted.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList, this list</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="toggleClass" scope="instance">
        <parameters>
          <parameter name="className" type="String" usage="required">
            <description>the CSS class to add</description>
          </parameter>
          <parameter name="condition" type="Boolean" usage="optional">
            <description>If passed, true means to add the class, false means to remove.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="connect" scope="instance">
        <examples>
          <example>add an onclick handler to every button on the page
		dojo.query("div:nth-child(odd)").connect("onclick", function(e){
			console.log("clicked!");
		});</example>
          <example>attach foo.bar() to every odd div's onmouseover
		dojo.query("div:nth-child(odd)").connect("onmouseover", foo, "bar");</example>
        </examples>
        <parameters>
          <parameter name="methodName" type="String" usage="required">
            <description>the name of the method to attach to. For DOM events, this should be
	the lower-case name of the event</description>
          </parameter>
          <parameter name="objOrFunc" type="Object|Function|String" usage="required">
            <description>if 2 arguments are passed (methodName, objOrFunc), objOrFunc should
	reference a function or be the name of the function in the global
	namespace to attach. If 3 arguments are provided
	(methodName, objOrFunc, funcName), objOrFunc must be the scope to
	locate the bound function in</description>
          </parameter>
          <parameter name="funcName" type="String" usage="optional">
            <description>optional. A string naming the function in objOrFunc to bind to the
	event. May also be a function reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="empty" scope="instance">
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="queryOrNode" type="String|Node" usage="required">
            <description>may be a string representing any valid CSS3 selector or a DOM node.
	In the selector case, only the first matching element will be used
	for relative positioning.</description>
          </parameter>
          <parameter name="position" type="String" usage="required">
            <description>can be one of:
		&amp;quot;last&amp;quot; (default)
		&amp;quot;first&amp;quot;
		&amp;quot;before&amp;quot;
		&amp;quot;after&amp;quot;
		&amp;quot;only&amp;quot;
		&amp;quot;replace&amp;quot;
	or an offset in the childNodes property</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="orphan" scope="instance">
        <parameters>
          <parameter name="filter" type="String" usage="optional">
            <description>CSS selector like &amp;quot;.foo&amp;quot; or &amp;quot;div &amp;gt; span&amp;quot;</description>
          </parameter>
        </parameters>
        <return-description>`dojo.NodeList` containing the orphaned elements</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="adopt" scope="instance">
        <parameters>
          <parameter name="queryOrListOrNode" type="String|Array|DomNode" usage="required">
            <description>a DOM node or a query string or a query result.
	Represents the nodes to be adopted relative to the
	first element of this NodeList.</description>
          </parameter>
          <parameter name="position" type="String" usage="optional">
            <description>can be one of:
		&amp;quot;last&amp;quot; (default)
		&amp;quot;first&amp;quot;
		&amp;quot;before&amp;quot;
		&amp;quot;after&amp;quot;
		&amp;quot;only&amp;quot;
		&amp;quot;replace&amp;quot;
	or an offset in the childNodes property</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="query" scope="instance">
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;
			&lt;p&gt;
				bacon is tasty, &lt;span&gt;dontcha think?&lt;/span&gt;
			&lt;/p&gt;
		&lt;/div&gt;
		&lt;div id="bar"&gt;
			&lt;p&gt;great comedians may not be funny &lt;span&gt;in person&lt;/span&gt;&lt;/p&gt;
		&lt;/div&gt;
	If we are presented with the following definition for a NodeList:
		var l = new dojo.NodeList(dojo.byId("foo"), dojo.byId("bar"));
	it's possible to find all span elements under paragraphs
	contained by these elements with this sub-query:
	 	var spans = l.query("p span");</example>
        </examples>
        <parameters>
          <parameter name="queryStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <examples>
          <example>"regular" JS filter syntax as exposed in dojo.filter:
		dojo.query("*").filter(function(item){
			// highlight every paragraph
			return (item.nodeName == "p");
		}).style("backgroundColor", "yellow");</example>
          <example>the same filtering using a CSS selector
		dojo.query("*").filter("p").styles("backgroundColor", "yellow");</example>
        </examples>
        <parameters>
          <parameter name="filter" type="String|Function" usage="required">
            <description>If a string, a CSS rule like &amp;quot;.thinger&amp;quot; or &amp;quot;div &amp;gt; span&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="instantiate" scope="instance">
        <examples>
          <example>Grabs all buttons in the page and converts them to diji.form.Buttons.
		var buttons = dojo.query("button").instantiate("dijit.form.Button", {showLabel: true});</example>
        </examples>
        <parameters>
          <parameter name="declaredClass" type="String|Object" usage="required"/>
          <parameter name="properties" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="at" scope="instance">
        <examples>
          <example>Shorten the list to the first, second, and third elements
		dojo.query("a").at(0, 1, 2).forEach(fn);</example>
          <example>Retrieve the first and last elements of a unordered list:
		dojo.query("ul &gt; li").at(0, -1).forEach(cb);</example>
          <example>Do something for the first element only, but end() out back to
	the original list and continue chaining:
		dojo.query("a").at(0).onclick(fn).end().forEach(function(n){
			console.log(n); // all anchors on the page.
		})</example>
        </examples>
        <parameters>
          <parameter name="index" type="Integer" usage="one-or-more">
            <description>One or more 0-based indices of items in the current
	NodeList. A negative index will start at the end of the
	list and go backwards.</description>
          </parameter>
        </parameters>
        <return-description>dojo.NodeList</return-description>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="delegate" scope="instance">
        <description>Sets up event handlers that can catch events on any subnodes matching a given selector,
	including nodes created after delegate() has been called.
	This allows an app to setup a single event handler on a high level node, rather than many
	event handlers on subnodes. For example, one onclick handler for a Tree widget, rather than separate
	handlers for each node in the tree.
	Since setting up many event handlers is expensive, this can increase performance.
	Note that delegate() will not work for events that don't bubble, like focus.
	onmouseenter/onmouseleave also don't currently work.</description>
        <examples>
          <example>	dojo.query("navbar").delegate("a", "onclick", function(evt){
				console.log("user clicked anchor ", this.node);
		});</example>
        </examples>
        <parameters>
          <parameter name="selector" type="String" usage="required">
            <description>CSS selector valid to &lt;code&gt;dojo.query&lt;/code&gt;, like &amp;quot;.foo&amp;quot; or &amp;quot;div &amp;gt; span&amp;quot;.  The
	selector is relative to the nodes in this NodeList, not the document root.
	For example myNodeList.delegate(&amp;quot;&amp;gt; a&amp;quot;, &amp;quot;onclick&amp;quot;, ...) will catch events on
	anchor nodes which are (immediate) children of the nodes in myNodeList.</description>
          </parameter>
          <parameter name="eventName" type="String" usage="required">
            <description>Standard event name used as an argument to &lt;code&gt;dojo.connect&lt;/code&gt;, like &amp;quot;onclick&amp;quot;.</description>
          </parameter>
          <parameter name="fn" type="Function" usage="required">
            <description>Callback function passed the event object, and where this == the node that matches the selector.
	That means that for example, after setting up a handler via
	dojo.query(&amp;quot;body&amp;quot;).delegate(&amp;quot;fieldset&amp;quot;, &amp;quot;onclick&amp;quot;, ...)
	clicking on a fieldset or *any nodes inside of a fieldset* will be reported
	as a click on the fieldset itself.</description>
          </parameter>
        </parameters>
      </method>
      <method name="dtl" scope="instance">
        <parameters>
          <parameter name="template" type="dojox.dtl.__StringArgs|String" usage="required">
            <description>The template string or location</description>
          </parameter>
          <parameter name="context" type="dojox.dtl.__ObjectArgs|Object" usage="required">
            <description>The context object or location</description>
          </parameter>
        </parameters>
      </method>
      <method name="addClassFx" scope="instance">
        <examples>
          <example>	// fade all elements with class "bar" to to 50% opacity
		dojo.query(".bar").addClassFx("bar").play();</example>
        </examples>
        <parameters>
          <parameter name="cssClass" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="removeClassFx" scope="instance">
        <examples>
          <example> dojo.query(".box").removeClassFx("bar").play();</example>
        </examples>
        <parameters>
          <parameter name="cssClass" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="toggleClassFx" scope="instance">
        <examples>
          <example> dojo.query(".box").toggleClass("bar").play();</example>
        </examples>
        <parameters>
          <parameter name="cssClass" type="Object" usage="required"/>
          <parameter name="force" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="sizeTo" scope="instance">
        <examples>
          <example>	// size all divs with class "blah"
		dojo.query("div.blah").sizeTo({
			width:50,
			height:50
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="slideBy" scope="instance">
        <examples>
          <example>	// slide all tables with class "blah" 10 px
		dojo.query("table.blah").slideBy({ top:10, left:10 }).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="highlight" scope="instance">
        <examples>
          <example>	// highlight all links with class "foo"
		dojo.query("a.foo").hightlight().play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeTo" scope="instance">
        <examples>
          <example>	// fade all elements with class "bar" to to 50% opacity
		dojo.query(".bar").fadeTo({ end: 0.5 }).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeTo" scope="instance">
        <examples>
          <example> dojo.query(".box").wipeTo({ width: 300px }).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_wrap" scope="instance" type="Object"/>
      <property name="_adaptAsMap" scope="instance" type="Object"/>
      <property name="_adaptAsForEach" scope="instance" type="Object"/>
      <property name="_adaptAsFilter" scope="instance" type="Object"/>
      <property name="_adaptWithCondition" scope="instance" type="Object"/>
      <property name="events" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo.NodeList._placeMultiple">
    <methods/>
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.NodeList.val">
    <methods/>
  </class>
  <class type="dojo.NodeList.val.0">
    <properties>
      <property name="type" scope="instance" type="Object"/>
      <property name="options" scope="instance" type="Object"/>
      <property name="checked" scope="instance" type="bool"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.NodeList.prototype">
    <properties>
      <property name="remove" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Stateful">
    <methods>
      <method name="get" scope="instance">
        <description>Get a named property on a Stateful object. The property may
	potentially be retrieved via a getter method in subclasses. In the base class
	this just retrieves the object's property.
	For example:
		stateful = new dojo.Stateful({foo: 3});
		stateful.get("foo") // returns 3
		stateful.foo // returns 3</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The property to get.</description>
          </parameter>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <description>Sets named properties on a stateful object and notifies any watchers of
	the property. A programmatic setter may be defined in subclasses.
	For example:
		stateful = new dojo.Stateful();
		stateful.watch(function(name, oldValue, value){
			// this will be called on the set below
		}
		stateful.set(foo, 5);
	set() may also be called with a hash of name/value pairs, ex:
		myObj.set({
			foo: "Howdy",
			bar: 3
		})
	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The property to set.</description>
          </parameter>
          <parameter name="value" type="Object" usage="required">
            <description>The value to set in the property.</description>
          </parameter>
        </parameters>
      </method>
      <method name="watch" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="optional">
            <description>Indicates the property to watch. This is optional (the callback may be the
	only parameter), and if omitted, all the properties will be watched</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>The function to execute when the property changes. This will be called after
	the property has been changed. The callback will be called with the |this|
	set to the instance, the first argument as the name of the property, the
	second argument as the old value and the third argument as the new value.</description>
          </parameter>
        </parameters>
        <return-description>An object handle for the watch. The unwatch method of this object
	can be used to discontinue watching this property:
		var watchHandle = obj.watch("foo", callback);
		watchHandle.unwatch(); // callback won't be called now</return-description>
      </method>
      <method name="_watchCallbacks" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="oldValue" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="ignoreCatchall" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.Color">
    <methods>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="r" type="Object" usage="required"/>
          <parameter name="g" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
          <parameter name="a" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColor" scope="instance">
        <examples>
          <example>	var c = new dojo.Color(); // no color
		c.setColor("#ededed"); // greyish</example>
        </examples>
        <parameters>
          <parameter name="color" type="Array|String|Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="sanitize" scope="instance">
        <description>the default implementation does nothing, include dojo.colors to
	augment it with real checks</description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="toRgb" scope="instance">
        <examples>
          <example>	var c = new dojo.Color("#000000");
	 	console.log(c.toRgb()); // [0,0,0]</example>
        </examples>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="toRgba" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="toHex" scope="instance">
        <examples>
          <example> 	console.log(new dojo.Color([0,0,0]).toHex()); // #000000</example>
        </examples>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toCss" scope="instance">
        <examples>
          <example>	var c = new dojo.Color("#FFF").toCss();
		console.log(c); // rgb('255','255','255')</example>
        </examples>
        <parameters>
          <parameter name="includeAlpha" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="r" scope="instance" type="Number"/>
      <property name="g" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.Color.named">
    <properties>
      <property name="black" scope="instance" type="Array"/>
      <property name="silver" scope="instance" type="Array"/>
      <property name="gray" scope="instance" type="Array"/>
      <property name="white" scope="instance" type="Array"/>
      <property name="maroon" scope="instance" type="Array"/>
      <property name="red" scope="instance" type="Array"/>
      <property name="purple" scope="instance" type="Array"/>
      <property name="fuchsia" scope="instance" type="Array"/>
      <property name="green" scope="instance" type="Array"/>
      <property name="lime" scope="instance" type="Array"/>
      <property name="olive" scope="instance" type="Array"/>
      <property name="yellow" scope="instance" type="Array"/>
      <property name="navy" scope="instance" type="Array"/>
      <property name="blue" scope="instance" type="Array"/>
      <property name="teal" scope="instance" type="Array"/>
      <property name="aqua" scope="instance" type="Array"/>
      <property name="transparent" scope="instance" type="Array"/>
      <property name="aliceblue" scope="instance" type="Array"/>
      <property name="antiquewhite" scope="instance" type="Array"/>
      <property name="aquamarine" scope="instance" type="Array"/>
      <property name="azure" scope="instance" type="Array"/>
      <property name="beige" scope="instance" type="Array"/>
      <property name="bisque" scope="instance" type="Array"/>
      <property name="blanchedalmond" scope="instance" type="Array"/>
      <property name="blueviolet" scope="instance" type="Array"/>
      <property name="brown" scope="instance" type="Array"/>
      <property name="burlywood" scope="instance" type="Array"/>
      <property name="cadetblue" scope="instance" type="Array"/>
      <property name="chartreuse" scope="instance" type="Array"/>
      <property name="chocolate" scope="instance" type="Array"/>
      <property name="coral" scope="instance" type="Array"/>
      <property name="cornflowerblue" scope="instance" type="Array"/>
      <property name="cornsilk" scope="instance" type="Array"/>
      <property name="crimson" scope="instance" type="Array"/>
      <property name="cyan" scope="instance" type="Array"/>
      <property name="darkblue" scope="instance" type="Array"/>
      <property name="darkcyan" scope="instance" type="Array"/>
      <property name="darkgoldenrod" scope="instance" type="Array"/>
      <property name="darkgray" scope="instance" type="Array"/>
      <property name="darkgreen" scope="instance" type="Array"/>
      <property name="darkgrey" scope="instance" type="Array"/>
      <property name="darkkhaki" scope="instance" type="Array"/>
      <property name="darkmagenta" scope="instance" type="Array"/>
      <property name="darkolivegreen" scope="instance" type="Array"/>
      <property name="darkorange" scope="instance" type="Array"/>
      <property name="darkorchid" scope="instance" type="Array"/>
      <property name="darkred" scope="instance" type="Array"/>
      <property name="darksalmon" scope="instance" type="Array"/>
      <property name="darkseagreen" scope="instance" type="Array"/>
      <property name="darkslateblue" scope="instance" type="Array"/>
      <property name="darkslategray" scope="instance" type="Array"/>
      <property name="darkslategrey" scope="instance" type="Array"/>
      <property name="darkturquoise" scope="instance" type="Array"/>
      <property name="darkviolet" scope="instance" type="Array"/>
      <property name="deeppink" scope="instance" type="Array"/>
      <property name="deepskyblue" scope="instance" type="Array"/>
      <property name="dimgray" scope="instance" type="Array"/>
      <property name="dimgrey" scope="instance" type="Array"/>
      <property name="dodgerblue" scope="instance" type="Array"/>
      <property name="firebrick" scope="instance" type="Array"/>
      <property name="floralwhite" scope="instance" type="Array"/>
      <property name="forestgreen" scope="instance" type="Array"/>
      <property name="gainsboro" scope="instance" type="Array"/>
      <property name="ghostwhite" scope="instance" type="Array"/>
      <property name="gold" scope="instance" type="Array"/>
      <property name="goldenrod" scope="instance" type="Array"/>
      <property name="greenyellow" scope="instance" type="Array"/>
      <property name="grey" scope="instance" type="Array"/>
      <property name="honeydew" scope="instance" type="Array"/>
      <property name="hotpink" scope="instance" type="Array"/>
      <property name="indianred" scope="instance" type="Array"/>
      <property name="indigo" scope="instance" type="Array"/>
      <property name="ivory" scope="instance" type="Array"/>
      <property name="khaki" scope="instance" type="Array"/>
      <property name="lavender" scope="instance" type="Array"/>
      <property name="lavenderblush" scope="instance" type="Array"/>
      <property name="lawngreen" scope="instance" type="Array"/>
      <property name="lemonchiffon" scope="instance" type="Array"/>
      <property name="lightblue" scope="instance" type="Array"/>
      <property name="lightcoral" scope="instance" type="Array"/>
      <property name="lightcyan" scope="instance" type="Array"/>
      <property name="lightgoldenrodyellow" scope="instance" type="Array"/>
      <property name="lightgray" scope="instance" type="Array"/>
      <property name="lightgreen" scope="instance" type="Array"/>
      <property name="lightgrey" scope="instance" type="Array"/>
      <property name="lightpink" scope="instance" type="Array"/>
      <property name="lightsalmon" scope="instance" type="Array"/>
      <property name="lightseagreen" scope="instance" type="Array"/>
      <property name="lightskyblue" scope="instance" type="Array"/>
      <property name="lightslategray" scope="instance" type="Array"/>
      <property name="lightslategrey" scope="instance" type="Array"/>
      <property name="lightsteelblue" scope="instance" type="Array"/>
      <property name="lightyellow" scope="instance" type="Array"/>
      <property name="limegreen" scope="instance" type="Array"/>
      <property name="linen" scope="instance" type="Array"/>
      <property name="magenta" scope="instance" type="Array"/>
      <property name="mediumaquamarine" scope="instance" type="Array"/>
      <property name="mediumblue" scope="instance" type="Array"/>
      <property name="mediumorchid" scope="instance" type="Array"/>
      <property name="mediumpurple" scope="instance" type="Array"/>
      <property name="mediumseagreen" scope="instance" type="Array"/>
      <property name="mediumslateblue" scope="instance" type="Array"/>
      <property name="mediumspringgreen" scope="instance" type="Array"/>
      <property name="mediumturquoise" scope="instance" type="Array"/>
      <property name="mediumvioletred" scope="instance" type="Array"/>
      <property name="midnightblue" scope="instance" type="Array"/>
      <property name="mintcream" scope="instance" type="Array"/>
      <property name="mistyrose" scope="instance" type="Array"/>
      <property name="moccasin" scope="instance" type="Array"/>
      <property name="navajowhite" scope="instance" type="Array"/>
      <property name="oldlace" scope="instance" type="Array"/>
      <property name="olivedrab" scope="instance" type="Array"/>
      <property name="orange" scope="instance" type="Array"/>
      <property name="orangered" scope="instance" type="Array"/>
      <property name="orchid" scope="instance" type="Array"/>
      <property name="palegoldenrod" scope="instance" type="Array"/>
      <property name="palegreen" scope="instance" type="Array"/>
      <property name="paleturquoise" scope="instance" type="Array"/>
      <property name="palevioletred" scope="instance" type="Array"/>
      <property name="papayawhip" scope="instance" type="Array"/>
      <property name="peachpuff" scope="instance" type="Array"/>
      <property name="peru" scope="instance" type="Array"/>
      <property name="pink" scope="instance" type="Array"/>
      <property name="plum" scope="instance" type="Array"/>
      <property name="powderblue" scope="instance" type="Array"/>
      <property name="rosybrown" scope="instance" type="Array"/>
      <property name="royalblue" scope="instance" type="Array"/>
      <property name="saddlebrown" scope="instance" type="Array"/>
      <property name="salmon" scope="instance" type="Array"/>
      <property name="sandybrown" scope="instance" type="Array"/>
      <property name="seagreen" scope="instance" type="Array"/>
      <property name="seashell" scope="instance" type="Array"/>
      <property name="sienna" scope="instance" type="Array"/>
      <property name="skyblue" scope="instance" type="Array"/>
      <property name="slateblue" scope="instance" type="Array"/>
      <property name="slategray" scope="instance" type="Array"/>
      <property name="slategrey" scope="instance" type="Array"/>
      <property name="snow" scope="instance" type="Array"/>
      <property name="springgreen" scope="instance" type="Array"/>
      <property name="steelblue" scope="instance" type="Array"/>
      <property name="tan" scope="instance" type="Array"/>
      <property name="thistle" scope="instance" type="Array"/>
      <property name="tomato" scope="instance" type="Array"/>
      <property name="turquoise" scope="instance" type="Array"/>
      <property name="violet" scope="instance" type="Array"/>
      <property name="wheat" scope="instance" type="Array"/>
      <property name="whitesmoke" scope="instance" type="Array"/>
      <property name="yellowgreen" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo._base">
    <properties>
      <property name="Color" scope="instance" type="Object"/>
      <property name="Deferred" scope="instance" type="Object"/>
      <property name="NodeList" scope="instance" type="Object"/>
      <property name="array" scope="instance" type="Object"/>
      <property name="connect" scope="instance" type="Object"/>
      <property name="declare" scope="instance" type="Object"/>
      <property name="event" scope="instance" type="Object"/>
      <property name="fx" scope="instance" type="Object"/>
      <property name="html" scope="instance" type="Object"/>
      <property name="json" scope="instance" type="Object"/>
      <property name="lang" scope="instance" type="Object"/>
      <property name="query" scope="instance" type="Object"/>
      <property name="window" scope="instance" type="Object"/>
      <property name="xhr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Deferred">
    <description>The dojo.Deferred API is based on the concept of promises that provide a
	generic interface into the eventual completion of an asynchronous action.
	The motivation for promises fundamentally is about creating a
	separation of concerns that allows one to achieve the same type of
	call patterns and logical data flow in asynchronous code as can be
	achieved in synchronous code. Promises allows one
	to be able to call a function purely with arguments needed for
	execution, without conflating the call with concerns of whether it is
	sync or async. One shouldn't need to alter a call's arguments if the
	implementation switches from sync to async (or vice versa). By having
	async functions return promises, the concerns of making the call are
	separated from the concerns of asynchronous interaction (which are
	handled by the promise).
	The dojo.Deferred is a type of promise that provides methods for fulfilling the
	promise with a successful result or an error. The most important method for
	working with Dojo's promises is the then() method, which follows the
	CommonJS proposed promise API. An example of using a Dojo promise:
	 	var resultingPromise = someAsyncOperation.then(function(result){
			... handle result ...
		},
		function(error){
			... handle error ...
		});
	The .then() call returns a new promise that represents the result of the
	execution of the callback. The callbacks will never affect the original promises value.
	The dojo.Deferred instances also provide the following functions for backwards compatibility:
	* addCallback(handler)
	* addErrback(handler)
	* callback(result)
	* errback(result)
	Callbacks are allowed to return promises themselves, so
	you can build complicated sequences of events with ease.
	The creator of the Deferred may specify a canceller.  The canceller
	is a function that will be called if Deferred.cancel is called
	before the Deferred fires. You can use this to implement clean
	aborting of an XMLHttpRequest, etc. Note that cancel will fire the
	deferred with a CancelledError (unless your canceller returns
	another kind of error), so the errbacks should be prepared to
	handle that error for cancellable Deferreds.</description>
    <methods>
      <method name="addCallback" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="addErrback" scope="instance">
        <parameters>
          <parameter name="errback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="addBoth" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="resolve" scope="instance"/>
      <method name="callback" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reject" scope="instance"/>
      <method name="errback" scope="instance">
        <parameters>
          <parameter name="error" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="progress" scope="instance">
        <parameters>
          <parameter name="update" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCallbacks" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="optional"/>
          <parameter name="errback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="then" scope="instance"/>
      <method name="cancel" scope="instance"/>
    </methods>
    <properties>
      <property name="fired" scope="instance-prototype" type="Number"/>
      <property name="promise" scope="instance" type="Object"/>
      <property name="results" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="Object">
    <methods>
      <method name="freeze" scope="instance"/>
      <method name="inherited" scope="instance">
        <description>This method is used inside method of classes produced with
	dojo.declare to call a super method (next in the chain). It is
	used for manually controlled chaining. Consider using the regular
	chaining, because it is faster. Use "this.inherited()" only in
	complex cases.
	This method cannot me called from automatically chained
	constructors including the case of a special (legacy)
	constructor chaining. It cannot be called from chained methods.
	If "this.inherited()" cannot find the next-in-chain method, it
	does nothing and returns "undefined". The last method in chain
	can be a default method implemented in Object, which will be
	called last.
	If "name" is specified, it is assumed that the method that
	received "args" is the parent method for this call. It is looked
	up in the chain list and if it is found the next-in-chain method
	is called. If it is not found, the first-in-chain method is
	called.
	If "name" is not specified, it will be derived from the calling
	method (using a methoid property "nom").</description>
        <examples>
          <example>	var B = dojo.declare(A, {
			method1: function(a, b, c){
				this.inherited(arguments);
			},
			method2: function(a, b){
				return this.inherited(arguments, [a + b]);
			}
		});
		// next method is not in the chain list because it is added
		// manually after the class was created.
		B.prototype.method3 = function(){
			console.log("This is a dynamically-added method.");
			this.inherited("method3", arguments);
		};</example>
          <example>	var B = dojo.declare(A, {
			method: function(a, b){
				var super = this.inherited(arguments, true);
				// ...
				if(!super){
					console.log("there is no super method");
					return 0;
				}
				return super.apply(this, arguments);
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="optional">
            <description>The optional method name. Should be the same as the caller's
	name. Usually &amp;quot;name&amp;quot; is specified in complex dynamic cases, when
	the calling method was dynamically added, undecorated by
	dojo.declare, and it cannot be determined.</description>
          </parameter>
          <parameter name="args" type="Arguments" usage="required">
            <description>The caller supply this argument, which should be the original
	&amp;quot;arguments&amp;quot;.</description>
          </parameter>
          <parameter name="newArgs" type="Object" usage="optional">
            <description>If &amp;quot;true&amp;quot;, the found function will be returned without
	executing it.
	If Array, it will be used to call a super method. Otherwise
	&amp;quot;args&amp;quot; will be used.</description>
          </parameter>
        </parameters>
        <return-description>Whatever is returned by a super method, or a super method itself,
	if "true" was specified as newArgs.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getInherited" scope="instance">
        <description>This method is a convenience method for "this.inherited()".
	It uses the same algorithm but instead of executing a super
	method, it returns it, or "undefined" if not found.</description>
        <examples>
          <example>	var B = dojo.declare(A, {
			method: function(a, b){
				var super = this.getInherited(arguments);
				// ...
				if(!super){
					console.log("there is no super method");
					return 0;
				}
				return super.apply(this, arguments);
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="optional">
            <description>The optional method name. Should be the same as the caller's
	name. Usually &amp;quot;name&amp;quot; is specified in complex dynamic cases, when
	the calling method was dynamically added, undecorated by
	dojo.declare, and it cannot be determined.</description>
          </parameter>
          <parameter name="args" type="Arguments" usage="required">
            <description>The caller supply this argument, which should be the original
	&amp;quot;arguments&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-description>Returns a super method (Function) or "undefined".</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="isInstanceOf" scope="instance">
        <description>This method is used with instances of classes produced with
	dojo.declare to determine of they support a certain interface or
	not. It models "instanceof" operator.</description>
        <examples>
          <example>	var A = dojo.declare(null, {
			// constructor, properties, and methods go here
			// ...
		});
		var B = dojo.declare(null, {
			// constructor, properties, and methods go here
			// ...
		});
		var C = dojo.declare([A, B], {
			// constructor, properties, and methods go here
			// ...
		});
		var D = dojo.declare(A, {
			// constructor, properties, and methods go here
			// ...
		});
		var a = new A(), b = new B(), c = new C(), d = new D();
		console.log(a.isInstanceOf(A)); // true
		console.log(b.isInstanceOf(A)); // false
		console.log(c.isInstanceOf(A)); // true
		console.log(d.isInstanceOf(A)); // true
		console.log(a.isInstanceOf(B)); // false
		console.log(b.isInstanceOf(B)); // true
		console.log(c.isInstanceOf(B)); // true
		console.log(d.isInstanceOf(B)); // false
		console.log(a.isInstanceOf(C)); // false
		console.log(b.isInstanceOf(C)); // false
		console.log(c.isInstanceOf(C)); // true
		console.log(d.isInstanceOf(C)); // false
		console.log(a.isInstanceOf(D)); // false
		console.log(b.isInstanceOf(D)); // false
		console.log(c.isInstanceOf(D)); // false
		console.log(d.isInstanceOf(D)); // true</example>
        </examples>
        <parameters>
          <parameter name="cls" type="Function" usage="required">
            <description>Class constructor.</description>
          </parameter>
        </parameters>
        <return-description>"true", if this object is inherited from this class, "false"
	otherwise.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="extend" scope="instance">
        <description>Adds source properties to the constructor's prototype. It can
	override existing properties.
	This method is similar to dojo.extend function, but it is specific
	to constructors produced by dojo.declare. It is implemented
	using dojo.safeMixin, and it skips a constructor property,
	and properly decorates copied functions.</description>
        <examples>
          <example>	var A = dojo.declare(null, {
			m1: function(){},
			s1: "Popokatepetl"
		});
		A.extend({
			m1: function(){},
			m2: function(){},
			f1: true,
			d1: 42
		});</example>
        </examples>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>Source object which properties are going to be copied to the
	constructor's prototype.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="toString" scope="instance" type="Object"/>
      <property name="hasOwnProperty" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.NodeList._stash">
    <methods/>
    <properties>
      <property name="_parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.NodeList.attr">
    <methods>
      <method name="safetyCheck" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.NodeList.style">
    <methods>
      <method name="safetyCheck" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.NodeList.addContent">
    <description>a copy of the HTML content is added to each item in the
	list, with an optional position argument. If no position
	argument is provided, the content is appended to the end of
	each item.</description>
    <methods>
      <method name="safetyCheck" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="Array">
    <properties>
      <property name="slice" scope="instance" type="Object"/>
      <property name="concat" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="navigator">
    <properties>
      <property name="userAgent" scope="instance" type="Object"/>
      <property name="appVersion" scope="instance" type="Object"/>
      <property name="cookieEnabled" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.config">
    <properties>
      <property name="modulePaths" scope="instance" type="Object"/>
      <property name="addOnLoad" scope="instance" type="Object"/>
      <property name="hashPollFrequency" scope="instance" type="Number"/>
      <property name="extraLocale" scope="instance" type="Array"/>
      <property name="dojoBlankHtmlUrl" scope="instance" type="Object"/>
      <property name="debugContainerId" scope="instance" type="String"/>
      <property name="debugHeight" scope="instance" type="Number"/>
      <property name="consoleLogFuncs" scope="instance" type="Array"/>
      <property name="timezoneFileBasePath" scope="instance" type="Object"/>
      <property name="timezoneLoadingScheme" scope="instance" type="String"/>
      <property name="ioPublish" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="console">
    <methods>
      <method name="log" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="debug" scope="instance"/>
    </methods>
    <properties>
      <property name="warn" scope="instance" type="Object"/>
      <property name="error" scope="instance" type="Object"/>
      <property name="info" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="e">
    <properties>
      <property name="stack" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo._modulePrefixes"/>
  <class type="dojo._modulePrefixes.dojo">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo._modulePrefixes.doh">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo._modulePrefixes.tests">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo._Url">
    <description>Each argument is evaluated in order relative to the next until
	a canonical uri is produced. To get an absolute Uri relative to
	the current document use:
	new dojo._Url(document.baseURI, url)</description>
    <methods>
      <method name="toString" scope="instance"/>
    </methods>
    <properties>
      <property name="uri" scope="instance" type="Object"/>
      <property name="scheme" scope="instance" type="Object"/>
      <property name="authority" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="Object"/>
      <property name="query" scope="instance" type="Object"/>
      <property name="fragment" scope="instance" type="Object"/>
      <property name="user" scope="instance" type="Object"/>
      <property name="password" scope="instance" type="Object"/>
      <property name="host" scope="instance" type="Object"/>
      <property name="port" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="define">
    <properties>
      <property name="vendor" scope="instance" type="String"/>
      <property name="version" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="window">
    <properties>
      <property name="dojo" scope="instance" type="Object"/>
      <property name="dijit" scope="instance" type="Object"/>
      <property name="dojox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._xdDebugQueue">
    <properties>
      <property name="currentResourceName" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._base._loader">
    <properties>
      <property name="loader_debug" scope="instance" type="Object"/>
      <property name="loader_xd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._xdDefList">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._listener">
    <methods>
      <method name="getDispatcher" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="listener" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo._event_listener">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="fp" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>DOM node to attach the event to</description>
          </parameter>
          <parameter name="event" type="String" usage="required">
            <description>the name of the handler to remove the function from</description>
          </parameter>
          <parameter name="handle" type="Handle" usage="required">
            <description>the handle returned from add</description>
          </parameter>
        </parameters>
      </method>
      <method name="_normalizeEventName" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_fixCallback" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="fp" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fixEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setKeyChar" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo._event_listener._punctMap">
    <properties>
      <property name="106" scope="instance" type="Number"/>
      <property name="111" scope="instance" type="Number"/>
      <property name="186" scope="instance" type="Number"/>
      <property name="187" scope="instance" type="Number"/>
      <property name="188" scope="instance" type="Number"/>
      <property name="189" scope="instance" type="Number"/>
      <property name="190" scope="instance" type="Number"/>
      <property name="191" scope="instance" type="Number"/>
      <property name="192" scope="instance" type="Number"/>
      <property name="219" scope="instance" type="Number"/>
      <property name="220" scope="instance" type="Number"/>
      <property name="221" scope="instance" type="Number"/>
      <property name="222" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.keys">
    <properties>
      <property name="BACKSPACE" scope="instance" type="Number"/>
      <property name="TAB" scope="instance" type="Number"/>
      <property name="CLEAR" scope="instance" type="Number"/>
      <property name="ENTER" scope="instance" type="Number"/>
      <property name="SHIFT" scope="instance" type="Number"/>
      <property name="CTRL" scope="instance" type="Number"/>
      <property name="ALT" scope="instance" type="Number"/>
      <property name="META" scope="instance" type="Object"/>
      <property name="PAUSE" scope="instance" type="Number"/>
      <property name="CAPS_LOCK" scope="instance" type="Number"/>
      <property name="ESCAPE" scope="instance" type="Number"/>
      <property name="SPACE" scope="instance" type="Number"/>
      <property name="PAGE_UP" scope="instance" type="Number"/>
      <property name="PAGE_DOWN" scope="instance" type="Number"/>
      <property name="END" scope="instance" type="Number"/>
      <property name="HOME" scope="instance" type="Number"/>
      <property name="LEFT_ARROW" scope="instance" type="Number"/>
      <property name="UP_ARROW" scope="instance" type="Number"/>
      <property name="RIGHT_ARROW" scope="instance" type="Number"/>
      <property name="DOWN_ARROW" scope="instance" type="Number"/>
      <property name="INSERT" scope="instance" type="Number"/>
      <property name="DELETE" scope="instance" type="Number"/>
      <property name="HELP" scope="instance" type="Number"/>
      <property name="LEFT_WINDOW" scope="instance" type="Number"/>
      <property name="RIGHT_WINDOW" scope="instance" type="Number"/>
      <property name="SELECT" scope="instance" type="Number"/>
      <property name="NUMPAD_0" scope="instance" type="Number"/>
      <property name="NUMPAD_1" scope="instance" type="Number"/>
      <property name="NUMPAD_2" scope="instance" type="Number"/>
      <property name="NUMPAD_3" scope="instance" type="Number"/>
      <property name="NUMPAD_4" scope="instance" type="Number"/>
      <property name="NUMPAD_5" scope="instance" type="Number"/>
      <property name="NUMPAD_6" scope="instance" type="Number"/>
      <property name="NUMPAD_7" scope="instance" type="Number"/>
      <property name="NUMPAD_8" scope="instance" type="Number"/>
      <property name="NUMPAD_9" scope="instance" type="Number"/>
      <property name="NUMPAD_MULTIPLY" scope="instance" type="Number"/>
      <property name="NUMPAD_PLUS" scope="instance" type="Number"/>
      <property name="NUMPAD_ENTER" scope="instance" type="Number"/>
      <property name="NUMPAD_MINUS" scope="instance" type="Number"/>
      <property name="NUMPAD_PERIOD" scope="instance" type="Number"/>
      <property name="NUMPAD_DIVIDE" scope="instance" type="Number"/>
      <property name="F1" scope="instance" type="Number"/>
      <property name="F2" scope="instance" type="Number"/>
      <property name="F3" scope="instance" type="Number"/>
      <property name="F4" scope="instance" type="Number"/>
      <property name="F5" scope="instance" type="Number"/>
      <property name="F6" scope="instance" type="Number"/>
      <property name="F7" scope="instance" type="Number"/>
      <property name="F8" scope="instance" type="Number"/>
      <property name="F9" scope="instance" type="Number"/>
      <property name="F10" scope="instance" type="Number"/>
      <property name="F11" scope="instance" type="Number"/>
      <property name="F12" scope="instance" type="Number"/>
      <property name="F13" scope="instance" type="Number"/>
      <property name="F14" scope="instance" type="Number"/>
      <property name="F15" scope="instance" type="Number"/>
      <property name="NUM_LOCK" scope="instance" type="Number"/>
      <property name="SCROLL_LOCK" scope="instance" type="Number"/>
      <property name="copyKey" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.mouseButtons">
    <methods>
      <method name="isButton" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event object to examine</description>
          </parameter>
          <parameter name="button" type="Number" usage="required">
            <description>The button value (example: dojo.mouseButton.LEFT)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isLeft" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event object to examine</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isMiddle" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event object to examine</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isRight" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event object to examine</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="LEFT" scope="instance" type="Number">
        <description>Numeric value of the left mouse button for the platform.</description>
      </property>
      <property name="MIDDLE" scope="instance" type="Number">
        <description>Numeric value of the middle mouse button for the platform.</description>
      </property>
      <property name="RIGHT" scope="instance" type="Number">
        <description>Numeric value of the right mouse button for the platform.</description>
      </property>
    </properties>
  </class>
  <class type="dojo._ie_listener">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="listener" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="handlers" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo.Animation">
    <description>To use, simply require dojox.fx.ext-dojo.reverse and a reverse()
	method will be added to all dojo.Animations.
	It can be used at any time during the animation. It does not
	need to be called when it ends. It also reverses the easing -
	if dojo.fx.easing.quadIn is used, dojo.fx.easing.quadOut will
	be used when animating backwards.</description>
    <methods>
      <method name="easing" scope="instance"/>
      <method name="_fire" scope="instance">
        <description>Convenience function.  Fire event "evt" and pass it the
	arguments specified in "args".
	Fires the callback in the scope of the `dojo.Animation`
	instance.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event to fire.</description>
          </parameter>
          <parameter name="args" type="Array" usage="optional">
            <description>The arguments to pass to the event.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="play" scope="instance">
        <parameters>
          <parameter name="delay" type="int" usage="optional">
            <description>How many milliseconds to delay before starting.</description>
          </parameter>
          <parameter name="gotoStart" type="Boolean" usage="optional">
            <description>If true, starts the animation from the beginning; otherwise,
	starts it from its current position.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Animation
	The instance to allow chaining.</return-description>
      </method>
      <method name="_play" scope="instance">
        <parameters>
          <parameter name="gotoStart" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="pause" scope="instance">
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="gotoPercent" scope="instance">
        <parameters>
          <parameter name="percent" type="Decimal" usage="required">
            <description>A percentage in decimal notation (between and including 0.0 and 1.0).</description>
          </parameter>
          <parameter name="andPlay" type="Boolean" usage="optional">
            <description>If true, play the animation after setting the progress.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="stop" scope="instance">
        <parameters>
          <parameter name="gotoEnd" type="boolean" usage="optional">
            <description>If true, the animation will end.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="status" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_cycle" scope="instance">
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_clearTimer" scope="instance"/>
    </methods>
    <properties>
      <property name="duration" scope="instance" type="Integer">
        <description>The time in milliseonds the animation will take to run</description>
      </property>
      <property name="curve" scope="instance-prototype" type="dojo._Line|Array">
        <description>A two element array of start and end values, or a &lt;code&gt;dojo._Line&lt;/code&gt; instance to be
	used in the Animation.</description>
      </property>
      <property name="repeat" scope="instance" type="Integer">
        <description>The number of times to loop the animation</description>
      </property>
      <property name="rate" scope="instance" type="Integer">
        <description>the time in milliseconds to wait before advancing to next frame
	(used as a fps timer: 1000/rate = fps)</description>
      </property>
      <property name="delay" scope="instance" type="Integer">
        <description>The time in milliseconds to wait before starting animation after it
	has been .play()'ed</description>
      </property>
      <property name="beforeBegin" scope="instance" type="Event">
        <description>Synthetic event fired before a dojo.Animation begins playing (synchronous)</description>
      </property>
      <property name="onBegin" scope="instance" type="Event">
        <description>Synthetic event fired as a dojo.Animation begins playing (useful?)</description>
      </property>
      <property name="onAnimate" scope="instance" type="Event">
        <description>Synthetic event fired at each interval of a &lt;code&gt;dojo.Animation&lt;/code&gt;</description>
      </property>
      <property name="onEnd" scope="instance" type="Event">
        <description>Synthetic event fired after the final frame of a &lt;code&gt;dojo.Animation&lt;/code&gt;</description>
      </property>
      <property name="onPlay" scope="instance" type="Event">
        <description>Synthetic event fired any time a &lt;code&gt;dojo.Animation&lt;/code&gt; is play()'ed</description>
      </property>
      <property name="onPause" scope="instance" type="Event">
        <description>Synthetic event fired when a &lt;code&gt;dojo.Animation&lt;/code&gt; is paused</description>
      </property>
      <property name="onStop" scope="instance" type="Event">
        <description>Synthetic event fires when a &lt;code&gt;dojo.Animation&lt;/code&gt; is stopped</description>
      </property>
      <property name="_percent" scope="instance" type="Number"/>
      <property name="_startRepeatCount" scope="instance" type="Number"/>
      <property name="_reversed" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.Animation._getStep">
    <methods/>
    <properties>
      <property name="_percent" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Animation._startTimer">
    <methods/>
    <properties>
      <property name="_timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Animation._stopTimer">
    <methods/>
    <properties>
      <property name="_timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.__AnimArgs" superclass="dojo.__FadeArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.__FadeArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="properties" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo._Line">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="float" usage="required">
            <description>a floating point number greater than 0 and less than 1</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="start" scope="instance" type="int">
        <description>Beginning value for range</description>
      </property>
      <property name="end" scope="instance" type="int">
        <description>Ending value for range</description>
      </property>
    </properties>
  </class>
  <class type="dojo.__FadeArgs">
    <methods>
      <method name="easing" scope="instance"/>
    </methods>
    <properties>
      <property name="node" scope="instance" type="DOMNode|String">
        <description>The node referenced in the animation</description>
      </property>
      <property name="duration" scope="instance" type="Integer">
        <description>Duration of the animation in milliseconds.</description>
      </property>
    </properties>
  </class>
  <class type="dojo._extraNames">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.__XhrArgs" superclass="dojo.__IoArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.__IoArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="handleAs" scope="instance" type="String">
        <description>Acceptable values are: text (default), json, json-comment-optional,
	json-comment-filtered, javascript, xml. See &lt;code&gt;dojo.contentHandlers&lt;/code&gt;</description>
      </property>
      <property name="sync" scope="instance" type="Boolean">
        <description>false is default. Indicates whether the request should
	be a synchronous (blocking) request.</description>
      </property>
      <property name="headers" scope="instance" type="Object">
        <description>Additional HTTP headers to send in the request.</description>
      </property>
      <property name="failOk" scope="instance" type="Boolean">
        <description>false is default. Indicates whether a request should be
	allowed to fail (and therefore no console error message in
	the event of a failure)</description>
      </property>
    </properties>
  </class>
  <class type="dojo.contentHandlers">
    <description>A map of availble XHR transport handle types. Name matches the
	`handleAs` attribute passed to XHR calls. Each contentHandler is
	called, passing the xhr object for manipulation. The return value
	from the contentHandler will be passed to the `load` or `handle`
	functions defined in the original xhr call.</description>
    <methods>
      <method name="text" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="json" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="json-comment-filtered" scope="instance">
        <description>A contentHandler which expects comment-filtered JSON.
	the json-comment-filtered option was implemented to prevent
	"JavaScript Hijacking", but it is less secure than standard JSON. Use
	standard JSON instead. JSON prefixing can be used to subvert hijacking.
	Will throw a notice suggesting to use application/json mimetype, as
	json-commenting can introduce security issues. To decrease the chances of hijacking,
	use the standard `json` contentHandler, and prefix your "JSON" with: {}&amp;&amp;
	use djConfig.useCommentedJson = true to turn off the notice</description>
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="javascript" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="xml" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
        </return-types>
      </method>
      <method name="json-comment-optional" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.__IoArgs">
    <methods>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="response" type="Object" usage="required">
            <description>The response in the format as defined with handleAs.</description>
          </parameter>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required">
            <description>Provides additional information about the request.</description>
          </parameter>
        </parameters>
      </method>
      <method name="error" scope="instance">
        <parameters>
          <parameter name="response" type="Object" usage="required">
            <description>The response in the format as defined with handleAs.</description>
          </parameter>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required">
            <description>Provides additional information about the request.</description>
          </parameter>
        </parameters>
      </method>
      <method name="handle" scope="instance">
        <parameters>
          <parameter name="loadOrError" type="String" usage="required">
            <description>Provides a string that tells you whether this function
	was called because of success (load) or failure (error).</description>
          </parameter>
          <parameter name="response" type="Object" usage="required">
            <description>The response in the format as defined with handleAs.</description>
          </parameter>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required">
            <description>Provides additional information about the request.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance" type="String">
        <description>URL to server endpoint.</description>
      </property>
      <property name="content" scope="instance" type="Object">
        <description>Contains properties with string values. These
	properties will be serialized as name1=value2 and
	passed in the request.</description>
      </property>
      <property name="timeout" scope="instance" type="Integer">
        <description>Milliseconds to wait for the response. If this time
	passes, the then error callbacks are called.</description>
      </property>
      <property name="form" scope="instance" type="DOMNode">
        <description>DOM node for a form. Used to extract the form values
	and send to the server.</description>
      </property>
      <property name="preventCache" scope="instance" type="Boolean">
        <description>Default is false. If true, then a
	&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
	with a value that changes with each request
	(timestamp). Useful only with GET-type requests.</description>
      </property>
      <property name="handleAs" scope="instance" type="String">
        <description>Acceptable values depend on the type of IO
	transport (see specific IO calls for more information).
	rawBody: String?
	Sets the raw body for an HTTP request. If this is used, then the content
	property is ignored. This is mostly useful for HTTP methods that have
	a body to their requests, like PUT or POST. This property can be used instead
	of postData and putData for dojo.rawXhrPost and dojo.rawXhrPut respectively.</description>
      </property>
      <property name="ioPublish" scope="instance" type="Boolean">
        <description>Set this explicitly to false to prevent publishing of topics related to
	IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
	will be published via dojo.publish for different phases of an IO operation.
	See dojo.__IoPublish for a list of topics that are published.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.__IoCallbackArgs">
    <methods/>
    <properties>
      <property name="args" scope="instance" type="Object">
        <description>the original object argument to the IO call.</description>
      </property>
      <property name="xhr" scope="instance" type="XMLHttpRequest">
        <description>For XMLHttpRequest calls only, the
	XMLHttpRequest object that was used for the
	request.</description>
      </property>
      <property name="url" scope="instance" type="String">
        <description>The final URL used for the call. Many times it
	will be different than the original args.url
	value.</description>
      </property>
      <property name="query" scope="instance" type="String">
        <description>For non-GET requests, the
	name1=value1&amp;amp;name2=value2 parameters sent up in
	the request.</description>
      </property>
      <property name="handleAs" scope="instance" type="String">
        <description>The final indicator on how the response will be
	handled.</description>
      </property>
      <property name="id" scope="instance" type="String">
        <description>For dojo.io.script calls only, the internal
	script ID used for the request.</description>
      </property>
      <property name="canDelete" scope="instance" type="Boolean">
        <description>For dojo.io.script calls only, indicates
	whether the script tag that represents the
	request can be deleted after callbacks have
	been called. Used internally to know when
	cleanup can happen on JSONP-type requests.</description>
      </property>
      <property name="json" scope="instance" type="Object">
        <description>For dojo.io.script calls only: holds the JSON
	response for JSONP-type requests. Used
	internally to hold on to the JSON responses.
	You should not need to access it directly --
	the same object should be passed to the success
	callbacks directly.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.__IoPublish">
    <methods/>
    <properties>
      <property name="start" scope="instance" type="String">
        <description>&amp;quot;/dojo/io/start&amp;quot; is sent when there are no outstanding IO
	requests, and a new IO request is started. No arguments
	are passed with this topic.</description>
      </property>
      <property name="send" scope="instance" type="String">
        <description>&amp;quot;/dojo/io/send&amp;quot; is sent whenever a new IO request is started.
	It passes the dojo.Deferred for the request with the topic.</description>
      </property>
      <property name="load" scope="instance" type="String">
        <description>&amp;quot;/dojo/io/load&amp;quot; is sent whenever an IO request has loaded
	successfully. It passes the response and the dojo.Deferred
	for the request with the topic.</description>
      </property>
      <property name="error" scope="instance" type="String">
        <description>&amp;quot;/dojo/io/error&amp;quot; is sent whenever an IO request has errored.
	It passes the error and the dojo.Deferred
	for the request with the topic.</description>
      </property>
      <property name="done" scope="instance" type="String">
        <description>&amp;quot;/dojo/io/done&amp;quot; is sent whenever an IO request has completed,
	either by loading or by erroring. It passes the error and
	the dojo.Deferred for the request with the topic.</description>
      </property>
      <property name="stop" scope="instance" type="String">
        <description>&amp;quot;/dojo/io/stop&amp;quot; is sent when all outstanding IO requests have
	finished. No arguments are passed with this topic.</description>
      </property>
    </properties>
  </class>
  <class type="window.console">
    <methods>
      <method name="log" scope="instance"/>
      <method name="debug" scope="instance"/>
      <method name="info" scope="instance"/>
      <method name="warn" scope="instance"/>
      <method name="error" scope="instance"/>
      <method name="assert" scope="instance">
        <parameters>
          <parameter name="truth" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dir" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dirxml" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="group" scope="instance"/>
      <method name="groupEnd" scope="instance"/>
      <method name="time" scope="instance">
        <examples>
          <example>	console.time("load");
		console.time("myFunction");
		console.timeEnd("load");
		console.timeEnd("myFunction");</example>
        </examples>
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="timeEnd" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="count" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="trace" scope="instance">
        <parameters>
          <parameter name="_value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="profile" scope="instance"/>
      <method name="profileEnd" scope="instance"/>
      <method name="clear" scope="instance"/>
      <method name="open" scope="instance"/>
      <method name="close" scope="instance"/>
      <method name="_restoreBorder" scope="instance"/>
      <method name="openDomInspector" scope="instance"/>
      <method name="_closeDomInspector" scope="instance"/>
      <method name="openConsole" scope="instance"/>
      <method name="openObjectInspector" scope="instance"/>
      <method name="recss" scope="instance"/>
    </methods>
    <properties>
      <property name="_connects" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo._firebug">
    <properties>
      <property name="firebug" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.back">
    <methods>
      <method name="getHash" scope="instance"/>
      <method name="setHash" scope="instance">
        <parameters>
          <parameter name="h" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <description>Only call this method before the page's DOM is finished loading. Otherwise
	it will not work. Be careful with xdomain loading or djConfig.debugAtAllCosts scenarios,
	in order for this method to work, dojo.back will need to be part of a build layer.</description>
        <return-types>
          <return-type type="prevent reinit"/>
        </return-types>
      </method>
      <method name="setInitialState" scope="instance">
        <description>It is recommended that you call this method as part of an event
	listener that is registered via dojo.addOnLoad().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>See the addToHistory() function for the list of valid args properties.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addToHistory" scope="instance">
        <description>To support getting back button notifications, the object
	argument should implement a function called either "back",
	"backButton", or "handle". The string "back" will be passed as
	the first and only argument to this callback.
	To support getting forward button notifications, the object
	argument should implement a function called either "forward",
	"forwardButton", or "handle". The string "forward" will be
	passed as the first and only argument to this callback.
	If you want the browser location string to change, define "changeUrl" on the object. If the
	value of "changeUrl" is true, then a unique number will be appended to the URL as a fragment
	identifier (http://some.domain.com/path#uniquenumber). If it is any other value that does
	not evaluate to false, that value will be used as the fragment identifier. For example,
	if changeUrl: 'page1', then the URL will look like: http://some.domain.com/path#page1
	There are problems with using dojo.back with semantically-named fragment identifiers
	("hash values" on an URL). In most browsers it will be hard for dojo.back to know
	distinguish a back from a forward event in those cases. For back/forward support to
	work best, the fragment ID should always be a unique value (something using new Date().getTime()
	for example). If you want to detect hash changes using semantic fragment IDs, then
	consider using dojo.hash instead (in Dojo 1.4+).</description>
        <examples>
          <example>	dojo.back.addToHistory({
			back: function(){ console.log('back pressed'); },
			forward: function(){ console.log('forward pressed'); },
			changeUrl: true
		});</example>
        </examples>
        <parameters>
          <parameter name="args" type="dojo.__backArgs" usage="required"/>
        </parameters>
      </method>
      <method name="_iframeLoaded" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="ifrLoc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="goBack" scope="instance" type="Object"/>
      <property name="goForward" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="window.frames">
    <properties>
      <property name="dj_history" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.behavior">
    <description>A very simple, lightweight mechanism for applying code to
	existing documents, based around `dojo.query` (CSS3 selectors) for node selection,
	and a simple two-command API: `dojo.behavior.add()` and `dojo.behavior.apply()`;
	Behaviors apply to a given page, and are registered following the syntax
	options described by `dojo.behavior.add` to match nodes to actions, or "behaviors".
	Added behaviors are applied to the current DOM when .apply() is called,
	matching only new nodes found since .apply() was last called.</description>
    <methods>
      <method name="add" scope="instance">
        <description>Add the specified behavior to the list of behaviors which will
	be applied the next time apply() is called. Calls to add() for
	an already existing behavior do not replace the previous rules,
	but are instead additive. New nodes which match the rule will
	have all add()-ed behaviors applied to them when matched.
	The "found" method is a generalized handler that's called as soon
	as the node matches the selector. Rules for values that follow also
	apply to the "found" key.
	The "on*" handlers are attached with `dojo.connect()`, using the
	matching node
	If the value corresponding to the ID key is a function and not a
	list, it's treated as though it was the value of "found".
	dojo.behavior.add() can be called any number of times before
	the DOM is ready. `dojo.behavior.apply()` is called automatically
	by `dojo.addOnLoad`, though can be called to re-apply previously added
	behaviors anytime the DOM changes.
	There are a variety of formats permitted in the behaviorObject</description>
        <examples>
          <example>Simple list of properties. "found" is special. "Found" is assumed if
	no property object for a given selector, and property is a function.
		dojo.behavior.add({
			"#id": {
				"found": function(element){
					// node match found
				},
				"onclick": function(evt){
					// register onclick handler for found node
				}
			},
			"#otherid": function(element){
				// assumes "found" with this syntax
			}
		});</example>
          <example>If property is a string, a dojo.publish will be issued on the channel:
		dojo.behavior.add({
			// dojo.publish() whenever class="noclick" found on anchors
			"a.noclick": "/got/newAnchor",
			"div.wrapper": {
				"onclick": "/node/wasClicked"
			}
		});
		dojo.subscribe("/got/newAnchor", function(node){
			// handle node finding when dojo.behavior.apply() is called,
			// provided a newly matched node is found.
		});</example>
          <example>Scoping can be accomplished by passing an object as a property to
	a connection handle (on*):
		dojo.behavior.add({
			 	"#id": {
					// like calling dojo.hitch(foo,"bar"). execute foo.bar() in scope of foo
					"onmouseenter": { targetObj: foo, targetFunc: "bar" },
					"onmouseleave": { targetObj: foo, targetFunc: "baz" }
				}
		});</example>
          <example>Bahaviors match on CSS3 Selectors, powered by dojo.query. Example selectors:
		dojo.behavior.add({
			// match all direct descendants
			"#id4 &gt; *": function(element){
				// ...
			},
			// match the first child node that's an element
			"#id4 &gt; :first-child": { ... },
			// match the last child node that's an element
			"#id4 &gt; :last-child":  { ... },
			// all elements of type tagname
			"tagname": {
				// ...
			},
			"tagname1 tagname2 tagname3": {
				// ...
			},
			".classname": {
				// ...
			},
			"tagname.classname": {
				// ...
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="behaviorObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="apply" scope="instance">
        <description>Applies all currently registered behaviors to the document,
	taking care to ensure that only incremental updates are made
	since the last time add() or apply() were called.
	If new matching nodes have been added, all rules in a behavior will be
	applied to that node. For previously matched nodes, only
	behaviors which have been added since the last call to apply()
	will be added to the nodes.
	apply() is called once automatically by `dojo.addOnLoad`, so
	registering behaviors with `dojo.behavior.add` before the DOM is
	ready is acceptable, provided the dojo.behavior module is ready.
	Calling appy() manually after manipulating the DOM is required
	to rescan the DOM and apply newly .add()ed behaviors, or to match
	nodes that match existing behaviors when those nodes are added to
	the DOM.</description>
      </method>
    </methods>
    <properties>
      <property name="_behaviors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.cache">
    <description>module and url are used to call `dojo.moduleUrl()` to generate a module URL.
	If value is specified, the cache value for the moduleUrl will be set to
	that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
	in its internal cache and return that cached value for the URL. To clear
	a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
	the URL contents, only modules on the same domain of the page can use this capability.
	The build system can inline the cache values though, to allow for xdomain hosting.</description>
    <methods>
      <method name="_sanitize" scope="instance">
        <description>Copied from dijit._Templated._sanitizeTemplateString.</description>
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.cldr.monetary">
    <methods>
      <method name="getData" scope="instance">
        <parameters>
          <parameter name="code" type="String" usage="required">
            <description>an [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.cldr"/>
  <class type="dojo.cldr.supplemental">
    <methods>
      <method name="getFirstDayOfWeek" scope="instance">
        <description>Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
	e.g. Sunday (returns 0), or Monday (returns 1)</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_region" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getWeekend" scope="instance">
        <description>Returns a hash containing the start and end days of the weekend according to local custom using locale,
	or by default in the user's locale.
	e.g. {start:6, end:0}</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.colors">
    <methods>
      <method name="makeGrey" scope="instance">
        <parameters>
          <parameter name="g" type="Number" usage="required"/>
          <parameter name="a" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.__cookieProps">
    <methods/>
    <properties>
      <property name="expires" scope="instance" type="Date|String|Number">
        <description>If a number, the number of days from today at which the cookie
	will expire. If a date, the date past which the cookie will expire.
	If expires is in the past, the cookie will be deleted.
	If expires is omitted or is 0, the cookie will expire when the browser closes. &amp;lt;&amp;lt; FIXME: 0 seems to disappear right away? FF3.</description>
      </property>
      <property name="path" scope="instance" type="String">
        <description>The path to use for the cookie.</description>
      </property>
      <property name="domain" scope="instance" type="String">
        <description>The domain to use for the cookie.</description>
      </property>
      <property name="secure" scope="instance" type="Boolean">
        <description>Whether to only send the cookie on secure connections</description>
      </property>
    </properties>
  </class>
  <class type="dojo.cookie">
    <description>If one argument is passed, returns the value of the cookie
	For two or more arguments, acts as a setter.</description>
    <methods>
      <method name="isSupported" scope="instance"/>
    </methods>
  </class>
  <class type="document">
    <properties>
      <property name="cookie" scope="instance" type="Object"/>
      <property name="styleSheets" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.currency">
    <description>extends dojo.number to provide culturally-appropriate formatting of values
	in various world currencies, including use of a currency symbol.  The currencies are specified
	by a three-letter international symbol in all uppercase, and support for the currencies is
	provided by the data in `dojo.cldr`.  The scripts generating dojo.cldr specify which
	currency support is included.  A fixed number of decimal places is determined based
	on the currency type and is not determined by the 'pattern' argument.  The fractional
	portion is optional, by default, and variable length decimals are not supported.</description>
    <methods>
      <method name="_mixInDefaults" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <description>Create a string from a Number using a known, localized pattern.
	[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Elements)
	appropriate to the locale are chosen from the [CLDR](http://unicode.org/cldr)
	as well as the appropriate symbols and delimiters and number of decimal places.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to be formatted.</description>
          </parameter>
          <parameter name="options" type="dojo.currency.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="regexp" scope="instance">
        <description>Returns regular expression with positive and negative match, group and decimal separators
	Note: the options.places default, the number of decimal places to accept, is defined by the currency type.</description>
        <parameters>
          <parameter name="options" type="dojo.number.__RegexpOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <description>Create a Number from a string using a known, localized pattern.
	[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	are chosen appropriate to the locale, as well as the appropriate symbols and delimiters
	and number of decimal places.</description>
        <parameters>
          <parameter name="expression" type="String" usage="required">
            <description>A string representation of a currency value</description>
          </parameter>
          <parameter name="options" type="dojo.currency.__ParseOptions" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.currency.__FormatOptions" superclass="dojo.number.__FormatOptions">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.number.__FormatOptions" scope="instance"/>
    </mixins>
    <properties>
      <property name="type" scope="instance" type="String">
        <description>Should not be set.  Value is assumed to be &amp;quot;currency&amp;quot;.</description>
      </property>
      <property name="symbol" scope="instance" type="String">
        <description>localized currency symbol. The default will be looked up in table of supported currencies in &lt;code&gt;dojo.cldr&lt;/code&gt;
	A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.</description>
      </property>
      <property name="currency" scope="instance" type="String">
        <description>an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like &amp;quot;USD&amp;quot;.
	For use with dojo.currency only.</description>
      </property>
      <property name="places" scope="instance" type="Number">
        <description>number of decimal places to show.  Default is defined based on which currency is used.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.currency.__ParseOptions" superclass="dojo.number.__ParseOptions">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.number.__ParseOptions" scope="instance"/>
    </mixins>
    <properties>
      <property name="type" scope="instance" type="String">
        <description>Should not be set.  Value is assumed to be currency.</description>
      </property>
      <property name="currency" scope="instance" type="String">
        <description>an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like &amp;quot;USD&amp;quot;.
	For use with dojo.currency only.</description>
      </property>
      <property name="symbol" scope="instance" type="String">
        <description>localized currency symbol. The default will be looked up in table of supported currencies in &lt;code&gt;dojo.cldr&lt;/code&gt;
	A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.</description>
      </property>
      <property name="places" scope="instance" type="Number">
        <description>fixed number of decimal places to accept.  The default is determined based on which currency is used.</description>
      </property>
      <property name="fractional" scope="instance" type="Boolean|Array">
        <description>Whether to include the fractional portion, where the number of decimal places are implied by the currency
	or explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
	By default for currencies, it the fractional portion is optional.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.data"/>
  <class type="dojo.data.ItemFileReadStore" superclass="dojo.data.util.simpleFetch">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="_getItemsArray" scope="instance">
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional">
            <description>The query options parameter, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getItemsFromLoadedData" scope="instance">
        <description>Function to parse the loaded data into item format and build the internal items array.</description>
        <parameters>
          <parameter name="dataObject" type="Object" usage="required">
            <description>The JS data object containing the raw data to convery into item format.</description>
          </parameter>
        </parameters>
        <return-description>array
	Array of items in store item format.</return-description>
      </method>
      <method name="_addReferenceToMap" scope="instance">
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item that holds the new reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the new reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemByIdentity" scope="instance">
        <parameters>
          <parameter name="identity" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_forceLoad" scope="instance"/>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="_ccUrl" scope="instance-prototype" type="String"/>
      <property name="data" scope="instance-prototype" type="Object"/>
      <property name="typeMap" scope="instance" type="Object"/>
      <property name="clearOnClose" scope="instance-prototype" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="bool"/>
      <property name="failOk" scope="instance-prototype" type="bool"/>
      <property name="hierarchical" scope="instance-prototype" type="Object"/>
      <property name="_jsonFileUrl" scope="instance-prototype" type="Object"/>
      <property name="_jsonData" scope="instance-prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_loadFinished" scope="instance-prototype" type="bool"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfTopLevelItems" scope="instance-prototype" type="Array"/>
      <property name="_itemsByIdentity" scope="instance-prototype" type="Object"/>
      <property name="_labelAttr" scope="instance" type="Object"/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_storeRefPropName" scope="instance" type="String"/>
      <property name="_itemNumPropName" scope="instance" type="String"/>
      <property name="_rootItemPropName" scope="instance" type="String"/>
      <property name="_reverseRefMap" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileReadStore._features.dojo.data.api">
    <properties>
      <property name="Identity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileReadStore._datatypeMap">
    <properties>
      <property name="Date" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileWriteStore" superclass="dojo.data.ItemFileReadStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="object" usage="required">
            <description>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  It is serialized assuming object.toString()
	serialization.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	serialize:	function(object) //The function that converts the object back into the proper file format form.
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assert" scope="instance">
        <parameters>
          <parameter name="condition" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getIdentifierAttribute" scope="instance"/>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="_removeArrayElement" scope="instance">
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="element" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="almost" usage="required">
            <description>anything</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueOrValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="newValueOrValues" type="anything" usage="required"/>
          <parameter name="callOnSet" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_addReferenceToMap" scope="instance">
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item that holds the new reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the new reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeReferenceFromMap" scope="instance">
        <description>Method to remove an reference map entry for an item and attribute.  This will
	also perform cleanup on the map such that if there are no more references at all to
	the item, its reference object and entry are removed.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item holding a reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="strin" usage="required">
            <description>The attribute on parentItem that contains the reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_dumpReferenceMap" scope="instance">
        <description>Function to dump the reverse reference map of all items in the store for debug purposes.</description>
      </method>
      <method name="_getValueOrValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_flatten" scope="instance">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewFileContentString" scope="instance"/>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="something" type="The" usage="required">
            <description>array or object to examine.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onSet" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
        </parameters>
      </method>
      <method name="onNew" scope="instance">
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <description>Over-ride of base close function of ItemFileReadStore to add in check for store state.
	If the store is still dirty (unsaved changes), then an error will be thrown instead of
	clearing the internal state for reload from the url.</description>
        <parameters>
          <parameter name="request" type="object" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.data.ItemFileReadStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="referenceIntegrity" scope="instance-prototype" type="bool"/>
      <property name="_saveInProgress" scope="instance-prototype" type="bool"/>
      <property name="_pending" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileWriteStore._features.dojo.data.api">
    <properties>
      <property name="Write" scope="instance" type="Object"/>
      <property name="Notification" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.ItemFileWriteStore._datatypeMap.Date">
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.data.ObjectStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="The" usage="required">
            <description>configuration information to pass into the data store.
	options.objectStore:
	The object store to use as the source provider for this data store</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <description>The item to get the value from</description>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <description>property to look up value for</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>the default value</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="property" type="string" usage="required">
            <description>property to look up value for</description>
          </parameter>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>attribute: /* string</description>
          </parameter>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <examples>
          <example>store.loadItem({
	item: item, // this item may or may not be loaded
	onItem: function(item){
	// do something with the item
	}
	});</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="data" type="object" usage="required">
            <description>The data to be added in as an item.</description>
          </parameter>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>to delete</description>
          </parameter>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changing" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="_deleting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="instance"/>
      <method name="onNew" scope="instance"/>
      <method name="onDelete" scope="instance"/>
    </methods>
    <properties>
      <property name="objectStore" scope="instance" type="Object"/>
      <property name="labelProperty" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.data.ObjectStore._dirtyObjects">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.data.api"/>
  <class type="dojo.data.api.Identity" superclass="dojo.data.api.Read">
    <methods>
      <method name="getFeatures" scope="instance"/>
      <method name="getIdentity" scope="instance">
        <examples>
          <example>	var itemId = store.getIdentity(kermit);
		assert(kermit === store.findByIdentity(store.getIdentity(kermit)));</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item from the store from which to obtain its identifier.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <examples>
          <example>	var itemId = store.getIdentity(kermit);
		var identifiers = store.getIdentityAttributes(itemId);
		assert(typeof identifiers === "array" || identifiers === null);</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item from the store from which to obtain the array of public attributes that
	compose the identifier, if any.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>An anonymous object that defines the item to locate and callbacks to invoke when the
	item has been located and load has completed.  The format of the object is as follows:
	{
	identity: string|object,
	onItem: Function,
	onError: Function,
	scope: object
	}
	The *identity* parameter.
	The identity parameter is the identity of the item you wish to locate and load
	This attribute is required.  It should be a string or an object that toString()
	can be called on.
	The *onItem* parameter.
	Function(item)
	The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
	parameter, the item located, or null if none found.
	The *onError* parameter.
	Function(error)
	The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
	parameter, the error object
	The *scope* parameter.
	If a scope object is provided, all of the callback functions (onItem,
	onError, etc) will be invoked in the context of the scope object.
	In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global.
	For example, onItem.call(scope, item, request) vs.
	onItem.call(dojo.global, item, request)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.data.api.Read" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.data.api.Notification" superclass="dojo.data.api.Read">
    <description>This API defines a set of APIs that all datastores that conform to the
	Notifications API must implement.  In general, most stores will implement
	these APIs as no-op functions for users who wish to monitor them to be able
	to connect to then via dojo.connect().  For non-users of dojo.connect,
	they should be able to just replace the function on the store to obtain
	notifications.  Both read-only and read-write stores may implement
	this feature.  In the case of a read-only store, this feature makes sense if
	the store itself does internal polling to a back-end server and periodically updates
	its cache of items (deletes, adds, and updates).</description>
    <methods>
      <method name="getFeatures" scope="instance"/>
      <method name="onSet" scope="instance">
        <description>This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
	Its purpose is to provide a hook point for those who wish to monitor actions on items in the store
	in a simple manner.  The general expected usage is to dojo.connect() to the store's
	implementation and be called after the store function is called.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item being modified.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute being changed represented as a string name.</description>
          </parameter>
          <parameter name="oldValue" type="object" usage="required">
            <description>The old value of the attribute.  In the case of single value calls, such as setValue, unsetAttribute, etc,
	this value will be generally be an atomic value of some sort (string, int, etc, object).  In the case of
	multi-valued attributes, it will be an array.</description>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <description>The new value of the attribute.  In the case of single value calls, such as setValue, this value will be
	generally be an atomic value of some sort (string, int, etc, object).  In the case of multi-valued attributes,
	it will be an array.  In the case of unsetAttribute, the new value will be 'undefined'.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="onNew" scope="instance">
        <description>This function is called any time a new item is created in the store.
	It is called immediately after the store newItem processing has completed.</description>
        <parameters>
          <parameter name="newItem" type="item" usage="required">
            <description>The item created.</description>
          </parameter>
          <parameter name="parentInfo" type="object" usage="optional">
            <description>An optional javascript object that is passed when the item created was placed in the store
	hierarchy as a value f another item's attribute, instead of a root level item.  Note that if this
	function is invoked with a value for parentInfo, then onSet is not invoked stating the attribute of
	the parent item was modified.  This is to avoid getting two notification  events occurring when a new item
	with a parent is created.  The structure passed in is as follows:
	{
	item: someItem,							//The parent item
	attribute:	&amp;quot;attribute-name-string&amp;quot;,	//The attribute the new item was assigned to.
	oldValue: something	//Whatever was the previous value for the attribute.
	//If it is a single-value attribute only, then this value will be a single value.
	//If it was a multi-valued attribute, then this will be an array of all the values minues the new one.
	newValue: something	//The new value of the attribute.  In the case of single value calls, such as setValue, this value will be
	//generally be an atomic value of some sort (string, int, etc, object).  In the case of multi-valued attributes,
	//it will be an array.
	}</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="onDelete" scope="instance">
        <description>This function is called any time an item is deleted from the store.
	It is called immediately after the store deleteItem processing has completed.</description>
        <parameters>
          <parameter name="deletedItem" type="item" usage="required">
            <description>The item deleted.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.data.api.Read" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.data.api.Read">
    <methods>
      <method name="getValue" scope="instance">
        <description>Saying that an "item x does not have a value for an attribute y"
	is identical to saying that an "item x does not have attribute y".
	It is an oxymoron to say "that attribute is present but has no values"
	or "the item has that attribute but does not have any attribute values".
	If store.hasAttribute(item, attribute) returns false, then
	store.getValue(item, attribute) will return undefined.</description>
        <examples>
          <example>	var darthVader = store.getValue(lukeSkywalker, "father");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access values on.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to access represented as a string.</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>Optional. A default value to use for the getValue return in the attribute does not exist or has no value.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="a literal, an item, null, or undefined (never an array)"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <examples>
          <example>	var friendsOfLuke = store.getValues(lukeSkywalker, "friends");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access values on.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to access represented as a string.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="an array that may contain literals and items"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <examples>
          <example>	var array = store.getAttributes(kermit);</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access attributes on.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <examples>
          <example>	var trueOrFalse = store.hasAttribute(kermit, "color");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access attributes on.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to access represented as a string.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <examples>
          <example>	var trueOrFalse = store.containsValue(kermit, "color", "green");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to access values on.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to access represented as a string.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match as a value for the attribute.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <examples>
          <example>	var yes = store.isItem(store.newItem());
		var no  = store.isItem("green");</example>
        </examples>
        <parameters>
          <parameter name="something" type="anything" usage="required">
            <description>Can be anything.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <examples>
          <example>	var yes = store.isItemLoaded(store.newItem());
		var no  = store.isItemLoaded("green");</example>
        </examples>
        <parameters>
          <parameter name="something" type="anything" usage="required">
            <description>Can be anything.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>An anonymous object that defines the item to load and callbacks to invoke when the
	load has completed.  The format of the object is as follows:
	{
	item: object,
	onItem: Function,
	onError: Function,
	scope: object
	}
	The *item* parameter.
	The item parameter is an object that represents the item in question that should be
	contained by the store.  This attribute is required.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <description>A Request object will always be returned and is returned immediately.
	The basic request is nothing more than the keyword args passed to fetch and
	an additional function attached, abort().  The returned request object may then be used
	to cancel a fetch.  All data items returns are passed through the callbacks defined in the
	fetch parameters and are not present on the 'request' object.
	This does not mean that custom stores can not add methods and properties to the request object
	returned, only that the API does not require it.  For more info about the Request API,
	see dojo.data.api.Request</description>
        <examples>
          <example>Fetch all books identified by the query and call 'showBooks' when complete
		var request = store.fetch({query:"all books", onComplete: showBooks});</example>
          <example>Fetch all items in the story and call 'showEverything' when complete.
		var request = store.fetch(onComplete: showEverything);</example>
          <example>Fetch only 10 books that match the query 'all books', starting at the fifth book found during the search.
	This demonstrates how paging can be done for specific queries.
		var request = store.fetch({query:"all books", start: 4, count: 10, onComplete: showBooks});</example>
          <example>Fetch all items that match the query, calling 'callback' each time an item is located.
		var request = store.fetch({query:"foo/bar", onItem:callback});</example>
          <example>Fetch the first 100 books by author King, call showKing when up to 100 items have been located.
		var request = store.fetch({query:{author:"King"}, start: 0, count:100, onComplete: showKing});</example>
          <example>Locate the books written by Author King, sort it on title and publisher, then return the first 100 items from the sorted items.
		var request = store.fetch({query:{author:"King"}, sort: [{ attribute: "title", descending: true}, {attribute: "publisher"}], ,start: 0, count:100, onComplete: 'showKing'});</example>
          <example>Fetch the first 100 books by authors starting with the name King, then call showKing when up to 100 items have been located.
		var request = store.fetch({query:{author:"King*"}, start: 0, count:100, onComplete: showKing});</example>
          <example>Fetch the first 100 books by authors ending with 'ing', but only have one character before it (King, Bing, Ling, Sing, etc.), then call showBooks when up to 100 items have been located.
		var request = store.fetch({query:{author:"?ing"}, start: 0, count:100, onComplete: showBooks});</example>
          <example>Fetch the first 100 books by author King, where the name may appear as King, king, KING, kInG, and so on, then call showKing when up to 100 items have been located.
		var request = store.fetch({query:{author:"King"}, queryOptions:(ignoreCase: true}, start: 0, count:100, onComplete: showKing});</example>
          <example>Paging
		var store = new dojo.data.LargeRdbmsStore({url:"jdbc:odbc:foobar"});
		var fetchArgs = {
			query: {type:"employees", name:"Hillary *"}, // string matching
			sort: [{attribute:"department", descending:true}],
			start: 0,
			count: 20,
			scope: displayer,
			onBegin: showThrobber,
			onItem: displayItem,
			onComplete: stopThrobber,
			onError: handleFetchError,
		};
		store.fetch(fetchArgs);
		...
	and then when the user presses the "Next Page" button...
		fetchArgs.start += 20;
		store.fetch(fetchArgs);  // get the next 20 items</example>
        </examples>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required">
            <description>The keywordArgs parameter may either be an instance of
	conforming to dojo.data.api.Request or may be a simple anonymous object
	that may contain any of the following:
	{
	query: query-object or query-string,
	queryOptions: object,
	onBegin: Function,
	onItem: Function,
	onComplete: Function,
	onError: Function,
	scope: object,
	start: int
	count: int
	sort: array
	}
	All implementations should accept keywordArgs objects with any of
	the 9 standard properties: query, onBegin, onItem, onComplete, onError
	scope, sort, start, and count.  Some implementations may accept additional
	properties in the keywordArgs object as valid parameters, such as
	{includeOutliers:true}.
	The *query* parameter.
	The query may be optional in some data store implementations.
	The dojo.data.api.Read API does not specify the syntax or semantics
	of the query itself -- each different data store implementation
	may have its own notion of what a query should look like.
	However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
	and dojox.data support an object structure query, where the object is a set of
	name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
	dijit widgets, such as ComboBox assume this to be the case when working with a datastore
	when they dynamically update the query.  Therefore, for maximum compatibility with dijit
	widgets the recommended query parameter is a key/value object.  That does not mean that the
	the datastore may not take alternative query forms, such as a simple string, a Date, a number,
	or a mix of such.  Ultimately, The dojo.data.api.Read API is agnostic about what the query
	format.
	Further note:  In general for query objects that accept strings as attribute
	value matches, the store should also support basic filtering capability, such as *
	(match any character) and ? (match single character).  An example query that is a query object
	would be like: { attrFoo: &amp;quot;value*&amp;quot;}.  Which generally means match all items where they have
	an attribute named attrFoo, with a value that starts with 'value'.
	The *queryOptions* parameter
	The queryOptions parameter is an optional parameter used to specify optiosn that may modify
	the query in some fashion, such as doing a case insensitive search, or doing a deep search
	where all items in a hierarchical representation of data are scanned instead of just the root
	items.  It currently defines two options that all datastores should attempt to honor if possible:
	{
	ignoreCase: boolean, //Whether or not the query should match case sensitively or not.  Default behaviour is false.
	deep: boolean 	//Whether or not a fetch should do a deep search of items and all child
	//items instead of just root-level items in a datastore.  Default is false.
	}
	The *onBegin* parameter.
	function(size, request);
	If an onBegin callback function is provided, the callback function
	will be called just once, before the first onItem callback is called.
	The onBegin callback function will be passed two arguments, the
	the total number of items identified and the Request object.  If the total number is
	unknown, then size will be -1.  Note that size is not necessarily the size of the
	collection of items returned from the query, as the request may have specified to return only a
	subset of the total set of items through the use of the start and count parameters.
	The *onItem* parameter.
	function(item, request);
	If an onItem callback function is provided, the callback function
	will be called as each item in the result is received. The callback
	function will be passed two arguments: the item itself, and the
	Request object.
	The *onComplete* parameter.
	function(items, request);
	If an onComplete callback function is provided, the callback function
	will be called just once, after the last onItem callback is called.
	Note that if the onItem callback is not present, then onComplete will be passed
	an array containing all items which matched the query and the request object.
	If the onItem callback is present, then onComplete is called as:
	onComplete(null, request).
	The *onError* parameter.
	function(errorData, request);
	If an onError callback function is provided, the callback function
	will be called if there is any sort of error while attempting to
	execute the query.
	The onError callback function will be passed two arguments:
	an Error object and the Request object.
	The *scope* parameter.
	If a scope object is provided, all of the callback functions (onItem,
	onComplete, onError, etc) will be invoked in the context of the scope
	object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global().
	For example, onItem.call(scope, item, request) vs.
	onItem.call(dojo.global(), item, request)
	The *start* parameter.
	If a start parameter is specified, this is a indication to the datastore to
	only start returning items once the start number of items have been located and
	skipped.  When this parameter is paired withh 'count', the store should be able
	to page across queries with millions of hits by only returning subsets of the
	hits for each query
	The *count* parameter.
	If a count parameter is specified, this is a indication to the datastore to
	only return up to that many items.  This allows a fetch call that may have
	millions of item matches to be paired down to something reasonable.
	The *sort* parameter.
	If a sort parameter is specified, this is a indication to the datastore to
	sort the items in some manner before returning the items.  The array is an array of
	javascript objects that must conform to the following format to be applied to the
	fetching of items:
	{
	attribute: attribute || attribute-name-string,
	descending: true|false;   // Optional.  Default is false.
	}
	Note that when comparing attributes, if an item contains no value for the attribute
	(undefined), then it the default ascending sort logic should push it to the bottom
	of the list.  In the descending order case, it such items should appear at the top of the list.</description>
          </parameter>
        </parameters>
        <return-description>The fetch() method will return a javascript object conforming to the API
	defined in dojo.data.api.Request.  In general, it will be the keywordArgs
	object returned with the required functions in Request.js attached.
	Its general purpose is to provide a convenient way for a caller to abort an
	ongoing fetch.
	The Request object may also have additional properties when it is returned
	such as request.store property, which is a pointer to the datastore object that
	fetch() is a method of.</return-description>
        <return-types>
          <return-type type="an object conforming to the dojo.data.api.Request API"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="close" scope="instance">
        <description>The close() method is intended for instructing the store to 'close' out
	any information associated with a particular request.  In general, this API
	expects to recieve as a parameter a request object returned from a fetch.
	It will then close out anything associated with that request, such as
	clearing any internal datastore caches and closing any 'open' connections.
	For some store implementations, this call may be a no-op.</description>
        <examples>
          <example>	var request = store.fetch({onComplete: doSomething});
		...
		store.close(request);</example>
        </examples>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>An instance of a request for the store to use to identify what to close out.
	If no request is passed, then the store should clear all internal caches (if any)
	and close out all 'open' connections.  It does not render the store unusable from
	there on, it merely cleans out any current data and resets the store to initial
	state.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <description>Method to inspect the item and return a user-readable 'label' for the item
	that provides a general/adequate description of what the item is.  In general
	most labels will be a specific attribute value or collection of the attribute
	values that combine to label the item in some manner.  For example for an item
	that represents a person it may return the label as:  "firstname lastlame" where
	the firstname and lastname are attributes on the item.  If the store is unable
	to determine an adequate human readable label, it should return undefined.  Users that wish
	to customize how a store instance labels items should replace the getLabel() function on
	their instance of the store, or extend the store and replace the function in
	the extension class.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to return the label for.</description>
          </parameter>
        </parameters>
        <return-description>A user-readable string representing the item or undefined if no user-readable label can
	be generated.</return-description>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <description>Method to inspect the item and return an array of what attributes of the item were used
	to generate its label, if any.  This function is to assist UI developers in knowing what
	attributes can be ignored out of the attributes an item has when displaying it, in cases
	where the UI is using the label as an overall identifer should they wish to hide
	redundant information.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to return the list of label attributes for.</description>
          </parameter>
        </parameters>
        <return-description>An array of attribute names that were used to generate the label, or null if public attributes
	were not used to generate the label.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojo.data.api.Request">
    <methods>
      <method name="abort" scope="instance">
        <description>This function is a hook point for stores to provide as a way for
	a fetch to be halted mid-processing.  For more details on the fetch() api,
	please see dojo.data.api.Read.fetch().</description>
      </method>
    </methods>
  </class>
  <class type="dojo.data.api.Write" superclass="dojo.data.api.Read">
    <methods>
      <method name="getFeatures" scope="instance"/>
      <method name="newItem" scope="instance">
        <examples>
          <example>	var kermit = store.newItem({name: "Kermit", color:[blue, green]});</example>
        </examples>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional">
            <description>A javascript object defining the initial content of the item as a set of JavaScript 'property name: value' pairs.</description>
          </parameter>
          <parameter name="parentInfo" type="Object" usage="optional">
            <description>An optional javascript object defining what item is the parent of this item (in a hierarchical store.  Not all stores do hierarchical items),
	and what attribute of that parent to assign the new item to.  If this is present, and the attribute specified
	is a multi-valued attribute, it will append this item into the array of values for that attribute.  The structure
	of the object is as follows:
	{
	parent: someItem,
	attribute: &amp;quot;attribute-name-string&amp;quot;
	}</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="instance">
        <examples>
          <example>	var success = store.deleteItem(kermit);</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to delete.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="instance">
        <examples>
          <example>	var success = store.set(kermit, "color", "green");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to modify.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute of the item to change represented as a string name.</description>
          </parameter>
          <parameter name="value" type="almost" usage="required">
            <description>The value to assign to the item.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <examples>
          <example>	var success = store.setValues(kermit, "color", ["green", "aqua"]);
		success = store.setValues(kermit, "color", []);
		if (success) {assert(!store.hasAttribute(kermit, "color"));}</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to modify.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute of the item to change represented as a string name.</description>
          </parameter>
          <parameter name="values" type="array" usage="required">
            <description>An array of values to assign to the attribute..</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="instance">
        <examples>
          <example>	var success = store.unsetAttribute(kermit, "color");
		if (success) {assert(!store.hasAttribute(kermit, "color"));}</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to modify.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute of the item to unset represented as a string.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <examples>
          <example>	store.save({onComplete: onSave});
		store.save({scope: fooObj, onComplete: onSave, onError: saveFailed});</example>
        </examples>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>{ onComplete: function
	onError: function
	scope: object
	}
	The *onComplete* parameter.
	function();
	If an onComplete callback function is provided, the callback function
	will be called just once, after the save has completed.  No parameters
	are generally passed to the onComplete.
	The *onError* parameter.
	function(errorData);
	If an onError callback function is provided, the callback function
	will be called if there is any sort of error while attempting to
	execute the save.  The onError function will be based one parameter, the
	error.
	The *scope* parameter.
	If a scope object is provided, all of the callback function (
	onComplete, onError, etc) will be invoked in the context of the scope
	object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global.
	For example, onComplete.call(scope) vs.
	onComplete.call(dojo.global)</description>
          </parameter>
        </parameters>
        <return-description>Nothing.  Since the saves are generally asynchronous, there is
	no need to return anything.  All results are passed via callbacks.</return-description>
      </method>
      <method name="revert" scope="instance">
        <description>Discards any unsaved changes.</description>
        <examples>
          <example>	var success = store.revert();</example>
        </examples>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <examples>
          <example>	var trueOrFalse = store.isDirty(kermit); // true if kermit is dirty
		var trueOrFalse = store.isDirty();       // true if any item is dirty</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="optional">
            <description>The item to check.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.data.api.Read" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.data.util.filter">
    <methods>
      <method name="patternToRegExp" scope="instance">
        <description>Returns a regular expression object that conforms to the defined conversion rules.
	For example:
	ca*   -&gt; /^ca.*$/
	*ca*  -&gt; /^.*ca.*$/
	*c\*a*  -&gt; /^.*c\*a.*$/
	*c\*a?*  -&gt; /^.*c\*a..*$/
	and so on.</description>
        <parameters>
          <parameter name="pattern" type="String" usage="required">
            <description>string A simple matching pattern to convert that follows basic rules:
	* Means match anything, so ca* means match anything starting with ca
	? Means match single character.  So, b?b will match to bob and bab, and so on.
	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	represented by \\ to be treated as an ordinary \ character instead of an escape.</description>
          </parameter>
          <parameter name="ignoreCase" type="boolean" usage="optional">
            <description>An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	By default, it is assumed case sensitive.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="RegExp"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.data.util"/>
  <class type="dojo.data.util.simpleFetch">
    <methods>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.data.util.sorter">
    <methods>
      <method name="basicComparator" scope="instance">
        <description>returns 1 if a &gt; b, -1 if a &lt; b, 0 if equal.
	'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	And compared to each other, null is equivalent to undefined.</description>
        <parameters>
          <parameter name="a" type="anything" usage="required"/>
          <parameter name="b" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="createSortFunction" scope="instance">
        <description>The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	Returns the sorting function for this particular list of attributes and sorting directions.</description>
        <parameters>
          <parameter name="sortSpec" type="attributes" usage="required">
            <description>array A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	The objects should be formatted as follows:
	{
	attribute: &amp;quot;attributeName-string&amp;quot; || attribute,
	descending: true|false;   // Default is false.
	}</description>
          </parameter>
          <parameter name="store" type="dojo.data.core.Read" usage="required">
            <description>object The datastore object to look up item values from.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.date.locale">
    <methods>
      <method name="_getZone" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>the date and/or time being formatted.</description>
          </parameter>
          <parameter name="getName" type="boolean" usage="required">
            <description>Whether to return the timezone string (if true), or the offset (if false)</description>
          </parameter>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional">
            <description>The options being used for formatting</description>
          </parameter>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <description>Create a string from a Date object using a known localized pattern.
	By default, this method formats both date and time from dateObject.
	Formatting patterns are chosen appropriate to the locale.  Different
	formatting lengths may be chosen, with "full" used by default.
	Custom patterns may be used or registered with translations using
	the dojo.date.locale.addCustomFormats method.
	Formatting patterns are implemented using [the syntax described at
	unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>the date and/or time to be formatted.  If a time only is formatted,
	the values in the year, month, and day fields are irrelevant.  The
	opposite is true when formatting only dates.</description>
          </parameter>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <description>Create a Date object from a string using a known localized pattern.
	By default, this method parses looking for both date and time in the string.
	Formatting patterns are chosen appropriate to the locale.  Different
	formatting lengths may be chosen, with "full" used by default.
	Custom patterns may be used or registered with translations using
	the dojo.date.locale.addCustomFormats method.
	Formatting patterns are implemented using [the syntax described at
	unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	When two digit years are used, a century is chosen according to a sliding
	window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	year &lt; 100CE requires strict mode.</description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string representation of a date</description>
          </parameter>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="addCustomFormats" scope="instance">
        <description>The user may add custom localized formats where the bundle has properties following the
	same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	The pattern string should match the format used by the CLDR.
	See dojo.date.locale.format() for details.
	The resources must be loaded by dojo.requireLocalization() prior to use</description>
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getGregorianBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNames" scope="instance">
        <parameters>
          <parameter name="item" type="String" usage="required">
            <description>'months' || 'days'</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>'wide' || 'narrow' || 'abbr' (e.g. &amp;quot;Monday&amp;quot;, &amp;quot;Mon&amp;quot;, or &amp;quot;M&amp;quot; respectively, in English)</description>
          </parameter>
          <parameter name="context" type="String" usage="optional">
            <description>'standAlone' || 'format' (default)</description>
          </parameter>
          <parameter name="locale" type="String" usage="optional">
            <description>override locale used to find the names</description>
          </parameter>
        </parameters>
      </method>
      <method name="isWeekend" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getDayOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_getWeekOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="firstDayOfWeek" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.date.locale.__FormatOptions">
    <methods/>
    <properties>
      <property name="selector" scope="instance" type="String">
        <description>choice of 'time','date' (default: date and time)</description>
      </property>
      <property name="formatLength" scope="instance" type="String">
        <description>choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'</description>
      </property>
      <property name="datePattern" scope="instance" type="String">
        <description>override pattern with this string</description>
      </property>
      <property name="timePattern" scope="instance" type="String">
        <description>override pattern with this string</description>
      </property>
      <property name="am" scope="instance" type="String">
        <description>override strings for am in times</description>
      </property>
      <property name="pm" scope="instance" type="String">
        <description>override strings for pm in times</description>
      </property>
      <property name="locale" scope="instance" type="String">
        <description>override the locale used to determine formatting rules</description>
      </property>
      <property name="fullYear" scope="instance" type="Boolean">
        <description>(format only) use 4 digit years whenever 2 digit years are called for</description>
      </property>
      <property name="strict" scope="instance" type="Boolean">
        <description>(parse only) strict parsing, off by default</description>
      </property>
    </properties>
  </class>
  <class type="dojo.date">
    <methods>
      <method name="getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="isLeapYear" scope="instance">
        <description>Leap years are years with an additional day YYYY-02-29, where the
	year number is a multiple of four with the following exception: If
	a year is a multiple of 100, then it is only a leap year if it is
	also a multiple of 400. For example, 1900 was not a leap year, but
	2000 is one.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getTimezoneName" scope="instance">
        <description>Try to get time zone info from toString or toLocaleString method of
	the Date object -- UTC offset is not a time zone.  See
	http://www.twinsun.com/tz/tz-link.htm Note: results may be
	inconsistent across browsers.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>Needed because the timezone may vary with time (daylight savings)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="compare" scope="instance">
        <description>Returns 0 if equal, positive if a &gt; b, else negative.</description>
        <parameters>
          <parameter name="date1" type="Date" usage="required">
            <description>object</description>
          </parameter>
          <parameter name="date2" type="Date" usage="optional">
            <description>object.  If not specified, the current Date is used.</description>
          </parameter>
          <parameter name="portion" type="String" usage="optional">
            <description>A string indicating the &amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; portion of a Date object.
	Compares both &amp;quot;date&amp;quot; and &amp;quot;time&amp;quot; by default.  One of the following:
	&amp;quot;date&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;datetime&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required">
            <description>Date object to start with</description>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;quarter&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</description>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <description>How much to add to the date.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="difference" scope="instance">
        <parameters>
          <parameter name="date1" type="Date" usage="required">
            <description>object</description>
          </parameter>
          <parameter name="date2" type="Date" usage="optional">
            <description>object.  If not specified, the current Date is used.</description>
          </parameter>
          <parameter name="interval" type="String" usage="optional">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;quarter&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.date.stamp">
    <methods>
      <method name="fromISOString" scope="instance">
        <description>Accepts a string formatted according to a profile of ISO8601 as defined by
	[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	The following combinations are valid:
	* dates only
		* yyyy
		* yyyy-MM
		* yyyy-MM-dd
	* times only, with an optional time zone appended
		* THH:mm
		* THH:mm:ss
		* THH:mm:ss.SSS
	* and "datetimes" which could be any combination of the above
	timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	input may return null.  Arguments which are out of bounds will be handled
	by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	Only years between 100 and 9999 are supported.</description>
        <parameters>
          <parameter name="formattedString" type="String" usage="required">
            <description>A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00</description>
          </parameter>
          <parameter name="defaultTime" type="Number" usage="optional">
            <description>Used for defaults for fields omitted in the formattedString.
	Uses 1970-01-01T00:00:00.0Z by default.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="toISOString" scope="instance">
        <description>When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	Does not check bounds.  Only years between 100 and 9999 are supported.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>A Date object</description>
          </parameter>
          <parameter name="options" type="dojo.date.stamp.__Options" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_isoRegExp" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojo.date.stamp.__Options">
    <methods/>
    <properties>
      <property name="selector" scope="instance" type="String">
        <description>&amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; for partial formatting of the Date object.
	Both date and time will be formatted by default.</description>
      </property>
      <property name="zulu" scope="instance" type="Boolean">
        <description>if true, UTC/GMT is used for a timezone</description>
      </property>
      <property name="milliseconds" scope="instance" type="Boolean">
        <description>if true, output milliseconds</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd">
    <methods>
      <method name="_createNode" scope="instance">
        <parameters>
          <parameter name="tag" type="String" usage="required">
            <description>a tag name or empty for SPAN</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_createTrTd" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>a text for TD</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_createSpan" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>a text for SPAN</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_defaultCreator" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a container node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="manager" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="autoScroll" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmousemove event</description>
          </parameter>
        </parameters>
      </method>
      <method name="autoScrollNodes" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>onmousemove event</description>
          </parameter>
        </parameters>
      </method>
      <method name="getUniqueId" scope="instance"/>
      <method name="isFormElement" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_manager" scope="instance" type="Object"/>
      <property name="getViewport" scope="instance" type="Object"/>
      <property name="V_TRIGGER_AUTOSCROLL" scope="instance" type="Number"/>
      <property name="H_TRIGGER_AUTOSCROLL" scope="instance" type="Number"/>
      <property name="V_AUTOSCROLL_VALUE" scope="instance" type="Number"/>
      <property name="H_AUTOSCROLL_VALUE" scope="instance" type="Number"/>
      <property name="autoscroll" scope="instance" type="Object"/>
      <property name="getCopyKeyState" scope="instance" type="Object"/>
      <property name="_uniqueId" scope="instance" type="Number"/>
      <property name="_empty" scope="instance" type="Object"/>
      <property name="common" scope="instance" type="Object"/>
      <property name="constrainedMover" scope="instance" type="Object"/>
      <property name="boxConstrainedMover" scope="instance" type="Object"/>
      <property name="parentConstrainedMover" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Avatar">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="construct" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="update" scope="instance"/>
      <method name="_generateText" scope="instance"/>
    </methods>
    <properties>
      <property name="isA11y" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.dnd.Avatar.manager">
    <properties>
      <property name="source" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.__ContainerArgs">
    <methods>
      <method name="creator" scope="instance"/>
    </methods>
    <properties>
      <property name="skipForm" scope="instance" type="Boolean">
        <description>don't start the drag operation, if clicked on form elements</description>
      </property>
      <property name="dropParent" scope="instance" type="Node|String">
        <description>node or node's id to use as the parent node for dropped items
	(must be underneath the 'node' parameter in the DOM)</description>
      </property>
      <property name="_skipStartup" scope="instance" type="Boolean">
        <description>skip startup(), which collects children, for deferred initialization
	(this is used in the markup mode)</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.Container">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>node or node's id to build the container on</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__ContainerArgs" usage="required">
            <description>a dictionary of parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.dnd.Item"/>
        </return-types>
      </method>
      <method name="setItem" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="data" type="dojo.dnd.Item" usage="required"/>
        </parameters>
      </method>
      <method name="delItem" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="forInItems" scope="instance">
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="clearItems" scope="instance"/>
      <method name="getAllNodes" scope="instance">
        <return-types>
          <return-type type="NodeList"/>
        </return-types>
      </method>
      <method name="sync" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="insertNodes" scope="instance">
        <parameters>
          <parameter name="data" type="Array" usage="required">
            <description>a list of data items, which should be processed by the creator function</description>
          </parameter>
          <parameter name="before" type="Boolean" usage="required">
            <description>insert before the anchor, if true, and after the anchor otherwise</description>
          </parameter>
          <parameter name="anchor" type="Node" usage="required">
            <description>the anchor node to be used as a point of insertion</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onSelectStart" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="_changeState" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>a name of the state to change</description>
          </parameter>
          <parameter name="newState" type="String" usage="required">
            <description>new state</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addItemClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>a variable suffix for a class name</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeItemClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>a variable suffix for a class name</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getChildByEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>a mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_normalizedCreator" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.dnd.Item" usage="required"/>
          <parameter name="hint" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="skipForm" scope="instance-prototype" type="bool"/>
      <property name="current" scope="instance-prototype" type="DomNode">
        <description>The DOM node the mouse is currently hovered over</description>
      </property>
      <property name="map" scope="instance-prototype" type="Object">
        <description>dojo.dnd.Item&amp;gt;
	Map from an item's id (which is also the DOMNode's id) to
	the dojo.dnd.Item itself.</description>
      </property>
      <property name="creator" scope="instance-prototype" type="Object">
        <description>creator function, dummy at the moment</description>
      </property>
      <property name="node" scope="instance-prototype" type="Node">
        <description>node or node's id to build the container on
	params: dojo.dnd.__ContainerArgs
	a dictionary of parameters</description>
      </property>
      <property name="parent" scope="instance-prototype" type="Object"/>
      <property name="defaultCreator" scope="instance" type="Object"/>
      <property name="containerState" scope="instance" type="String"/>
      <property name="events" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo.dnd.Item">
    <methods/>
    <properties>
      <property name="type" scope="instance" type="Array&lt;String&gt;">
        <description>Type(s) of this item, by default this is [&amp;quot;text&amp;quot;]</description>
      </property>
      <property name="data" scope="instance" type="Object">
        <description>Logical representation of the object being dragged.
	If the drag object's type is &amp;quot;text&amp;quot; then data is a String,
	if it's another type then data could be a different Object,
	perhaps a name/value hash.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd._defaultCreatorNodes">
    <properties>
      <property name="ul" scope="instance" type="String"/>
      <property name="ol" scope="instance" type="String"/>
      <property name="div" scope="instance" type="String"/>
      <property name="p" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.dnd.Manager">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="overSource" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the reporter</description>
          </parameter>
        </parameters>
      </method>
      <method name="outSource" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the reporter</description>
          </parameter>
        </parameters>
      </method>
      <method name="startDrag" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="stopDrag" scope="instance"/>
      <method name="makeAvatar" scope="instance"/>
      <method name="updateAvatar" scope="instance"/>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>keyboard event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>keyboard event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setCopyStatus" scope="instance">
        <parameters>
          <parameter name="copy" type="Boolean" usage="required">
            <description>the copy status</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="OFFSET_X" scope="instance" type="Number"/>
      <property name="OFFSET_Y" scope="instance" type="Number"/>
      <property name="target" scope="instance-prototype" type="Object"/>
      <property name="canDropFlag" scope="instance-prototype" type="bool"/>
      <property name="source" scope="instance-prototype" type="Object"/>
      <property name="nodes" scope="instance-prototype" type="Array"/>
      <property name="copy" scope="instance-prototype" type="Object"/>
      <property name="avatar" scope="instance-prototype" type="Object"/>
      <property name="events" scope="instance-prototype" type="Array"/>
    </properties>
  </class>
  <class type="dojo.dnd.Manager.canDrop">
    <methods/>
    <properties>
      <property name="target" scope="instance" type="Object"/>
      <property name="canDropFlag" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Manager.avatar.node"/>
  <class type="dojo.dnd.Manager.avatar.node.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.dnd.__MoveableArgs">
    <methods/>
    <properties>
      <property name="handle" scope="instance" type="Node|String">
        <description>A node (or node's id), which is used as a mouse handle.
	If omitted, the node itself is used as a handle.</description>
      </property>
      <property name="delay" scope="instance" type="Number">
        <description>delay move by this number of pixels</description>
      </property>
      <property name="skip" scope="instance" type="Boolean">
        <description>skip move of form elements</description>
      </property>
      <property name="mover" scope="instance" type="Object">
        <description>a constructor of custom Mover</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.Moveable">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__MoveableArgs" usage="optional">
            <description>optional parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse/touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse/touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onSelectStart" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragDetected" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStart" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMoving" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoved" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="handle" scope="instance-prototype" type="Object"/>
      <property name="delay" scope="instance-prototype" type="Number"/>
      <property name="skip" scope="instance-prototype" type="bool"/>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="node" scope="instance-prototype" type="Node">
        <description>a node (or node's id) to be moved
	params: dojo.dnd.__MoveableArgs?
	optional parameters</description>
      </property>
      <property name="_lastX" scope="instance" type="Object"/>
      <property name="_lastY" scope="instance" type="Object"/>
      <property name="mover" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Mover">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <description>a mouse event, which started the move;
	only pageX and pageY properties are used</description>
          </parameter>
          <parameter name="host" type="Object" usage="optional">
            <description>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse/touch event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="host" scope="instance-prototype" type="Object">
        <description>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</description>
      </property>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="mouseButton" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Mover.node"/>
  <class type="dojo.dnd.Mover.node.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.dnd.Mover.marginBox">
    <properties>
      <property name="l" scope="instance" type="Number"/>
      <property name="t" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.dnd.__SelectorArgs" superclass="dojo.dnd.__ContainerArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.dnd.__ContainerArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="singular" scope="instance" type="Boolean">
        <description>allows selection of only one element, if true</description>
      </property>
      <property name="autoSync" scope="instance" type="Boolean">
        <description>autosynchronizes the source with its list of DnD nodes,</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.Selector" superclass="dojo.dnd.Container">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node|String" usage="required">
            <description>node or node's id to build the selector on</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SelectorArgs" usage="optional">
            <description>a dictionary of parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="getSelectedNodes" scope="instance">
        <return-types>
          <return-type type="NodeList"/>
        </return-types>
      </method>
      <method name="selectNone" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="selectAll" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="deleteSelectedNodes" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="forInSelectedItems" scope="instance">
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="sync" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="insertNodes" scope="instance">
        <parameters>
          <parameter name="addSelected" type="Boolean" usage="required">
            <description>all new nodes will be added to selected items, if true, no selection change otherwise</description>
          </parameter>
          <parameter name="data" type="Array" usage="required">
            <description>a list of data items, which should be processed by the creator function</description>
          </parameter>
          <parameter name="before" type="Boolean" usage="required">
            <description>insert before the anchor, if true, and after the anchor otherwise</description>
          </parameter>
          <parameter name="anchor" type="Node" usage="required">
            <description>the anchor node to be used as a point of insertion</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_normalizedCreator" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="hint" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="_removeSelection" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_removeAnchor" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="selection" scope="instance-prototype" type="Object">
        <description>The set of id's that are currently selected, such that this.selection[id] == 1
	if the node w/that id is selected.  Can iterate over selected node's id's like:
			for(var id in this.selection)</description>
      </property>
      <property name="singular" scope="instance-prototype" type="bool"/>
      <property name="anchor" scope="instance-prototype" type="Object"/>
      <property name="simpleSelection" scope="instance-prototype" type="bool"/>
      <property name="onmousemoveEvent" scope="instance" type="Object"/>
      <property name="autoSync" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.Source" superclass="dojo.dnd.Selector">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>node or node's id to build the source on</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SourceArgs" usage="optional">
            <description>any property of this class may be configured via the params
	object which is mixed-in to the &lt;code&gt;dojo.dnd.Source&lt;/code&gt; instance</description>
          </parameter>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="copyState" scope="instance">
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required">
            <description>the &amp;quot;copy&amp;quot; key was pressed</description>
          </parameter>
          <parameter name="self" type="Boolean" usage="optional">
            <description>optional flag that means that we are about to drop on itself</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndSourceOver" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which has the mouse over it</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndStart" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
          <parameter name="target" type="Object" usage="required">
            <description>the target which accepts items</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="onDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDropExternal" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="_normalizedCreator" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="hint" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDropInternal" scope="instance">
        <parameters>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDraggingOver" scope="instance"/>
      <method name="onDraggingOut" scope="instance"/>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="_markTargetAnchor" scope="instance">
        <parameters>
          <parameter name="before" type="Boolean" usage="required">
            <description>insert before, if true, after otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="instance"/>
      <method name="_markDndStatus" scope="instance">
        <parameters>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Selector" scope="instance"/>
    </mixins>
    <properties>
      <property name="isSource" scope="instance" type="Object"/>
      <property name="horizontal" scope="instance" type="bool"/>
      <property name="copyOnly" scope="instance" type="bool"/>
      <property name="selfCopy" scope="instance" type="bool"/>
      <property name="selfAccept" scope="instance" type="Object"/>
      <property name="skipForm" scope="instance" type="bool"/>
      <property name="withHandles" scope="instance" type="bool"/>
      <property name="autoSync" scope="instance" type="bool"/>
      <property name="delay" scope="instance" type="Number"/>
      <property name="accept" scope="instance-prototype" type="Object"/>
      <property name="generateText" scope="instance" type="Object"/>
      <property name="targetAnchor" scope="instance-prototype" type="Object"/>
      <property name="targetBox" scope="instance-prototype" type="Object"/>
      <property name="mouseDown" scope="instance-prototype" type="bool"/>
      <property name="_lastX" scope="instance-prototype" type="Number"/>
      <property name="_lastY" scope="instance-prototype" type="Number"/>
      <property name="isDragging" scope="instance-prototype" type="bool"/>
      <property name="before" scope="instance-prototype" type="Object"/>
      <property name="sourceState" scope="instance" type="String"/>
      <property name="targetState" scope="instance" type="String"/>
      <property name="topics" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojo.dnd.Target" superclass="dojo.dnd.Source">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
    <properties>
      <property name="isSource" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.dnd.AutoSource" superclass="dojo.dnd.Source">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
    <properties>
      <property name="autoSync" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.__SourceArgs">
    <methods/>
    <properties>
      <property name="isSource" scope="instance" type="Boolean">
        <description>can be used as a DnD source. Defaults to true.</description>
      </property>
      <property name="accept" scope="instance" type="Array">
        <description>list of accepted types (text strings) for a target; defaults to
	[&amp;quot;text&amp;quot;]</description>
      </property>
      <property name="autoSync" scope="instance" type="Boolean">
        <description>if true refreshes the node list on every operation; false by default</description>
      </property>
      <property name="copyOnly" scope="instance" type="Boolean">
        <description>copy items, if true, use a state of Ctrl key otherwise,
	see selfCopy and selfAccept for more details</description>
      </property>
      <property name="delay" scope="instance" type="Number">
        <description>the move delay in pixels before detecting a drag; 0 by default</description>
      </property>
      <property name="horizontal" scope="instance" type="Boolean">
        <description>a horizontal container, if true, vertical otherwise or when omitted</description>
      </property>
      <property name="selfCopy" scope="instance" type="Boolean">
        <description>copy items by default when dropping on itself,
	false by default, works only if copyOnly is true</description>
      </property>
      <property name="selfAccept" scope="instance" type="Boolean">
        <description>accept its own items when copyOnly is true,
	true by default, works only if copyOnly is true</description>
      </property>
      <property name="withHandles" scope="instance" type="Boolean">
        <description>allows dragging only by handles, false by default</description>
      </property>
      <property name="generateText" scope="instance" type="Boolean">
        <description>generate text node for drag and drop, true by default</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.__TimedMoveableArgs" superclass="dojo.dnd.__MoveableArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.dnd.__MoveableArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="timeout" scope="instance" type="Number">
        <description>delay move by this number of ms,
	accumulating position changes during the timeout</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.TimedMoveable" superclass="dojo.dnd.Moveable">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node|String" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__TimedMoveableArgs" usage="required">
            <description>object with additional parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Moveable" scope="instance"/>
    </mixins>
    <properties>
      <property name="timeout" scope="instance-prototype" type="Number"/>
    </properties>
  </class>
  <class type="dojo.dnd._validNodes">
    <properties>
      <property name="div" scope="instance" type="Number"/>
      <property name="p" scope="instance" type="Number"/>
      <property name="td" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.dnd._validOverflow">
    <properties>
      <property name="auto" scope="instance" type="Number"/>
      <property name="scroll" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.dnd.move"/>
  <class type="dojo.dnd.move.__constrainedMoveableArgs" superclass="dojo.dnd.__MoveableArgs">
    <methods>
      <method name="constraints" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.__MoveableArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="within" scope="instance" type="Boolean">
        <description>restrict move within boundaries.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.move.constrainedMoveable" superclass="dojo.dnd.Moveable">
    <methods>
      <method name="constraints" scope="instance-prototype"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__constrainedMoveableArgs" usage="optional">
            <description>an optional object with additional parameters;
	the rest is passed to the base class</description>
          </parameter>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Moveable" scope="instance"/>
    </mixins>
    <properties>
      <property name="within" scope="instance-prototype" type="bool"/>
      <property name="constraintBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.dnd.move.__boxConstrainedMoveableArgs" superclass="dojo.dnd.move.__constrainedMoveableArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.dnd.move.__constrainedMoveableArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="box" scope="instance" type="Object">
        <description>a constraint box</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.move.boxConstrainedMoveable" superclass="dojo.dnd.move.constrainedMoveable">
    <methods>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__boxConstrainedMoveableArgs" usage="optional">
            <description>an optional object with parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="constraints" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.move.constrainedMoveable" scope="instance"/>
    </mixins>
    <properties>
      <property name="box" scope="instance" type="object">
        <description>attributes (for markup)</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.move.__parentConstrainedMoveableArgs" superclass="dojo.dnd.move.__constrainedMoveableArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojo.dnd.move.__constrainedMoveableArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="area" scope="instance" type="String">
        <description>A parent's area to restrict the move.
	Can be &amp;quot;margin&amp;quot;, &amp;quot;border&amp;quot;, &amp;quot;padding&amp;quot;, or &amp;quot;content&amp;quot;.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.move.parentConstrainedMoveable" superclass="dojo.dnd.move.constrainedMoveable">
    <methods>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>a node (or node's id) to be moved</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__parentConstrainedMoveableArgs" usage="optional">
            <description>an optional object with parameters</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constraints" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.move.constrainedMoveable" scope="instance"/>
    </mixins>
    <properties>
      <property name="area" scope="instance" type="object">
        <description>attributes (for markup)</description>
      </property>
    </properties>
  </class>
  <class type="dojo.dnd.move.parentConstrainedMoveable.node">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojoConfig">
    <properties>
      <property name="baseUrl" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.fx">
    <methods>
      <method name="chain" scope="instance">
        <description>Return a `dojo.Animation` which will play all passed
	`dojo.Animation` instances in sequence, firing its own
	synthesized events simulating a single animation. (eg:
	onEnd of this animation means the end of the chain,
	not the individual animations within)</description>
        <examples>
          <example>Once `node` is faded out, fade in `otherNode`
		dojo.fx.chain([
			dojo.fadeIn({ node:node }),
			dojo.fadeOut({ node:otherNode })
		]).play();</example>
        </examples>
        <parameters>
          <parameter name="animations" type="Array&lt;dojo.Animation&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="combine" scope="instance">
        <description>Combine an array of `dojo.Animation`s to run in parallel,
	providing a new `dojo.Animation` instance encompasing each
	animation, firing standard animation events.</description>
        <examples>
          <example>Fade out `node` while fading in `otherNode` simultaneously
		dojo.fx.combine([
			dojo.fadeIn({ node:node }),
			dojo.fadeOut({ node:otherNode })
		]).play();</example>
          <example>When the longest animation ends, execute a function:
		var anim = dojo.fx.combine([
			dojo.fadeIn({ node: n, duration:700 }),
			dojo.fadeOut({ node: otherNode, duration: 300 })
		]);
		dojo.connect(anim, "onEnd", function(){
			// overall animation is done.
		});
		anim.play(); // play the animation</example>
        </examples>
        <parameters>
          <parameter name="animations" type="Array&lt;dojo.Animation&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="wipeIn" scope="instance">
        <description>Returns an animation that will expand the
	node defined in 'args' object from it's current height to
	it's natural height (with no scrollbar).
	Node must have no margin/border/padding.</description>
        <examples>
          <example>	dojo.fx.wipeIn({
			node:"someId"
		}).play()</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>A hash-map of standard &lt;code&gt;dojo.Animation&lt;/code&gt; constructor properties
	(such as easing: node: duration: and so on)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="wipeOut" scope="instance">
        <description>Returns an animation that will shrink node defined in "args"
	from it's current height to 1px, and then hide it.</description>
        <examples>
          <example>	dojo.fx.wipeOut({ node:"someId" }).play()</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>A hash-map of standard &lt;code&gt;dojo.Animation&lt;/code&gt; constructor properties
	(such as easing: node: duration: and so on)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="slideTo" scope="instance">
        <description>Returns an animation that will slide "node"
	defined in args Object from its current position to
	the position defined by (args.left, args.top).</description>
        <examples>
          <example>	dojo.fx.slideTo({ node: node, left:"40", top:"50", units:"px" }).play()</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>A hash-map of standard &lt;code&gt;dojo.Animation&lt;/code&gt; constructor properties
	(such as easing: node: duration: and so on). Special args members
	are &lt;code&gt;top&lt;/code&gt; and &lt;code&gt;left&lt;/code&gt;, which indicate the new position to slide to.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.fx.Toggler">
    <description>class constructor for an animation toggler. It accepts a packed
	set of arguments about what type of animation to use in each
	direction, duration, etc. All available members are mixed into
	these animations from the constructor (for example, `node`,
	`showDuration`, `hideDuration`).</description>
    <methods>
      <method name="showFunc" scope="instance"/>
      <method name="hideFunc" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="delay" type="Integer" usage="optional">
            <description>Ammount of time to stall playing the show animation</description>
          </parameter>
        </parameters>
      </method>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="delay" type="Integer" usage="optional">
            <description>Ammount of time to stall playing the hide animation</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="node" scope="instance" type="DomNode">
        <description>the node to target for the showing and hiding animations</description>
      </property>
      <property name="showDuration" scope="instance" type="Time">
        <description>in milliseconds to run the show Animation</description>
      </property>
      <property name="hideDuration" scope="instance" type="Time">
        <description>in milliseconds to run the hide Animation</description>
      </property>
      <property name="_showArgs" scope="instance" type="Object"/>
      <property name="_showAnim" scope="instance" type="Object"/>
      <property name="_hideArgs" scope="instance" type="Object"/>
      <property name="_hideAnim" scope="instance" type="Object"/>
      <property name="_isShowing" scope="instance" type="bool"/>
      <property name="_isHiding" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.fx.easing">
    <description>Easing functions are used to manipulate the iteration through
	an `dojo.Animation`s _Line. _Line being the properties of an Animation,
	and the easing function progresses through that Line determing
	how quickly (or slowly) it should go. Or more accurately: modify
	the value of the _Line based on the percentage of animation completed.
	All functions follow a simple naming convention of "ease type" + "when".
	If the name of the function ends in Out, the easing described appears
	towards the end of the animation. "In" means during the beginning,
	and InOut means both ranges of the Animation will applied, both
	beginning and end.
	One does not call the easing function directly, it must be passed to
	the `easing` property of an animation.</description>
    <methods>
      <method name="linear" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backOut" scope="instance">
        <description>An easing function that pops past the range briefly, and slowly comes back.
	Use caution when the easing will cause values to become negative as some
	properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backInOut" scope="instance">
        <description>An easing function combining the effects of `backIn` and `backOut`.
	Use caution when the easing will cause values to become negative
	as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticIn" scope="instance">
        <description>An easing function the elastically snaps from the start value
	Use caution when the elasticity will cause values to become negative
	as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticOut" scope="instance">
        <description>An easing function that elasticly snaps around the target value,
	near the end of the Animation
	Use caution when the elasticity will cause values to become
	negative as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticInOut" scope="instance">
        <description>An easing function that elasticly snaps around the value, near
	the beginning and end of the Animation.
	Use caution when the elasticity will cause values to become
	negative as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="bounceIn" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
      <method name="bounceOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="bounceInOut" scope="instance">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.gears">
    <methods>
      <method name="_gearsObject" scope="instance">
        <return-types>
          <return-type type="already defined elsewhere"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="available" scope="instance" type="bool">
        <description>True if client is using Google Gears</description>
      </property>
    </properties>
  </class>
  <class type="dojo.html">
    <methods>
      <method name="_secureForInnerHtml" scope="instance">
        <parameters>
          <parameter name="cont" type="String" usage="required">
            <description>An html string for insertion into the dom</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_emptyNode" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>the parent element</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setNodeContent" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>the parent element
	content:
	the content to be set on the parent element.
	This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes</description>
          </parameter>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <description>Unless you need to use the params capabilities of this method, you should use
	dojo.place(cont, node, "only"). dojo.place() has more robust support for injecting
	an HTML string into the DOM, but it only handles inserting an HTML string as DOM
	elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
	or the other capabilities as defined by the params object for this method.</description>
        <examples>
          <example>A safe string/node/nodelist content replacement/injection with hooks for extension
	Example Usage:
	dojo.html.set(node, "some string");
	dojo.html.set(node, contentNode, {options});
	dojo.html.set(node, myNode.childNodes, {options});</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>the parent element that will receive the content</description>
          </parameter>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required">
            <description>the content to be set on the parent element.
	This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes</description>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <description>Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.html._ContentSetter">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="cont" type="String|DomNode|NodeList" usage="optional">
            <description>An html string, node or enumerable list of nodes for insertion into the dom
	If not provided, the object's content property will be used</description>
          </parameter>
          <parameter name="params" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setContent" scope="instance"/>
      <method name="empty" scope="instance"/>
      <method name="onBegin" scope="instance"/>
      <method name="onEnd" scope="instance"/>
      <method name="tearDown" scope="instance"/>
      <method name="onContentError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixin" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="instance"/>
      <method name="_onError" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="consoleText" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="node" scope="instance-prototype" type="DomNode|String">
        <description>An node which will be the parent element that we set content into</description>
      </property>
      <property name="content" scope="instance" type="String|DomNode|Array&lt;DomNode&gt;">
        <description>The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes</description>
      </property>
      <property name="id" scope="instance-prototype" type="String">
        <description>Usually only used internally, and auto-generated with each instance</description>
      </property>
      <property name="cleanContent" scope="instance" type="Boolean">
        <description>Should the content be treated as a full html document,
	and the real content stripped of &amp;lt;html&amp;gt;, &amp;lt;body&amp;gt; wrapper before injection</description>
      </property>
      <property name="extractContent" scope="instance" type="Boolean">
        <description>Should the content be treated as a full html document, and the real content stripped of &amp;lt;html&amp;gt;, &amp;lt;body&amp;gt; wrapper before injection</description>
      </property>
      <property name="parseContent" scope="instance" type="Boolean">
        <description>Should the node by passed to the parser after the new content is set</description>
      </property>
      <property name="parserScope" scope="instance" type="String">
        <description>Flag passed to parser.  Root for attribute names to search for.   If scopeName is dojo,
	will search for data-dojo-type (or dojoType).  For backwards compatibility
	reasons defaults to dojo._scopeName (which is &amp;quot;dojo&amp;quot; except when
	multi-version support is used, when it will be something like dojo16, dojo20, etc.)</description>
      </property>
      <property name="startup" scope="instance" type="Boolean">
        <description>Start the child widgets after parsing them.   Only obeyed if parseContent is true.</description>
      </property>
      <property name="parseResults" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.i18n">
    <methods>
      <method name="getLocalization" scope="instance"/>
      <method name="normalizeLocale" scope="instance">
        <description>All variants are case-insensitive and are separated by '-' as specified in [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	If no locale is specified, the dojo.locale is returned.  dojo.locale is defined by
	the user agent's locale unless overridden by djConfig.</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_requireLocalization" scope="instance">
        <description>Called by the bootstrap, but factored out so that it is only
	included in the build when needed.</description>
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="availableFlatLocales" type="String" usage="optional"/>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_searchLocalePath" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
          <parameter name="down" type="Boolean" usage="required"/>
          <parameter name="searchFunc" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_preloadLocalizations" scope="instance">
        <parameters>
          <parameter name="bundlePrefix" type="String" usage="required"/>
          <parameter name="localesGenerated" type="Array" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.io.iframe">
    <methods>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="fname" type="String" usage="required">
            <description>The name of the iframe. Used for the name attribute on the
	iframe.</description>
          </parameter>
          <parameter name="onloadstr" type="String" usage="required">
            <description>A string of JavaScript that will be executed when the content
	in the iframe loads.</description>
          </parameter>
          <parameter name="uri" type="String" usage="optional">
            <description>The value of the src attribute on the iframe element. If a
	value is not given, then dojo/resources/blank.html will be
	used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSrc" scope="instance">
        <parameters>
          <parameter name="iframe" type="DOMNode" usage="required"/>
          <parameter name="src" type="String" usage="required"/>
          <parameter name="replace" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="doc" scope="instance">
        <parameters>
          <parameter name="iframeNode" type="DOMNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_currentDfd" scope="instance" type="Object"/>
      <property name="_dfdQueue" scope="instance" type="Array"/>
      <property name="_iframeName" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojo.io.iframe.__ioArgs" superclass="dojo.__IoArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.__IoArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="method" scope="instance" type="String">
        <description>The HTTP method to use. &amp;quot;GET&amp;quot; or &amp;quot;POST&amp;quot; are the only supported
	values.  It will try to read the value from the form node's
	method, then try this argument. If neither one exists, then it
	defaults to POST.</description>
      </property>
      <property name="handleAs" scope="instance" type="String">
        <description>Specifies what format the result data should be given to the
	load/handle callback. Valid values are: text, html, xml, json,
	javascript. IMPORTANT: For all values EXCEPT html and xml, The
	server response should be an HTML file with a textarea element.
	The response data should be inside the textarea element. Using an
	HTML document the only reliable, cross-browser way this
	transport can know when the response has loaded. For the html
	handleAs value, just return a normal HTML document.  NOTE: xml
	is now supported with this transport (as of 1.1+); a known issue
	is if the XML document in question is malformed, Internet Explorer
	will throw an uncatchable error.</description>
      </property>
      <property name="content" scope="instance" type="Object">
        <description>If &amp;quot;form&amp;quot; is one of the other args properties, then the content
	object properties become hidden form form elements. For
	instance, a content object of {name1 : &amp;quot;value1&amp;quot;} is converted
	to a hidden form element with a name of &amp;quot;name1&amp;quot; and a value of
	&amp;quot;value1&amp;quot;. If there is not a &amp;quot;form&amp;quot; property, then the content
	object is converted into a name=value&amp;amp;name=value string, by
	using dojo.objectToQuery().</description>
      </property>
    </properties>
  </class>
  <class type="dojo.io"/>
  <class type="dojo.io.iframe.send">
    <methods/>
    <properties>
      <property name="_frame" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io.iframe._fireNextRequest">
    <methods/>
    <properties>
      <property name="_currentDfd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io.iframe._iframeOnload">
    <methods/>
  </class>
  <class type="dojo.io.iframe._iframeOnload._currentDfd"/>
  <class type="dojo.io.iframe._iframeOnload._currentDfd.ioArgs">
    <properties>
      <property name="args" scope="instance" type="Object"/>
      <property name="_contentToClean" scope="instance" type="Object"/>
      <property name="_finished" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.io.script">
    <methods>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="args" type="dojo.io.script.__ioArgs" usage="required"/>
        </parameters>
      </method>
      <method name="attach" scope="instance">
        <description>Attaches the script element to the DOM.  Use this method if you
	just want to attach a script to the DOM and do not care when or
	if it loads.</description>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="_makeScriptDeferred" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_deferredCancel" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredOk" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_addDeadScript" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_validCheck" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_ioCheck" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_resHandle" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_canAttach" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_deadScripts" scope="instance" type="Array"/>
      <property name="_counter" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.io.script.__ioArgs" superclass="dojo.__IoArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.__IoArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="callbackParamName" scope="instance" type="String">
        <description>Deprecated as of Dojo 1.4 in favor of &amp;quot;jsonp&amp;quot;, but still supported for
	legacy code. See notes for jsonp property.</description>
      </property>
      <property name="jsonp" scope="instance" type="c"/>
      <property name="checkString" scope="instance" type="String">
        <description>A string of JavaScript that when evaluated like so:
	&amp;quot;typeof(&amp;quot; + checkString + &amp;quot;) != 'undefined'&amp;quot;
	being true means that the script fetched has been loaded.
	Do not use this if doing a JSONP type of call (use callbackParamName instead).</description>
      </property>
      <property name="frameDoc" scope="instance" type="Document">
        <description>The Document object for a child iframe. If this is passed in, the script
	will be attached to that document. This can be helpful in some comet long-polling
	scenarios with Firefox and Opera.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.io.script._jsonpCallback">
    <methods/>
  </class>
  <class type="dojo.io.script._jsonpCallback.ioArgs">
    <properties>
      <property name="json" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.number">
    <methods>
      <method name="format" scope="instance">
        <description>Create a string from a Number using a known localized pattern.
	Formatting patterns appropriate to the locale are chosen from the
	[Common Locale Data Repository](http://unicode.org/cldr) as well as the appropriate symbols and
	delimiters.
	If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to be formatted</description>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_applyPattern" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to be formatted.</description>
          </parameter>
          <parameter name="pattern" type="String" usage="required">
            <description>a pattern string as described by
	[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)</description>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional">
            <description>_applyPattern is usually called via &lt;code&gt;dojo.number.format()&lt;/code&gt; which
	populates an extra property in the options parameter, &amp;quot;customs&amp;quot;.
	The customs object specifies group and decimal parameters if set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="round" scope="instance">
        <description>Rounds to the nearest value with the given number of decimal places, away from zero if equal.
	Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
	fractional increments also, such as the nearest quarter.
	NOTE: Subject to floating point errors.  See dojox.math.round for experimental workaround.</description>
        <examples>
          <example>&gt;&gt;&gt; dojo.number.round(-0.5)
	-1
	&gt;&gt;&gt; dojo.number.round(162.295, 2)
	162.29  // note floating point error.  Should be 162.3
	&gt;&gt;&gt; dojo.number.round(10.71, 0, 2.5)
	10.75</example>
        </examples>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>The number to round</description>
          </parameter>
          <parameter name="places" type="Number" usage="optional">
            <description>The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	Must be non-negative.</description>
          </parameter>
          <parameter name="increment" type="Number" usage="optional">
            <description>Rounds next place to nearest value of increment/10.  10 by default.</description>
          </parameter>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="m" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_formatAbsolute" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>the number to be formatted, ignores sign</description>
          </parameter>
          <parameter name="pattern" type="String" usage="required">
            <description>the number portion of a pattern (e.g. &lt;code&gt;#,##0.00&lt;/code&gt;)</description>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatAbsoluteOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="regexp" scope="instance">
        <description>Returns regular expression with positive and negative match, group
	and decimal separators</description>
        <parameters>
          <parameter name="options" type="dojo.number.__RegexpOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="parse" scope="instance">
        <description>Create a Number from a string using a known localized pattern.
	Formatting patterns are chosen appropriate to the locale
	and follow the syntax described by
	[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	Note that literal characters in patterns are not supported.</description>
        <parameters>
          <parameter name="expression" type="String" usage="required">
            <description>A string representation of a Number</description>
          </parameter>
          <parameter name="options" type="dojo.number.__ParseOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="NaN"/>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_realNumberRegexp" scope="instance">
        <parameters>
          <parameter name="flags" type="dojo.number.__RealNumberRegexpFlags" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_integerRegexp" scope="instance">
        <parameters>
          <parameter name="flags" type="dojo.number.__IntegerRegexpFlags" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_numberPatternRE" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojo.number.__FormatOptions">
    <methods/>
    <properties>
      <property name="pattern" scope="instance" type="String">
        <description>override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	with this string.  Default value is based on locale.  Overriding this property will defeat
	localization.  Literal characters in patterns are not supported.</description>
      </property>
      <property name="type" scope="instance" type="String">
        <description>choose a format type based on the locale from the following:
	decimal, scientific (not yet supported), percent, currency. decimal by default.</description>
      </property>
      <property name="places" scope="instance" type="Number">
        <description>fixed number of decimal places to show.  This overrides any
	information in the provided pattern.</description>
      </property>
      <property name="round" scope="instance" type="Number">
        <description>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	means do not round.</description>
      </property>
      <property name="locale" scope="instance" type="String">
        <description>override the locale used to determine formatting rules</description>
      </property>
      <property name="fractional" scope="instance" type="Boolean">
        <description>If false, show no decimal places, overriding places and pattern settings.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.number.__FormatAbsoluteOptions">
    <methods/>
    <properties>
      <property name="decimal" scope="instance" type="String">
        <description>the decimal separator</description>
      </property>
      <property name="group" scope="instance" type="String">
        <description>the group separator</description>
      </property>
      <property name="places" scope="instance" type="Number|String">
        <description>number of decimal places.  the range &amp;quot;n,m&amp;quot; will format to m places.</description>
      </property>
      <property name="round" scope="instance" type="Number">
        <description>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	means don't round.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.number.__RegexpOptions">
    <methods/>
    <properties>
      <property name="pattern" scope="instance" type="String">
        <description>override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	with this string.  Default value is based on locale.  Overriding this property will defeat
	localization.</description>
      </property>
      <property name="type" scope="instance" type="String">
        <description>choose a format type based on the locale from the following:
	decimal, scientific (not yet supported), percent, currency. decimal by default.</description>
      </property>
      <property name="locale" scope="instance" type="String">
        <description>override the locale used to determine formatting rules</description>
      </property>
      <property name="strict" scope="instance" type="Boolean">
        <description>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators</description>
      </property>
      <property name="places" scope="instance" type="Number|String">
        <description>number of decimal places to accept: Infinity, a positive number, or
	a range &amp;quot;n,m&amp;quot;.  Defined by pattern or Infinity if pattern not provided.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.number.__ParseOptions">
    <methods/>
    <properties>
      <property name="pattern" scope="instance" type="String">
        <description>override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	with this string.  Default value is based on locale.  Overriding this property will defeat
	localization.  Literal characters in patterns are not supported.</description>
      </property>
      <property name="type" scope="instance" type="String">
        <description>choose a format type based on the locale from the following:
	decimal, scientific (not yet supported), percent, currency. decimal by default.</description>
      </property>
      <property name="locale" scope="instance" type="String">
        <description>override the locale used to determine formatting rules</description>
      </property>
      <property name="strict" scope="instance" type="Boolean">
        <description>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators</description>
      </property>
      <property name="fractional" scope="instance" type="Boolean|Array">
        <description>Whether to include the fractional portion, where the number of decimal places are implied by pattern
	or explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.number.__RealNumberRegexpFlags">
    <methods/>
    <properties>
      <property name="places" scope="instance" type="Number">
        <description>The integer number of decimal places or a range given as &amp;quot;n,m&amp;quot;.  If
	not given, the decimal part is optional and the number of places is
	unlimited.</description>
      </property>
      <property name="decimal" scope="instance" type="String">
        <description>A string for the character used as the decimal point.  Default
	is &amp;quot;.&amp;quot;.</description>
      </property>
      <property name="fractional" scope="instance" type="Boolean|Array">
        <description>Whether decimal places are used.  Can be true, false, or [true,
	false].  Default is [true, false] which means optional.</description>
      </property>
      <property name="exponent" scope="instance" type="Boolean|Array">
        <description>Express in exponential notation.  Can be true, false, or [true,
	false]. Default is [true, false], (i.e. will match if the
	exponential part is present are not).</description>
      </property>
      <property name="eSigned" scope="instance" type="Boolean|Array">
        <description>The leading plus-or-minus sign on the exponent.  Can be true,
	false, or [true, false].  Default is [true, false], (i.e. will
	match if it is signed or unsigned).  flags in regexp.integer can be
	applied.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.number.__IntegerRegexpFlags">
    <methods/>
    <properties>
      <property name="signed" scope="instance" type="Boolean">
        <description>The leading plus-or-minus sign. Can be true, false, or &lt;code&gt;[true,false]&lt;/code&gt;.
	Default is &lt;code&gt;[true, false]&lt;/code&gt;, (i.e. will match if it is signed
	or unsigned).</description>
      </property>
      <property name="separator" scope="instance" type="String">
        <description>The character used as the thousands separator. Default is no
	separator. For more than one symbol use an array, e.g. &lt;code&gt;[&amp;quot;,&amp;quot;, &amp;quot;&amp;quot;]&lt;/code&gt;,
	makes ',' optional.</description>
      </property>
      <property name="groupSize" scope="instance" type="Number">
        <description>group size between separators</description>
      </property>
      <property name="groupSize2" scope="instance" type="Number">
        <description>second grouping, where separators 2..n have a different interval than the first separator (for India)</description>
      </property>
    </properties>
  </class>
  <class type="dojo.regexp">
    <methods>
      <method name="escapeString" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="except" type="String" usage="optional">
            <description>a String with special characters to be left unescaped</description>
          </parameter>
        </parameters>
      </method>
      <method name="buildGroupRE" scope="instance">
        <description>A utility function used by some of the RE generators. The
	subexpressions are constructed by the function, re, in the second
	parameter.  re builds one subexpression for each elem in the array
	a, in the first parameter. Returns a string for a regular
	expression that groups all the subexpressions.</description>
        <parameters>
          <parameter name="arr" type="Object|Array" usage="required">
            <description>A single value or an array of values.</description>
          </parameter>
          <parameter name="re" type="Function" usage="required">
            <description>A function. Takes one parameter and converts it to a regular
	expression.</description>
          </parameter>
          <parameter name="nonCapture" type="Boolean" usage="optional">
            <description>If true, uses non-capturing match, otherwise matches are retained
	by regular expression. Defaults to false</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="group" scope="instance">
        <parameters>
          <parameter name="expression" type="String" usage="required"/>
          <parameter name="nonCapture" type="Boolean" usage="optional">
            <description>If true, uses non-capturing match, otherwise matches are retained
	by regular expression.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.rpc"/>
  <class type="dojo.rpc.JsonService" superclass="dojo.rpc.RpcService">
    <methods>
      <method name="callRemote" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>the name of the remote method you want to call.</description>
          </parameter>
          <parameter name="params" type="array" usage="required">
            <description>array of parameters to pass to method</description>
          </parameter>
        </parameters>
      </method>
      <method name="bind" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>The name of the method we are calling</description>
          </parameter>
          <parameter name="parameters" type="array" usage="required">
            <description>The parameters we are passing off to the method</description>
          </parameter>
          <parameter name="deferredRequestHandler" type="deferred" usage="required">
            <description>The Deferred object for this particular request</description>
          </parameter>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRequest" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>The name of the method we are creating the requst for</description>
          </parameter>
          <parameter name="params" type="array" usage="required">
            <description>The array of parameters for this request;</description>
          </parameter>
        </parameters>
      </method>
      <method name="parseResults" scope="instance">
        <parameters>
          <parameter name="obj" type="anything" usage="required">
            <description>Object Object containing envelope of data we recieve from the server</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.rpc.RpcService" scope="instance"/>
    </mixins>
    <properties>
      <property name="bustCache" scope="instance" type="bool"/>
      <property name="contentType" scope="instance" type="String"/>
      <property name="lastSubmissionId" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.rpc.JsonpService" superclass="dojo.rpc.RpcService">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="requiredArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bind" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>The name of the method we are calling</description>
          </parameter>
          <parameter name="parameters" type="array" usage="required">
            <description>The parameters we are passing off to the method</description>
          </parameter>
          <parameter name="deferredRequestHandler" type="deferred" usage="required">
            <description>The Deferred object for this particular request</description>
          </parameter>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRequest" scope="instance">
        <parameters>
          <parameter name="parameters" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.rpc.RpcService" scope="instance"/>
    </mixins>
    <properties>
      <property name="strictArgChecks" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojo.rpc.RpcService">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required">
            <description>Takes a number of properties as kwArgs for defining the service.  It also
	accepts a string.  When passed a string, it is treated as a url from
	which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
	object.  It accepts serviceUrl, to manually define a url for the rpc service
	allowing the rpc system to be used without an smd definition. strictArgChecks
	forces the system to verify that the # of arguments provided in a call
	matches those defined in the smd.  smdString allows a developer to pass
	a jsonString directly, which will be converted into an object or alternatively
	smdObject is accepts an smdObject directly.</description>
          </parameter>
        </parameters>
      </method>
      <method name="parseResults" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <description>Object that is the return results from an rpc request</description>
          </parameter>
        </parameters>
      </method>
      <method name="errorCallback" scope="instance">
        <parameters>
          <parameter name="deferredRequestHandler" type="dojo.Deferred" usage="required">
            <description>Deferred The deferred object handling a request.</description>
          </parameter>
        </parameters>
      </method>
      <method name="resultCallback" scope="instance">
        <parameters>
          <parameter name="deferredRequestHandler" type="dojo.Deferred" usage="required">
            <description>Deferred The deferred object handling a request.</description>
          </parameter>
        </parameters>
      </method>
      <method name="generateMethod" scope="instance">
        <parameters>
          <parameter name="method" type="string" usage="required">
            <description>The name of the method we are generating</description>
          </parameter>
          <parameter name="parameters" type="array" usage="required">
            <description>the array of parameters for this call.</description>
          </parameter>
          <parameter name="url" type="string" usage="required">
            <description>the service url for this call</description>
          </parameter>
        </parameters>
      </method>
      <method name="processSmd" scope="instance">
        <parameters>
          <parameter name="object" type="smd" usage="required">
            <description>object defining this service.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="strictArgChecks" scope="instance-prototype" type="Object"/>
      <property name="serviceUrl" scope="instance-prototype" type="Object"/>
      <property name="required" scope="instance" type="Object"/>
      <property name="smd" scope="instance" type="Object"/>
      <property name="timeout" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojo.store">
    <methods>
      <method name="Observable" scope="instance">
        <description>Observable wraps an existing store so that notifications can be made when a query
	is performed.</description>
        <examples>
          <example>Create a Memory store that returns an observable query, and then log some
	information about that query.
		var store = dojo.store.Observable(new dojo.store.Memory({
			data: [
				{id: 1, name: "one", prime: false},
				{id: 2, name: "two", even: true, prime: true},
				{id: 3, name: "three", prime: true},
				{id: 4, name: "four", even: true, prime: false},
				{id: 5, name: "five", prime: true}
			]
		}));
		var changes = [], results = store.query({ prime: true });
		var observer = results.observe(function(object, previousIndex, newIndex){
			changes.push({previousIndex:previousIndex, newIndex:newIndex, object:object});
		});
	See the Observable tests for more information.</example>
        </examples>
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.store.__CacheArgs">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="isLoaded" scope="instance"/>
    </methods>
  </class>
  <class type="dojo.store.Cache">
    <methods>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="query" type="Object|String" usage="required">
            <description>The object or string containing query information. Dependent on the query engine used.</description>
          </parameter>
          <parameter name="directives" type="dojo.store.util.SimpleQueryEngine.__queryOptions" usage="optional">
            <description>An optional keyword arguments object with additional parameters describing the query.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	A QueryResults object that can be used to iterate over.</return-description>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identifier for the object in question.</description>
          </parameter>
          <parameter name="directives" type="dojo.store.__GetOptions" usage="optional">
            <description>Any additional parameters needed to describe how the get should be performed.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	A QueryResults object.</return-description>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to add to the store.</description>
          </parameter>
          <parameter name="directives" type="dojo.store.__AddOptions" usage="optional">
            <description>Any additional parameters needed to describe how the add should be performed.</description>
          </parameter>
        </parameters>
        <return-description>Number
	The new id for the object.</return-description>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to put to the store.</description>
          </parameter>
          <parameter name="directives" type="dojo.store.__PutOptions" usage="optional">
            <description>Any additional parameters needed to describe how the put should be performed.</description>
          </parameter>
        </parameters>
        <return-description>Number
	The new id for the object.</return-description>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identifier for the object in question.</description>
          </parameter>
          <parameter name="directives" type="dojo.store.__RemoveOptions" usage="optional">
            <description>Any additional parameters needed to describe how the remove should be performed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="evict" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identifier for the object in question.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.store.DataStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="optional">
            <description>This provides any configuration information that will be mixed into the store,
	including a reference to the Dojo data store under the property &amp;quot;store&amp;quot;.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_objectConverter" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="optional">
            <description>The identity to use to lookup the object</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to store.</description>
          </parameter>
          <parameter name="options" type="Object" usage="optional">
            <description>Additional metadata for storing the data.  Includes a reference to an id
	that the object may be stored with (i.e. { id: &amp;quot;foo&amp;quot; }).</description>
          </parameter>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required">
            <description>The identity to use to delete the object</description>
          </parameter>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required">
            <description>The query to use for retrieving objects from the store</description>
          </parameter>
          <parameter name="options" type="Object" usage="optional">
            <description>Optional options object as used by the underlying dojo.data Store.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	A query results object that can be used to iterate over results.</return-description>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The data object to get the identity from.</description>
          </parameter>
        </parameters>
        <return-description>Number
	The id of the given object.</return-description>
      </method>
    </methods>
    <properties>
      <property name="target" scope="instance" type="String"/>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.store.JsonRest">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.store.JsonRest" usage="required">
            <description>This provides any configuration information that will be mixed into the store</description>
          </parameter>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identity to use to lookup the object</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
        <return-description>Object
	The object in the store that matches the given id.</return-description>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to get the identity from</description>
          </parameter>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to store.</description>
          </parameter>
          <parameter name="options" type="Object" usage="optional">
            <description>Additional metadata for storing the data.  Includes an &amp;quot;id&amp;quot;
	property if a specific id is to be used.</description>
          </parameter>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to store.</description>
          </parameter>
          <parameter name="options" type="Object" usage="optional">
            <description>Additional metadata for storing the data.  Includes an &amp;quot;id&amp;quot;
	property if a specific id is to be used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identity to use to delete the object</description>
          </parameter>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required">
            <description>The query to use for retrieving objects from the store.</description>
          </parameter>
          <parameter name="options" type="dojo.store.util.SimpleQueryEngine.__queryOptions" usage="optional">
            <description>The optional arguments to apply to the resultset.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	The results of the query, extended with iterative methods.</return-description>
      </method>
    </methods>
    <properties>
      <property name="target" scope="instance" type="String">
        <description>The target base URL to use for all requests to the server. This string will be
	prepended to the id to generate the URL (relative or absolute) for requests
	sent to the server</description>
      </property>
      <property name="idProperty" scope="instance" type="String">
        <description>Indicates the property to use as the identity property. The values of this
	property should be unique.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.store.Memory">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="dojo.store.Memory" usage="required">
            <description>This provides any configuration information that will be mixed into the store.
	This should generally include the data property to provide the starting set of data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="queryEngine" scope="instance"/>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identity to use to lookup the object</description>
          </parameter>
        </parameters>
        <return-description>Object
	The object in the store that matches the given id.</return-description>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to get the identity from</description>
          </parameter>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to store.</description>
          </parameter>
          <parameter name="options" type="Object" usage="optional">
            <description>Additional metadata for storing the data.  Includes an &amp;quot;id&amp;quot;
	property if a specific id is to be used.</description>
          </parameter>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to store.</description>
          </parameter>
          <parameter name="options" type="Object" usage="optional">
            <description>Additional metadata for storing the data.  Includes an &amp;quot;id&amp;quot;
	property if a specific id is to be used.</description>
          </parameter>
        </parameters>
        <return-description>Number</return-description>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="Number" usage="required">
            <description>The identity to use to delete the object</description>
          </parameter>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <examples>
          <example>Given the following store:
		var store = new dojo.store.Memory({
			data: [
				{id: 1, name: "one", prime: false },
				{id: 2, name: "two", even: true, prime: true},
				{id: 3, name: "three", prime: true},
				{id: 4, name: "four", even: true, prime: false},
				{id: 5, name: "five", prime: true}
			]
		});
	...find all items where "prime" is true:
		var results = store.query({ prime: true });
	...or find all items where "even" is true:
		var results = store.query({ even: true });</example>
        </examples>
        <parameters>
          <parameter name="query" type="Object" usage="required">
            <description>The query to use for retrieving objects from the store.</description>
          </parameter>
          <parameter name="options" type="dojo.store.util.SimpleQueryEngine.__queryOptions" usage="optional">
            <description>The optional arguments to apply to the resultset.</description>
          </parameter>
        </parameters>
        <return-description>dojo.store.util.QueryResults
	The results of the query, extended with iterative methods.</return-description>
      </method>
      <method name="setData" scope="instance">
        <parameters>
          <parameter name="data" type="Array&lt;Object&gt;" usage="required">
            <description>An array of objects to use as the source of data.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="idProperty" scope="instance" type="String">
        <description>Indicates the property to use as the identity property. The values of this
	property should be unique.</description>
      </property>
      <property name="index" scope="instance-prototype" type="Object">
        <description>An index of data by id</description>
      </property>
    </properties>
  </class>
  <class type="dojo.store.Memory.data">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.store.util">
    <methods>
      <method name="QueryResults" scope="instance">
        <description>QueryResults is a basic wrapper that allows for array-like iteration
	over any kind of returned data from a query.  While the simplest store
	will return a plain array of data, other stores may return deferreds or
	promises; this wrapper makes sure that *all* results can be treated
	the same.
	Additional methods include `forEach`, `filter` and `map`.</description>
        <examples>
          <example>Query a store and iterate over the results.
		store.query({ prime: true }).forEach(function(item){
			//	do something
		});</example>
        </examples>
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
        <return-description>Object
	An array-like object that can be used for iterating over.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojo.store.util.SimpleQueryEngine">
    <description>The SimpleQueryEngine provides a way of getting a QueryResults through
	the use of a simple object hash as a filter.  The hash will be used to
	match properties on data objects with the corresponding value given. In
	other words, only exact matches will be returned.
	This function can be used as a template for more complex query engines;
	for example, an engine can be created that accepts an object hash that
	contains filtering functions, or a string that gets evaluated, etc.
	When creating a new dojo.store, simply set the store's queryEngine
	field as a reference to this function.</description>
  </class>
  <class type="dojo.store.util.SimpleQueryEngine.__sortInformation">
    <methods/>
    <properties>
      <property name="attribute" scope="instance" type="String">
        <description>The name of the attribute to sort on.</description>
      </property>
      <property name="descending" scope="instance" type="Boolean">
        <description>The direction of the sort.  Default is false.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.store.util.SimpleQueryEngine.__queryOptions">
    <methods/>
    <properties>
      <property name="sort" scope="instance" type="Array&lt;dojo.store.util.SimpleQueryEngine.__sortInformation&gt;">
        <description>A list of attributes to sort on, as well as direction</description>
      </property>
      <property name="start" scope="instance" type="Number">
        <description>The first result to begin iteration on</description>
      </property>
      <property name="count" scope="instance" type="Number">
        <description>The number of how many results should be returned.</description>
      </property>
    </properties>
  </class>
  <class type="dojo.string">
    <methods>
      <method name="rep" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>the string to replicate</description>
          </parameter>
          <parameter name="num" type="Integer" usage="required">
            <description>number of times to replicate the string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="pad" scope="instance">
        <examples>
          <example>	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
		dojo.string.pad("Dojo", 10, "+", true);</example>
        </examples>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>the string to pad</description>
          </parameter>
          <parameter name="size" type="Integer" usage="required">
            <description>length to provide padding</description>
          </parameter>
          <parameter name="ch" type="String" usage="optional">
            <description>character to pad, defaults to '0'</description>
          </parameter>
          <parameter name="end" type="Boolean" usage="optional">
            <description>adds padding at the end if true, otherwise pads at start</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="substitute" scope="instance">
        <examples>
          <example>Substitutes two expressions in a string from an Array or Object
		// returns "File 'foo.html' is not found in directory '/temp'."
		// by providing substitution data in an Array
		dojo.string.substitute(
			"File '${0}' is not found in directory '${1}'.",
			["foo.html","/temp"]
		);
		// also returns "File 'foo.html' is not found in directory '/temp'."
		// but provides substitution data in an Object structure.  Dotted
		// notation may be used to traverse the structure.
		dojo.string.substitute(
			"File '${name}' is not found in directory '${info.dir}'.",
			{ name: "foo.html", info: { dir: "/temp" } }
		);</example>
          <example>Use a transform function to modify the values:
		// returns "file 'foo.html' is not found in directory '/temp'."
		dojo.string.substitute(
			"${0} is not found in ${1}.",
			["foo.html","/temp"],
			function(str){
				// try to figure out the type
				var prefix = (str.charAt(0) == "/") ? "directory": "file";
				return prefix + " '" + str + "'";
			}
		);</example>
          <example>Use a formatter
		// returns "thinger -- howdy"
		dojo.string.substitute(
			"${0:postfix}", ["thinger"], null, {
				postfix: function(value, key){
					return value + " -- howdy";
				}
			}
		);</example>
        </examples>
        <parameters>
          <parameter name="template" type="String" usage="required">
            <description>a string with expressions in the form &lt;code&gt;${key}&lt;/code&gt; to be replaced or
	&lt;code&gt;${key:format}&lt;/code&gt; which specifies a format function. keys are case-sensitive.</description>
          </parameter>
          <parameter name="map" type="Object|Array" usage="required">
            <description>hash to search for substitutions</description>
          </parameter>
          <parameter name="transform" type="Function" usage="optional">
            <description>a function to process all parameters before substitution takes
	place, e.g. mylib.encodeXML</description>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <description>where to look for optional format function; default to the global
	namespace</description>
          </parameter>
        </parameters>
      </method>
      <method name="trim" scope="instance">
        <description>This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	The short yet performant version of this function is dojo.trim(),
	which is part of Dojo base.  Uses String.prototype.trim instead, if available.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>String to be trimmed</description>
          </parameter>
        </parameters>
        <return-description>String
	Returns the trimmed string</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojo.doc">
    <description>Refer to dojo.doc rather
	than referring to 'window.document' to ensure your code runs
	correctly in managed contexts.</description>
    <properties>
      <property name="styleSheets" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="Math">
    <properties>
      <property name="floor" scope="instance" type="Object"/>
      <property name="PI" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.doc.documentElement">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.window">
    <methods>
      <method name="getBox" scope="instance"/>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Window"/>
        </return-types>
      </method>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="pos" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="nothing to do"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="node"/>
  <class type="node.ownerDocument">
    <properties>
      <property name="documentElement" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="node.ownerDocument.body">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.doc.body">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.NodeList">
    <properties>
      <property name="delegate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox">
    <description>DojoX is a collection of subprojects provided by Dojo committers and subject to
	the generous licensing and policies of the [Dojo CLA](http://dojotoolkit.org/cla)
	Each subproject in DojoX has its own top-level directory and a README file with
	status information and project status and a stability rating (experimental, beta, stable)
	Projects may or may not depend on other top-level Dojo projects, like Dojo or Dijit.
	Unlike Dojo and Dijit, code is not subject to i18n and a11y restrictions and may vary
	in quality (experimental code is encouraged in DojoX, but currently prohibited in Dojo
	and Dijit)
	DojoX projects may mature to a stable state and stay in DojoX, or on occasion
	after proving themselves may migrate to Dojo Core or Dijit.  Dojo and Dijit projects
	are constrained both by development resources as well as design goals, so DojoX is
	a natural place to provide enhanced behavior or extend Dojo Core or Dijit primitives.
	DojoX can also be an incubator for entirely new projects.</description>
    <properties>
      <property name="jq" scope="instance" type="Object">
        <description>A JQuery compatibility layer</description>
      </property>
      <property name="mobileApp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="djConfig">
    <properties>
      <property name="urchin" scope="instance" type="String">
        <description>Used by &lt;code&gt;dojox.analytics.Urchin&lt;/code&gt; as the default UA-123456-7 account
	number used when being created. Alternately, you can pass an acct:&amp;quot;&amp;quot;
	parameter to the constructor a la: new dojox.analytics.Urchin({ acct:&amp;quot;UA-123456-7&amp;quot; });</description>
      </property>
      <property name="preloadImages" scope="instance" type="Array">
        <description>An optional array of urls to preload immediately upon
	page load. Uses &lt;code&gt;dojox.image&lt;/code&gt;, and is unused if not present.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.analytics">
    <methods>
      <method name="schedulePusher" scope="instance">
        <parameters>
          <parameter name="interval" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="addData" scope="instance">
        <parameters>
          <parameter name="dataType" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkData" scope="instance"/>
      <method name="onPushComplete" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_data" scope="instance" type="Array"/>
      <property name="_id" scope="instance" type="Number"/>
      <property name="sendInterval" scope="instance" type="Number"/>
      <property name="inTransitRetry" scope="instance" type="Number"/>
      <property name="dataUrl" scope="instance" type="Object"/>
      <property name="sendMethod" scope="instance" type="String"/>
      <property name="maxRequestSize" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.analytics.Urchin">
    <description>A small class object will allows for lazy-loading the Google Analytics API
	at any point during a page lifecycle. Most commonly, Google-Analytics is loaded
	via a synchronous script tag in the body, which causes `dojo.addOnLoad` to
	stall until the external API has been completely loaded. The Urchin helper
	will load the API on the fly, and provide a convenient API to use, wrapping
	Analytics for Ajaxy or single page applications.
	The class can be instantiated two ways: Programatically, by passing an
	`acct:` parameter, or via Markup / dojoType and defining a djConfig
	parameter `urchin:`
	IMPORTANT:
	This module will not work simultaneously with the core dojox.analytics
	package. If you need the ability to run Google Analytics AND your own local
	analytics system, you MUST include dojox.analytics._base BEFORE dojox.analytics.Urchin</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_gotGA" scope="instance"/>
      <method name="GAonLoad" scope="instance">
        <description>This function is executed when the tracker variable is
	complete and initialized. The initial trackPageView (with
	no arguments) is called here as well, so remeber to call
	manually if overloading this method.</description>
        <examples>
          <example>Create an Urchin tracker that will track a specific page on init
	after page load (or parsing, if parseOnLoad is true)
		dojo.addOnLoad(function(){
			new dojox.ananlytics.Urchin({
				acct:"UA-12345-67",
				GAonLoad: function(){
					this.trackPageView("/custom-page");
				}
			});
		});</example>
        </examples>
      </method>
      <method name="trackPageView" scope="instance">
        <examples>
          <example>Track clicks from a container of anchors and populate a `ContentPane`
		// 'tracker' is our `Urchin` instance, pane is the `ContentPane` ref.
		dojo.connect(container, "onclick", function(e){
			var ref = dojo.attr(e.target, "href");
			tracker.trackPageView(ref);
			pane.attr("href", ref);
		});</example>
        </examples>
        <parameters>
          <parameter name="url" type="string" usage="required">
            <description>String A location to tell the tracker to track, eg: &amp;quot;/my-ajaxy-endpoint&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="acct" scope="instance-prototype" type="String">
        <description>your GA urchin tracker account number. Overrides &lt;code&gt;djConfig.urchin&lt;/code&gt;</description>
      </property>
      <property name="tracker" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.analytics.pushData">
    <methods/>
    <properties>
      <property name="_inTransit" scope="instance" type="Object"/>
      <property name="_data" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.analytics.getQueryPacket">
    <methods/>
    <properties>
      <property name="_split" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.analytics.plugins">
    <properties>
      <property name="consoleMessages" scope="instance" type="Object"/>
      <property name="dojo" scope="instance" type="Object"/>
      <property name="idle" scope="instance" type="Object"/>
      <property name="mouseClick" scope="instance" type="Object"/>
      <property name="mouseOver" scope="instance" type="Object"/>
      <property name="window" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dependencies">
    <properties>
      <property name="layers" scope="instance" type="Array"/>
      <property name="prefixes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.atom.io"/>
  <class type="dojox.atom.io.Connection">
    <description>This object implements a transport layer for working with ATOM feeds and ATOM publishing protocols.
	Specifically, it provides a mechanism by which feeds can be fetched and entries can be fetched, created
	deleted, and modified.  It also provides access to the introspection data.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="sync" type="Boolean" usage="required"/>
          <parameter name="preventCache" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getFeed" scope="instance">
        <description>This function takes the URL for a specific ATOM feed and returns
	the data from that feed to the caller through the use of a callback
	handler.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>The URL of the ATOM feed to fetch.</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the feed when it has been retrieved.
	The callback should accept two parameters:  The feed object and the original complete DOM object.</description>
          </parameter>
          <parameter name="errorCallback" type="Function" usage="required"/>
          <parameter name="scope" type="Object" usage="required">
            <description>The scope to use for all callbacks.</description>
          </parameter>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="getService" scope="instance">
        <description>This function takes the URL for an ATOM item and feed and returns
	the introspection document.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>The URL of the ATOM document to obtain the introspection document of.</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the introspection document when it has been retrieved.
	The callback should accept two parameters:  The introspection document object and the original complete DOM object.</description>
          </parameter>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="getEntry" scope="instance">
        <description>This function takes the URL for an ATOM entry and returns the constructed dojox.atom.io.model.Entry object through
	the specified callback.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>The URL of the ATOM Entry document to parse.</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the Entry object obtained.
	The callback should accept two parameters, the dojox.atom.io.model.Entry object and the original dom.</description>
          </parameter>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="_getXmlDoc" scope="instance">
        <description>This internal function takes the URL for an XML document and and passes the
	parsed contents to a specified callback.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>The URL of the XML document to retrieve</description>
          </parameter>
          <parameter name="nodeName" type="Object" usage="required"/>
          <parameter name="newNode" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the retrieved XML data.
	The callback should accept one parameter, the DOM of the parsed XML document.</description>
          </parameter>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="updateEntry" scope="instance">
        <description>This function takes a specific dojox.atom.io.model.Entry object and pushes the
	changes back to the provider of the Entry.
	The entry MUST have a link tag with rel="edit" for this to work.</description>
        <parameters>
          <parameter name="entry" type="Object" usage="required">
            <description>The dojox.atom.io.model.Entry object to update.</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the results from the entry update.
	The callback should accept two parameters:  The first is an Entry object, and the second is the URL of that Entry
	Either can be null, depending on the value of retrieveUpdated.</description>
          </parameter>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="retrieveUpdated" type="boolean" usage="required">
            <description>A boolean flag denoting if the entry that was updated should then be
	retrieved and returned to the caller via the callback.</description>
          </parameter>
          <parameter name="xmethod" type="boolean" usage="required">
            <description>Whether to use POST for PUT/DELETE items and send the X-Method-Override header.</description>
          </parameter>
          <parameter name="scope" type="Object" usage="required">
            <description>The scope to use for all callbacks.</description>
          </parameter>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="addEntry" scope="instance">
        <description>This function takes a specific dojox.atom.io.model.Entry object and pushes the
	changes back to the provider of the Entry.</description>
        <parameters>
          <parameter name="entry" type="Object" usage="required">
            <description>The dojox.atom.io.model.Entry object to publish.</description>
          </parameter>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the results from the entry publish.
	The callback should accept two parameters:   The first is an dojox.atom.io.model.Entry object, and the second is the location of the entry
	Either can be null, depending on the value of retrieveUpdated.</description>
          </parameter>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="retrieveEntry" type="boolean" usage="required">
            <description>A boolean flag denoting if the entry that was created should then be
	retrieved and returned to the caller via the callback.</description>
          </parameter>
          <parameter name="scope" type="Object" usage="required">
            <description>The scope to use for all callbacks.</description>
          </parameter>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
      <method name="deleteEntry" scope="instance">
        <description>This function takes a specific dojox.atom.io.model.Entry object and calls for a delete on the
	service housing the ATOM Entry database.
	The entry MUST have a link tag with rel="edit" for this to work.</description>
        <parameters>
          <parameter name="entry" type="Object" usage="required">
            <description>The dojox.atom.io.model.Entry object to delete.</description>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <description>A function reference that will handle the results from the entry delete.
	The callback is called only if the delete is successful.</description>
          </parameter>
          <parameter name="errorCallback" type="Object" usage="required"/>
          <parameter name="xmethod" type="Object" usage="required"/>
          <parameter name="scope" type="Object" usage="required"/>
        </parameters>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
      </method>
    </methods>
    <properties>
      <property name="preventCache" scope="instance-prototype" type="bool"/>
      <property name="alertsEnabled" scope="instance" type="bool"/>
      <property name="sync" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom"/>
  <class type="dojox.atom.io.model"/>
  <class type="dojox.atom.io.model.Node">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="name_space" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="attributes" type="Object" usage="required"/>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="shortNs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_saveAttributes" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addAttribute" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttribute" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance"/>
      <method name="addContent" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="name_space" scope="instance-prototype" type="Object"/>
      <property name="shortNs" scope="instance-prototype" type="Object"/>
      <property name="name" scope="instance-prototype" type="Object"/>
      <property name="textContent" scope="instance-prototype" type="Object"/>
      <property name="attributes" scope="instance-prototype" type="Array"/>
      <property name="content" scope="instance" type="Array"/>
      <property name="rawNodes" scope="instance" type="Array"/>
      <property name="_objName" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.AtomItem" superclass="dojox.atom.io.model.Node">
    <description>Class container for generic Atom items.
	child objects can override this if they want to be called after a Dom build</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance"/>
      <method name="accept" scope="instance">
        <parameters>
          <parameter name="tag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_postBuild" scope="instance"/>
      <method name="buildFromDom" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addNamespace" scope="instance">
        <parameters>
          <parameter name="fullName" type="Object" usage="required"/>
          <parameter name="shortName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addAuthor" scope="instance">
        <description>Function to add in an author to the list of authors.</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The author's name.</description>
          </parameter>
          <parameter name="email" type="String" usage="required">
            <description>The author's e-mail address.</description>
          </parameter>
          <parameter name="uri" type="String" usage="required">
            <description>A URI associated with the author.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addContributor" scope="instance">
        <description>Function to add in an author to the list of authors.</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The author's name.</description>
          </parameter>
          <parameter name="email" type="String" usage="required">
            <description>The author's e-mail address.</description>
          </parameter>
          <parameter name="uri" type="String" usage="required">
            <description>A URI associated with the author.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addLink" scope="instance">
        <description>Function to add in a link to the list of links.</description>
        <parameters>
          <parameter name="href" type="String" usage="required">
            <description>The href.</description>
          </parameter>
          <parameter name="rel" type="String" usage="required"/>
          <parameter name="hrefLang" type="String" usage="required"/>
          <parameter name="title" type="String" usage="required">
            <description>A title to associate with the link.</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>The type of link is is.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeLink" scope="instance">
        <description>Function to remove a link from the list of links.</description>
        <parameters>
          <parameter name="href" type="String" usage="required">
            <description>The href.</description>
          </parameter>
          <parameter name="rel" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeBasicLinks" scope="instance">
        <description>Function to remove all basic link from the list of links.</description>
      </method>
      <method name="addCategory" scope="instance">
        <description>Function to add in a category to the list of categories.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required"/>
          <parameter name="term" type="String" usage="required"/>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getCategories" scope="instance">
        <description>Function to get all categories that match a particular scheme.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required">
            <description>The scheme to filter on.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeCategories" scope="instance">
        <description>Function to remove all categories that match a particular scheme and term.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required">
            <description>The scheme to filter on.</description>
          </parameter>
          <parameter name="term" type="String" usage="required">
            <description>The term to filter on.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setTitle" scope="instance">
        <description>Function to set the title of the item.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>The title to set.</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>The type of title format, text, xml, xhtml, etc.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addExtension" scope="instance">
        <description>Function to add in an extension namespace into the item.</description>
        <parameters>
          <parameter name="name_space" type="String" usage="required">
            <description>The namespace of the extension.</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>The name of the extension</description>
          </parameter>
          <parameter name="attributes" type="Array" usage="required">
            <description>The attributes associated with the extension.</description>
          </parameter>
          <parameter name="content" type="String" usage="required">
            <description>The content of the extension.</description>
          </parameter>
          <parameter name="shortNS" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getExtensions" scope="instance">
        <description>Function to get extensions that match a namespace and name.</description>
        <parameters>
          <parameter name="name_space" type="String" usage="required">
            <description>The namespace of the extension.</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>The name of the extension</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeExtensions" scope="instance">
        <description>Function to remove extensions that match a namespace and name.</description>
        <parameters>
          <parameter name="name_space" type="String" usage="required">
            <description>The namespace of the extension.</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>The name of the extension</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="_accepts" scope="instance" type="Object"/>
      <property name="extensions" scope="instance-prototype" type="Object"/>
      <property name="authors" scope="instance-prototype" type="Object"/>
      <property name="contributors" scope="instance-prototype" type="Object"/>
      <property name="links" scope="instance-prototype" type="Object"/>
      <property name="categories" scope="instance-prototype" type="Object"/>
      <property name="icon" scope="instance-prototype" type="Object"/>
      <property name="id" scope="instance-prototype" type="Object"/>
      <property name="logo" scope="instance-prototype" type="Object"/>
      <property name="xmlBase" scope="instance-prototype" type="Object"/>
      <property name="rights" scope="instance-prototype" type="Object"/>
      <property name="subtitle" scope="instance-prototype" type="Object"/>
      <property name="updated" scope="instance-prototype" type="Object"/>
      <property name="published" scope="instance-prototype" type="Object"/>
      <property name="issued" scope="instance-prototype" type="Object"/>
      <property name="modified" scope="instance-prototype" type="Object"/>
      <property name="content" scope="instance-prototype" type="Object"/>
      <property name="entries" scope="instance-prototype" type="Object"/>
      <property name="ATOM_URI" scope="instance" type="Object"/>
      <property name="name_spaces" scope="instance" type="Object"/>
      <property name="_objName" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.AtomItem.title">
    <properties>
      <property name="value" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Category" superclass="dojox.atom.io.model.Node">
    <description>Class container for 'Category' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="scheme" type="String" usage="required"/>
          <parameter name="term" type="String" usage="required"/>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_postBuild" scope="instance"/>
      <method name="_getAttributeNames" scope="instance"/>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the category tag, which is an XML structure.</description>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Category data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <description>The DOM node to process for content.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="scheme" scope="instance-prototype" type="Object"/>
      <property name="term" scope="instance-prototype" type="Object"/>
      <property name="_objName" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Content" superclass="dojox.atom.io.model.Node">
    <description>Class container for 'Content' types. Such as summary, content, username, and so on types of data.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="tagName" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="src" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="xmlLang" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance"/>
      <method name="_postBuild" scope="instance"/>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Content data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <description>The DOM node to process for content.
	Handle checking for XML content as the content type</description>
          </parameter>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the content tag, which is an XML structure.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="value" scope="instance-prototype" type="Object"/>
      <property name="type" scope="instance-prototype" type="String"/>
      <property name="scheme" scope="instance" type="Object"/>
      <property name="term" scope="instance" type="Object"/>
      <property name="tagName" scope="instance" type="Object"/>
      <property name="src" scope="instance" type="Object"/>
      <property name="xmlLang" scope="instance" type="Object"/>
      <property name="HTML" scope="instance" type="String"/>
      <property name="TEXT" scope="instance" type="String"/>
      <property name="XHTML" scope="instance" type="String"/>
      <property name="XML" scope="instance" type="String"/>
      <property name="_useTextContent" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Link" superclass="dojox.atom.io.model.Node">
    <description>Class container for 'link' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="href" type="Object" usage="required"/>
          <parameter name="rel" type="Object" usage="required"/>
          <parameter name="hrefLang" type="Object" usage="required"/>
          <parameter name="title" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance"/>
      <method name="_postBuild" scope="instance"/>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the link data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>DOM node to process for link data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the link tag, which is an XML structure.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="href" scope="instance-prototype" type="Object"/>
      <property name="hrefLang" scope="instance-prototype" type="Object"/>
      <property name="rel" scope="instance-prototype" type="Object"/>
      <property name="title" scope="instance-prototype" type="Object"/>
      <property name="type" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Person" superclass="dojox.atom.io.model.Node">
    <description>Class container for 'person' types, such as Author, controbutors, and so on.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="personType" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="email" type="Object" usage="required"/>
          <parameter name="uri" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance"/>
      <method name="_postBuild" scope="instance"/>
      <method name="accept" scope="instance">
        <parameters>
          <parameter name="tag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the person data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>DOM node to process for person data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the Person tag, which is an XML structure.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="extensions" scope="instance" type="Array"/>
      <property name="author" scope="instance" type="String"/>
      <property name="contributor" scope="instance" type="String"/>
      <property name="personType" scope="instance" type="Object"/>
      <property name="name" scope="instance" type="String"/>
      <property name="email" scope="instance" type="String"/>
      <property name="uri" scope="instance" type="String"/>
      <property name="_objName" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Person._accepts">
    <properties>
      <property name="name" scope="instance" type="Object"/>
      <property name="uri" scope="instance" type="Object"/>
      <property name="email" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Generator" superclass="dojox.atom.io.model.Node">
    <description>Class container for 'Generator' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
          <parameter name="version" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_postBuild" scope="instance"/>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the generator data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>DOM node to process for link data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the Generator tag, which is an XML structure.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.Node" scope="instance"/>
    </mixins>
    <properties>
      <property name="value" scope="instance-prototype" type="Object"/>
      <property name="uri" scope="instance-prototype" type="Object"/>
      <property name="version" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Entry" superclass="dojox.atom.io.model.AtomItem">
    <description>Class container for 'Entry' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="instance"/>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the entry tag, which is an XML structure.</description>
        <parameters>
          <parameter name="amPrimary" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getEditHref" scope="instance">
        <description>Function to get the href that allows editing of this feed entry.</description>
        <return-description>The href that specifies edit capability.</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="setEditHref" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.AtomItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="published" scope="instance" type="Object"/>
      <property name="updated" scope="instance" type="Object"/>
      <property name="links" scope="instance" type="Array"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="_objName" scope="instance" type="String"/>
      <property name="feedUrl" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Entry._accepts">
    <properties>
      <property name="author" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="category" scope="instance" type="Object"/>
      <property name="contributor" scope="instance" type="Object"/>
      <property name="created" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="link" scope="instance" type="Object"/>
      <property name="published" scope="instance" type="Object"/>
      <property name="rights" scope="instance" type="Object"/>
      <property name="summary" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
      <property name="updated" scope="instance" type="Object"/>
      <property name="xmlbase" scope="instance" type="Object"/>
      <property name="issued" scope="instance" type="Object"/>
      <property name="modified" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Feed" superclass="dojox.atom.io.model.AtomItem">
    <description>Class container for 'Feed' types.</description>
    <methods>
      <method name="addEntry" scope="instance">
        <description>Function to add an entry to this feed.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The entry object to add.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFirstEntry" scope="instance">
        <description>Function to get the first entry of the feed.</description>
        <return-description>The first entry in the feed.</return-description>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getEntry" scope="instance">
        <description>Function to get an entry by its id.</description>
        <parameters>
          <parameter name="entryId" type="String" usage="required"/>
        </parameters>
        <return-description>The entry desired, or null if none.</return-description>
      </method>
      <method name="removeEntry" scope="instance">
        <description>Function to remove an entry from the list of links.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The entry.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setEntries" scope="instance">
        <description>Function to get an entry by its id.</description>
        <parameters>
          <parameter name="arrayOfEntry" type="array" usage="required">
            <description>An array of entry objects to add to the feed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <description>Function to construct string form of the feed tag, which is an XML structure.</description>
      </method>
      <method name="createEntry" scope="instance">
        <description>Function to Create a new entry object in the feed.</description>
        <return-description>An empty entry object in the feed.</return-description>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getSelfHref" scope="instance">
        <description>Function to get the href that refers to this feed.</description>
        <return-description>The href that refers to this feed or null if none.</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.AtomItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="entries" scope="instance" type="Array"/>
      <property name="rights" scope="instance" type="Object"/>
      <property name="updated" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Feed._accepts">
    <properties>
      <property name="author" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="category" scope="instance" type="Object"/>
      <property name="contributor" scope="instance" type="Object"/>
      <property name="created" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="link" scope="instance" type="Object"/>
      <property name="published" scope="instance" type="Object"/>
      <property name="rights" scope="instance" type="Object"/>
      <property name="summary" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
      <property name="updated" scope="instance" type="Object"/>
      <property name="xmlbase" scope="instance" type="Object"/>
      <property name="entry" scope="instance" type="Object"/>
      <property name="logo" scope="instance" type="Object"/>
      <property name="issued" scope="instance" type="Object"/>
      <property name="modified" scope="instance" type="Object"/>
      <property name="icon" scope="instance" type="Object"/>
      <property name="subtitle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Service" superclass="dojox.atom.io.model.AtomItem">
    <description>Class container for 'Feed' types.
	builds a Service document.  each element of this, except for the namespace, is the href of
	a service that the server supports.  Some of the common services are:
	"create-entry" , "user-prefs" , "search-entries" , "edit-template" , "categories"</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Service data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <description>The DOM node to process for content.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getCollection" scope="instance">
        <description>Function to collections that match a specific url.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>e URL to match collections against.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.AtomItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="workspaces" scope="instance" type="Array"/>
      <property name="name_space" scope="instance" type="Object"/>
      <property name="href" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Workspace" superclass="dojox.atom.io.model.AtomItem">
    <description>Class container for 'Workspace' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="title" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Workspace data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <description>The DOM node to process for content.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.AtomItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance-prototype" type="Object"/>
      <property name="collections" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model.Collection" superclass="dojox.atom.io.model.AtomItem">
    <description>Class container for 'Collection' types.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="href" type="Object" usage="required"/>
          <parameter name="title" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="instance">
        <description>Function to do construction of the Collection data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <description>The DOM node to process for content.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.io.model.AtomItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="href" scope="instance-prototype" type="Object"/>
      <property name="memberType" scope="instance-prototype" type="Object"/>
      <property name="id" scope="instance-prototype" type="Object"/>
      <property name="title" scope="instance-prototype" type="Object"/>
      <property name="attributes" scope="instance" type="Array"/>
      <property name="features" scope="instance" type="Array"/>
      <property name="children" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model._Constants">
    <description>Container for general constants.</description>
    <properties>
      <property name="ATOM_URI" scope="instance" type="String"/>
      <property name="ATOM_NS" scope="instance" type="String"/>
      <property name="PURL_NS" scope="instance" type="String"/>
      <property name="APP_NS" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.io.model._actions">
    <description>Container for tag handling functions.  Each child of this container is
	a handler function for the given type of node. Each accepts two parameters:
	obj:  Object.
	The object to insert data into.
	node: DOM Node.
	The dom node containing the data
	Google news
	Google news</description>
    <methods>
      <method name="link" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="author" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="contributor" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="category" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="icon" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="id" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rights" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subtitle" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="title" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updated" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="issued" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="modified" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="published" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="entry" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="content" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="summary" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="name" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="email" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uri" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generator" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.atom.io.model.util">
    <methods>
      <method name="createDate" scope="instance">
        <description>Utility function to create a date from a DOM node's text content.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <description>The DOM node to inspect.</description>
          </parameter>
        </parameters>
        <return-description>Date object from a DOM Node containing a ISO-8610 string.</return-description>
      </method>
      <method name="escapeHtml" scope="instance">
        <description>Utility function to escape XML special characters in an HTML string.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>The string to escape</description>
          </parameter>
        </parameters>
        <return-description>HTML String with special characters (&lt;,&gt;,&amp;, ", etc,) escaped.</return-description>
      </method>
      <method name="unEscapeHtml" scope="instance">
        <description>Utility function to un-escape XML special characters in an HTML string.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>The string to un-escape.</description>
          </parameter>
        </parameters>
        <return-description>HTML String converted back to the normal text (unescaped) characters (&lt;,&gt;,&amp;, ", etc,).</return-description>
      </method>
      <method name="getNodename" scope="instance">
        <description>Utility function to get a node name and deal with IE's bad handling of namespaces
	on tag names.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <description>The DOM node whose name to retrieve.</description>
          </parameter>
        </parameters>
        <return-description>String
	The name without namespace prefixes.</return-description>
      </method>
    </methods>
  </class>
  <class type="dojox.atom.widget"/>
  <class type="dojox.atom.widget.FeedEntryEditor" superclass="dojox.atom.widget.FeedEntryViewer">
    <description>An ATOM feed entry editor that allows viewing of the individual attributes of an entry.
	Flag denoting if the current entry is editable or not.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setEntry" scope="instance">
        <description>Function to set the current entry that is being edited.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>Instance of dojox.atom.io.model.Entry to display for reading/editing.</description>
          </parameter>
          <parameter name="feed" type="object" usage="required"/>
          <parameter name="leaveMenuState" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_toggleEdit" scope="instance">
        <description>Internal function for toggling/enabling the display of edit mode</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_handleEvent" scope="instance">
        <description>Internal function for listening to a topic that will handle entry notification.</description>
        <parameters>
          <parameter name="entrySelectionEvent" type="object" usage="required">
            <description>The topic message containing the entry that was selected for view.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_isEditable" scope="instance">
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The dojox.atom.io.model.Entry object to examine</description>
          </parameter>
        </parameters>
        <return-description>Boolean denoting if the entry seems editable or not..</return-description>
      </method>
      <method name="setTitle" scope="instance">
        <description>Function to set the contents of the title node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="titleAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the title data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setAuthors" scope="instance">
        <description>Function to set the contents of the author node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="authorsAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the author data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setContributors" scope="instance">
        <description>Function to set the contents of the contributor node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contributorsAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the contributor data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setId" scope="instance">
        <description>Function to set the contents of the ID node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="idAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the ID data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setUpdated" scope="instance">
        <description>Function to set the contents of the updated node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="updatedAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the udpated data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSummary" scope="instance">
        <description>Function to set the contents of the summary node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="summaryAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the summary data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setContent" scope="instance">
        <description>Function to set the contents of the content node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	summaryAnchorNode:
	The DOM node to attach the content data to.</description>
        <parameters>
          <parameter name="contentAnchorNode" type="DOM" usage="required">
            <description>node</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_createEditor" scope="instance">
        <description>Function to create an appropriate text editor widget based on the given parameters.</description>
        <parameters>
          <parameter name="anchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the editor widget to.</description>
          </parameter>
          <parameter name="node" type="DOM" usage="required">
            <description>An object containing the value to be put into the editor.  This ranges from an anonymous object
	with a value parameter to a dojox.atom.io.model.Content object.</description>
          </parameter>
          <parameter name="multiline" type="boolean" usage="required">
            <description>A boolean indicating whether the content should be multiline (such as a textarea) instead of a
	single line (such as a textbox).</description>
          </parameter>
          <parameter name="rte" type="object" usage="required">
            <description>A boolean indicating whether the content should be a rich text editor widget.</description>
          </parameter>
        </parameters>
        <return-description>Either a widget (for textarea or textbox widgets) or an anonymous object to be used to create a
	rich text area widget.</return-description>
      </method>
      <method name="_switchEditor" scope="instance">
        <description>Function to switch between a rich text editor and a textarea widget.  Used for title, summary,
	And content when switching between text and html/xhtml content.</description>
        <parameters>
          <parameter name="event" type="object" usage="required">
            <description>The event generated by the change in the select box on the page.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_createPeopleEditor" scope="instance">
        <description>Creates a People Editor widget, sets its value, and returns it.</description>
        <parameters>
          <parameter name="anchorNode" type="DOM" usage="required">
            <description>The node to attach the editor to.</description>
          </parameter>
          <parameter name="node" type="DOM" usage="required">
            <description>An object containing the value to be put into the editor. Typically, this is an
	dojox.atom.io.model.Person object.</description>
          </parameter>
        </parameters>
        <return-description>A new People Editor object.</return-description>
      </method>
      <method name="saveEdits" scope="instance">
        <description>Saves edits submitted when the 'save' button is pressed.  Distinguishes between new and existing
	entries and saves appropriately.  Fetches the values of the editors, and, if existing, compares them to
	the existing values and submits the updates, otherwise creates a new entry and posts it as a new entry.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_handleSave" scope="instance">
        <description>Function for handling the save of an entry, cleaning up the display after the edit is completed.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>dojox.atom.io.model.Entry object
	The entry that was saved.
	Location: String
	A URL to be used, not used here, but part of the call back from the AtomIO</description>
          </parameter>
          <parameter name="location" type="string" usage="required"/>
        </parameters>
        <return-description>Nothing.
	Close the editor and revert out.</return-description>
      </method>
      <method name="cancelEdits" scope="instance">
        <description>Cancels edits and reverts the editor to its previous state (display mode)</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="clear" scope="instance">
        <description>Clears the editor, destorys all editors, leaving the editor completely clear</description>
      </method>
      <method name="clearEditors" scope="instance"/>
      <method name="_enforceXhtml" scope="instance">
        <description>Function for cleaning up/enforcing the XHTML standard in HTML returned from the editor2 widget.</description>
        <parameters>
          <parameter name="html" type="string" usage="required">
            <description>HTML string to be enforced as xhtml.</description>
          </parameter>
        </parameters>
        <return-description>string of cleaned up HTML.</return-description>
      </method>
      <method name="_closeTag" scope="instance">
        <description>Function for closing tags in a text of HTML/XHTML</description>
        <parameters>
          <parameter name="xhtml" type="string" usage="required">
            <description>String XHTML string which needs the closing tag.</description>
          </parameter>
          <parameter name="tag" type="string" usage="required">
            <description>The tag to close.</description>
          </parameter>
        </parameters>
        <return-description>string of cleaned up HTML.
	NOTE:  Probably should redo this function in a more efficient way.  This could get expensive.</return-description>
      </method>
      <method name="_toggleNew" scope="instance">
        <description>Function to put the editor into a state to create a new entry.</description>
      </method>
      <method name="_displaySections" scope="instance">
        <description>Function to display the appropriate sections based on validity.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.atom.widget.FeedEntryViewer" scope="instance"/>
    </mixins>
    <properties>
      <property name="_contentEditor" scope="instance" type="Object"/>
      <property name="_oldContent" scope="instance" type="Object"/>
      <property name="_setObject" scope="instance" type="Object"/>
      <property name="enableEdit" scope="instance" type="bool"/>
      <property name="_contentEditorCreator" scope="instance" type="Object"/>
      <property name="entryNewButton" scope="instance" type="Object"/>
      <property name="_editable" scope="instance" type="bool"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
      <property name="_editMode" scope="instance" type="bool"/>
      <property name="_toLoad" scope="instance" type="Object"/>
      <property name="entryContentNode" scope="instance" type="Object"/>
      <property name="_new" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.displayOptions">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelTitle">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelAuthors">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelContributors">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelId">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.close">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelUpdated">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelSummary">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelContent">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.doNew">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.edit">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.save">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.cancel">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.entryTitleSelect">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor._editors">
    <properties>
      <property name="authors" scope="instance" type="Object"/>
      <property name="contributors" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="updated" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
      <property name="summary" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.entrySummarySelect">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryEditor.entryContentSelect">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.PeopleEditor" superclass="dijit._Widget">
    <description>An editor for dojox.atom.io.model.Person objects.  Displays multiple rows for the respective arrays
	of people.  Can add/remove rows on the fly.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_createEditors" scope="instance">
        <description>creates editor boxes (textbox widgets) for the individual values of a Person.</description>
        <parameters>
          <parameter name="name" type="string" usage="required">
            <description>The name of this Person.</description>
          </parameter>
          <parameter name="email" type="string" usage="required">
            <description>The email of this Person.</description>
          </parameter>
          <parameter name="uri" type="string" usage="required">
            <description>The Person's URI.</description>
          </parameter>
          <parameter name="index" type="int" usage="required">
            <description>The row index to use for this Person.</description>
          </parameter>
          <parameter name="widgetName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_createEditor" scope="instance">
        <description>Creates an individual editor widget (textbox) for a value.</description>
        <parameters>
          <parameter name="value" type="string" usage="required">
            <description>The initial value of the textbox</description>
          </parameter>
          <parameter name="id" type="string" usage="required">
            <description>The id the textbox should have.</description>
          </parameter>
          <parameter name="name" type="string" usage="required">
            <description>The text to put in the label element for this textbox.</description>
          </parameter>
          <parameter name="labelNode" type="DOM" usage="required">
            <description>The node to attach the label to.</description>
          </parameter>
          <parameter name="node" type="DOM" usage="required">
            <description>The node to attach the editor rows to.</description>
          </parameter>
        </parameters>
        <return-description>Editor widget.</return-description>
      </method>
      <method name="_removeEditor" scope="instance">
        <description>Removes a Person from our list of editors by removing the block of editors that
	make up that Person.</description>
        <parameters>
          <parameter name="event" type="object" usage="required">
            <description>The event generated when the remove button is pressed on the page.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_add" scope="instance">
        <description>Adds a new block of blank editors to represent a Person.</description>
      </method>
      <method name="getValues" scope="instance">
        <description>Gets the values of this editor in an array, with each Person as an object within the array.</description>
        <return-description>An array of anonymous objects representing dojox.atom.io.model.Persons.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_rows" scope="instance" type="Array"/>
      <property name="_editors" scope="instance" type="Array"/>
      <property name="_index" scope="instance" type="Number"/>
      <property name="_numRows" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer" superclass="dijit._Widget">
    <description>An ATOM feed entry editor for publishing updated ATOM entries, or viewing non-editable entries.
	The topic to listen on for entries to edit.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="clear" scope="instance">
        <description>Function to clear the state of the widget.</description>
      </method>
      <method name="clearNodes" scope="instance">
        <description>Function to clear all the display nodes for the ATOM entry from the viewer.</description>
      </method>
      <method name="setEntry" scope="instance">
        <description>Function to set the current entry that is being edited.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>Instance of dojox.atom.io.model.Entry to display for reading/editing.</description>
          </parameter>
          <parameter name="feed" type="object" usage="required"/>
          <parameter name="leaveMenuState" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setTitleHeader" scope="instance">
        <description>Function to set the contents of the title header node in the template to some value.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	titleAchorNode:
	The DOM node to attach the title data to.
	editMode:
	Boolean to indicate if the display should be in edit mode or not.</description>
        <parameters>
          <parameter name="titleHeaderNode" type="DOM" usage="required">
            <description>node</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setTitle" scope="instance">
        <description>Function to set the contents of the title node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	titleAchorNode:
	The DOM node to attach the title data to.</description>
        <parameters>
          <parameter name="titleAnchorNode" type="Object" usage="required"/>
          <parameter name="editMode" type="Boolean" usage="required">
            <description>to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="The" usage="required">
            <description>Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setAuthorsHeader" scope="instance">
        <description>Function to set the title format for the authors section of the author row in the template to some value from the entry.
	This exists specifically so users can over-ride how the author data is filled out from an entry.</description>
        <parameters>
          <parameter name="authorHeaderNode" type="DOM" usage="required">
            <description>The DOM node to attach the author section header data to.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setAuthors" scope="instance">
        <description>Function to set the contents of the author node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	authorsAchorNode:
	The DOM node to attach the author data to.</description>
        <parameters>
          <parameter name="authorsAnchorNode" type="DOM" usage="required">
            <description>node</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setContributorsHeader" scope="instance">
        <description>Function to set the contents of the contributor header node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contributorsHeaderNode" type="DOM" usage="required">
            <description>The DOM node to attach the contributor title to.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setContributors" scope="instance">
        <description>Function to set the contents of the contributor node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contributorsAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the contributor data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setIdHeader" scope="instance">
        <description>Function to set the contents of the ID node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	idAnchorNode:
	The DOM node to attach the ID data to.</description>
        <parameters>
          <parameter name="idHeaderNode" type="DOM" usage="required">
            <description>node</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setId" scope="instance">
        <description>Function to set the contents of the ID node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="idAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the ID data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setUpdatedHeader" scope="instance">
        <description>Function to set the contents of the updated header node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="updatedHeaderNode" type="DOM" usage="required">
            <description>The DOM node to attach the updated header data to.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setUpdated" scope="instance">
        <description>Function to set the contents of the updated node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="updatedAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the udpated data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSummaryHeader" scope="instance">
        <description>Function to set the contents of the summary node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="summaryHeaderNode" type="DOM" usage="required">
            <description>The DOM node to attach the summary title to.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSummary" scope="instance">
        <description>Function to set the contents of the summary node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="summaryAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the summary data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setContentHeader" scope="instance">
        <description>Function to set the contents of the content node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contentHeaderNode" type="DOM" usage="required">
            <description>The DOM node to attach the content data to.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setContent" scope="instance">
        <description>Function to set the contents of the content node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contentAnchorNode" type="DOM" usage="required">
            <description>The DOM node to attach the content data to.</description>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <description>Boolean to indicate if the display should be in edit mode or not.</description>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <description>The Feed Entry to work with.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_displaySections" scope="instance">
        <description>Internal function for determining which sections of the view to actually display.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setDisplaySections" scope="instance">
        <description>Function for setting which sections of the entry should be displayed.</description>
        <parameters>
          <parameter name="sectionsArray" type="array" usage="required">
            <description>Array of string names that indicate which sections to display.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_setDisplaySectionsCheckboxes" scope="instance">
        <description>Internal function for setting which checkboxes on the display are selected.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_readDisplaySections" scope="instance">
        <description>Internal function for reading what is currently checked for display and generating the display list from it.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_toggleCheckbox" scope="instance">
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <parameters>
          <parameter name="checkBox" type="object" usage="required">
            <description>The checkbox object to toggle the selection on.</description>
          </parameter>
        </parameters>
        <return-description>Nothing</return-description>
      </method>
      <method name="_toggleOptions" scope="instance">
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <parameters>
          <parameter name="checkBox" type="object" usage="required">
            <description>The checkbox object to toggle the selection on.</description>
          </parameter>
        </parameters>
        <return-description>Nothing</return-description>
      </method>
      <method name="_handleEvent" scope="instance">
        <description>Internal function for listening to a topic that will handle entry notification.</description>
        <parameters>
          <parameter name="entrySelectionEvent" type="object" usage="required">
            <description>The topic message containing the entry that was selected for view.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setFieldValidity" scope="instance">
        <description>Function to set whether a field in the view is valid and displayable.
	This is needed for over-riding of the set* functions and customization of how data is displayed in the attach point.
	So if custom implementations use their own display logic, they can still enable the field.</description>
        <parameters>
          <parameter name="field" type="string" usage="required">
            <description>The field name to set the valid parameter on.  Such as 'content', 'id', etc.</description>
          </parameter>
          <parameter name="isValid" type="boolean" usage="required">
            <description>Flag denoting if the field is valid or not.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="isFieldValid" scope="instance">
        <description>Function to return if a displayable field is valid or not</description>
        <parameters>
          <parameter name="field" type="string" usage="required">
            <description>The field name to get the valid parameter of.  Such as 'content', 'id', etc.</description>
          </parameter>
        </parameters>
        <return-description>boolean denoting if the field is valid and set.</return-description>
      </method>
      <method name="getEntry" scope="instance"/>
      <method name="getFeed" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="entrySelectionTopic" scope="instance" type="String"/>
      <property name="_validEntryFields" scope="instance" type="Object"/>
      <property name="displayEntrySections" scope="instance" type="String"/>
      <property name="_displayEntrySections" scope="instance" type="Array"/>
      <property name="enableMenu" scope="instance" type="bool"/>
      <property name="enableMenuFade" scope="instance" type="bool"/>
      <property name="_optionButtonDisplayed" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_entry" scope="instance" type="Object"/>
      <property name="_feed" scope="instance" type="Object"/>
      <property name="_editMode" scope="instance" type="bool"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.displayOptions">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelTitle">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelAuthors">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelContributors">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelId">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.close">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelUpdated">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelSummary">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelContent">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.EntryHeader" superclass="dijit._Widget">
    <description>Widget representing a header in a FeedEntryViewer/Editor</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setListHeader" scope="instance">
        <parameters>
          <parameter name="title" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewer" superclass="dijit._Widget">
    <description>An ATOM feed viewer that allows for viewing a feed, deleting entries, and editing entries.
	The body of the feed viewer table so we can access it and populate it.  Will be assigned via template.
	The overal table container which contains the feed viewer table.  Will be assigned via template.
	The topic to broadcast when any entry is clicked so that a listener can pick up it and display it.
	The URL to which to connect to initially on creation.</description>
    <methods>
      <method name="postCreate" scope="instance">
        <description>The postCreate function.  Creates our AtomIO object for future interactions and subscribes to the
	event given in markup/creation.</description>
      </method>
      <method name="startup" scope="instance">
        <description>The startup function.  Parses the filters and sets the feed based on the given url.</description>
      </method>
      <method name="clear" scope="instance">
        <description>Function clearing all current entries in the feed view.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setFeedFromUrl" scope="instance">
        <description>Function setting the dojox.atom.io.model.Feed data into the view.</description>
        <parameters>
          <parameter name="url" type="string" usage="required">
            <description>The URL to the feed to load.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setFeed" scope="instance">
        <description>Function setting the dojox.atom.io.model.Feed data into the view.
	entry:
	The dojox.atom.io.model.Feed object to process</description>
        <parameters>
          <parameter name="feed" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_displayDateForEntry" scope="instance">
        <description>Internal function for determining of a particular entry is editable.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The dojox.atom.io.model.Entry object to examine.</description>
          </parameter>
        </parameters>
        <return-description>An appropriate date for the feed viewer display.</return-description>
      </method>
      <method name="appendGrouping" scope="instance">
        <description>Function for appending a grouping of entries to the feed view.
	entry:
	The title of the new grouping to create on the view.</description>
        <parameters>
          <parameter name="titleText" type="string" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="appendEntry" scope="instance">
        <description>Function for appending an entry to the feed view.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The dojox.atom.io.model.Entry object to append</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="deleteEntry" scope="instance">
        <description>Function for deleting a row from the view</description>
        <parameters>
          <parameter name="entryRow" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeEntry" scope="instance">
        <description>callback for when an entry is deleted from a feed.</description>
        <parameters>
          <parameter name="entry" type="FeedViewerEntry" usage="required"/>
          <parameter name="success" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_rowSelected" scope="instance">
        <description>Internal function for handling the selection of feed entries.</description>
        <parameters>
          <parameter name="evt" type="object" usage="required">
            <description>The click event that triggered a selection.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_deselectCurrentSelection" scope="instance">
        <description>Internal function for unselecting the current selection.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_isEditable" scope="instance">
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The dojox.atom.io.model.Entry object to examine</description>
          </parameter>
        </parameters>
        <return-description>Boolean denoting if the entry seems editable or not..</return-description>
      </method>
      <method name="onEntrySelected" scope="instance">
        <description>Function intended for over0-riding/replacement as an attachpoint to for other items to recieve
	selection notification.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <description>The dojox.atom.io.model.Entry object selected.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_isRelativeURL" scope="instance">
        <description>Method to determine if the URL is relative or absolute.  Basic assumption is if it doesn't start
	with http:// or file://, it's relative to the current document.</description>
        <parameters>
          <parameter name="url" type="string" usage="required">
            <description>The URL to inspect.</description>
          </parameter>
        </parameters>
        <return-description>boolean indicating whether it's a relative url or not.</return-description>
      </method>
      <method name="_calculateBaseURL" scope="instance">
        <description>Internal function to calculate a baseline URL from the provided full URL.</description>
        <parameters>
          <parameter name="fullURL" type="string" usage="required">
            <description>The full URL as a string.</description>
          </parameter>
          <parameter name="currentPageRelative" type="boolean" usage="required">
            <description>Flag to denote of the base URL should be calculated as just the server base, or relative to the current page/location in the URL.</description>
          </parameter>
        </parameters>
        <return-description>String of the baseline URL</return-description>
      </method>
      <method name="_isFilterAccepted" scope="instance">
        <description>Internal function to do matching of category filters to widgets.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
        <return-description>boolean denoting if this entry matched one of the accept filters.</return-description>
      </method>
      <method name="addCategoryIncludeFilter" scope="instance">
        <description>Function to add a filter for entry inclusion in the feed view.</description>
        <parameters>
          <parameter name="filter" type="object" usage="required">
            <description>The basic items to filter on and the values.
	Should be of format: {scheme: &amp;lt;some text or null&amp;gt;, term: &amp;lt;some text or null&amp;gt;, label: &amp;lt;some text or null&amp;gt;}</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="removeCategoryIncludeFilter" scope="instance">
        <description>Function to remove a filter for entry inclusion in the feed view.</description>
        <parameters>
          <parameter name="filter" type="object" usage="required">
            <description>The basic items to identify the filter that is present.
	Should be of format: {scheme: &amp;lt;some text or null&amp;gt;, term: &amp;lt;some text or null&amp;gt;, label: &amp;lt;some text or null&amp;gt;}</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_handleEvent" scope="instance">
        <description>Internal function for listening to a topic that will handle entry notification.</description>
        <parameters>
          <parameter name="entrySelectionEvent" type="object" usage="required">
            <description>The topic message containing the entry that was selected for view.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_addEntry" scope="instance">
        <description>callback function used when adding an entry to the feed.  After the entry has been posted to the feed,
	we add it to our feed representation (to show it on the page) and publish an event to update any entry viewers.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <description>Destroys this widget, including all descendants and subscriptions.</description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="feedViewerTableBody" scope="instance" type="Object"/>
      <property name="feedViewerTable" scope="instance" type="Object"/>
      <property name="entrySelectionTopic" scope="instance" type="String"/>
      <property name="url" scope="instance" type="String"/>
      <property name="xmethod" scope="instance" type="bool"/>
      <property name="localSaveOnly" scope="instance" type="bool"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_feed" scope="instance" type="Object"/>
      <property name="_currentSelection" scope="instance" type="Object"/>
      <property name="_includeFilters" scope="instance" type="Array"/>
      <property name="alertsEnabled" scope="instance" type="bool"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
      <property name="atomIO" scope="instance" type="Object"/>
      <property name="childWidgets" scope="instance" type="Array"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewerEntry" superclass="dijit._Widget">
    <description>Widget for handling the display of an entry and specific events associated with it.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setTitle" scope="instance">
        <description>Function to set the title of the entry.</description>
        <parameters>
          <parameter name="text" type="string" usage="required">
            <description>The title.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setTime" scope="instance">
        <description>Function to set the time of the entry.</description>
        <parameters>
          <parameter name="timeText" type="string" usage="required">
            <description>The string form of the date.</description>
          </parameter>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="enableDelete" scope="instance">
        <description>Function to enable the delete action on this entry.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="disableDelete" scope="instance">
        <description>Function to disable the delete action on this entry.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="deleteEntry" scope="instance">
        <description>Function to handle the delete event and delete the entry.</description>
        <parameters>
          <parameter name="event" type="object" usage="required"/>
        </parameters>
        <return-description>Nothing.</return-description>
      </method>
      <method name="onClick" scope="instance">
        <description>Attach point for when a row is clicked on.</description>
        <parameters>
          <parameter name="e" type="object" usage="required">
            <description>The event generated by the click.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="entryNode" scope="instance" type="Object"/>
      <property name="timeNode" scope="instance" type="Object"/>
      <property name="entry" scope="instance" type="Object"/>
      <property name="feed" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewerEntry.deleteButton">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewerEntry.deleteButton.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewerGrouping" superclass="dijit._Widget">
    <description>Grouping of feed entries.</description>
    <methods>
      <method name="setText" scope="instance">
        <description>Sets the text to be shown above this grouping.</description>
        <parameters>
          <parameter name="text" type="The" usage="required">
            <description>text to show.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="groupingNode" scope="instance" type="Object"/>
      <property name="titleNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.AtomEntryCategoryFilter" superclass="dijit._Widget">
    <description>A filter to be applied to the list of entries.</description>
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="scheme" scope="instance" type="String"/>
      <property name="term" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="isFilter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.atom.widget.FeedViewer.CategoryIncludeFilter">
    <description>The initializer function.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The initializer function.</description>
        <parameters>
          <parameter name="scheme" type="Object" usage="required"/>
          <parameter name="term" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="match" scope="instance">
        <description>Function to determine if this category filter matches against a category on an atom entry</description>
        <parameters>
          <parameter name="entry" type="Object" usage="required"/>
        </parameters>
        <return-description>boolean denoting if this category filter matched to this entry.</return-description>
      </method>
    </methods>
    <properties>
      <property name="scheme" scope="instance" type="Object"/>
      <property name="term" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av"/>
  <class type="dojox.av.FLAudio">
    <description>This class is brand new, so there is a lot of
	functionality not yet available. The initial
	purpose is for playing "event" sounds like button
	clicks, and for loading and controlling multiple
	sounds at once. As of yet, streaming is not supported
	and polling the sounds for events during playback
	may still be missing information. Markup is not
	supported, as it may not be needed.
	TODO:
	Streaming, playback events, crossdomain, CDN support,
	(alternate SWF location), global volume, ID3 tag,
	factor out doLater, onLoadStatus needs work,
	play(position) / seek()</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance"/>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>url: String
	(required) path to MP3 media
	url must be absolute or relative to SWF,
	not dojo or the html. An effort will be made
	to fix incorrect paths.
	id: String
	(optional) an identifier to later determine
	which media to control.</description>
          </parameter>
        </parameters>
        <return-description>The normalized url, which can be used to identify the
	audio.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="doPlay" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>volume: Number
	Sets the volume
	pan: Number
	Sets left/right pan
	index:Number OR id:String OR url:String
	Choose one of the above to indentify
	the media you wish to control. id is
	set by you. index is the order in which
	media was added (zero based)
	NOTE: lack of an identifier will default
	to first (or only) item.
	NOTE: Can't name this method &amp;quot;play()&amp;quot; as it causes
	an IE error.</description>
          </parameter>
        </parameters>
      </method>
      <method name="pause" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="stop" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="setVolume" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>volume: Number
	0 to 1
	index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="setPan" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>pan:Number -1 to 1
	index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="getVolume" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPan" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPosition" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>index:Number OR id:String OR url:String
	See doPlay()</description>
          </parameter>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoadStatus" scope="instance">
        <parameters>
          <parameter name="events" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onAllLoaded" scope="instance"/>
      <method name="onPlayStatus" scope="instance">
        <parameters>
          <parameter name="events" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="events" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance"/>
      <method name="onID3" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_sub" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeVolume" scope="instance">
        <parameters>
          <parameter name="vol" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeUrl" scope="instance">
        <parameters>
          <parameter name="_url" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="id" scope="instance-prototype" type="String">
        <description>The id of this widget and the id of the SWF movie.</description>
      </property>
      <property name="initialVolume" scope="instance" type="Number">
        <description>From 0-1
	Sets volume for all files unless changed with doPlay
	or setVolume</description>
      </property>
      <property name="initialPan" scope="instance" type="Number">
        <description>From -1 to 1 (-1 is left, 1 is right, 0 is middle)
	Sets pan for all files unless changed with play
	or setPan
	autoPlay: Boolean
	If true, all files will play upon load. If false,
	they load and wait for doPlay() command.</description>
      </property>
      <property name="isDebug" scope="instance" type="Boolean">
        <description>Setting to true tells the SWF to output log messages to Firebug.</description>
      </property>
      <property name="statusInterval" scope="instance" type="Number">
        <description>How often in milliseconds that the status of the
	player is checked - both load and play</description>
      </property>
      <property name="_swfPath" scope="instance" type="Uri">
        <description>The path to the video player SWF resource</description>
      </property>
      <property name="allowScriptAccess" scope="instance" type="String">
        <description>Whether the SWF can access the container JS</description>
      </property>
      <property name="allowNetworking" scope="instance" type="String">
        <description>Whether SWF is restricted to a domain</description>
      </property>
      <property name="_subs" scope="instance" type="Array"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.FLAudio._flashObject">
    <methods>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="onLoad" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.global">
    <methods>
      <method name="swfIsInHTML" scope="instance"/>
      <method name="$" scope="instance"/>
      <method name="jQuery" scope="instance"/>
    </methods>
    <properties>
      <property name="_loadedCss" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.FLVideo" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="play" scope="instance">
        <parameters>
          <parameter name="newUrl" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="pause" scope="instance"/>
      <method name="seek" scope="instance">
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="volume" scope="instance">
        <parameters>
          <parameter name="vol" type="Float" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="mov" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloaded" scope="instance">
        <parameters>
          <parameter name="percent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSwfSized" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPosition" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlay" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPause" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEnd" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStop" scope="instance"/>
      <method name="onBuffer" scope="instance">
        <parameters>
          <parameter name="isBuffering" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <examples>
          <example> console.warn("ERROR-"+data.type.toUpperCase()+":",
			data.info.code, " - URL:", url);</example>
        </examples>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStatus" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlayerStatus" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="instance"/>
      <method name="_checkBuffer" scope="instance">
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
          <parameter name="bufferLength" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.av._Media.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dojox.av._Media" scope="instance"/>
    </mixins>
    <properties>
      <property name="_swfPath" scope="instance" type="Uri">
        <description>The path to the video player SWF resource</description>
      </property>
      <property name="_subs" scope="instance" type="Array"/>
      <property name="_cons" scope="instance" type="Array"/>
      <property name="mediaUrl" scope="instance" type="Object"/>
      <property name="initialVolume" scope="instance" type="Object"/>
      <property name="isPlaying" scope="instance" type="bool"/>
      <property name="isStopped" scope="instance" type="bool"/>
      <property name="isBuffering" scope="instance" type="Object"/>
      <property name="percentDownloaded" scope="instance" type="Object"/>
      <property name="_updateHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.FLVideo._flashObject">
    <methods>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="onLoad" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av._Media">
    <description>Calculates the current status of the playing media and fires
	the appropriate events.</description>
    <methods>
      <method name="_initStatus" scope="instance"/>
      <method name="getTime" scope="instance">
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="mov" type="SWF" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloaded" scope="instance">
        <parameters>
          <parameter name="percent" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSwfSized" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPosition" scope="instance">
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlay" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPause" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEnd" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStop" scope="instance"/>
      <method name="onBuffer" scope="instance">
        <parameters>
          <parameter name="isBuffering" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <examples>
          <example> console.warn("ERROR-"+data.type.toUpperCase()+":",
			data.info.code, " - URL:", url);</example>
        </examples>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onStatus" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlayerStatus" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="instance"/>
      <method name="_figureStatus" scope="instance"/>
      <method name="_eventFactory" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_sub" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeVolume" scope="instance">
        <parameters>
          <parameter name="vol" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeUrl" scope="instance">
        <parameters>
          <parameter name="_url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="mediaUrl" scope="instance" type="String"/>
      <property name="initialVolume" scope="instance" type="Float">
        <description>The initial volume setting of the player. Acccepts between 0 and 1.</description>
      </property>
      <property name="autoPlay" scope="instance" type="Boolean">
        <description>Whether the video automatically plays on load or not.</description>
      </property>
      <property name="bufferTime" scope="instance" type="Number">
        <description>Time in milliseconds that the video should be loaded before it will
	play. May pause and resume to build up buffer. Prevents stuttering.
	Note:
	Older FLVs, without a duration, cannot be buffered.</description>
      </property>
      <property name="minBufferTime" scope="instance" type="Number">
        <description>Time in milliseconds bwteen the playhead time and loaded time that
	will trigger the buffer. When buffer is triggered, video will pause
	until the bufferTime amount is buffered.
	Note: Should be a small number, greater than zero.</description>
      </property>
      <property name="updateTime" scope="instance" type="Number">
        <description>How often, in milliseconds to get an update of the video position.</description>
      </property>
      <property name="id" scope="instance" type="String">
        <description>The id of this widget and the id of the SWF movie.</description>
      </property>
      <property name="isDebug" scope="instance" type="Boolean">
        <description>Setting to true tells the SWF to output log messages to Firebug.</description>
      </property>
      <property name="percentDownloaded" scope="instance" type="Number">
        <description>The percentage the media has downloaded; from 0-100</description>
      </property>
      <property name="_flashObject" scope="instance" type="Object">
        <description>The dojox.embed object</description>
      </property>
      <property name="flashMedia" scope="instance" type="SWF">
        <description>The SWF object. Methods are passed to this.</description>
      </property>
      <property name="allowScriptAccess" scope="instance" type="String">
        <description>Whether the SWF can access the container JS</description>
      </property>
      <property name="allowNetworking" scope="instance" type="String">
        <description>Whether SWF is restricted to a domain</description>
      </property>
      <property name="wmode" scope="instance" type="String">
        <description>The render type of the SWF</description>
      </property>
      <property name="allowFullScreen" scope="instance" type="Boolean">
        <description>Whether to allow the SWF to go to fullscreen</description>
      </property>
      <property name="status" scope="instance" type="String"/>
      <property name="_positionHandle" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="isBuffering" scope="instance" type="Object"/>
      <property name="_prevPos" scope="instance" type="Object"/>
      <property name="_prevStatus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget"/>
  <class type="dojox.av.widget.PlayButton" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setMedia" scope="instance">
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance"/>
      <method name="onPlay" scope="instance"/>
      <method name="onPause" scope="instance"/>
      <method name="showPlay" scope="instance"/>
      <method name="showPause" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
      <property name="_mode" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Player" superclass="dijit._Widget">
    <description>Currently for markup only. All controls should reside as child
	nodes within the Player node. 'controlType' is used to determine
	the placement of the control. If no type or an unrecoginized type
	is used, it will be left-aligned in the same row as the volume.
	Note:
	Be sure to use 'controlType' as a node attribute. It is not a
	property of the widget.</description>
    <methods>
      <method name="_fillContent" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="onResize" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="playerWidth" scope="instance" type="Number">
        <description>or String
	Sets the width of the player (not the video size)
	Number will be converted to pixels
	String will be used literally. EX: &amp;quot;320px&amp;quot; or &amp;quot;100%&amp;quot;
	TODO:
	playerHeight
	videoWidth: 320,
	videoHeight: 240,</description>
      </property>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="items" scope="instance" type="Array"/>
      <property name="children" scope="instance" type="Array"/>
      <property name="media" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.ProgressSlider" superclass="dijit._Widget">
    <description>Displays the current playhead position of the media. Has two
	progress bars: one for playhead position, and one for download
	progress.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setMedia" scope="instance">
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
          <parameter name="playerWidget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDrag" scope="instance">
        <parameters>
          <parameter name="evt" type="HTMLEvent" usage="required"/>
        </parameters>
      </method>
      <method name="startDrag" scope="instance"/>
      <method name="endDrag" scope="instance"/>
      <method name="setHandle" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setLoadedPosition" scope="instance">
        <parameters>
          <parameter name="decimal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleOver" scope="instance"/>
      <method name="handleOut" scope="instance"/>
      <method name="onResize" scope="instance">
        <parameters>
          <parameter name="playerDimensions" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="seeking" scope="instance" type="bool"/>
      <property name="handleWidth" scope="instance" type="Object"/>
      <property name="finalWidth" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="x" scope="instance" type="Object"/>
      <property name="playerWidget" scope="instance" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
      <property name="cmove" scope="instance" type="Object"/>
      <property name="cup" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Status" superclass="dijit._Widget">
    <description>Displays the name of the media file, and it's current status
	(playing, paused, buffering, etc.) in the middle. Displays
	the playhead time on the left and the duration on the right.</description>
    <methods>
      <method name="setMedia" scope="instance">
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBuffer" scope="instance">
        <parameters>
          <parameter name="isBuffering" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPosition" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="instance"/>
      <method name="onPlay" scope="instance"/>
      <method name="onPaused" scope="instance"/>
      <method name="onStop" scope="instance"/>
      <method name="onEnd" scope="instance"/>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance"/>
      <method name="setStatus" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
          <parameter name="isError" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toSeconds" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
      <property name="isBuffering" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Status.durNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.av.widget.Status.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.av.widget.VolumeButton" superclass="dijit._Widget">
    <description>Controls and displays the volume of the media. This widget
	opens a slider on click that is used to adjust the volume.
	The icon changes according to the volume level.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setMedia" scope="instance">
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateIcon" scope="instance">
        <parameters>
          <parameter name="vol" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="onShowVolume" scope="instance">
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onDocClick" scope="instance">
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onHideVolume" scope="instance"/>
      <method name="onDrag" scope="instance">
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="startDrag" scope="instance"/>
      <method name="endDrag" scope="instance"/>
      <method name="handleOver" scope="instance"/>
      <method name="handleOut" scope="instance"/>
      <method name="_getVolumeDim" scope="instance"/>
      <method name="_getHandleDim" scope="instance"/>
      <method name="onResize" scope="instance">
        <parameters>
          <parameter name="playerDimensions" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="handleWidth" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="slotWidth" scope="instance" type="Number"/>
      <property name="volumeSlider" scope="instance" type="Object"/>
      <property name="media" scope="instance" type="Object"/>
      <property name="showing" scope="instance" type="bool"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="clickOff" scope="instance" type="Object"/>
      <property name="isDragging" scope="instance" type="bool"/>
      <property name="cmove" scope="instance" type="Object"/>
      <property name="cup" scope="instance" type="Object"/>
      <property name="_domCoords" scope="instance" type="Object"/>
      <property name="_handleCoords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.calc">
    <methods>
      <method name="approx" scope="instance">
        <parameters>
          <parameter name="r" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pow" scope="instance">
        <parameters>
          <parameter name="base" type="Number" usage="required"/>
          <parameter name="exponent" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="toFrac" scope="instance">
        <parameters>
          <parameter name="number" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.calc.FuncGen" superclass="dijit._Widget">
    <methods>
      <method name="onSelect" scope="instance"/>
      <method name="onClear" scope="instance"/>
      <method name="saveFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSaved" scope="instance"/>
      <method name="clear" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="onReset" scope="instance"/>
      <method name="deleteThing" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance"/>
      <method name="readyStatus" scope="instance"/>
      <method name="startup" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="writeStore" scope="instance" type="Object"/>
      <property name="readStore" scope="instance" type="Object"/>
      <property name="functions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.calc.FuncGen.combo">
    <properties>
      <property name="item" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.calc.GraphPro" superclass="dojox.calc.Standard">
    <methods>
      <method name="executorLoaded" scope="instance"/>
      <method name="makeFunctionWindow" scope="instance"/>
      <method name="makeGrapherWindow" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.calc.Standard" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="grapher" scope="instance" type="Object"/>
      <property name="funcMaker" scope="instance" type="Object"/>
      <property name="aFloatingPane" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.calc.Grapher" superclass="dijit._Widget">
    <methods>
      <method name="addXYAxes" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectAll" scope="instance"/>
      <method name="deselectAll" scope="instance"/>
      <method name="drawOne" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDraw" scope="instance"/>
      <method name="erase" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onErase" scope="instance"/>
      <method name="onDelete" scope="instance"/>
      <method name="createFunction" scope="instance"/>
      <method name="setStatus" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
          <parameter name="status" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changedColor" scope="instance"/>
      <method name="makeDirty" scope="instance"/>
      <method name="checkDirty1" scope="instance"/>
      <method name="checkDirty" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="chart" type="Chart2D" usage="required"/>
          <parameter name="functionToGraph" type="Function" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generatePoints" scope="instance">
        <parameters>
          <parameter name="funcToGraph" type="Function" usage="required"/>
          <parameter name="x" type="String" usage="required"/>
          <parameter name="y" type="String" usage="required"/>
          <parameter name="width" type="Number" usage="required"/>
          <parameter name="minX" type="Number" usage="required"/>
          <parameter name="maxX" type="Number" usage="required"/>
          <parameter name="minY" type="Number" usage="required"/>
          <parameter name="maxY" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="someone pushed cancel in the val code"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="checkboxIndex" scope="instance" type="Number"/>
      <property name="functionMode" scope="instance" type="Number"/>
      <property name="expressionIndex" scope="instance" type="Number"/>
      <property name="colorIndex" scope="instance" type="Number"/>
      <property name="dropDownIndex" scope="instance" type="Number"/>
      <property name="tooltipIndex" scope="instance" type="Number"/>
      <property name="colorBoxFieldsetIndex" scope="instance" type="Number"/>
      <property name="statusIndex" scope="instance" type="Number"/>
      <property name="chartIndex" scope="instance" type="Number"/>
      <property name="funcNumberIndex" scope="instance" type="Number"/>
      <property name="evaluatedExpression" scope="instance" type="Number"/>
      <property name="functionRef" scope="instance" type="Number"/>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="funcNumber" scope="instance" type="Number"/>
      <property name="rowCount" scope="instance" type="Number"/>
      <property name="array" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.calc.Standard" superclass="dijit._Widget">
    <methods>
      <method name="executorLoaded" scope="instance"/>
      <method name="saveFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="isReadOnly" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parseTextbox" scope="instance"/>
      <method name="cycleCommands" scope="instance">
        <parameters>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cycleCommandUp" scope="instance"/>
      <method name="cycleCommandDown" scope="instance"/>
      <method name="onBlur" scope="instance"/>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertMinus" scope="instance"/>
      <method name="print" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
          <parameter name="isRight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTextboxValue" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putInAnsIfTextboxIsHighlighted" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearText" scope="instance"/>
      <method name="insertOperator" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertText" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="readStore" scope="instance" type="Object"/>
      <property name="writeStore" scope="instance" type="Object"/>
      <property name="functions" scope="instance" type="Array"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="commandIndex" scope="instance" type="Number"/>
      <property name="hasDisplay" scope="instance" type="Object"/>
      <property name="handle" scope="instance" type="Object"/>
      <property name="commandList" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.calc.Standard.textboxWidget.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
      <property name="selectionEnd" scope="instance" type="String"/>
      <property name="selectionStart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.calc.Standard.displayBox">
    <properties>
      <property name="scrollTop" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.calc._Executor" superclass="dijit._Widget">
    <methods>
      <method name="_onLoad" scope="instance">
        <parameters>
          <parameter name="env" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance"/>
      <method name="Function" scope="instance">
        <parameters>
          <parameter name="name" type="this" usage="required">
            <description>argument is simply a String that represents the name of the function being evaluated. It can be undefined, but in that case the function is a one time use.</description>
          </parameter>
          <parameter name="args" type="the" usage="required">
            <description>function arguments (a String)</description>
          </parameter>
          <parameter name="body" type="the" usage="required">
            <description>function body, also a String</description>
          </parameter>
        </parameters>
      </method>
      <method name="normalizedFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteFunction" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="eval" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting">
    <properties>
      <property name="__ChartCtorArgs" scope="instance" type="Object"/>
      <property name="Chart2D" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Chart">
    <description>dojox.charting.Chart is the primary object used for any kind of charts.  It
	is simple to create--just pass it a node reference, which is used as the
	container for the chart--and a set of optional keyword arguments and go.
	Note that like most of dojox.gfx, most of dojox.charting.Chart's methods are
	designed to return a reference to the chart itself, to allow for functional
	chaining.  This makes defining everything on a Chart very easy to do.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="kwArgs" type="dojox.charting.__ChartCtorArgs" usage="optional"/>
        </parameters>
        <return-description>dojox.charting.Chart
	The newly created chart.</return-description>
      </method>
      <method name="destroy" scope="instance">
        <return-description>void</return-description>
      </method>
      <method name="getCoords" scope="instance">
        <return-description>Object
	The resulting coordinates of the chart.  See dojo.coords for details.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setTheme" scope="instance">
        <parameters>
          <parameter name="theme" type="dojox.charting.Theme" usage="required">
            <description>The theme to be used for visual rendering.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="addAxis" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the axis.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional">
            <description>An optional keyword arguments object for use in defining details of an axis.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="getAxis" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name the axis was defined by.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.axis2d.Default
	The axis as stored in the chart's axis map.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="removeAxis" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The axis name, as defined in addAxis.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="addPlot" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the plot to be added to the chart.  If you only plan on using one plot, call it &amp;quot;default&amp;quot;.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__PlotCtorArgs" usage="required">
            <description>An object with optional parameters for the plot in question.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="removePlot" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the plot as defined using addPlot.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="getPlotOrder" scope="instance">
        <return-description>Array</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="setPlotOrder" scope="instance">
        <parameters>
          <parameter name="newOrder" type="Array" usage="required">
            <description>Array of plot names compatible with getPlotOrder().</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="movePlotToFront" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Plot's name to move.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="movePlotToBack" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Plot's name to move.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the data series to be plotted.</description>
          </parameter>
          <parameter name="data" type="Array|Object" usage="required">
            <description>The array of data points (either numbers or objects) that
	represents the data to be drawn. Or it can be an object. In
	the latter case, it should have a property &amp;quot;data&amp;quot; (an array),
	destroy(), and setSeriesObject().</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.__SeriesCtorArgs" usage="optional">
            <description>An optional keyword arguments object that will be mixed into
	the resultant series object.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart:
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="removeSeries" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the series as defined by addSeries.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="updateSeries" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the series as defined in addSeries.</description>
          </parameter>
          <parameter name="data" type="Array|Object" usage="required">
            <description>The array of data points (either numbers or objects) that
	represents the data to be drawn. Or it can be an object. In
	the latter case, it should have a property &amp;quot;data&amp;quot; (an array),
	destroy(), and setSeriesObject().</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="getSeriesOrder" scope="instance">
        <parameters>
          <parameter name="plotName" type="String" usage="required">
            <description>Plot's name.</description>
          </parameter>
        </parameters>
        <return-description>Array</return-description>
      </method>
      <method name="setSeriesOrder" scope="instance">
        <parameters>
          <parameter name="newOrder" type="Array" usage="required">
            <description>Array of series names compatible with getPlotOrder(). All
	series should belong to the same plot.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="moveSeriesToFront" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Series' name to move.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="moveSeriesToBack" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Series' name to move.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="resize" scope="instance">
        <description>Resize the chart and its surface to the width and height dimensions.
	If no width/height or box is provided, resize the surface to the marginBox of the chart.</description>
        <parameters>
          <parameter name="width" type="Number" usage="required">
            <description>The new width of the chart.</description>
          </parameter>
          <parameter name="height" type="Number" usage="required">
            <description>The new height of the chart.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="getGeometry" scope="instance">
        <return-description>Object
	An map of geometry objects, a one-to-one mapping of axes.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setAxisWindow" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the axis as defined by addAxis.</description>
          </parameter>
          <parameter name="scale" type="Number" usage="required">
            <description>The scale on the target axis.</description>
          </parameter>
          <parameter name="offset" type="Number" usage="required">
            <description>Any offest, as measured by axis tick</description>
          </parameter>
          <parameter name="zoom" type="Boolean|Object" usage="optional">
            <description>The chart zooming animation trigger.  This is null by default,
	e.g. {duration: 1200}, or just set true.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="setWindow" scope="instance">
        <parameters>
          <parameter name="sx" type="Number" usage="required">
            <description>The scale for the x axis.</description>
          </parameter>
          <parameter name="sy" type="Number" usage="required">
            <description>The scale for the y axis.</description>
          </parameter>
          <parameter name="dx" type="Number" usage="required">
            <description>The pixel offset on the x axis.</description>
          </parameter>
          <parameter name="dy" type="Number" usage="required">
            <description>The pixel offset on the y axis.</description>
          </parameter>
          <parameter name="zoom" type="Boolean|Object" usage="optional">
            <description>The chart zooming animation trigger.  This is null by default,
	e.g. {duration: 1200}, or just set true.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="zoomIn" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the axis as defined by addAxis.</description>
          </parameter>
          <parameter name="range" type="Array" usage="required">
            <description>The end points of the zoom range, measured in axis ticks.</description>
          </parameter>
        </parameters>
      </method>
      <method name="calculateGeometry" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="fullGeometry" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="fullRender" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="delayedRender" scope="instance">
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="connectToPlot" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the plot as defined by addPlot.</description>
          </parameter>
          <parameter name="object" type="Object" usage="required">
            <description>The object to be connected.</description>
          </parameter>
          <parameter name="method" type="Function" usage="required">
            <description>The function to be executed.</description>
          </parameter>
        </parameters>
        <return-description>Array
	A handle to the connection, as defined by dojo.connect (see dojo.connect).</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fireEvent" scope="instance">
        <parameters>
          <parameter name="seriesName" type="String" usage="required">
            <description>Series name.</description>
          </parameter>
          <parameter name="eventName" type="String" usage="required">
            <description>Event name to simulate: onmouseover, onmouseout, onclick.</description>
          </parameter>
          <parameter name="index" type="Number" usage="required">
            <description>Valid data value index for the event.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Chart
	A reference to the current chart for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Chart"/>
        </return-types>
      </method>
      <method name="_makeClean" scope="instance"/>
      <method name="_makeDirty" scope="instance"/>
      <method name="_invalidateDependentPlots" scope="instance">
        <parameters>
          <parameter name="plotName" type="Object" usage="required"/>
          <parameter name="verticalAxis" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="coords" scope="instance-prototype" type="Object"/>
      <property name="theme" scope="instance-prototype" type="Object"/>
      <property name="dirty" scope="instance-prototype" type="Object"/>
      <property name="runs" scope="instance-prototype" type="Object"/>
      <property name="series" scope="instance-prototype" type="Array"/>
      <property name="stack" scope="instance-prototype" type="Array"/>
      <property name="dim" scope="instance" type="Object"/>
      <property name="offsets" scope="instance" type="Object"/>
      <property name="titleGap" scope="instance-prototype" type="Object"/>
      <property name="titlePos" scope="instance-prototype" type="String"/>
      <property name="titleFont" scope="instance-prototype" type="Object"/>
      <property name="titleFontColor" scope="instance-prototype" type="String"/>
      <property name="plotArea" scope="instance" type="Object"/>
      <property name="chartTitle" scope="instance-prototype" type="Object"/>
      <property name="_delayedRenderHandle" scope="instance" type="Object"/>
      <property name="margins" scope="instance" type="Object"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="delayInMs" scope="instance" type="Number"/>
      <property name="title" scope="instance" type="Object"/>
      <property name="axes" scope="instance" type="Object"/>
      <property name="plots" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang">
    <methods>
      <method name="observable" scope="instance">
        <parameters>
          <parameter name="wrapped" type="Object" usage="required">
            <description>The object to be wrapped and monitored for property access and modification</description>
          </parameter>
          <parameter name="onRead" type="function" usage="required">
            <description>See dojox.lang.makeObservable.onRead</description>
          </parameter>
          <parameter name="onWrite" type="function" usage="required">
            <description>See dojox.lang.makeObservable.onWrite</description>
          </parameter>
          <parameter name="onInvoke" type="function" usage="required">
            <description>See dojox.lang.makeObservable.onInvoke</description>
          </parameter>
        </parameters>
      </method>
      <method name="makeObservable" scope="instance">
        <examples>
          <example>The following could be used to create a wrapper that would
	prevent functions from being accessed on an object:
		function onRead(obj,prop){
			return typeof obj[prop] == 'function' ? null : obj[prop];
		}
		var observable = dojox.lang.makeObservable(onRead,onWrite);
		var obj = {foo:1,bar:function(){}};
		obj = observable(obj);
		obj.foo -&gt; 1
		obj.bar -&gt; null</example>
        </examples>
        <parameters>
          <parameter name="onRead" type="function" usage="required">
            <description>This is called whenever one of the wrapper objects created
	from the constructor has a property that is accessed. onRead
	will be called with two arguments, the first being the wrapped object,
	and the second is the name of property that is being accessed.
	The value that onRead returns will be used as the value returned
	by the property access</description>
          </parameter>
          <parameter name="onWrite" type="function" usage="required">
            <description>This is called whenever one of the wrapper objects created
	from the constructor has a property that is modified. onWrite
	will be called with three arguments, the first being the wrapped object,
	the second is the name of property that is being modified, and the
	third is the value that is being set on the property.</description>
          </parameter>
          <parameter name="onInvoke" type="function" usage="required">
            <description>This is called when a method on the object is invoked. The first
	argument is the wrapper object, the second is the original wrapped object,
	the third is the method name, and the fourth is the arguments.</description>
          </parameter>
          <parameter name="hiddenFunctions" type="Object" usage="required">
            <description>allows you to define functions that should be delegated
	but may not be enumerable on the wrapped objects, so they must be
	explicitly included</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="do it with getters and setters"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="lettableWin" scope="instance" type="Object"/>
      <property name="ReadOnlyProxy" scope="instance" type="Object"/>
      <property name="typed" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Chart3D">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
          <parameter name="camera" type="Object" usage="required"/>
          <parameter name="theme" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generate" scope="instance"/>
      <method name="invalidate" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="addPlot" scope="instance">
        <parameters>
          <parameter name="plot" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removePlot" scope="instance">
        <parameters>
          <parameter name="plot" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addWall" scope="instance">
        <parameters>
          <parameter name="wall" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeWall" scope="instance">
        <parameters>
          <parameter name="wall" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_add" scope="instance">
        <parameters>
          <parameter name="array" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="instance">
        <parameters>
          <parameter name="array" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_generateWalls" scope="instance"/>
      <method name="_generatePlots" scope="instance"/>
    </methods>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="view" scope="instance" type="Object"/>
      <property name="theme" scope="instance" type="Object"/>
      <property name="walls" scope="instance" type="Array"/>
      <property name="plots" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d">
    <methods>
      <method name="gradient" scope="instance">
        <parameters>
          <parameter name="model" type="dojox.gfx3d.lighting.Model" usage="required">
            <description>color model</description>
          </parameter>
          <parameter name="material" type="Object" usage="required">
            <description>defines visual properties</description>
          </parameter>
          <parameter name="center" type="Object" usage="required">
            <description>center of the cylinder's bottom</description>
          </parameter>
          <parameter name="radius" type="Number" usage="required">
            <description>radius of the cylinder</description>
          </parameter>
          <parameter name="from" type="Number" usage="required">
            <description>from position in radians</description>
          </parameter>
          <parameter name="to" type="Number" usage="required">
            <description>from position in radians</description>
          </parameter>
          <parameter name="matrix" type="dojox.gfx3d.Matrix3D" usage="required">
            <description>the cumulative transformation matrix
	tolerance: Number: tolerable diffirence in colors between gradient steps</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
      <property name="Matrix3D" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx">
    <description>dojox.gfx is an advanced API providing normalized vector drawing
	in a variety of browsers. It has individual renderers for SVG, VML,
	Canvas, and Silverlight.</description>
    <methods>
      <method name="normalizedLength" scope="instance">
        <parameters>
          <parameter name="len" type="String" usage="required">
            <description>a length, e.g., &amp;quot;12pc&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="getVectorFont" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="normalizeColor" scope="instance">
        <parameters>
          <parameter name="color" type="Color" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="normalizeParameters" scope="instance">
        <parameters>
          <parameter name="existed" type="Object" usage="required">
            <description>the &amp;quot;target&amp;quot; object to be updated</description>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <description>the &amp;quot;update&amp;quot; object, whose properties will be used to update
	the existed object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="makeParameters" scope="instance">
        <parameters>
          <parameter name="defaults" type="Object" usage="required">
            <description>the object to be cloned before updating</description>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <description>the object, which properties are to be cloned during updating</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formatNumber" scope="instance">
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>number to be converted</description>
          </parameter>
          <parameter name="addSpace" type="Boolean" usage="optional">
            <description>if it is true, add a space before a positive number</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="makeFontString" scope="instance">
        <parameters>
          <parameter name="font" type="Object" usage="required">
            <description>font object (see dojox.gfx.defaultFont)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="splitFontString" scope="instance">
        <description>Converts a CSS font string to a gfx font object. The CSS font
	string components should follow the W3C specified order
	(see http://www.w3.org/TR/CSS2/fonts.html#font-shorthand):
	style, variant, weight, size, optional line height (will be
	ignored), and family.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>a CSS font string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="px_in_pt" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="pt2px" scope="instance">
        <parameters>
          <parameter name="len" type="Number" usage="required">
            <description>a value in points</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="px2pt" scope="instance">
        <parameters>
          <parameter name="len" type="Number" usage="required">
            <description>a value in pixels</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="equalSources" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="switchTo" scope="instance">
        <parameters>
          <parameter name="renderer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hasClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_addClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_removeClass" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="decompose" scope="instance">
        <description>this function decompose a matrix into four logical components:
	translation, rotation, scaling, and one more rotation using SVD.
	The components should be applied in following order:
	 [translate, rotate(angle2), scale, rotate(angle1)]</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix-like object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_vectorFontCache" scope="instance" type="Object"/>
      <property name="_svgFontCache" scope="instance" type="Object"/>
      <property name="VectorText" scope="instance" type="Object"/>
      <property name="getDefault" scope="instance" type="Object"/>
      <property name="cm_in_pt" scope="instance" type="Number"/>
      <property name="mm_in_pt" scope="instance" type="Number"/>
      <property name="pathVmlRegExp" scope="instance" type="RegExp"/>
      <property name="pathSvgRegExp" scope="instance" type="RegExp"/>
      <property name="attach" scope="instance" type="Object"/>
      <property name="canvas_attach" scope="instance" type="Object"/>
      <property name="Matrix2D" scope="instance" type="Object"/>
      <property name="move" scope="instance" type="Object"/>
      <property name="silverlight_attach" scope="instance" type="Object"/>
      <property name="svg_attach" scope="instance" type="Object"/>
      <property name="renderer" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.DataChart" superclass="dojox.charting.Chart2D">
    <description>This code should be considered very experimental and the APIs subject
	to change. This is currently an alpha version and will need some testing
	and review.
	The main reason for this extension is to create animated charts, generally
	available with scroll=true, and a property field that gets continually updated.
	The previous property settings are kept in memory and displayed until scrolled
	off the chart.
	Although great effort was made to maintain the integrity of the current
	charting APIs, some things have been added or modified in order to get
	the store to connect and also to get the data to scroll/animate.
	"displayRange" in particular is used to force the xaxis to a specific
	size and keep the chart from stretching or squashing to fit the data.
	Currently, plot lines can only be set at initialization. Setting
	a new store query will have no effect (although using setStore
	may work but its untested).</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to attach the chart to.</description>
          </parameter>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required">
            <description>String</description>
          </parameter>
          <parameter name="fieldName" type="Object" usage="required">
            <description>String</description>
          </parameter>
          <parameter name="queryOptions" type="Object" usage="required">
            <description>Object</description>
          </parameter>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="onSet" scope="instance">
        <parameters>
          <parameter name="item" type="storeObject" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="err" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDataReceived" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="getProperty" scope="instance">
        <parameters>
          <parameter name="item" type="storeObject" usage="required"/>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onData" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance"/>
      <method name="convertLabels" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="seriesLabels" scope="instance">
        <parameters>
          <parameter name="val" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="resizeChart" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.Chart2D" scope="instance"/>
    </mixins>
    <properties>
      <property name="scroll" scope="instance" type="Boolean">
        <description>Whether live data updates and changes display, like columns moving
	up and down, or whether it scrolls to the left as data is added</description>
      </property>
      <property name="comparative" scope="instance" type="Boolean">
        <description>If false, all items are each their own series.
	If true, the items are combined into one series
	so that their charted properties can be compared.</description>
      </property>
      <property name="query" scope="instance" type="String">
        <description>Used for fetching items. Will vary depending upon store.</description>
      </property>
      <property name="queryOptions" scope="instance" type="String">
        <description>Option used for fetching items</description>
      </property>
      <property name="fieldName" scope="instance" type="String">
        <description>The field in the store item that is getting charted</description>
      </property>
      <property name="chartTheme" scope="instance" type="dojox.charting.themes.*">
        <description>The theme to style the chart. Defaults to PlotKit.blue.</description>
      </property>
      <property name="displayRange" scope="instance" type="Number">
        <description>The number of major ticks to show on the xaxis</description>
      </property>
      <property name="stretchToFit" scope="instance-prototype" type="Boolean">
        <description>If true, chart is sized to data. If false, chart is a
	fixed size. Note, is overridden by displayRange.
	TODO: Stretch for the y-axis?</description>
      </property>
      <property name="minWidth" scope="instance" type="Number">
        <description>The the smallest the chart width can be</description>
      </property>
      <property name="minHeight" scope="instance" type="Number">
        <description>The the smallest the chart height can be</description>
      </property>
      <property name="showing" scope="instance" type="Boolean">
        <description>Whether the chart is showing (default) on
	initialization or hidden.</description>
      </property>
      <property name="label" scope="instance" type="String">
        <description>The name field of the store item
	DO NOT SET: Set from store.labelAttribute</description>
      </property>
      <property name="firstRun" scope="instance-prototype" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="_events" scope="instance-prototype" type="Array"/>
      <property name="onSetInterval" scope="instance-prototype" type="Number"/>
      <property name="items" scope="instance" type="Object"/>
      <property name="dataOffset" scope="instance-prototype" type="Number"/>
      <property name="dataLength" scope="instance-prototype" type="Number"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="onSetItems" scope="instance" type="Object"/>
      <property name="seriesData" scope="instance" type="Object"/>
      <property name="seriesDataBk" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.DataChart.xaxis">
    <properties>
      <property name="labelFunc" scope="instance" type="Object"/>
      <property name="to" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.DataChart.yaxis">
    <properties>
      <property name="labelFunc" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.DataChart.chartTheme.plotarea">
    <properties>
      <property name="stroke" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.DataSeries">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required">
            <description>A dojo.data store object.</description>
          </parameter>
          <parameter name="kwArgs" type="Object" usage="required">
            <description>A store-specific keyword parameters used for fetching items.
	See dojo.data.api.Read.fetch().</description>
          </parameter>
          <parameter name="value" type="Function|Object|String|Null" usage="required">
            <description>Function, which takes a store, and an object handle, and
	produces an output possibly inspecting the store's item. Or
	a dictionary object, which tells what names to extract from
	an object and how to map them to an output. Or a string, which
	is a numeric field name to use for plotting. If undefined, null
	or empty string (the default), &amp;quot;value&amp;quot; field is extracted.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="setSeriesObject" scope="instance">
        <parameters>
          <parameter name="series" type="dojox.charting.Series" usage="required">
            <description>Our interface to the chart.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_dictValue" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="dict" type="Object" usage="required"/>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fieldValue" scope="instance">
        <parameters>
          <parameter name="field" type="Object" usage="required"/>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_defaultValue" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance"/>
      <method name="_onFetchComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFetchError" scope="instance">
        <parameters>
          <parameter name="errorData" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildItemMap" scope="instance"/>
      <method name="_pushDataChanges" scope="instance"/>
      <method name="_onStoreNew" scope="instance"/>
      <method name="_onStoreDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onStoreSet" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="series" scope="instance" type="Object"/>
      <property name="_inFlight" scope="instance" type="bool"/>
      <property name="items" scope="instance" type="Object"/>
      <property name="data" scope="instance-prototype" type="Array"/>
      <property name="itemMap" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object">
        <description>A dojo.data store object.</description>
      </property>
      <property name="kwArgs" scope="instance" type="Object">
        <description>A store-specific keyword parameters used for fetching items.
	See dojo.data.api.Read.fetch().</description>
      </property>
      <property name="value" scope="instance" type="Function|Object|String|Null">
        <description>Function, which takes a store, and an object handle, and
	produces an output possibly inspecting the store's item. Or
	a dictionary object, which tells what names to extract from
	an object and how to map them to an output. Or a string, which
	is a numeric field name to use for plotting. If undefined, null
	or empty string (the default), &amp;quot;value&amp;quot; field is extracted.</description>
      </property>
      <property name="_events" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart that this element belongs to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="createGroup" scope="instance">
        <parameters>
          <parameter name="creator" type="dojox.gfx.Surface" usage="optional">
            <description>An optional surface in which to create this group.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Element
	A reference to this object for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Element"/>
        </return-types>
      </method>
      <method name="purgeGroup" scope="instance">
        <return-description>dojox.charting.Element
	A reference to this object for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Element"/>
        </return-types>
      </method>
      <method name="cleanGroup" scope="instance">
        <parameters>
          <parameter name="creator" type="dojox.gfx.Surface" usage="optional">
            <description>An optional surface to work with.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Element
	A reference to this object for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.Element"/>
        </return-types>
      </method>
      <method name="destroyHtmlElements" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="getTextWidth" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextWithLimitLength" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="optional">
            <description>candidate text.</description>
          </parameter>
          <parameter name="font" type="String" usage="optional">
            <description>text's font style.</description>
          </parameter>
          <parameter name="limitWidth" type="Number" usage="optional">
            <description>text limited width in px.</description>
          </parameter>
          <parameter name="truncated" type="whether" usage="required">
            <description>text has been truncated
	}</description>
          </parameter>
        </parameters>
        <return-description>Object
	{
	text: processed text, maybe truncated or not</return-description>
      </method>
      <method name="getTextWithLimitCharCount" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="optional">
            <description>candidate text.</description>
          </parameter>
          <parameter name="font" type="String" usage="optional">
            <description>text's font style.</description>
          </parameter>
          <parameter name="wcLimit" type="Number" usage="optional">
            <description>text limited character count.</description>
          </parameter>
          <parameter name="truncated" type="whether" usage="required">
            <description>text has been truncated
	}</description>
          </parameter>
        </parameters>
        <return-description>Object
	{
	text: processed text, maybe truncated or not</return-description>
      </method>
      <method name="_plotFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_shapeFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
          <parameter name="bbox" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pseudoRadialFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
          <parameter name="center" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="group" scope="instance-prototype" type="dojox.gfx.Group">
        <description>The visual GFX group representing this element.
	htmlElement: Array
	Any DOMNodes used as a part of this element (such as HTML-based labels).</description>
      </property>
      <property name="htmlElements" scope="instance-prototype" type="Array"/>
      <property name="dirty" scope="instance-prototype" type="Boolean">
        <description>A flag indicating whether or not this element needs to be rendered.</description>
      </property>
      <property name="_events" scope="instance-prototype" type="Array"/>
      <property name="trailingSymbol" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Element.chart">
    <properties>
      <property name="surface" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Series" superclass="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart that this series belongs to.</description>
          </parameter>
          <parameter name="data" type="Array|Object" usage="required">
            <description>The array of data points (either numbers or objects) that
	represents the data to be drawn. Or it can be an object. In
	the latter case, it should have a property &amp;quot;data&amp;quot; (an array),
	destroy(), and setSeriesObject().</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.__SeriesCtorArgs" usage="optional">
            <description>An optional keyword arguments object to set details for this series.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="update" scope="instance">
        <parameters>
          <parameter name="data" type="Array|Object" usage="required">
            <description>The array of data points (either numbers or objects) that
	represents the data to be drawn. Or it can be an object. In
	the latter case, it should have a property &amp;quot;data&amp;quot; (an array),
	destroy(), and setSeriesObject().</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
    </mixins>
    <properties>
      <property name="dyn" scope="instance" type="Object"/>
      <property name="data" scope="instance" type="Object"/>
      <property name="source" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="plot" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.__SeriesCtorArgs">
    <methods/>
    <properties>
      <property name="plot" scope="instance" type="String">
        <description>The plot (by name) that this series belongs to.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.StoreSeries">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required">
            <description>A dojo object store.</description>
          </parameter>
          <parameter name="kwArgs" type="Object" usage="required">
            <description>A store-specific keyword parameters used for querying objects.
	See dojo.store docs</description>
          </parameter>
          <parameter name="value" type="Function|Object|String|Null" usage="required">
            <description>Function, which takes an object handle, and
	produces an output possibly inspecting the store's item. Or
	a dictionary object, which tells what names to extract from
	an object and how to map them to an output. Or a string, which
	is a numeric field name to use for plotting. If undefined, null
	or empty string (the default), &amp;quot;value&amp;quot; field is extracted.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="setSeriesObject" scope="instance">
        <parameters>
          <parameter name="series" type="dojox.charting.Series" usage="required">
            <description>Our interface to the chart.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fetch" scope="instance"/>
      <method name="_pushDataChanges" scope="instance"/>
    </methods>
    <properties>
      <property name="series" scope="instance" type="Object"/>
      <property name="objects" scope="instance" type="Array"/>
      <property name="observeHandle" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object">
        <description>A dojo object store.</description>
      </property>
      <property name="kwArgs" scope="instance" type="Object">
        <description>A store-specific keyword parameters used for querying objects.
	See dojo.store docs</description>
      </property>
      <property name="value" scope="instance" type="Function|Object|String|Null">
        <description>Function, which takes an object handle, and
	produces an output possibly inspecting the store's item. Or
	a dictionary object, which tells what names to extract from
	an object and how to map them to an output. Or a string, which
	is a numeric field name to use for plotting. If undefined, null
	or empty string (the default), &amp;quot;value&amp;quot; field is extracted.</description>
      </property>
      <property name="data" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme">
    <description>While you can set up style definitions on a chart directly (usually through the various add methods
	on a dojox.charting.Chart2D object), a Theme simplifies this manual setup by allowing you to
	pre-define all of the various visual parameters of each element in a chart.
	Most of the properties of a Theme are straight-forward; if something is line-based (such as
	an axis or the ticks on an axis), they will be defined using basic stroke parameters.  Likewise,
	if an element is primarily block-based (such as the background of a chart), it will be primarily
	fill-based.
	In addition (for convenience), a Theme definition does not have to contain the entire JSON-based
	structure.  Each theme is built on top of a default theme (which serves as the basis for the theme
	"GreySkies"), and is mixed into the default theme object.  This allows you to create a theme based,
	say, solely on colors for data series.
	Defining a new theme is relatively easy; see any of the themes in dojox.charting.themes for examples
	on how to define your own.
	When you set a theme on a chart, the theme itself is deep-cloned.  This means that you cannot alter
	the theme itself after setting the theme value on a chart, and expect it to change your chart.  If you
	are looking to make alterations to a theme for a chart, the suggestion would be to create your own
	theme, based on the one you want to use, that makes those alterations before it is applied to a chart.
	Finally, a Theme contains a number of functions to facilitate rendering operations on a chart--the main
	helper of which is the ~next~ method, in which a chart asks for the information for the next data series
	to be rendered.
	A note on colors:
	The Theme constructor was on the use of dojox.color.Palette (in general) for creating a visually distinct
	set of colors for usage in a chart.  A palette is usually comprised of 5 different color definitions, and
	no more.  If you have a need to render a chart with more than 5 data elements, you can simply "push"
	new color definitions into the theme's .color array.  Make sure that you do that with the actual
	theme object from a Chart, and not in the theme itself (i.e. either do that before using .setTheme
	on a chart).</description>
    <methods>
      <method name="defineColors" scope="instance">
        <examples>
          <example>	var colors = dojox.charting.Theme.defineColors({
			base: "#369",
			generator: "compound"
		});</example>
          <example>	var colors = dojox.charting.Theme.defineColors({
			hue: 60,
			saturation: 90,
			low: 30,
			high: 80
		});</example>
        </examples>
        <parameters>
          <parameter name="kwArgs" type="dojox.charting.Theme.__DefineColorArgs" usage="required">
            <description>The arguments object used to define colors.</description>
          </parameter>
        </parameters>
        <return-description>dojo.Color[]
	An array of colors for use in a theme.</return-description>
        <return-types>
          <return-type type="Array&lt;dojo.Color&gt;"/>
        </return-types>
      </method>
      <method name="generateGradient" scope="instance">
        <parameters>
          <parameter name="fillPattern" type="Object" usage="required"/>
          <parameter name="colorFrom" type="Object" usage="required"/>
          <parameter name="colorTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generateHslColor" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
          <parameter name="luminance" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="generateHslGradient" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
          <parameter name="fillPattern" type="Object" usage="required"/>
          <parameter name="lumFrom" type="Object" usage="required"/>
          <parameter name="lumTo" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="instance">
        <return-description>dojox.charting.Theme
	The cloned theme; any alterations made will not affect the original.</return-description>
        <return-types>
          <return-type type="dojox.charting.Theme"/>
        </return-types>
      </method>
      <method name="clear" scope="instance"/>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="String" usage="optional">
            <description>An optional element type (for use with series themes)</description>
          </parameter>
          <parameter name="mixin" type="Object" usage="optional">
            <description>An optional object to mix into the theme.</description>
          </parameter>
          <parameter name="doPost" type="Boolean" usage="optional">
            <description>A flag to post-process the results.</description>
          </parameter>
        </parameters>
        <return-description>Object
	An object of the structure { series, marker, symbol }</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="skip" scope="instance"/>
      <method name="addMixin" scope="instance">
        <parameters>
          <parameter name="theme" type="dojox.charting.Theme" usage="required">
            <description>The theme to mixin to.</description>
          </parameter>
          <parameter name="elementType" type="String" usage="required">
            <description>The type of element in question. Can be &amp;quot;line&amp;quot;, &amp;quot;bar&amp;quot; or &amp;quot;circle&amp;quot;</description>
          </parameter>
          <parameter name="mixin" type="Object|Array" usage="required">
            <description>The object or objects to mix into the theme.</description>
          </parameter>
          <parameter name="doPost" type="Boolean" usage="required">
            <description>If true, run the new theme through the post-processor.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Theme
	The new theme.</return-description>
        <return-types>
          <return-type type="dojox.charting.Theme"/>
        </return-types>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="dojox.charting.Theme" usage="required">
            <description>The theme to post process with.</description>
          </parameter>
          <parameter name="elementType" type="String" usage="required">
            <description>The type of element being filled.  Can be &amp;quot;bar&amp;quot; or &amp;quot;circle&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.Theme
	The post-processed theme.</return-description>
        <return-types>
          <return-type type="dojox.charting.Theme"/>
        </return-types>
      </method>
      <method name="getTick" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Tick name, can be &amp;quot;major&amp;quot;, &amp;quot;minor&amp;quot;, or &amp;quot;micro&amp;quot;.</description>
          </parameter>
          <parameter name="mixin" type="Object" usage="optional">
            <description>Optional object to mix in to the tick.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="inspectObjects" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reverseFills" scope="instance"/>
      <method name="addMarker" scope="instance">
        <examples>
          <example>	myTheme.addMarker("Ellipse", foo);</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="segment" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setMarkers" scope="instance">
        <examples>
          <example>	myTheme.setMarkers({ "CIRCLE": foo });</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildMarkerArray" scope="instance"/>
    </methods>
    <properties>
      <property name="defaultColors" scope="instance" type="Array"/>
      <property name="_current" scope="instance-prototype" type="Number"/>
      <property name="markers" scope="instance-prototype" type="Object"/>
      <property name="_markers" scope="instance" type="Array"/>
      <property name="colors" scope="instance" type="Object"/>
      <property name="seriesThemes" scope="instance" type="Object"/>
      <property name="markerThemes" scope="instance" type="Object"/>
      <property name="noGradConv" scope="instance" type="Object"/>
      <property name="noRadialConv" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultMarkers">
    <properties>
      <property name="CIRCLE" scope="instance" type="String"/>
      <property name="SQUARE" scope="instance" type="String"/>
      <property name="DIAMOND" scope="instance" type="String"/>
      <property name="CROSS" scope="instance" type="String"/>
      <property name="X" scope="instance" type="String"/>
      <property name="TRIANGLE" scope="instance" type="String"/>
      <property name="TRIANGLE_INVERTED" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme"/>
  <class type="dojox.charting.Theme.defaultTheme.chart">
    <properties>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="String"/>
      <property name="pageStyle" scope="instance" type="Object"/>
      <property name="titleGap" scope="instance" type="Number"/>
      <property name="titlePos" scope="instance" type="String"/>
      <property name="titleFont" scope="instance" type="String"/>
      <property name="titleFontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.plotarea">
    <properties>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.axis"/>
  <class type="dojox.charting.Theme.defaultTheme.axis.stroke">
    <properties>
      <property name="color" scope="instance" type="String"/>
      <property name="width" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.axis.tick">
    <properties>
      <property name="color" scope="instance" type="String"/>
      <property name="position" scope="instance" type="String"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
      <property name="titleGap" scope="instance" type="Number"/>
      <property name="titleFont" scope="instance" type="String"/>
      <property name="titleFontColor" scope="instance" type="String"/>
      <property name="titleOrientation" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.axis.majorTick">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.axis.minorTick">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.axis.microTick">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.series">
    <properties>
      <property name="shadow" scope="instance" type="dx">
        <description>1, dy: 1, width: 2, color: [0, 0, 0, 0.3]},
	no shadow
	fill, if appropriate
	if there's a label
	color of labels
	connect marker and target data item(slice, column, bar...)</description>
      </property>
      <property name="fill" scope="instance" type="String"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.series.stroke">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.series.outline">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.series.labelWiring">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.marker">
    <properties>
      <property name="shadow" scope="instance" type="dx">
        <description>1, dy: 1, width: 2, color: [0, 0, 0, 0.3]},
	no shadow
	fill if needed
	label</description>
      </property>
      <property name="fill" scope="instance" type="String"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.marker.stroke">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.defaultTheme.marker.outline">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.shapeSpaces">
    <properties>
      <property name="shape" scope="instance" type="Number"/>
      <property name="shapeX" scope="instance" type="Number"/>
      <property name="shapeY" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.Theme.__DefineColorArgs">
    <methods/>
    <properties>
      <property name="num" scope="instance" type="Number">
        <description>The number of colors to generate.  Defaults to 5.</description>
      </property>
      <property name="colors" scope="instance" type="Array&lt;String&gt;|Array&lt;dojo.Color&gt;">
        <description>A pre-defined set of colors; this is passed through to the Theme directly.</description>
      </property>
      <property name="hue" scope="instance" type="Number">
        <description>A hue to base the generated colors from (a number from 0 - 359).</description>
      </property>
      <property name="saturation" scope="instance" type="Number">
        <description>If a hue is passed, this is used for the saturation value (0 - 100).</description>
      </property>
      <property name="low" scope="instance" type="Number">
        <description>An optional value to determine the lowest value used to generate a color (HSV model)</description>
      </property>
      <property name="high" scope="instance" type="Number">
        <description>An optional value to determine the highest value used to generate a color (HSV model)</description>
      </property>
      <property name="base" scope="instance" type="String|dojo.Color">
        <description>A base color to use if we are defining colors using dojox.color.Palette</description>
      </property>
      <property name="generator" scope="instance" type="String">
        <description>The generator function name from dojox.color.Palette.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.action2d">
    <properties>
      <property name="__BaseCtorArgs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this action applies to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The name of the plot this action belongs to.  If none is passed &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwargs" type="dojox.charting.action2d.__BaseCtorArgs" usage="optional">
            <description>Optional arguments for the action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance"/>
      <method name="disconnect" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="handle" scope="instance" type="Object"/>
      <property name="anim" scope="instance-prototype" type="Object"/>
      <property name="chart" scope="instance" type="dojox.charting.Chart2D">
        <description>The chart this action applies to.</description>
      </property>
      <property name="plot" scope="instance" type="String">
        <description>The name of the plot this action belongs to.  If none is passed &amp;quot;default&amp;quot; is assumed.
	kwargs: dojox.charting.action2d.__BaseCtorArgs?
	Optional arguments for the action.</description>
      </property>
      <property name="duration" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Base.overOutEvents">
    <properties>
      <property name="onmouseover" scope="instance" type="Number"/>
      <property name="onmouseout" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.__HighlightCtorArgs" superclass="dojox.charting.action2d.__BaseCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__BaseCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="highlight" scope="instance" type="String|dojo.Color|Function">
        <description>Either a color or a function that creates a color when highlighting happens.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Highlight" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot this action is attached to.  If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__HighlightCtorArgs" usage="optional">
            <description>Optional keyword arguments object for setting parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required">
            <description>The object on which to process the highlighting action.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="colorFun" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Highlight.defaultParams">
    <properties>
      <property name="duration" scope="instance" type="Number"/>
      <property name="easing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Highlight.optionalParams">
    <properties>
      <property name="highlight" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.__MagnifyCtorArgs" superclass="dojox.charting.action2d.__BaseCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__BaseCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="scale" scope="instance" type="Number">
        <description>The amount to magnify the given object to.  Default is 2.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Magnify" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot to apply the action to. If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__MagnifyCtorArgs" usage="optional">
            <description>Optional keyword arguments for this action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required">
            <description>The object on which to process the magnifying action.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Magnify.defaultParams">
    <properties>
      <property name="duration" scope="instance" type="Number"/>
      <property name="easing" scope="instance" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.__MoveSliceCtorArgs" superclass="dojox.charting.action2d.__BaseCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__BaseCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="scale" scope="instance" type="Number">
        <description>The amount to scale the pie slice.  Default is 1.05.</description>
      </property>
      <property name="shift" scope="instance" type="Number">
        <description>The amount in pixels to shift the pie slice.  Default is 7.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.action2d.MoveSlice" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot this action is attached to.  If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__MoveSliceCtorArgs" usage="optional">
            <description>Optional keyword arguments object for setting parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required">
            <description>The object on which to process the slice moving action.</description>
          </parameter>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="angles" scope="instance" type="Object"/>
      <property name="shift" scope="instance-prototype" type="Number"/>
      <property name="scale" scope="instance-prototype" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.MoveSlice.defaultParams">
    <properties>
      <property name="duration" scope="instance" type="Number"/>
      <property name="easing" scope="instance" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
      <property name="shift" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.__ShakeCtorArgs" superclass="dojox.charting.action2d.__BaseCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__BaseCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="shift" scope="instance" type="Number">
        <description>The amount in pixels to shift the pie slice.  Default is 3.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Shake" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot this action is attached to.  If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__ShakeCtorArgs" usage="optional">
            <description>Optional keyword arguments object for setting parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required">
            <description>The object on which to process the slice moving action.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="shiftX" scope="instance" type="Object"/>
      <property name="shiftY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Shake.defaultParams">
    <properties>
      <property name="duration" scope="instance" type="Number"/>
      <property name="easing" scope="instance" type="Object"/>
      <property name="shiftX" scope="instance" type="Object"/>
      <property name="shiftY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.__TooltipCtorArgs" superclass="dojox.charting.action2d.__BaseCtorArgs">
    <methods>
      <method name="text" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.__BaseCtorArgs" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.action2d.Tooltip" superclass="dojox.charting.action2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this action belongs to.</description>
          </parameter>
          <parameter name="plot" type="String" usage="optional">
            <description>The plot this action is attached to.  If not passed, &amp;quot;default&amp;quot; is assumed.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.action2d.__TooltipCtorArgs" usage="optional">
            <description>Optional keyword arguments object for setting parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="o" type="dojox.gfx.Shape" usage="required">
            <description>The object on which to process the highlighting action.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.action2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="aroundRect" scope="instance" type="Object"/>
      <property name="angles" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.action2d.Tooltip.defaultParams">
    <properties>
      <property name="text" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d">
    <properties>
      <property name="__AxisCtorArgs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Base" superclass="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this axis belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional">
            <description>An optional arguments object to define the axis parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.axis2d.Base
	A reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Base"/>
        </return-types>
      </method>
      <method name="initialized" scope="instance">
        <return-description>Boolean
	If the axis is initialized or not.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="calculate" scope="instance">
        <parameters>
          <parameter name="min" type="Object" usage="required"/>
          <parameter name="max" type="Object" usage="required"/>
          <parameter name="span" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.axis2d.Base
	A reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Base"/>
        </return-types>
      </method>
      <method name="getScaler" scope="instance">
        <return-description>Object
	The scaler object (see dojox.charting.scaler.linear for more information)</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTicks" scope="instance">
        <return-description>Object
	The ticks object.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getOffsets" scope="instance">
        <return-description>Object
	An object of the form { l, r, t, b }.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
          <parameter name="offsets" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.axis2d.Base
	A reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Base"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="vertical" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default" superclass="dojox.charting.axis2d.Invisible">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart the axis belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional">
            <description>Any optional keyword arguments to be used to define this axis.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getOffsets" scope="instance">
        <return-description>Object
	The calculated offsets in the form of { l, r, t, b } (left, right, top, bottom).</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height}.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.axis2d.Default
	The reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="labelTooltip" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
          <parameter name="truncatedLabel" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
          <parameter name="elemType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.axis2d.Invisible" scope="instance"/>
    </mixins>
    <properties>
      <property name="trailingSymbol" scope="instance" type="Object"/>
      <property name="_cachedLabelWidth" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="ticks" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.defaultParams">
    <properties>
      <property name="vertical" scope="instance" type="bool"/>
      <property name="fixUpper" scope="instance" type="String"/>
      <property name="fixLower" scope="instance" type="String"/>
      <property name="natural" scope="instance" type="bool"/>
      <property name="leftBottom" scope="instance" type="Object"/>
      <property name="includeZero" scope="instance" type="bool"/>
      <property name="fixed" scope="instance" type="Object"/>
      <property name="majorLabels" scope="instance" type="Object"/>
      <property name="minorTicks" scope="instance" type="Object"/>
      <property name="minorLabels" scope="instance" type="Object"/>
      <property name="microTicks" scope="instance" type="bool"/>
      <property name="rotation" scope="instance" type="Number"/>
      <property name="htmlLabels" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.optionalParams">
    <properties>
      <property name="min" scope="instance" type="Number"/>
      <property name="max" scope="instance" type="Number"/>
      <property name="from" scope="instance" type="Number"/>
      <property name="to" scope="instance" type="Number"/>
      <property name="majorTickStep" scope="instance" type="Number"/>
      <property name="minorTickStep" scope="instance" type="Number"/>
      <property name="microTickStep" scope="instance" type="Number"/>
      <property name="labels" scope="instance" type="Array"/>
      <property name="labelFunc" scope="instance" type="Object"/>
      <property name="maxLabelSize" scope="instance" type="Number"/>
      <property name="maxLabelCharCount" scope="instance" type="Number"/>
      <property name="trailingSymbol" scope="instance" type="Object"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="majorTick" scope="instance" type="Object"/>
      <property name="minorTick" scope="instance" type="Object"/>
      <property name="microTick" scope="instance" type="Object"/>
      <property name="tick" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
      <property name="title" scope="instance" type="String"/>
      <property name="titleGap" scope="instance" type="Number"/>
      <property name="titleFont" scope="instance" type="String"/>
      <property name="titleFontColor" scope="instance" type="String"/>
      <property name="titleOrientation" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.scaler">
    <properties>
      <property name="major" scope="instance" type="Object"/>
      <property name="minor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.chart.theme">
    <properties>
      <property name="axis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Default.opt">
    <properties>
      <property name="font" scope="instance" type="Object"/>
      <property name="titleFont" scope="instance" type="Object"/>
      <property name="leftBottom" scope="instance" type="Object"/>
      <property name="fontColor" scope="instance" type="Object"/>
      <property name="titleFontColor" scope="instance" type="Object"/>
      <property name="titleOrientation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.scaler"/>
  <class type="dojox.charting.axis2d.Invisible" superclass="dojox.charting.axis2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart the axis belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.axis2d.__AxisCtorArgs" usage="optional">
            <description>Any optional keyword arguments to be used to define this axis.</description>
          </parameter>
        </parameters>
      </method>
      <method name="dependOnData" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.axis2d.Default
	The reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="initialized" scope="instance">
        <return-description>Boolean
	Whether a scaler has been calculated and if the axis is not dirty.</return-description>
      </method>
      <method name="setWindow" scope="instance">
        <parameters>
          <parameter name="scale" type="Number" usage="required">
            <description>The new scale for the axis.</description>
          </parameter>
          <parameter name="offset" type="Number" usage="required">
            <description>The new offset for the axis.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.axis2d.Default
	The reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="getWindowScale" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="getWindowOffset" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_groupLabelWidth" scope="instance">
        <parameters>
          <parameter name="labels" type="Object" usage="required"/>
          <parameter name="font" type="Object" usage="required"/>
          <parameter name="wcLimit" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calculate" scope="instance">
        <parameters>
          <parameter name="min" type="Number" usage="required">
            <description>The smallest value represented on this axis.</description>
          </parameter>
          <parameter name="max" type="Number" usage="required">
            <description>The largest value represented on this axis.</description>
          </parameter>
          <parameter name="span" type="Number" usage="required">
            <description>The span in pixels over which axis calculations are made.</description>
          </parameter>
          <parameter name="labels" type="Array&lt;String&gt;" usage="required">
            <description>Optional list of labels.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.axis2d.Default
	The reference to the axis for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.axis2d.Default"/>
        </return-types>
      </method>
      <method name="getScaler" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTicks" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.axis2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="scale" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Number"/>
      <property name="labels" scope="instance" type="Object"/>
      <property name="ticks" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Invisible.defaultParams">
    <properties>
      <property name="vertical" scope="instance" type="bool"/>
      <property name="fixUpper" scope="instance" type="String"/>
      <property name="fixLower" scope="instance" type="String"/>
      <property name="natural" scope="instance" type="bool"/>
      <property name="leftBottom" scope="instance" type="Object"/>
      <property name="includeZero" scope="instance" type="bool"/>
      <property name="fixed" scope="instance" type="Object"/>
      <property name="majorLabels" scope="instance" type="Object"/>
      <property name="minorTicks" scope="instance" type="Object"/>
      <property name="minorLabels" scope="instance" type="Object"/>
      <property name="microTicks" scope="instance" type="bool"/>
      <property name="rotation" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Invisible.optionalParams">
    <properties>
      <property name="min" scope="instance" type="Number"/>
      <property name="max" scope="instance" type="Number"/>
      <property name="from" scope="instance" type="Number"/>
      <property name="to" scope="instance" type="Number"/>
      <property name="majorTickStep" scope="instance" type="Number"/>
      <property name="minorTickStep" scope="instance" type="Number"/>
      <property name="microTickStep" scope="instance" type="Number"/>
      <property name="labels" scope="instance" type="Array"/>
      <property name="labelFunc" scope="instance" type="Object"/>
      <property name="maxLabelSize" scope="instance" type="Number"/>
      <property name="maxLabelCharCount" scope="instance" type="Number"/>
      <property name="trailingSymbol" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Invisible.scaler">
    <properties>
      <property name="bounds" scope="instance" type="Object"/>
      <property name="minMinorStep" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Invisible.opt">
    <properties>
      <property name="from" scope="instance" type="String"/>
      <property name="to" scope="instance" type="String"/>
      <property name="font" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.axis2d.Invisible.chart.theme">
    <properties>
      <property name="axis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.utils">
    <methods>
      <method name="merge" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>original object.</description>
          </parameter>
          <parameter name="mixin" type="Object" usage="required">
            <description>additional object, which properties will override object's properties.</description>
          </parameter>
        </parameters>
      </method>
      <method name="coerceType" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <description>object, which typeof result is used to coerce &amp;quot;source&amp;quot; object.</description>
          </parameter>
          <parameter name="source" type="Object" usage="required">
            <description>object, which will be forced to change type.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateWithObject" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <description>the &amp;quot;target&amp;quot; object to be updated</description>
          </parameter>
          <parameter name="source" type="Object" usage="required">
            <description>the &amp;quot;source&amp;quot; object, whose properties will be used to source the existed object.</description>
          </parameter>
          <parameter name="conv" type="Boolean" usage="optional">
            <description>force conversion to the original type</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="updateWithPattern" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <description>the &amp;quot;target&amp;quot; object to be updated</description>
          </parameter>
          <parameter name="source" type="Object" usage="required">
            <description>the &amp;quot;source&amp;quot; object, whose properties will be used to source the existed object.</description>
          </parameter>
          <parameter name="pattern" type="Object" usage="required">
            <description>object, whose properties will be used to pull values from the &amp;quot;source&amp;quot;</description>
          </parameter>
          <parameter name="conv" type="Boolean" usage="optional">
            <description>force conversion to the original type</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.axis2d.common"/>
  <class type="dojox.charting.axis2d.common.createText">
    <methods>
      <method name="gfx" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart to create the text into.</description>
          </parameter>
          <parameter name="creator" type="dojox.gfx.Surface" usage="required">
            <description>The graphics surface to use for creating the text.</description>
          </parameter>
          <parameter name="x" type="Number" usage="required">
            <description>Where to create the text along the x axis (CSS left).</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>Where to create the text along the y axis (CSS top).</description>
          </parameter>
          <parameter name="align" type="String" usage="required">
            <description>How to align the text.  Can be &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;center&amp;quot;.</description>
          </parameter>
          <parameter name="text" type="String" usage="required">
            <description>The text to render.</description>
          </parameter>
          <parameter name="font" type="String" usage="required">
            <description>The font definition, a la CSS &amp;quot;font&amp;quot;.</description>
          </parameter>
          <parameter name="fontColor" type="String|dojo.Color" usage="required">
            <description>The color of the resultant text.</description>
          </parameter>
        </parameters>
        <return-description>dojox.gfx.Text
	The resultant GFX object.</return-description>
      </method>
      <method name="html" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart to create the text into.</description>
          </parameter>
          <parameter name="creator" type="dojox.gfx.Surface" usage="required">
            <description>The graphics surface to use for creating the text.</description>
          </parameter>
          <parameter name="x" type="Number" usage="required">
            <description>Where to create the text along the x axis (CSS left).</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>Where to create the text along the y axis (CSS top).</description>
          </parameter>
          <parameter name="align" type="String" usage="required">
            <description>How to align the text.  Can be &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;center&amp;quot;.</description>
          </parameter>
          <parameter name="text" type="String" usage="required">
            <description>The text to render.</description>
          </parameter>
          <parameter name="font" type="String" usage="required">
            <description>The font definition, a la CSS &amp;quot;font&amp;quot;.</description>
          </parameter>
          <parameter name="fontColor" type="String|dojo.Color" usage="required">
            <description>The color of the resultant text.</description>
          </parameter>
          <parameter name="labelWidth" type="Number" usage="optional">
            <description>The maximum width of the resultant DOM node.</description>
          </parameter>
        </parameters>
        <return-description>DOMNode
	The resultant DOMNode (a "div" element).</return-description>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.plot2d">
    <methods>
      <method name="__PlotCtorArgs" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.charting.plot2d.Areas" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.Areas.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
      <property name="areas" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.__BarCtorArgs" superclass="dojox.charting.plot2d.__DefaultCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.__DefaultCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="minBarSize" scope="instance" type="Number">
        <description>The minimum size for a bar in pixels.  Default is 1.</description>
      </property>
      <property name="maxBarSize" scope="instance" type="Number">
        <description>The maximum size for a bar in pixels.  Default is 1.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bars" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Bars
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Bars"/>
        </return-types>
      </method>
      <method name="_animateBar" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="hoffset" type="Object" usage="required"/>
          <parameter name="hsize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bars.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bars.optionalParams">
    <properties>
      <property name="minBarSize" scope="instance" type="Number"/>
      <property name="maxBarSize" scope="instance" type="Number"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bars.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Base" superclass="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.chart.Chart2D" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__PlotCtorArgs" usage="optional">
            <description>An optional arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="setAxis" scope="instance">
        <parameters>
          <parameter name="axis" type="dojox.charting.axis2d.Base" usage="required">
            <description>The axis to set.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="run" type="dojox.charting.Series" usage="required">
            <description>The series to be added.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="calculateAxes" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <return-description>Boolean
	The state of the plot.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isDataDirty" scope="instance">
        <return-description>Boolean
	Flag indicating if any of this plot's series are invalid and need rendering.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="performZoom" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="getRequiredColors" scope="instance">
        <return-description>Number
	The number of colors needed.</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="initializeScalers" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>Size of a plot area in pixels as {width, height}.</description>
          </parameter>
          <parameter name="stats" type="Object" usage="required">
            <description>Min/max of data in both directions as {hmin, hmax, vmin, vmax}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d._PlotEvents.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
      <mixin type="dojox.charting.plot2d._PlotEvents" scope="instance"/>
    </mixins>
    <properties>
      <property name="series" scope="instance" type="Array"/>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="zoom" scope="instance" type="Object"/>
      <property name="zoomQueue" scope="instance" type="Array"/>
      <property name="lastWindow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Base._vAxis">
    <properties>
      <property name="scale" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Base._hAxis">
    <properties>
      <property name="scale" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Base._hScaler">
    <properties>
      <property name="bounds" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Base._vScaler">
    <properties>
      <property name="bounds" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bubble" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__DefaultCtorArgs" usage="optional">
            <description>Optional keyword arguments object to help define plot parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Bubble
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Bubble"/>
        </return-types>
      </method>
      <method name="_animateBubble" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bubble.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bubble.optionalParams">
    <properties>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Bubble.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Candlesticks" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="collectStats" scope="instance">
        <parameters>
          <parameter name="series" type="Array&lt;dojox.charting.Series&gt;" usage="required">
            <description>The data series array to be drawn on this plot.</description>
          </parameter>
        </parameters>
        <return-description>Object
	Returns an object in the form of { hmin, hmax, vmin, vmax }.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Candlesticks
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Candlesticks"/>
        </return-types>
      </method>
      <method name="_animateCandlesticks" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="voffset" type="Object" usage="required"/>
          <parameter name="vsize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Candlesticks.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Candlesticks.optionalParams">
    <properties>
      <property name="minBarSize" scope="instance" type="Number"/>
      <property name="maxBarSize" scope="instance" type="Number"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Candlesticks.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.ClusteredBars" superclass="dojox.charting.plot2d.Bars">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.ClusteredBars
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.ClusteredBars"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Bars" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.ClusteredBars.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.ClusteredColumns" superclass="dojox.charting.plot2d.Columns">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.ClusteredColumns
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.ClusteredColumns"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Columns" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.ClusteredColumns.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Columns" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Columns
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Columns"/>
        </return-types>
      </method>
      <method name="_animateColumn" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="voffset" type="Object" usage="required"/>
          <parameter name="vsize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Columns.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Columns.optionalParams">
    <properties>
      <property name="minBarSize" scope="instance" type="Number"/>
      <property name="maxBarSize" scope="instance" type="Number"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Columns.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.__DefaultCtorArgs" superclass="dojox.charting.plot2d.__PlotCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.__PlotCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="hAxis" scope="instance" type="String">
        <description>The horizontal axis name.</description>
      </property>
      <property name="vAxis" scope="instance" type="String">
        <description>The vertical axis name</description>
      </property>
      <property name="lines" scope="instance" type="Boolean">
        <description>Whether or not to draw lines on this plot.  Defaults to true.</description>
      </property>
      <property name="areas" scope="instance" type="Boolean">
        <description>Whether or not to draw areas on this plot. Defaults to false.</description>
      </property>
      <property name="markers" scope="instance" type="Boolean">
        <description>Whether or not to draw markers at data points on this plot. Default is false.</description>
      </property>
      <property name="tension" scope="instance" type="Number|String">
        <description>Whether or not to apply 'tensioning' to the lines on this chart.
	Options include a number, &amp;quot;X&amp;quot;, &amp;quot;x&amp;quot;, or &amp;quot;S&amp;quot;; if a number is used, the
	simpler bezier curve calculations are used to draw the lines.  If X, x or S
	is used, the more accurate smoothing algorithm is used.</description>
      </property>
      <property name="animate" scope="instance" type="Boolean">
        <description>Whether or not to animate the chart to place.</description>
      </property>
      <property name="stroke" scope="instance" type="dojox.gfx.Stroke">
        <description>An optional stroke to use for any series on the plot.</description>
      </property>
      <property name="outline" scope="instance" type="dojox.gfx.Stroke">
        <description>An optional stroke used to outline any series on the plot.</description>
      </property>
      <property name="shadow" scope="instance" type="dojox.gfx.Stroke">
        <description>An optional stroke to use to draw any shadows for a series on a plot.</description>
      </property>
      <property name="fill" scope="instance" type="dojox.gfx.Fill">
        <description>Any fill to be used for elements on the plot (such as areas).</description>
      </property>
      <property name="font" scope="instance" type="String">
        <description>A font definition to be used for labels and other text-based elements on the plot.</description>
      </property>
      <property name="fontColor" scope="instance" type="String|dojo.Color">
        <description>The color to be used for any text-based elements on the plot.</description>
      </property>
      <property name="markerStroke" scope="instance" type="dojo.gfx.Stroke">
        <description>An optional stroke to use for any markers on the plot.</description>
      </property>
      <property name="markerOutline" scope="instance" type="dojo.gfx.Stroke">
        <description>An optional outline to use for any markers on the plot.</description>
      </property>
      <property name="markerShadow" scope="instance" type="dojo.gfx.Stroke">
        <description>An optional shadow to use for any markers on the plot.</description>
      </property>
      <property name="markerFill" scope="instance" type="dojo.gfx.Fill">
        <description>An optional fill to use for any markers on the plot.</description>
      </property>
      <property name="markerFont" scope="instance" type="String">
        <description>An optional font definition to use for any markers on the plot.</description>
      </property>
      <property name="markerFontColor" scope="instance" type="String|dojo.Color">
        <description>An optional color to use for any marker text on the plot.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Default" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__DefaultCtorArgs" usage="optional">
            <description>An optional arguments object to help define this plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Default
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Default"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Default.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="lines" scope="instance" type="Object"/>
      <property name="areas" scope="instance" type="bool"/>
      <property name="markers" scope="instance" type="bool"/>
      <property name="tension" scope="instance" type="String"/>
      <property name="animate" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Default.optionalParams">
    <properties>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
      <property name="markerStroke" scope="instance" type="Object"/>
      <property name="markerOutline" scope="instance" type="Object"/>
      <property name="markerShadow" scope="instance" type="Object"/>
      <property name="markerFill" scope="instance" type="Object"/>
      <property name="markerFont" scope="instance" type="String"/>
      <property name="markerFontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Default.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.__GridCtorArgs" superclass="dojox.charting.plot2d.__DefaultCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.__DefaultCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="hMajorLines" scope="instance" type="Boolean">
        <description>Whether to show lines at the major ticks along the horizontal axis. Default is true.</description>
      </property>
      <property name="hMinorLines" scope="instance" type="Boolean">
        <description>Whether to show lines at the minor ticks along the horizontal axis. Default is false.</description>
      </property>
      <property name="vMajorLines" scope="instance" type="Boolean">
        <description>Whether to show lines at the major ticks along the vertical axis. Default is true.</description>
      </property>
      <property name="vMinorLines" scope="instance" type="Boolean">
        <description>Whether to show lines at the major ticks along the vertical axis. Default is false.</description>
      </property>
      <property name="hStripes" scope="instance" type="String">
        <description>Whether or not to show stripes (alternating fills) along the horizontal axis. Default is &amp;quot;none&amp;quot;.</description>
      </property>
      <property name="vStripes" scope="instance" type="String">
        <description>Whether or not to show stripes (alternating fills) along the vertical axis. Default is &amp;quot;none&amp;quot;.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid" superclass="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__GridCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the parameters of the underlying grid.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.plot2d.Grid
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="setAxis" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Grid
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="run" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Grid
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="initializeScalers" scope="instance"/>
      <method name="isDirty" scope="instance">
        <return-description>Boolean
	If this plot needs to be rendered, this will return true.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="performZoom" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Grid
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="getRequiredColors" scope="instance">
        <return-description>Number
	Returns 0, since there are no series associated with this plot type.</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Grid
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Grid"/>
        </return-types>
      </method>
      <method name="_animateGrid" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="instance" type="Object"/>
      <property name="dirty" scope="instance-prototype" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
      <property name="zoom" scope="instance" type="Object"/>
      <property name="zoomQueue" scope="instance" type="Array"/>
      <property name="lastWindow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="hMajorLines" scope="instance" type="Object"/>
      <property name="hMinorLines" scope="instance" type="bool"/>
      <property name="vMajorLines" scope="instance" type="Object"/>
      <property name="vMinorLines" scope="instance" type="bool"/>
      <property name="hStripes" scope="instance" type="String"/>
      <property name="vStripes" scope="instance" type="String"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid._vAxis">
    <properties>
      <property name="scale" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid._hAxis">
    <properties>
      <property name="scale" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Grid.chart.theme">
    <properties>
      <property name="axis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Lines" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.Lines.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Markers" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.Markers.opt">
    <properties>
      <property name="markers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.MarkersOnly" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.MarkersOnly.opt">
    <properties>
      <property name="lines" scope="instance" type="bool"/>
      <property name="markers" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.OHLC" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__BarCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define the plot.</description>
          </parameter>
        </parameters>
      </method>
      <method name="collectStats" scope="instance">
        <parameters>
          <parameter name="series" type="Array&lt;dojox.charting.Series&gt;" usage="required">
            <description>The data series array to be drawn on this plot.</description>
          </parameter>
        </parameters>
        <return-description>Object
	Returns an object in the form of { hmin, hmax, vmin, vmax }.</return-description>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.OHLC
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.OHLC"/>
        </return-types>
      </method>
      <method name="_animateOHLC" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="voffset" type="Object" usage="required"/>
          <parameter name="vsize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.OHLC.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.OHLC.optionalParams">
    <properties>
      <property name="minBarSize" scope="instance" type="Number"/>
      <property name="maxBarSize" scope="instance" type="Number"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.OHLC.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.__PieCtorArgs" superclass="dojox.charting.plot2d.__DefaultCtorArgs">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.__DefaultCtorArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="labels" scope="instance" type="Boolean">
        <description>Whether or not to draw labels within each pie slice.  Default is true.</description>
      </property>
      <property name="ticks" scope="instance" type="Boolean">
        <description>Whether or not to draw ticks to labels within each slice. Default is false.</description>
      </property>
      <property name="fixed" scope="instance" type="Boolean">
        <description>TODO</description>
      </property>
      <property name="precision" scope="instance" type="Number">
        <description>The precision at which to sum/add data values. Default is 1.</description>
      </property>
      <property name="labelOffset" scope="instance" type="Number">
        <description>The amount in pixels by which to offset labels.  Default is 20.</description>
      </property>
      <property name="labelStyle" scope="instance" type="String">
        <description>Options as to where to draw labels.  Values include &amp;quot;default&amp;quot;, &amp;quot;rows&amp;quot;, and &amp;quot;auto&amp;quot;. Default is &amp;quot;default&amp;quot;.
	default/rows/auto</description>
      </property>
      <property name="htmlLabels" scope="instance" type="Boolean">
        <description>Whether or not to use HTML to render slice labels. Default is true.</description>
      </property>
      <property name="radGrad" scope="instance" type="String">
        <description>The type of radial gradient to use in rendering.  Default is &amp;quot;native&amp;quot;.</description>
      </property>
      <property name="fanSize" scope="instance" type="Number">
        <description>The amount for a radial gradient.  Default is 5.</description>
      </property>
      <property name="startAngle" scope="instance" type="Number">
        <description>Where to being rendering gradients in slices, in degrees.  Default is 0.</description>
      </property>
      <property name="radius" scope="instance" type="Number">
        <description>The size of the radial gradient.  Default is 0.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie" superclass="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.plot2d.Pie
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Pie"/>
        </return-types>
      </method>
      <method name="setAxis" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Pie
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Pie"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="run" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Pie
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Pie"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="initializeScalers" scope="instance"/>
      <method name="getRequiredColors" scope="instance"/>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Pie
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="continue"/>
          <return-type type="stop iteration"/>
          <return-type type="dojox.charting.plot2d.Pie"/>
        </return-types>
      </method>
      <method name="_getProperLabelRadius" scope="instance">
        <parameters>
          <parameter name="slices" type="Object" usage="required"/>
          <parameter name="labelHeight" type="Object" usage="required"/>
          <parameter name="minRidius" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_caculateLabelR" scope="instance">
        <parameters>
          <parameter name="firstSlice" type="Object" usage="required"/>
          <parameter name="slices" type="Object" usage="required"/>
          <parameter name="labelHeight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLabel" scope="instance">
        <parameters>
          <parameter name="number" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d._PlotEvents.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
      <mixin type="dojox.charting.plot2d._PlotEvents" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="dyn" scope="instance-prototype" type="Array"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.defaultParams">
    <properties>
      <property name="labels" scope="instance" type="Object"/>
      <property name="ticks" scope="instance" type="bool"/>
      <property name="fixed" scope="instance" type="Object"/>
      <property name="precision" scope="instance" type="Number"/>
      <property name="labelOffset" scope="instance" type="Number"/>
      <property name="labelStyle" scope="instance" type="String"/>
      <property name="htmlLabels" scope="instance" type="Object"/>
      <property name="radGrad" scope="instance" type="String"/>
      <property name="fanSize" scope="instance" type="Number"/>
      <property name="startAngle" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.optionalParams">
    <properties>
      <property name="radius" scope="instance" type="Number"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="outline" scope="instance" type="Object"/>
      <property name="shadow" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
      <property name="labelWiring" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.opt">
    <properties>
      <property name="radius" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Pie.run">
    <properties>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Scatter" superclass="dojox.charting.plot2d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="dojox.charting.Chart2D" usage="required">
            <description>The chart this plot belongs to.</description>
          </parameter>
          <parameter name="kwArgs" type="dojox.charting.plot2d.__DefaultCtorArgs" usage="optional">
            <description>An optional keyword arguments object to help define this plot's parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Scatter
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Scatter"/>
        </return-types>
      </method>
      <method name="_animateScatter" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type="Object"/>
      <property name="vAxis" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Scatter.defaultParams">
    <properties>
      <property name="hAxis" scope="instance" type="String"/>
      <property name="vAxis" scope="instance" type="String"/>
      <property name="shadows" scope="instance" type="Object"/>
      <property name="animate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Scatter.optionalParams">
    <properties>
      <property name="markerStroke" scope="instance" type="Object"/>
      <property name="markerOutline" scope="instance" type="Object"/>
      <property name="markerShadow" scope="instance" type="Object"/>
      <property name="markerFill" scope="instance" type="Object"/>
      <property name="markerFont" scope="instance" type="String"/>
      <property name="markerFontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Scatter.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider" superclass="dojox.charting.Element">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <return-description>dojox.charting.plot2d.Spider
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Spider"/>
        </return-types>
      </method>
      <method name="setAxis" scope="instance">
        <parameters>
          <parameter name="axis" type="Object" usage="required"/>
        </parameters>
        <return-description>dojox.charting.plot2d.Spider
	The reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Spider"/>
        </return-types>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="run" type="dojox.charting.Series" usage="required">
            <description>The series to be added.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="calculateAxes" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="getRequiredColors" scope="instance">
        <return-description>Number
	The number of colors needed.</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="initializeScalers" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>Size of a plot area in pixels as {width, height}.</description>
          </parameter>
          <parameter name="stats" type="Object" usage="required">
            <description>Min/max of data in both directions as {hmin, hmax, vmin, vmax}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Base
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Base"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object of the form { width, height }.</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b }.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Spider
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Spider"/>
        </return-types>
      </method>
      <method name="_createSeriesEntry" scope="instance">
        <parameters>
          <parameter name="ts" type="Object" usage="required"/>
          <parameter name="osps" type="Object" usage="required"/>
          <parameter name="sps" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="sk" type="Object" usage="required"/>
          <parameter name="r" type="Object" usage="required"/>
          <parameter name="ro" type="Object" usage="required"/>
          <parameter name="ms" type="Object" usage="required"/>
          <parameter name="at" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="plotEvent" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required">
            <description>An object intended to represent event parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getBoundary" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_drawArrow" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildPoints" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="circle" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
          <parameter name="angle" type="Object" usage="required"/>
          <parameter name="recursive" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCoordinate" scope="instance">
        <parameters>
          <parameter name="circle" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
          <parameter name="angle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getObjectLength" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLabel" scope="instance">
        <parameters>
          <parameter name="number" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d._PlotEvents.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.charting.Element" scope="instance"/>
      <mixin type="dojox.charting.plot2d._PlotEvents" scope="instance"/>
    </mixins>
    <properties>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="dyn" scope="instance-prototype" type="Array"/>
      <property name="series" scope="instance-prototype" type="Array"/>
      <property name="datas" scope="instance-prototype" type="Object"/>
      <property name="labelKey" scope="instance-prototype" type="Array"/>
      <property name="oldSeriePoints" scope="instance-prototype" type="Object"/>
      <property name="animations" scope="instance-prototype" type="Object"/>
      <property name="_hScaler" scope="instance" type="Object"/>
      <property name="_vScaler" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="aroundRect" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider.defaultParams">
    <properties>
      <property name="labels" scope="instance" type="Object"/>
      <property name="ticks" scope="instance" type="bool"/>
      <property name="fixed" scope="instance" type="Object"/>
      <property name="precision" scope="instance" type="Number"/>
      <property name="labelOffset" scope="instance" type="Number"/>
      <property name="labelStyle" scope="instance" type="String"/>
      <property name="htmlLabels" scope="instance" type="Object"/>
      <property name="startAngle" scope="instance" type="Number"/>
      <property name="divisions" scope="instance" type="Number"/>
      <property name="axisColor" scope="instance" type="String"/>
      <property name="axisWidth" scope="instance" type="Number"/>
      <property name="spiderColor" scope="instance" type="String"/>
      <property name="spiderWidth" scope="instance" type="Number"/>
      <property name="seriesWidth" scope="instance" type="Number"/>
      <property name="seriesFillAlpha" scope="instance" type="Number"/>
      <property name="spiderOrigin" scope="instance" type="Number"/>
      <property name="markerSize" scope="instance" type="Number"/>
      <property name="spiderType" scope="instance" type="String"/>
      <property name="animationType" scope="instance" type="Object"/>
      <property name="axisTickFont" scope="instance" type="String"/>
      <property name="axisTickFontColor" scope="instance" type="String"/>
      <property name="axisFont" scope="instance" type="String"/>
      <property name="axisFontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider.optionalParams">
    <properties>
      <property name="radius" scope="instance" type="Number"/>
      <property name="font" scope="instance" type="String"/>
      <property name="fontColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider.chart">
    <properties>
      <property name="seriesShapes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider.chart.theme">
    <properties>
      <property name="axis" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Spider.opt">
    <properties>
      <property name="radius" scope="instance" type="String"/>
      <property name="font" scope="instance" type="Object"/>
      <property name="axisFont" scope="instance" type="Object"/>
      <property name="axisTickFontColor" scope="instance" type="Object"/>
      <property name="axisFontColor" scope="instance" type="Object"/>
      <property name="axisColor" scope="instance" type="Object"/>
      <property name="spiderColor" scope="instance" type="Object"/>
      <property name="axisWidth" scope="instance" type="Object"/>
      <property name="spiderWidth" scope="instance" type="Object"/>
      <property name="seriesWidth" scope="instance" type="Object"/>
      <property name="spiderOrigin" scope="instance" type="Object"/>
      <property name="markerSize" scope="instance" type="Object"/>
      <property name="spiderType" scope="instance" type="Object"/>
      <property name="animationType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Stacked" superclass="dojox.charting.plot2d.Default">
    <methods>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.Stacked
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.Stacked"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Default" scope="instance"/>
    </mixins>
    <properties>
      <property name="_maxRunLength" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.Stacked.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedAreas" superclass="dojox.charting.plot2d.Stacked">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Stacked" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.StackedAreas.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
      <property name="areas" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedBars" superclass="dojox.charting.plot2d.Bars">
    <methods>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.StackedBars
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.StackedBars"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Bars" scope="instance"/>
    </mixins>
    <properties>
      <property name="_maxRunLength" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedBars.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedColumns" superclass="dojox.charting.plot2d.Columns">
    <methods>
      <method name="getSeriesStats" scope="instance">
        <return-description>Object
	{hmin, hmax, vmin, vmax} min/max in both directions.</return-description>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required">
            <description>An object in the form of { width, height }</description>
          </parameter>
          <parameter name="offsets" type="Object" usage="required">
            <description>An object of the form { l, r, t, b}.</description>
          </parameter>
        </parameters>
        <return-description>dojox.charting.plot2d.StackedColumns
	A reference to this plot for functional chaining.</return-description>
        <return-types>
          <return-type type="dojox.charting.plot2d.StackedColumns"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Columns" scope="instance"/>
    </mixins>
    <properties>
      <property name="_maxRunLength" scope="instance" type="Object"/>
      <property name="dirty" scope="instance" type="bool"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedColumns.chart">
    <properties>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.StackedLines" superclass="dojox.charting.plot2d.Stacked">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot2d.Stacked" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.charting.plot2d.StackedLines.opt">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d._PlotEvents">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="plotEvent" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required">
            <description>An object intended to represent event parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="raiseEvent" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required">
            <description>An object intended to represent event parameters.</description>
          </parameter>
        </parameters>
      </method>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>The object to connect to.</description>
          </parameter>
          <parameter name="method" type="String|Function" usage="required">
            <description>The method to fire when our plotEvent is fired.</description>
          </parameter>
        </parameters>
        <return-description>Array
	The handle as returned from dojo.connect (see dojo.connect).</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="events" scope="instance">
        <return-description>Boolean
	A flag indicating that there are handlers attached.</return-description>
      </method>
      <method name="resetEvents" scope="instance"/>
      <method name="_connectSingleEvent" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
          <parameter name="eventName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_connectEvents" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_reconnectEvents" scope="instance">
        <parameters>
          <parameter name="seriesName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fireEvent" scope="instance">
        <parameters>
          <parameter name="seriesName" type="String" usage="required">
            <description>Series name.</description>
          </parameter>
          <parameter name="eventName" type="String" usage="required">
            <description>Event name to emulate.</description>
          </parameter>
          <parameter name="index" type="Number" usage="required">
            <description>Valid data value index used to raise an event.</description>
          </parameter>
          <parameter name="eventObject" type="Object" usage="optional">
            <description>Optional event object. Especially useful for synthetic events.
	Default: null.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="dirty" scope="instance" type="Object"/>
      <property name="_shapeEvents" scope="instance-prototype" type="Array"/>
      <property name="_eventSeries" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot2d.common">
    <methods>
      <method name="makeStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="augmentColor" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="augmentStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="augmentFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="collectSimpleStats" scope="instance">
        <parameters>
          <parameter name="series" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calculateBarSize" scope="instance">
        <parameters>
          <parameter name="availableSize" type="Number" usage="required"/>
          <parameter name="opt" type="Object" usage="required"/>
          <parameter name="clusterSize" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="collectStackedStats" scope="instance">
        <parameters>
          <parameter name="series" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="curve" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
          <parameter name="tension" type="Number|String" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="number" type="Number" usage="required"/>
          <parameter name="fixed" type="Boolean" usage="required"/>
          <parameter name="precision" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.plot2d.common.defaultStats">
    <properties>
      <property name="vmin" scope="instance" type="Object"/>
      <property name="vmax" scope="instance" type="Object"/>
      <property name="hmin" scope="instance" type="Object"/>
      <property name="hmax" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d"/>
  <class type="dojox.charting.plot3d.Bars" superclass="dojox.charting.plot3d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDepth" scope="instance"/>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot3d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="depth" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="data" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Bars.material">
    <properties>
      <property name="color" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDepth" scope="instance"/>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="data" scope="instance" type="Array"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Cylinders" superclass="dojox.charting.plot3d.Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDepth" scope="instance"/>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
          <parameter name="creator" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.plot3d.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="depth" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="data" scope="instance" type="Array"/>
      <property name="outline" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.plot3d.Cylinders.material">
    <properties>
      <property name="color" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.scaler.common">
    <methods>
      <method name="findString" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
          <parameter name="text" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="getNumericLabel" scope="instance">
        <parameters>
          <parameter name="number" type="Number" usage="required"/>
          <parameter name="precision" type="Number" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.scaler.linear">
    <methods>
      <method name="buildScaler" scope="instance">
        <parameters>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
          <parameter name="span" type="Number" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="buildTicks" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTransformerFromModel" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="getTransformerFromPlot" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.scaler.primitive">
    <methods>
      <method name="buildScaler" scope="instance">
        <parameters>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
          <parameter name="span" type="Number" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildTicks" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTransformerFromModel" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="getTransformerFromPlot" scope="instance">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes">
    <properties>
      <property name="Adobebricks" scope="instance" type="Object"/>
      <property name="Algae" scope="instance" type="Object"/>
      <property name="Bahamation" scope="instance" type="Object"/>
      <property name="BlueDusk" scope="instance" type="Object"/>
      <property name="CubanShirts" scope="instance" type="Object"/>
      <property name="Desert" scope="instance" type="Object"/>
      <property name="Distinctive" scope="instance" type="Object"/>
      <property name="Dollar" scope="instance" type="Object"/>
      <property name="Grasshopper" scope="instance" type="Object"/>
      <property name="Grasslands" scope="instance" type="Object"/>
      <property name="GreySkies" scope="instance" type="Object"/>
      <property name="Harmony" scope="instance" type="Object"/>
      <property name="IndigoNation" scope="instance" type="Object"/>
      <property name="Ireland" scope="instance" type="Object"/>
      <property name="MiamiNice" scope="instance" type="Object"/>
      <property name="Midwest" scope="instance" type="Object"/>
      <property name="Minty" scope="instance" type="Object"/>
      <property name="PrimaryColors" scope="instance" type="Object"/>
      <property name="PurpleRain" scope="instance" type="Object"/>
      <property name="RoyalPurples" scope="instance" type="Object"/>
      <property name="SageToLime" scope="instance" type="Object"/>
      <property name="Shrooms" scope="instance" type="Object"/>
      <property name="Tufte" scope="instance" type="Object"/>
      <property name="WatersEdge" scope="instance" type="Object"/>
      <property name="Wetland" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.Charged">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.Chris">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.Claro">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.Electric">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.Julie">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.PlotKit"/>
  <class type="dojox.charting.themes.PlotKit.base">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.PlotKit.blue.chart">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.blue.plotarea">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.blue">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.cyan.chart">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.cyan.plotarea">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.cyan">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.green.chart">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.green.plotarea">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.green">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.orange.chart">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.orange.plotarea">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.orange">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.purple.chart">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.purple.plotarea">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.purple">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.red.chart">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.red.plotarea">
    <properties>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.PlotKit.red">
    <properties>
      <property name="colors" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.Renkoo">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.gradientGenerator">
    <methods>
      <method name="generateGradientByIntensity" scope="instance">
        <parameters>
          <parameter name="color" type="dojo.Color" usage="required">
            <description>Color to use to generate gradients.</description>
          </parameter>
          <parameter name="intensityMap" type="Array" usage="required">
            <description>Array of tuples {o, i}, where o is a gradient offset (0-1),
	and i is an intensity (0-255).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="generateFills" scope="instance">
        <parameters>
          <parameter name="colors" type="Array" usage="required">
            <description>Array of colors to generate gradients for each.</description>
          </parameter>
          <parameter name="fillPattern" type="Object" usage="required">
            <description>Gradient fill descriptor which colors list will be generated.</description>
          </parameter>
          <parameter name="lumFrom" type="Number" usage="required">
            <description>Initial luminance value (0-100).</description>
          </parameter>
          <parameter name="lumTo" type="Number" usage="required">
            <description>Final luminance value (0-100).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="updateFills" scope="instance">
        <parameters>
          <parameter name="themes" type="Array" usage="required">
            <description>Array of mini-themes (usually series themes or marker themes), which fill will be transformed.</description>
          </parameter>
          <parameter name="fillPattern" type="Object" usage="required">
            <description>Gradient fill descriptor which colors list will be generated.</description>
          </parameter>
          <parameter name="lumFrom" type="Number" usage="required">
            <description>Initial luminance value (0-100).</description>
          </parameter>
          <parameter name="lumTo" type="Number" usage="required">
            <description>Final luminance value (0-100).</description>
          </parameter>
        </parameters>
      </method>
      <method name="generateMiniTheme" scope="instance">
        <parameters>
          <parameter name="colors" type="Array" usage="required">
            <description>Array of colors to generate gradients for each.</description>
          </parameter>
          <parameter name="fillPattern" type="Object" usage="required">
            <description>Gradient fill descriptor which colors list will be generated.</description>
          </parameter>
          <parameter name="lumFrom" type="Number" usage="required">
            <description>Initial luminance value (0-100).</description>
          </parameter>
          <parameter name="lumTo" type="Number" usage="required">
            <description>Final luminance value (0-100).</description>
          </parameter>
          <parameter name="lumStroke" type="Number" usage="required">
            <description>Stroke luminance value (0-100).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.ThreeD.series"/>
  <class type="dojox.charting.themes.ThreeD.series.shadow">
    <properties>
      <property name="dx" scope="instance" type="Number"/>
      <property name="dy" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.charting.themes.ThreeD">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.themes.Tom">
    <methods>
      <method name="next" scope="instance">
        <parameters>
          <parameter name="elementType" type="Object" usage="required"/>
          <parameter name="mixin" type="Object" usage="required"/>
          <parameter name="doPost" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="post" scope="instance">
        <parameters>
          <parameter name="theme" type="Object" usage="required"/>
          <parameter name="elementType" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.charting.widget">
    <properties>
      <property name="Chart2D" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Chart" superclass="dijit._Widget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="resize" scope="instance">
        <description>Resize the domNode and the widget surface to the dimensions of a box of the following form:
	`{ l: 50, t: 200, w: 300: h: 150 }`
	If no box is provided, resize the surface to the marginBox of the domNode.</description>
        <parameters>
          <parameter name="box" type="If" usage="required">
            <description>passed, denotes the new size of the widget.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="theme" scope="instance" type="Object"/>
      <property name="margins" scope="instance" type="Object"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="fill" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
      <property name="actions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Legend" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="_addLabel" scope="instance">
        <parameters>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeIcon" scope="instance">
        <parameters>
          <parameter name="div" type="Object" usage="required"/>
          <parameter name="dyn" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="chartRef" scope="instance" type="String"/>
      <property name="horizontal" scope="instance" type="Object"/>
      <property name="swatchSize" scope="instance" type="Number"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="legendNode" scope="instance" type="Object"/>
      <property name="legendBody" scope="instance" type="Object"/>
      <property name="chart" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Object"/>
      <property name="_surfaces" scope="instance" type="Array"/>
      <property name="_tr" scope="instance" type="Object"/>
      <property name="_inrow" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Legend.series.0.chart.stack">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.SelectableLegend" superclass="dojox.charting.widget.Legend">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="_addLabel" scope="instance">
        <parameters>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_applyEvents" scope="instance"/>
      <method name="_toggle" scope="instance">
        <parameters>
          <parameter name="shapes" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="isOff" type="Object" usage="required"/>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="seriesName" type="Object" usage="required"/>
          <parameter name="plotName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlight" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="iconShape" type="Object" usage="required"/>
          <parameter name="shapes" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="isOff" type="Object" usage="required"/>
          <parameter name="dyn" type="Object" usage="required"/>
          <parameter name="seriesName" type="Object" usage="required"/>
          <parameter name="plotName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAnim" scope="instance">
        <parameters>
          <parameter name="plotName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getTransitionFill" scope="instance">
        <parameters>
          <parameter name="plotName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getFilledShape" scope="instance">
        <parameters>
          <parameter name="shapes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isPie" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.widget.Legend" scope="instance"/>
    </mixins>
    <properties>
      <property name="outline" scope="instance" type="bool"/>
      <property name="transitionFill" scope="instance" type="Object"/>
      <property name="transitionStroke" scope="instance" type="Object"/>
      <property name="legends" scope="instance" type="Array"/>
      <property name="legendAnim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget._FocusManager">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="legend" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getHrizontalLength" scope="instance"/>
      <method name="_onKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToFocus" scope="instance"/>
    </methods>
    <properties>
      <property name="index" scope="instance" type="Number"/>
      <property name="horizontalLength" scope="instance" type="Object"/>
      <property name="firstLabel" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget._FocusManager.legend">
    <properties>
      <property name="horizontal" scope="instance" type="Object"/>
      <property name="active" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.charting.widget._FocusManager.legend.legends">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Sparkline" superclass="dojox.charting.widget.Chart2D">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.charting.widget.Chart2D" scope="instance"/>
    </mixins>
    <properties>
      <property name="theme" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="String"/>
      <property name="valueFn" scope="instance" type="String"/>
      <property name="store" scope="instance" type="String"/>
      <property name="field" scope="instance" type="String"/>
      <property name="query" scope="instance" type="String"/>
      <property name="queryOptions" scope="instance" type="String"/>
      <property name="start" scope="instance" type="String"/>
      <property name="count" scope="instance" type="String"/>
      <property name="sort" scope="instance" type="String"/>
      <property name="data" scope="instance" type="String"/>
      <property name="name" scope="instance" type="String"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.charting.widget.Sparkline.margins">
    <properties>
      <property name="l" scope="instance" type="Number"/>
      <property name="r" scope="instance" type="Number"/>
      <property name="t" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.collections">
    <properties>
      <property name="Set" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.ArrayList">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="addRange" scope="instance">
        <parameters>
          <parameter name="a" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.ArrayList"/>
        </return-types>
      </method>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="indexOf" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="insert" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="removeAt" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="reverse" scope="instance"/>
      <method name="sort" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="optional"/>
        </parameters>
      </method>
      <method name="setByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="toArray" scope="instance"/>
      <method name="toString" scope="instance">
        <parameters>
          <parameter name="delim" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.collections.BinaryTree">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance"/>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance"/>
      <method name="search" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <parameters>
          <parameter name="order" type="Object" usage="required"/>
          <parameter name="sep" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Number"/>
      <property name="root" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.BinaryTree.TraversalMethods">
    <properties>
      <property name="Preorder" scope="instance" type="Number"/>
      <property name="Inorder" scope="instance" type="Number"/>
      <property name="Postorder" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.collections.Dictionary">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Dictionary"/>
        </return-types>
      </method>
      <method name="contains" scope="instance"/>
      <method name="containsKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="entry" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.DictionaryEntry"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getKeyList" scope="instance"/>
      <method name="getValueList" scope="instance"/>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.DictionaryIterator"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.collections.Queue">
    <methods>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Queue"/>
        </return-types>
      </method>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="dequeue" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="enqueue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="peek" scope="instance"/>
      <method name="toArray" scope="instance"/>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.SortedList">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.SortedList"/>
        </return-types>
      </method>
      <method name="contains" scope="instance"/>
      <method name="containsKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="entry" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.DictionaryEntry"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.DictionaryIterator"/>
        </return-types>
      </method>
      <method name="getKey" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="getKeyList" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getValueList" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="indexOfKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="indexOfValue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="removeAt" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="setByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.Stack">
    <methods>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance"/>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="peek" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="pop" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="push" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="toArray" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="count" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.DictionaryEntry">
    <methods>
      <method name="valueOf" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="key" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.Iterator">
    <methods>
      <method name="atEnd" scope="instance">
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="get" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <properties>
      <property name="element" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.collections.DictionaryIterator">
    <methods>
      <method name="atEnd" scope="instance">
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="get" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <properties>
      <property name="element" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.color">
    <methods>
      <method name="fromXYZ" scope="instance">
        <parameters>
          <parameter name="xyz" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="fromCmy" scope="instance">
        <parameters>
          <parameter name="cyan" type="Object|Array|int" usage="required"/>
          <parameter name="magenta" type="int" usage="required"/>
          <parameter name="yellow" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromCmyk" scope="instance">
        <parameters>
          <parameter name="cyan" type="Object|Array|int" usage="required"/>
          <parameter name="magenta" type="int" usage="required"/>
          <parameter name="yellow" type="int" usage="required"/>
          <parameter name="black" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromHsl" scope="instance">
        <parameters>
          <parameter name="hue" type="Object|Array|int" usage="required"/>
          <parameter name="saturation" type="int" usage="required"/>
          <parameter name="luminosity" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromHsv" scope="instance">
        <parameters>
          <parameter name="hue" type="Object|Array|int" usage="required"/>
          <parameter name="saturation" type="int" usage="required"/>
          <parameter name="value" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="Colorspace" scope="instance" type="Object"/>
      <property name="blend" scope="instance" type="Object"/>
      <property name="fromRgb" scope="instance" type="Object"/>
      <property name="fromHex" scope="instance" type="Object"/>
      <property name="fromArray" scope="instance" type="Object"/>
      <property name="fromString" scope="instance" type="Object"/>
      <property name="greyscale" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.color.Color">
    <methods>
      <method name="toXYZ" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toCmy" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toCmyk" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toHsl" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toHsv" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.math">
    <methods>
      <method name="toRadians" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="toDegrees" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="degreesToRadians" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="radiansToDegrees" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_gamma" scope="instance">
        <parameters>
          <parameter name="z" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="normal integer quick return"/>
          <return-type type="undefined at nonpositive integers since sin() below will return 0"/>
          <return-type type="popular gamma(1/2)"/>
          <return-type type="reflection"/>
        </return-types>
      </method>
      <method name="factorial" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="permutations" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="k" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="combinations" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="r" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="bernstein" scope="instance">
        <parameters>
          <parameter name="t" type="Number" usage="required"/>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="i" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="gaussian" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="range" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="optional"/>
          <parameter name="step" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="distance" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="midpoint" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="round" scope="instance">
        <description>Rounds to the nearest value with the given number of decimal places, away from zero if equal,
	similar to Number.toFixed().  Rounding can be done by fractional increments also.
	Makes minor adjustments to accommodate for precision errors due to binary floating point representation
	of Javascript Numbers.  See http://speleotrove.com/decimal/decifaq.html for more information.
	Because of this adjustment, the rounding may not be mathematically correct for full precision
	floating point values.  The calculations assume 14 significant figures, so the accuracy will
	be limited to a certain number of decimal places preserved will vary with the magnitude of
	the input.  This is not a substitute for decimal arithmetic.</description>
        <examples>
          <example>&gt;&gt;&gt; 4.8-(1.1+2.2)
	1.4999999999999996
	&gt;&gt;&gt; Math.round(4.8-(1.1+2.2))
	1
	&gt;&gt;&gt; dojox.math.round(4.8-(1.1+2.2))
	2
	&gt;&gt;&gt; ((4.8-(1.1+2.2))/100)
	0.014999999999999996
	&gt;&gt;&gt; ((4.8-(1.1+2.2))/100).toFixed(2)
	"0.01"
	&gt;&gt;&gt; dojox.math.round((4.8-(1.1+2.2))/100,2)
	0.02
	&gt;&gt;&gt; dojox.math.round(10.71, 0, 2.5)
	10.75
	&gt;&gt;&gt; dojo.number.round(162.295, 2)
	162.29
	&gt;&gt;&gt; dojox.math.round(162.295, 2)
	162.3</example>
        </examples>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>The number to round</description>
          </parameter>
          <parameter name="places" type="Number" usage="optional">
            <description>The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	Must be non-negative.</description>
          </parameter>
          <parameter name="increment" type="Number" usage="optional">
            <description>Rounds next place to nearest value of increment/10.  10 by default.</description>
          </parameter>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="m" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="BigInteger-ext" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.color.Palette">
    <description>A Palette is a representation of a set of colors.  While the standard
	number of colors contained in a palette is 5, it can really handle any
	number of colors.
	A palette is useful for the ability to transform all the colors in it
	using a simple object-based approach.  In addition, you can generate
	palettes using dojox.color.Palette.generate; these generated palettes
	are based on the palette generators at http://kuler.adobe.com.</description>
    <methods>
      <method name="generate" scope="instance">
        <parameters>
          <parameter name="base" type="String|dojox.color.Color" usage="required"/>
          <parameter name="type" type="Function|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
      <method name="transform" scope="instance">
        <description>{palette}.transform is a simple way to uniformly transform
	all of the colors in a palette using any of 5 formulae:
	RGBA, HSL, HSV, CMYK or CMY.
	Once the forumula to be used is determined, you can pass any
	number of parameters based on the formula "d"[param]; for instance,
	{ use: "rgba", dr: 20, dg: -50 } will take all of the colors in
	palette, add 20 to the R value and subtract 50 from the G value.
	Unlike other types of transformations, transform does *not* alter
	the original palette but will instead return a new one.</description>
        <parameters>
          <parameter name="kwArgs" type="dojox.color.Palette.__transformArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="colors" scope="instance" type="Array&lt;dojox.color.Color&gt;">
        <description>The actual color references in this palette.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.color.Palette.generators">
    <methods>
      <method name="analogous" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__analogousArgs" usage="required"/>
        </parameters>
      </method>
      <method name="monochromatic" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="triadic" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="complementary" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="splitComplementary" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__splitComplementaryArgs" usage="required"/>
        </parameters>
      </method>
      <method name="compound" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
      <method name="shades" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.color.Palette.__generatorArgs" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.color.Palette.__transformArgs">
    <methods/>
    <properties>
      <property name="use" scope="instance" type="String">
        <description>Specify the color model to use for the transformation.  Can be &amp;quot;rgb&amp;quot;, &amp;quot;rgba&amp;quot;, &amp;quot;hsv&amp;quot;, &amp;quot;hsl&amp;quot;, &amp;quot;cmy&amp;quot;, &amp;quot;cmyk&amp;quot;.</description>
      </property>
      <property name="dr" scope="instance" type="Number">
        <description>The delta to be applied to the red aspect of the RGB/RGBA color model.</description>
      </property>
      <property name="dg" scope="instance" type="Number">
        <description>The delta to be applied to the green aspect of the RGB/RGBA color model.</description>
      </property>
      <property name="db" scope="instance" type="Number">
        <description>The delta to be applied to the blue aspect of the RGB/RGBA color model.</description>
      </property>
      <property name="da" scope="instance" type="Number">
        <description>The delta to be applied to the alpha aspect of the RGBA color model.</description>
      </property>
      <property name="dc" scope="instance" type="Number">
        <description>The delta to be applied to the cyan aspect of the CMY/CMYK color model.</description>
      </property>
      <property name="dm" scope="instance" type="Number">
        <description>The delta to be applied to the magenta aspect of the CMY/CMYK color model.</description>
      </property>
      <property name="dy" scope="instance" type="Number">
        <description>The delta to be applied to the yellow aspect of the CMY/CMYK color model.</description>
      </property>
      <property name="dk" scope="instance" type="Number">
        <description>The delta to be applied to the black aspect of the CMYK color model.</description>
      </property>
      <property name="dh" scope="instance" type="Number">
        <description>The delta to be applied to the hue aspect of the HSL/HSV color model.</description>
      </property>
      <property name="ds" scope="instance" type="Number">
        <description>The delta to be applied to the saturation aspect of the HSL/HSV color model.</description>
      </property>
      <property name="dl" scope="instance" type="Number">
        <description>The delta to be applied to the luminosity aspect of the HSL color model.</description>
      </property>
      <property name="dv" scope="instance" type="Number">
        <description>The delta to be applied to the value aspect of the HSV color model.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.color.Palette.__generatorArgs">
    <methods/>
    <properties>
      <property name="base" scope="instance" type="dojo.Color">
        <description>The base color to be used to generate the palette.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.color.Palette.__analogousArgs">
    <methods/>
    <properties>
      <property name="base" scope="instance" type="dojo.Color">
        <description>The base color to be used to generate the palette.</description>
      </property>
      <property name="high" scope="instance" type="Number">
        <description>The difference between the hue of the base color and the highest hue.  In degrees, default is 60.</description>
      </property>
      <property name="low" scope="instance" type="Number">
        <description>The difference between the hue of the base color and the lowest hue.  In degrees, default is 18.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.color.Palette.__splitComplementaryArgs">
    <methods/>
    <properties>
      <property name="base" scope="instance" type="dojo.Color">
        <description>The base color to be used to generate the palette.</description>
      </property>
      <property name="da" scope="instance" type="Number">
        <description>The delta angle to be used to determine where the split for the complementary rules happen.
	In degrees, the default is 30.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.cometd">
    <properties>
      <property name="HttpChannels" scope="instance" type="Object"/>
      <property name="connectionTypes" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="ackEnabled" scope="instance" type="Object"/>
      <property name="ack" scope="instance" type="Object"/>
      <property name="longPollTransport" scope="instance" type="Object"/>
      <property name="timestamp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.RestChannels">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <description>arguments:
	The *autoSubscribeRoot* parameter:
	When this is set, all REST service requests that have this
	prefix will be auto-subscribed. The default is '/' (all REST requests).
	The *url* parameter:
	This is the url to connect to for server-sent messages. The default
	is &amp;quot;/channels&amp;quot;.
	The *autoReconnectTime* parameter:
	This is amount time to wait to reconnect with a connection is broken
	The *reloadDataOnReconnect* parameter:
	This indicates whether RestChannels should re-download data when a connection
	is restored (value of true), or if it should re-subscribe with retroactive subscriptions
	(Subscribe-Since header) using HEAD requests (value of false). The
	default is true.</description>
          </parameter>
        </parameters>
      </method>
      <method name="absoluteUrl" scope="instance">
        <parameters>
          <parameter name="baseUrl" type="Object" usage="required"/>
          <parameter name="relativeUrl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="instance">
        <description>Note that if there is no connection open, this is automatically called when you do a subscription,
	it is often not necessary to call this</description>
        <return-types>
          <return-type type="this can be called after dojo is unloaded, just do nothing in that case"/>
        </return-types>
      </method>
      <method name="_send" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <description>the uri for the resource you want to monitor</description>
          </parameter>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional">
            <description>See dojo.xhr
	headers:
	These are the headers to be applied to the channel subscription request
	callback:
	This will be called when a event occurs for the channel
	The callback will be called with a single argument:
		callback(message)
	where message is an object that follows the XHR API:
	status : Http status
	statusText : Http status text
	getAllResponseHeaders() : The response headers
	getResponseHeaders(headerName) : Retrieve a header by name
	responseText : The response body as text
	with the following additional Bayeux properties
	data : The response body as JSON
	channel : The channel/url of the response</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="don't process the response, the response will be received in the main channels response"/>
        </return-types>
      </method>
      <method name="publish" scope="instance">
        <description>This does a simple POST operation to the provided URL,
	POST is the semantic equivalent of publishing a message within REST/Channels</description>
        <parameters>
          <parameter name="channel" type="Channel" usage="required">
            <description>path to publish to</description>
          </parameter>
          <parameter name="data" type="data" usage="required">
            <description>to publish</description>
          </parameter>
        </parameters>
      </method>
      <method name="_processMessage" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="indicate an error"/>
        </return-types>
      </method>
      <method name="onprogress" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="contentType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="receive" scope="instance">
        <parameters>
          <parameter name="message" type="A" usage="required">
            <description>cometd/XHR message</description>
          </parameter>
        </parameters>
      </method>
      <method name="disconnected" scope="instance"/>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
    </methods>
    <properties>
      <property name="acceptType" scope="instance" type="String"/>
      <property name="subscriptions" scope="instance" type="Object"/>
      <property name="subCallbacks" scope="instance" type="Object"/>
      <property name="autoReconnectTime" scope="instance" type="Number"/>
      <property name="reloadDataOnReconnect" scope="instance" type="Object"/>
      <property name="sendAsJson" scope="instance" type="bool"/>
      <property name="url" scope="instance" type="String"/>
      <property name="autoSubscribeRoot" scope="instance" type="String"/>
      <property name="started" scope="instance" type="bool"/>
      <property name="connectionId" scope="instance" type="Object"/>
      <property name="createdClientId" scope="instance" type="Object"/>
      <property name="lastIndex" scope="instance" type="Number"/>
      <property name="connected" scope="instance" type="bool"/>
      <property name="defaultInstance" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.Connection">
    <methods>
      <method name="state" scope="instance"/>
      <method name="init" scope="instance">
        <description>Initialize the cometd implementation of the Bayeux protocol by
	sending a handshake message. The cometd state will be changed to CONNECTING
	until a handshake response is received and the first successful connect message
	has returned.
	The protocol state changes may be monitored
	by subscribing to the dojo topic "/prefix/meta" (typically "/cometd/meta") where
	events are published in the form
	{cometd:this,action:"handshake",successful:true,state:this.state()}</description>
        <examples>
          <example>	dojox.cometd.init("/cometd");
		dojox.cometd.init("http://xdHost/cometd",{ext:{user:"fred",pwd:"secret"}});</example>
        </examples>
        <parameters>
          <parameter name="root" type="String" usage="required">
            <description>The URL of the cometd server. If the root is absolute, the host
	is examined to determine if xd transport is needed. Otherwise the
	same domain is assumed.</description>
          </parameter>
          <parameter name="props" type="Object" usage="optional">
            <description>An optional object that is used as the basis of the handshake message</description>
          </parameter>
          <parameter name="bargs" type="Object" usage="optional">
            <description>An optional object of bind args mixed in with the send of the handshake</description>
          </parameter>
        </parameters>
      </method>
      <method name="publish" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <description>the destination channel for the message</description>
          </parameter>
          <parameter name="data" type="Object" usage="required">
            <description>a JSON object containing the message &amp;quot;payload&amp;quot;
	properties:
	Optional. Other meta-data to be mixed into the top-level of the
	message</description>
          </parameter>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <description>`dojox.cometd.subscribe()` handles all the hard work of telling
	the server that we want to be notified when events are
	published on a particular topic. `subscribe` accepts a function
	to handle messages and returns a `dojo.Deferred` object which
	has an extra property added to it which makes it suitable for
	passing to `dojox.cometd.unsubscribe()` as a "subscription
	handle" (much like the handle object that `dojo.connect()`
	produces and which `dojo.disconnect()` expects).
	Note that of a subscription is registered before a connection
	with the server is established, events sent before the
	connection is established will not be delivered to this client.
	The deferred object which `subscribe` returns will callback
	when the server successfuly acknolwedges receipt of our
	"subscribe" request.</description>
        <examples>
          <example>Simple subscribe use-case
		dojox.cometd.init("http://myserver.com:8080/cometd");
		// log out all incoming messages on /foo/bar
		dojox.cometd.subscribe("/foo/bar", console, "debug");</example>
          <example>Subscribe before connection is initialized
		dojox.cometd.subscribe("/foo/bar", console, "debug");
		dojox.cometd.init("http://myserver.com:8080/cometd");</example>
          <example>Subscribe an unsubscribe
		dojox.cometd.init("http://myserver.com:8080/cometd");
		var h = dojox.cometd.subscribe("/foo/bar", console, "debug");
		dojox.cometd.unsubscribe(h);</example>
          <example>Listen for successful subscription:
		dojox.cometd.init("http://myserver.com:8080/cometd");
		var h = dojox.cometd.subscribe("/foo/bar", console, "debug");
		h.addCallback(function(){
			console.debug("subscription to /foo/bar established");
		});</example>
        </examples>
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <description>name of the cometd channel to subscribe to</description>
          </parameter>
          <parameter name="objOrFunc" type="Object" usage="required">
            <description>an object scope for funcName or the name or reference to a
	function to be called when messages are delivered to the
	channel</description>
          </parameter>
          <parameter name="funcName" type="String" usage="required">
            <description>the second half of the objOrFunc/funcName pair for identifying
	a callback function to notifiy upon channel message delivery</description>
          </parameter>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <description>name of the cometd channel to unsubscribe from</description>
          </parameter>
          <parameter name="objOrFunc" type="Object" usage="optional">
            <description>an object scope for funcName or the name or reference to a
	function to be called when messages are delivered to the
	channel. If null then all subscribers to the channel are unsubscribed.</description>
          </parameter>
          <parameter name="funcName" type="String" usage="optional">
            <description>the second half of the objOrFunc/funcName pair for identifying
	a callback function to notifiy upon channel message delivery</description>
          </parameter>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <description>Disconnect from the server by sending a disconnect message</description>
        <examples>
          <example>	dojox.cometd.disconnect();</example>
        </examples>
      </method>
      <method name="subscribed" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribed" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance">
        <parameters>
          <parameter name="childLocation" type="Object" usage="required"/>
          <parameter name="childDomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="_backoff" scope="instance"/>
      <method name="_backon" scope="instance"/>
      <method name="_interval" scope="instance"/>
      <method name="_publishMeta" scope="instance">
        <parameters>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="successful" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finishInit" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_extendIn" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_extendOut" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_deliver" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_sendMessage" scope="instance">
        <parameters>
          <parameter name="message" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="startBatch" scope="instance"/>
      <method name="endBatch" scope="instance"/>
      <method name="_onUnload" scope="instance"/>
      <method name="_connectTimeout" scope="instance"/>
    </methods>
    <properties>
      <property name="url" scope="instance" type="Object"/>
      <property name="_isXD" scope="instance" type="bool"/>
      <property name="_props" scope="instance" type="Object"/>
      <property name="_messageQ" scope="instance" type="Array"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="_status" scope="instance" type="String"/>
      <property name="batch" scope="instance" type="Number"/>
      <property name="_deferredSubscribes" scope="instance" type="Object"/>
      <property name="_handshook" scope="instance" type="Object"/>
      <property name="_backoffInterval" scope="instance" type="Number"/>
      <property name="handshakeReturn" scope="instance" type="Object"/>
      <property name="clientId" scope="instance" type="Object"/>
      <property name="lastMessage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.Connection._advice">
    <properties>
      <property name="interval" scope="instance" type="Number"/>
      <property name="reconnect" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.cometd.Connection.currentTransport">
    <properties>
      <property name="_cometd" scope="instance" type="Object"/>
      <property name="version" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd._ack">
    <methods>
      <method name="_in" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_out" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.cometd.callbackPollTransport">
    <methods>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="xdomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance"/>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="cancelConnect" scope="instance"/>
    </methods>
    <properties>
      <property name="_connectionType" scope="instance" type="String"/>
      <property name="tunnelCollapse" scope="instance" type="Object"/>
      <property name="_connect" scope="instance" type="Object"/>
      <property name="deliver" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.callbackPollTransport._cometd">
    <properties>
      <property name="_polling" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportFormEncoded">
    <methods>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="xdomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance"/>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="_connect" scope="instance"/>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="cancelConnect" scope="instance"/>
    </methods>
    <properties>
      <property name="_connectionType" scope="instance" type="String"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="_poll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportFormEncoded._cometd">
    <properties>
      <property name="_status" scope="instance" type="String"/>
      <property name="_polling" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportJsonEncoded">
    <methods>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="Object" usage="required"/>
          <parameter name="version" type="Object" usage="required"/>
          <parameter name="xdomain" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance"/>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="_connect" scope="instance"/>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="cancelConnect" scope="instance"/>
    </methods>
    <properties>
      <property name="_connectionType" scope="instance" type="String"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="_poll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.cometd.longPollTransportJsonEncoded._cometd">
    <properties>
      <property name="_status" scope="instance" type="String"/>
      <property name="_polling" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.cometd.timesync">
    <methods>
      <method name="getServerTime" scope="instance"/>
      <method name="getServerDate" scope="instance"/>
      <method name="setTimeout" scope="instance">
        <parameters>
          <parameter name="call" type="function" usage="required">
            <description>the function to call when the timeout occurs
	atTimeOrTime:
	a long timestamp or a Date representing the server time at
	which the timeout should occur.</description>
          </parameter>
          <parameter name="atTimeOrDate" type="long|Date" usage="required"/>
        </parameters>
      </method>
      <method name="_in" scope="instance">
        <description>Look for ext:{timesync:{}} field and calculate offset if present.</description>
        <parameters>
          <parameter name="msg" type="Object" usage="required">
            <description>The incoming bayeux message</description>
          </parameter>
        </parameters>
      </method>
      <method name="_out" scope="instance">
        <description>Look for handshake and connect messages and add the ext:{timesync:{}} fields</description>
        <parameters>
          <parameter name="msg" type="The" usage="required">
            <description>outgoing bayeux message</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_window" scope="instance" type="Number"/>
      <property name="_lags" scope="instance" type="Array"/>
      <property name="_offsets" scope="instance" type="Array"/>
      <property name="lag" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Object"/>
      <property name="samples" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.css3.fx">
    <methods>
      <method name="puff" scope="instance">
        <description>Fades out an element and scales it to args.endScale</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="expand" scope="instance">
        <description>Scales an element to args.endScale</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shrink" scope="instance">
        <description>Shrinks an element, same as expand({ node: node, endScale: .01 });</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rotate" scope="instance">
        <description>Rotates an element from args.startAngle to args.endAngle</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flip" scope="instance">
        <description>Flips an element around his y axis. The default is a 360deg flip
	but it's possible to run a partial flip using args.whichAnims</description>
        <examples>
          <example>	// half flip
		dojox.css3.fx.flip({
			node: domNode,
			whichAnim: [0, 1]
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bounce" scope="instance">
        <description>Vertical bounce animation, the scaleX, scaleY deformation and the
	jump height (args.jumpHeight) can be specified</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.css3"/>
  <class type="dojox.data">
    <methods>
      <method name="_getStoreForItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="restListener" scope="instance">
        <description>Example:
		dojo.connect(window,"onMessage",null,function(event) {
			var data = dojo.fromJson(event.data);
			dojox.restListener(data);
		});</description>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="ASYNC_MODE" scope="instance" type="Number"/>
      <property name="SYNC_MODE" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrReadStore" superclass="dojo.data.util.simpleFetch">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="_getItemsArray" scope="instance">
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional">
            <description>The query options parameter, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getItemsFromLoadedData" scope="instance">
        <description>Function to parse the loaded data into item format and build the internal items array.</description>
        <parameters>
          <parameter name="dataObject" type="Object" usage="required">
            <description>The JS data object containing the raw data to convery into item format.</description>
          </parameter>
        </parameters>
        <return-description>array
	Array of items in store item format.</return-description>
      </method>
      <method name="_addReferenceToMap" scope="instance">
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item that holds the new reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the new reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemByIdentity" scope="instance">
        <parameters>
          <parameter name="identity" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_forceLoad" scope="instance"/>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="_ccUrl" scope="instance-prototype" type="String"/>
      <property name="data" scope="instance-prototype" type="Object"/>
      <property name="typeMap" scope="instance" type="Object"/>
      <property name="clearOnClose" scope="instance-prototype" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="bool"/>
      <property name="hierarchical" scope="instance-prototype" type="Object"/>
      <property name="_jsonFileUrl" scope="instance-prototype" type="Object"/>
      <property name="_jsonData" scope="instance-prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_loadFinished" scope="instance-prototype" type="bool"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfTopLevelItems" scope="instance-prototype" type="Array"/>
      <property name="_itemsByIdentity" scope="instance-prototype" type="Object"/>
      <property name="_labelAttr" scope="instance" type="Object"/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_storeRefPropName" scope="instance" type="String"/>
      <property name="_itemNumPropName" scope="instance" type="String"/>
      <property name="_rootItemPropName" scope="instance" type="String"/>
      <property name="_reverseRefMap" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrReadStore._features.dojo.data.api">
    <properties>
      <property name="Identity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrReadStore._datatypeMap">
    <properties>
      <property name="Date" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrWriteStore" superclass="dojox.data.AndOrReadStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="object" usage="required">
            <description>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  It is serialized assuming object.toString()
	serialization.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	serialize:	function(object) //The function that converts the object back into the proper file format form.
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assert" scope="instance">
        <parameters>
          <parameter name="condition" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getIdentifierAttribute" scope="instance"/>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="_removeArrayElement" scope="instance">
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="element" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="almost" usage="required">
            <description>anything</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueOrValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="newValueOrValues" type="anything" usage="required"/>
          <parameter name="callOnSet" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_addReferenceToMap" scope="instance">
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item that holds the new reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <description>The attribute on parentItem that contains the new reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeReferenceFromMap" scope="instance">
        <description>Method to remove an reference map entry for an item and attribute.  This will
	also perform cleanup on the map such that if there are no more references at all to
	the item, its reference object and entry are removed.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <description>The item that is referenced.</description>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <description>The item holding a reference to refItem.</description>
          </parameter>
          <parameter name="attribute" type="strin" usage="required">
            <description>The attribute on parentItem that contains the reference.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_dumpReferenceMap" scope="instance">
        <description>Function to dump the reverse reference map of all items in the store for debug purposes.</description>
      </method>
      <method name="_getValueOrValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_flatten" scope="instance">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewFileContentString" scope="instance"/>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="something" type="The" usage="required">
            <description>array or object to examine.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onSet" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
        </parameters>
      </method>
      <method name="onNew" scope="instance">
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <description>Over-ride of base close function of ItemFileReadStore to add in check for store state.
	If the store is still dirty (unsaved changes), then an error will be thrown instead of
	clearing the internal state for reload from the url.</description>
        <parameters>
          <parameter name="request" type="object" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.AndOrReadStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="referenceIntegrity" scope="instance-prototype" type="bool"/>
      <property name="_saveInProgress" scope="instance-prototype" type="bool"/>
      <property name="_pending" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrWriteStore._features.dojo.data.api">
    <properties>
      <property name="Write" scope="instance" type="Object"/>
      <property name="Notification" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AndOrWriteStore._datatypeMap.Date">
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.AppStore" superclass="dojo.data.util.simpleFetch">
    <description>The APP Store is instantiated either in markup or programmatically by supplying a
	url of the Collection to be used.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The APP Store is instantiated either in markup or programmatically by supplying a
	url of the Collection to be used.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>An anonymous object to initialize properties.  It expects the following values:</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setFeed" scope="instance">
        <description>Sets the internal feed using a dojox.atom.io.model.Feed object.  Also adds
	a property to the entries to track that they belong to this store. It
	also parses stored requests (since we were waiting on a callback) and
	executes those as well.</description>
        <parameters>
          <parameter name="feed" type="dojox.atom.io.model.Feed" usage="required">
            <description>object
	The Feed to use for this data store.</description>
          </parameter>
          <parameter name="data" type="unused" usage="required">
            <description>Signature for this function is defined by AtomIO.getFeed, since this is a callback.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getAllItems" scope="instance">
        <description>Function to return all entries in the Feed as an array of items.</description>
        <return-description>Array of all entries in the feed.</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <description>This function tests whether the item passed in is indeed an item
	in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <description>This function tests whether the item passed in is indeed a valid
	'attribute' like type for the store.</description>
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
        <return-description>Returns a boolean indicating whether this is a valid attribute.</return-description>
      </method>
      <method name="_addUpdate" scope="instance">
        <description>Internal function to add an updated entry to our updates array</description>
        <parameters>
          <parameter name="update" type="Object" usage="required">
            <description>dojox.atom.io.model.Entry object
	The updated Entry we've changed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="int"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
          <parameter name="trim" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <description>Fetch items (Atom entries) that match to a query</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_finishFetchItems" scope="instance">
        <description>Internal function for finishing a fetch request.  Needed since the feed
	might not have been loaded, so we finish the fetch in a callback.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="value" type="almost" usage="required">
            <description>anything</description>
          </parameter>
        </parameters>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>{ onComplete: function
	onError: function
	scope: object
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="revert" scope="instance"/>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <description>string So the parser can instantiate the store via markup.</description>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="Whether">
        <description>boolean Whether or not to pass the preventCache parameter to the connection</description>
      </property>
      <property name="xmethod" scope="instance" type="boolean">
        <description>Whether to use X-Method-Override for PUT/DELETE.</description>
      </property>
      <property name="_atomIO" scope="instance" type="Object"/>
      <property name="_feed" scope="instance" type="Object"/>
      <property name="_requests" scope="instance" type="Array"/>
      <property name="_processing" scope="instance" type="Object"/>
      <property name="_updates" scope="instance" type="Object"/>
      <property name="_adds" scope="instance" type="Object"/>
      <property name="_deletes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.AtomReadStore" superclass="dojo.data.util.simpleFetch">
    <description>A data store for Atom XML based services or documents.	This store is still under development
	and doesn't support wildcard filtering yet.	Attribute filtering is limited to category or id.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required">
            <description>An anonymous object to initialize properties.	It expects the following values:</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <description>'item' must be an instance of an object created by the AtomReadStore instance.
	Accepted attributes are id, subtitle, title, summary, content, author, updated,
	published, category, link and alternate</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An item returned by a call to the 'fetch' method.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A attribute of the Atom Entry</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>A default value</description>
          </parameter>
        </parameters>
        <return-description>An attribute value found, otherwise 'defaultValue'</return-description>
      </method>
      <method name="getValues" scope="instance">
        <description>'item' must be an instance of an object created by the AtomReadStore instance.
	Accepted attributes are id, subtitle, title, summary, content, author, updated,
	published, category, link and alternate</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An item returned by a call to the 'fetch' method.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A attribute of the Atom Entry</description>
          </parameter>
        </parameters>
        <return-description>An array of values for the attribute value found, otherwise 'defaultValue'</return-description>
      </method>
      <method name="getAttributes" scope="instance">
        <description>'item' must be have been created by the AtomReadStore instance.
	tag names of child elements and XML attribute names of attributes
	specified to the element are returned along with special attribute
	names applicable to the element including "tagName", "childNodes"
	if the element has child elements, "text()" if the element has
	child text nodes, and attribute names in '_attributeMap' that match
	the tag name of the element.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element</description>
          </parameter>
        </parameters>
        <return-description>An array of attributes found</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>'item' must be created by the AtomReadStore instance.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>An attribute of an Atom Entry item.</description>
          </parameter>
        </parameters>
        <return-description>True if the element has the attribute, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the attribute values contain the value, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>containing the args for loadItem.	See dojo.data.api.Read.loadItem()</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-description>"dojo.data.api.Read" and "dojo.data.api.Write"</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getFeedValue" scope="instance">
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeedValues" scope="instance">
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getFetchUrl" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="instance">
        <parameters>
          <parameter name="document" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getItem" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parseItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHTML" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <description>url to a service or an XML document that represents the store</description>
      </property>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="sendQuery" scope="instance-prototype" type="A">
        <description>boolean indicate to add a query string to the service URL</description>
      </property>
      <property name="unescapeHTML" scope="instance-prototype" type="A">
        <description>boolean to specify whether or not to unescape HTML text</description>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="bool"/>
      <property name="_feedMetaData" scope="instance" type="Object"/>
      <property name="_items" scope="instance" type="Object"/>
      <property name="rewriteUrl" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.CdfStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasProperty" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <description>The store always loads all items, so if it's an item, then it's loaded.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetch" scope="instance">
        <description>Returns an Array of items based on the request arguments.
	If the store is in ASYNC mode, the items should be expected in an onComplete
	method passed in the request object. If store is in SYNC mode, the items will
	be return directly as well as within the onComplete method.
	note:
	The mode can be set on store initialization or during a fetch as one of the
	parameters.
	query: String
	The items in the store are treated as objects, but this is reading an XML
	document. Further, the actual querying of the items takes place in Tibco GI's
	jsx3.xml.Entity. Therefore, we are using their syntax which is xpath.
	Note:
	As conforming to a CDF document, most, if not all nodes are considered "records"
	and their tagNames are as such. The root node is named "data".
	examples:
	All items:
		store.fetch({query:"*"});
	Item with a jsxid attribute equal to "1" (note you could use byId for this)
		store.fetch({query:"//record[@jsxid='1']"});
	All items with any jsxid attribute:
		"//record[@jsxid='*']"
	The items with a jsxid of '1' or '4':
		"//record[@jsxid='4' or @jsxid='1']"
	All children within a "group" node (could be multiple group nodes):
	"//group/record"
	All children within a specific group node:
	"//group[@name='mySecondGroup']/record"
	Any record, anywhere in the document:
		"//record"
	Only the records beneath the root (data) node:
		"//data/record"
	See:
	http://www.tibco.com/devnet/resources/gi/3_7/api/html/jsx3/xml/Entity.html#method:selectNodes
	http://www.w3.org/TR/xpath
	http://msdn.microsoft.com/en-us/library/ms256086.aspx
	See dojo.data.Read.fetch():
	onBegin
	onComplete
	onItem
	onError
	scope
	start
	count
	sort</description>
        <parameters>
          <parameter name="request" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_loadCDF" scope="instance">
        <return-types>
          <return-type type="jsx3.xml.CDF"/>
          <return-type type="dojo.Deferred"/>
          <return-type type="Error"/>
        </return-types>
      </method>
      <method name="_getItems" scope="instance">
        <parameters>
          <parameter name="cdfDoc" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="optional"/>
          <parameter name="parentInfo" type="object" usage="optional">
            <description>|| String?</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="jsx3.xml.Entity"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="value" type="almost" usage="required">
            <description>anything</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="revert" scope="instance">
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required">
            <description>?</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_makeDirty" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeXmlString" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>|| String</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="byId" scope="instance-prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>|| String</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="identity" scope="instance-prototype" type="String">
        <description>The unique identifier for each item. Defaults to &amp;quot;jsxid&amp;quot; which is standard for a CDF
	document. Should not be changed.
	url : String
	The location from which to fetch the XML (CDF) document.</description>
      </property>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="xmlStr" scope="instance-prototype" type="String">
        <description>A string that can be parsed into an XML document and should be formatted according
	to the CDF spec.</description>
      </property>
      <property name="data" scope="instance" type="Object">
        <description>A object that will be converted into the xmlStr property, and then parsed into a CDF.</description>
      </property>
      <property name="label" scope="instance-prototype" type="String">
        <description>The property within each item used to define the item.
	mode [const]: dojox.data.ASYNC_MODE | dojox.data.SYNC_MODE
	This store supports syncronous fetches if this property is set to dojox.data.SYNC_MODE.</description>
      </property>
      <property name="mode" scope="instance-prototype" type="Object"/>
      <property name="cdfDoc" scope="instance" type="Object"/>
      <property name="_modifiedItems" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.ClientFilter">
    <description>To a update a result set after a notification (onNew, onSet, and onDelete),
	widgets can call the updateResultSet method. Widgets can use the updated
	result sets to determine how to react to notifications, and how to update their displayed results
	based on changes.
	This module will use the best available information to update result sets, using query attribute
	objects to determine if items are in a result set, and using the sort arrays to maintain sort
	information. However, queries can be opaque strings, and this module can not update
	results by itself in this case. In this situations, data stores can provide a isUpdateable(request) function
	and matchesQuery(item,request) function. If a data store can handle a query, it can return true from
	isUpdateable and if an item matches a query, it can return true from matchesQuery. Here is
	definition of isUpdateable and matchesQuery
	isUpdateable(request)  - request is the keywords arguments as is passed to the fetch function.
	matchesQuery(item,request) - item is the item to test, and request is the value arguments object
	for the fetch function.
	You can define a property on this object instance "cacheByDefault" to a value of true that will
	cause all queries to be cached by default unless the cache queryOption is explicitly set to false.
	This can be defined in the constructor options for ServiceStore/JsonRestStore and subtypes.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>To a update a result set after a notification (onNew, onSet, and onDelete),
	widgets can call the updateResultSet method. Widgets can use the updated
	result sets to determine how to react to notifications, and how to update their displayed results
	based on changes.
	This module will use the best available information to update result sets, using query attribute
	objects to determine if items are in a result set, and using the sort arrays to maintain sort
	information. However, queries can be opaque strings, and this module can not update
	results by itself in this case. In this situations, data stores can provide a isUpdateable(request) function
	and matchesQuery(item,request) function. If a data store can handle a query, it can return true from
	isUpdateable and if an item matches a query, it can return true from matchesQuery. Here is
	definition of isUpdateable and matchesQuery
	isUpdateable(request)  - request is the keywords arguments as is passed to the fetch function.
	matchesQuery(item,request) - item is the item to test, and request is the value arguments object
	for the fetch function.
	You can define a property on this object instance "cacheByDefault" to a value of true that will
	cause all queries to be cached by default unless the cache queryOption is explicitly set to false.
	This can be defined in the constructor options for ServiceStore/JsonRestStore and subtypes.</description>
        <examples>
          <example>to make a updated-result-set data store from an existing data store:
		dojo.declare("dojox.data.MyLiveDataStore",
			dojox.data.MyDataStore,dojox.data.ClientFilter], // subclass LiveResultSets if available
			{}
		);</example>
        </examples>
      </method>
      <method name="clearCache" scope="instance"/>
      <method name="updateResultSet" scope="instance">
        <description>This will attempt to update the provide result based on previous notification, adding new items
	from onNew calls, removing deleted items, and updating modified items, and properly removing
	and adding items as required by the query and sort parameters. This function will return:
	0: Indicates it could not successfully update the result set
	1: Indicates it could successfully handle all the notifications, but no changes were made to the result set
	2: Indicates it successfully handled all the notifications and result set has been updated.</description>
        <parameters>
          <parameter name="resultSet" type="Array" usage="required">
            <description>The result set array that should be updated</description>
          </parameter>
          <parameter name="request" type="Object" usage="required">
            <description>This object follows the same meaning as the keywordArgs passed to a dojo.data.api.Read.fetch.</description>
          </parameter>
        </parameters>
      </method>
      <method name="querySuperSet" scope="instance">
        <parameters>
          <parameter name="argsSuper" type="Dojo" usage="required">
            <description>Data Fetch arguments</description>
          </parameter>
          <parameter name="argsSub" type="Dojo" usage="required">
            <description>Data Fetch arguments</description>
          </parameter>
        </parameters>
      </method>
      <method name="cachingFetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isUpdateable" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>See dojo.data.api.Read.fetch request</description>
          </parameter>
        </parameters>
      </method>
      <method name="clientSideFetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>See dojo.data.api.Read.fetch request</description>
          </parameter>
          <parameter name="baseResults" type="Array" usage="required">
            <description>This provides the result set to start with for client side querying</description>
          </parameter>
        </parameters>
      </method>
      <method name="clientSidePaging" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="baseResults" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="matchesQuery" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeComparator" scope="instance">
        <parameters>
          <parameter name="sort" type="See" usage="required">
            <description>dojox.data.api.Read.fetch</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="keep the order unchanged"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="cacheByDefault" scope="instance" type="bool"/>
      <property name="_fetchCache" scope="instance-prototype" type="Array"/>
      <property name="serverVersion" scope="instance" type="Number"/>
      <property name="onSet" scope="instance" type="Object"/>
      <property name="onNew" scope="instance" type="Object"/>
      <property name="onDelete" scope="instance" type="Object"/>
      <property name="_updates" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.data.CouchDBRestStore" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStores" scope="instance">
        <parameters>
          <parameter name="couchServerUrl" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonRestStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.CouchDBRestStore.service">
    <properties>
      <property name="servicePath" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.CssClassStore" superclass="dojox.data.CssRuleStore">
    <description>The CssClassStore allows users to get information about active Css classes in the page running the CssClassStore.
	It can also filter out classes from specific stylesheets.  The attributes it exposes on classes are as follows:
	class:		The classname, including the '.'.
	classSans:	The classname without the '.'.</description>
    <methods>
      <method name="getFeatures" scope="instance"/>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleRule" scope="instance">
        <parameters>
          <parameter name="rule" type="Object" usage="required"/>
          <parameter name="styleSheet" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleReturn" scope="instance"/>
      <method name="_handleFetchByIdentityReturn" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="request" type="request" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.CssRuleStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_labelAttribute" scope="instance" type="String"/>
      <property name="_idAttribute" scope="instance" type="String"/>
      <property name="_cName" scope="instance" type="String"/>
      <property name="_pending" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.data.CssRuleStore">
    <description>The CssRuleStore allows users to get information about active CSS rules in the page running the CssRuleStore.
	It can also filter out rules from specific stylesheets.  The attributes it exposes on rules are as follows:
	selector:				The selector text.
	classes:				An array of classes present in this selector.
	rule:					The actual DOM Rule object.
	style:					The actual DOM CSSStyleDeclaration object.
	cssText:				The cssText string provided on the rule object.
	styleSheet:				The originating DOM Stylesheet object.
	parentStyleSheet: 		The parent stylesheet to the sheet this rule originates from.
	parentStyleSheetHref: 	The href of the parent stylesheet.
	AND every style attribute denoted as style.*, such as style.textAlign or style.backgroundColor</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setContext" scope="instance">
        <parameters>
          <parameter name="context" type="Array" usage="required">
            <description>- Array of CSS string paths to execute queries within</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleRule" scope="instance">
        <parameters>
          <parameter name="rule" type="Object" usage="required"/>
          <parameter name="styleSheet" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleReturn" scope="instance"/>
      <method name="_handleFetchReturn" scope="instance">
        <parameters>
          <parameter name="request" type="Request" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance"/>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_storeRef" scope="instance" type="String"/>
      <property name="_labelAttribute" scope="instance" type="String"/>
      <property name="_cache" scope="instance-prototype" type="Object"/>
      <property name="_browserMap" scope="instance" type="Object"/>
      <property name="_cName" scope="instance" type="String"/>
      <property name="context" scope="instance" type="Object"/>
      <property name="_pending" scope="instance" type="Array"/>
      <property name="_allItems" scope="instance-prototype" type="Object"/>
      <property name="_waiting" scope="instance" type="Array"/>
      <property name="gatherHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.CsvStore" superclass="dojo.data.util.simpleFetch">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>identifier: String} The column label for the column to use for the identity.  Optional.  If not set, the identity is the row number.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getIndex" scope="instance">
        <parameters>
          <parameter name="item" type="The" usage="required">
            <description>idem handle to get the index for.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <description>The CsvStore always loads all items, so if it's an item, then it's loaded.
	From the dojo.data.api.Read.loadItem docs:
	If a call to isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke
	the callback handlers.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="_splitLines" scope="instance">
        <parameters>
          <parameter name="csvContent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processData" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required">
            <description>The CSV data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_createItemFromIdentity" scope="instance">
        <parameters>
          <parameter name="identity" type="String" usage="required">
            <description>The identity</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="string">
        <description>Declarative hook for setting Csv source url.</description>
      </property>
      <property name="label" scope="instance-prototype" type="string">
        <description>Declarative hook for setting the label attribute.</description>
      </property>
      <property name="identifier" scope="instance-prototype" type="string">
        <description>Declarative hook for setting the identifier.</description>
      </property>
      <property name="separator" scope="instance-prototype" type="string">
        <description>Parameter to allow specifying if preventCache should be passed to
	the xhrGet call or not when loading data from a url.
	Note this does not mean the store calls the server on each fetch,
	only that the data load has preventCache set as an option.</description>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="bool"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_csvData" scope="instance-prototype" type="Object"/>
      <property name="_getArrayOfArraysFromCsvFileContents" scope="instance" type="Object"/>
      <property name="_attributes" scope="instance-prototype" type="Array"/>
      <property name="_dataArray" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance-prototype" type="Array"/>
      <property name="_loadFinished" scope="instance-prototype" type="bool"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_attributeIndexes" scope="instance" type="Object"/>
      <property name="_storeProp" scope="instance" type="String"/>
      <property name="_idProp" scope="instance" type="String"/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_idMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.FileStore">
    <description>A simple store that provides a datastore interface to a filesystem.  It takes a few parameters
	for initialization:</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>A simple store that provides a datastore interface to a filesystem.  It takes a few parameters
	for initialization:</description>
        <examples>
          <example>options="expand,dirsOnly,showHiddenFiles"</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResult" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemArray" scope="instance">
        <parameters>
          <parameter name="itemArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <description>string The URL to the file path service.</description>
      </property>
      <property name="_storeRef" scope="instance" type="string">
        <description>Internal variable used to denote an item came from this store instance.</description>
      </property>
      <property name="label" scope="instance-prototype" type="The">
        <description>string Default attribute to use to represent the item as a user-readable
	string.  Public, so users can change it.</description>
      </property>
      <property name="_identifier" scope="instance" type="string">
        <description>Default attribute to use to represent the item's identifier.
	Path should always be unique in the store instance.</description>
      </property>
      <property name="_attributes" scope="instance" type="string">
        <description>Internal variable of attributes all file items should have.</description>
      </property>
      <property name="pathSeparator" scope="instance" type="string">
        <description>The path separator to use when chaining requests for children
	Can be overriden by the server on initial load</description>
      </property>
      <property name="options" scope="instance-prototype" type="array">
        <description>Array of options to always send when doing requests.
	Back end service controls this, like 'dirsOnly', 'showHiddenFiles', 'expandChildren', etc.</description>
      </property>
      <property name="failOk" scope="instance" type="boolean">
        <description>Flag to pass on to xhr functions to check if we are OK to fail the call silently</description>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="string">
        <description>Flag to dennote if preventCache should be passed to xhrGet.
	Function to switch between REST style URL lookups and passing the path to specific items as a query param: 'path'.</description>
      </property>
      <property name="pathAsQueryParam" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.FlickrRestStore" superclass="dojox.data.FlickrStore">
    <description>The FlickrRestStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The FlickrRestStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>A request object</description>
          </parameter>
          <parameter name="fetchHandler" type="Function" usage="required">
            <description>A function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="Function" usage="required">
            <description>A function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_processFlickrData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required">
            <description>Data returned from Flickr</description>
          </parameter>
          <parameter name="request" type="Object" usage="required">
            <description>The original dojo.data.Request object passed in by the user.</description>
          </parameter>
          <parameter name="cacheKey" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_checkPrevRanges" scope="instance">
        <parameters>
          <parameter name="primaryKey" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.FlickrStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_id" scope="instance-prototype" type="Integer">
        <description>A unique identifier for this store.</description>
      </property>
      <property name="_requestCount" scope="instance" type="Integer">
        <description>A counter for the number of requests made. This is used to define
	the callback function that Flickr will use.</description>
      </property>
      <property name="_flickrRestUrl" scope="instance" type="String">
        <description>The URL to the Flickr REST services.</description>
      </property>
      <property name="_apikey" scope="instance-prototype" type="String">
        <description>The users API key to be used when accessing Flickr REST services.</description>
      </property>
      <property name="_storeRef" scope="instance" type="String">
        <description>A key used to mark an data store item as belonging to this store.</description>
      </property>
      <property name="_cache" scope="instance-prototype" type="Array">
        <description>An Array of all previously downloaded picture info.</description>
      </property>
      <property name="_prevRequests" scope="instance-prototype" type="Object">
        <description>A HashMap used to record the signature of a request to prevent duplicate
	request being made.</description>
      </property>
      <property name="_handlers" scope="instance-prototype" type="Object">
        <description>A HashMap used to record the handlers registered for a single remote request.  Multiple
	requests may be made for the same information before the first request has finished.
	Each element of this Object is an array of handlers to call back when the request finishes.
	This prevents multiple requests being made for the same information.</description>
      </property>
      <property name="label" scope="instance" type="Object"/>
      <property name="_prevRequestRanges" scope="instance" type="Array"/>
      <property name="_maxPhotosPerUser" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.FlickrRestStore._sortAttributes">
    <properties>
      <property name="date-posted" scope="instance" type="Object"/>
      <property name="date-taken" scope="instance" type="Object"/>
      <property name="interestingness" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.FlickrStore" superclass="dojo.data.util.simpleFetch">
    <description>The FlickrStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The FlickrStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_processFlickrData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHtml" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>String. The string to un-escape</description>
          </parameter>
        </parameters>
        <return-description>HTML String converted back to the normal text (unescaped)
	characters (&lt;,&gt;,&amp;, ", etc,).</return-description>
      </method>
    </methods>
    <properties>
      <property name="_storeRef" scope="instance" type="String"/>
      <property name="label" scope="instance-prototype" type="String"/>
      <property name="urlPreventCache" scope="instance-prototype" type="Object"/>
      <property name="urlRegistry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleFeedStore" superclass="dojox.data.GoogleSearchStore">
    <methods>
      <method name="getFeedValue" scope="instance">
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeedValues" scope="instance">
        <parameters>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createContent" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_googleUrl" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_feedMetaData" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleFeedStore._queryAttrs">
    <properties>
      <property name="url" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleSearchStore">
    <description>The GoogleSearchStore is a Datastore interface to
	the Google search service. The constructor accepts the following arguments:
	&lt;ul&gt;
	&lt;li&gt;label - the label attribute to use. Defaults to titleNoFormatting&lt;/li&gt;
	&lt;li&gt;key - The API key to use. This is optional&lt;/li&gt;
	&lt;li&gt;lang - The language locale to use. Defaults to the browser locale&lt;/li&gt;
	&lt;/ul&gt;</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The GoogleSearchStore is a Datastore interface to
	the Google search service. The constructor accepts the following arguments:
	&lt;ul&gt;
	&lt;li&gt;label - the label attribute to use. Defaults to titleNoFormatting&lt;/li&gt;
	&lt;li&gt;key - The API key to use. This is optional&lt;/li&gt;
	&lt;li&gt;lang - The language locale to use. Defaults to the browser locale&lt;/li&gt;
	&lt;/ul&gt;</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_format" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="base implementation does not format any items"/>
        </return-types>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object
	fetchHandler:
	A function to call for fetched items
	errorHandler:
	A function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getSort" scope="instance"/>
      <method name="_processItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createContent" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_id" scope="instance-prototype" type="Integer">
        <description>A unique identifier for this store.</description>
      </property>
      <property name="_requestCount" scope="instance" type="Integer">
        <description>A counter for the number of requests made. This is used to define
	the callback function that GoogleSearchStore will use.</description>
      </property>
      <property name="_googleUrl" scope="instance" type="String">
        <description>The URL to Googles search web service.</description>
      </property>
      <property name="_storeRef" scope="instance" type="String">
        <description>The internal reference added to each item pointing at the store which owns it.</description>
      </property>
      <property name="_attributes" scope="instance" type="Array">
        <description>The list of attributes that this store supports</description>
      </property>
      <property name="label" scope="instance-prototype" type="String">
        <description>The default attribute which acts as a label for each item.</description>
      </property>
      <property name="_type" scope="instance" type="String"/>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean">
        <description>Sets whether or not to pass preventCache to dojo.io.script.</description>
      </property>
      <property name="_key" scope="instance" type="Object"/>
      <property name="_lang" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleSearchStore._aggregatedAttributes">
    <properties>
      <property name="estimatedResultCount" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleSearchStore._queryAttrs">
    <properties>
      <property name="text" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleWebSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.GoogleBlogSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_aggregatedAttributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleLocalSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleLocalSearchStore._aggregatedAttributes">
    <properties>
      <property name="viewport" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleLocalSearchStore._queryAttrs">
    <properties>
      <property name="text" scope="instance" type="String"/>
      <property name="centerLatLong" scope="instance" type="String"/>
      <property name="searchSpan" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleVideoSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_aggregatedAttributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleNewsSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_aggregatedAttributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleBookSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_aggregatedAttributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.GoogleImageSearchStore" superclass="dojox.data.GoogleSearchStore">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.data.GoogleSearchStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_aggregatedAttributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.HtmlStore" superclass="dojo.data.util.simpleFetch">
    <description>The HtmlStore can be created in one of two ways: a) by parsing an existing
	table or list DOM node on the current page or b) by referencing an external url and giving
	the id of the table or list in that page.  The remote url will be parsed as an html page.
	The HTML table or list should be of the following form:
		&lt;table id="myTable"&gt;
			&lt;thead&gt;
				&lt;tr&gt;
					&lt;th&gt;Attribute1&lt;/th&gt;
					&lt;th&gt;Attribute2&lt;/th&gt;
				&lt;/tr&gt;
			&lt;/thead&gt;
			&lt;tbody&gt;
				&lt;tr&gt;
					&lt;td&gt;Value1.1&lt;/td&gt;
					&lt;td&gt;Value1.2&lt;/td&gt;
				&lt;/tr&gt;
				&lt;tr&gt;
					&lt;td&gt;Value2.1&lt;/td&gt;
					&lt;td&gt;Value2.2&lt;/td&gt;
				&lt;/tr&gt;
			&lt;/tbody&gt;
		&lt;/table&gt;
	-or-
		&lt;ul id="myUnorderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ul&gt;
	-or-
		&lt;ol id="myOrderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ol&gt;</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The HtmlStore can be created in one of two ways: a) by parsing an existing
	table or list DOM node on the current page or b) by referencing an external url and giving
	the id of the table or list in that page.  The remote url will be parsed as an html page.
	The HTML table or list should be of the following form:
		&lt;table id="myTable"&gt;
			&lt;thead&gt;
				&lt;tr&gt;
					&lt;th&gt;Attribute1&lt;/th&gt;
					&lt;th&gt;Attribute2&lt;/th&gt;
				&lt;/tr&gt;
			&lt;/thead&gt;
			&lt;tbody&gt;
				&lt;tr&gt;
					&lt;td&gt;Value1.1&lt;/td&gt;
					&lt;td&gt;Value1.2&lt;/td&gt;
				&lt;/tr&gt;
				&lt;tr&gt;
					&lt;td&gt;Value2.1&lt;/td&gt;
					&lt;td&gt;Value2.2&lt;/td&gt;
				&lt;/tr&gt;
			&lt;/tbody&gt;
		&lt;/table&gt;
	-or-
		&lt;ul id="myUnorderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ul&gt;
	-or-
		&lt;ol id="myOrderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ol&gt;</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>An anonymous object to initialize properties.  It expects the following values:</description>
          </parameter>
        </parameters>
      </method>
      <method name="_indexItems" scope="instance"/>
      <method name="_getHeadings" scope="instance"/>
      <method name="_getAllItems" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
        <return-description>Returns the index (column) that the attribute resides in the row.</return-description>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="int"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <description>If '_fetchUrl' is specified, it is used to load an XML document
	with a query string.
	Otherwise and if 'url' is specified, the XML document is
	loaded and list XML elements that match to a query (set of element
	names and their text attribute values that the items to contain).
	A wildcard, "*" can be used to query values to match all
	occurrences.
	If '_rootItem' is specified, it is used to fetch items.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_finishFetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <description>string The URL from which to load an HTML document for data loading</description>
      </property>
      <property name="dataId" scope="instance-prototype" type="The">
        <description>string The id in the document for an element from which to get the data.</description>
      </property>
      <property name="trimWhitespace" scope="instance-prototype" type="Trim">
        <description>off any surrounding whitespace from the headers (attribute
	names) and text content of the items in question.  Default is false for
	backwards compatibility.</description>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean">
        <description>Flag to denote if peventCache should be used on xhrGet calls.</description>
      </property>
      <property name="fetchOnCreate" scope="instance-prototype" type="boolean">
        <description>Flag to denote if it should try to load from a data id (nested in the page)
	The moment the store is created, instead of waiting for first
	fetch call.</description>
      </property>
      <property name="_rootNode" scope="instance" type="Object"/>
      <property name="_headings" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.data.HtmlTableStore" superclass="dojo.data.util.simpleFetch">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getHeadings" scope="instance"/>
      <method name="_getAllItems" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
        <return-description>Returns the index (column) that the attribute resides in the row.</return-description>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="int"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <description>If '_fetchUrl' is specified, it is used to load an XML document
	with a query string.
	Otherwise and if 'url' is specified, the XML document is
	loaded and list XML elements that match to a query (set of element
	names and their text attribute values that the items to contain).
	A wildcard, "*" can be used to query values to match all
	occurrences.
	If '_rootItem' is specified, it is used to fetch items.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_finishFetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="string">
        <description>The URL from which to load an HTML document for data loading</description>
      </property>
      <property name="tableId" scope="instance-prototype" type="string">
        <description>The id of the table to load as store contents.</description>
      </property>
      <property name="_headings" scope="instance" type="Array"/>
      <property name="_rootNode" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.ItemExplorer" superclass="dijit.Tree">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshItem" scope="instance"/>
      <method name="_createEditDialog" scope="instance">
        <return-types>
          <return-type type="isFocused"/>
          <return-type type="Object"/>
          <return-type type="this.store.getItemByIdentity(this._editDialog.attr(&quot;value&quot;)._reference)"/>
        </return-types>
      </method>
      <method name="_enableFields" scope="instance">
        <parameters>
          <parameter name="selection" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateItem" scope="instance">
        <parameters>
          <parameter name="vals" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_editProperty" scope="instance"/>
      <method name="_destroyProperty" scope="instance"/>
      <method name="_addProperty" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Tree" scope="instance"/>
    </mixins>
    <properties>
      <property name="useSelect" scope="instance" type="bool"/>
      <property name="refSelectSearchAttr" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="_modelNodeIdMap" scope="instance-prototype" type="Object"/>
      <property name="_modelNodePropMap" scope="instance-prototype" type="Object"/>
      <property name="_editDialog" scope="instance" type="Object"/>
      <property name="model" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.ItemExplorer.rootModelNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.JsonQueryRestStore" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="matchesQuery" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.util.JsonQuery.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonRestStore" scope="instance"/>
      <mixin type="dojox.data.util.JsonQuery" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.JsonRestStore" superclass="dojox.data.ServiceStore">
    <description>The JsonRestStore will cause all saved modifications to be sent to the server using Rest commands (PUT, POST, or DELETE).
	When using a Rest store on a public network, it is important to implement proper security measures to
	control access to resources.
	On the server side implementing a REST interface means providing GET, PUT, POST, and DELETE handlers.
	GET - Retrieve an object or array/result set, this can be by id (like /table/1) or with a
	query (like /table/?name=foo).
	PUT - This should modify a object, the URL will correspond to the id (like /table/1), and the body will
	provide the modified object
	POST - This should create a new object. The URL will correspond to the target store (like /table/)
	and the body should be the properties of the new object. The server's response should include a
	Location header that indicates the id of the newly created object. This id will be used for subsequent
	PUT and DELETE requests. JsonRestStore also includes a Content-Location header that indicates
	the temporary randomly generated id used by client, and this location is used for subsequent
	PUT/DELETEs if no Location header is provided by the server or if a modification is sent prior
	to receiving a response from the server.
	DELETE - This should delete an object by id.
	These articles include more detailed information on using the JsonRestStore:
	http://www.sitepen.com/blog/2008/06/13/restful-json-dojo-data/
	http://blog.medryx.org/2008/07/24/jsonreststore-overview/</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The JsonRestStore will cause all saved modifications to be sent to the server using Rest commands (PUT, POST, or DELETE).
	When using a Rest store on a public network, it is important to implement proper security measures to
	control access to resources.
	On the server side implementing a REST interface means providing GET, PUT, POST, and DELETE handlers.
	GET - Retrieve an object or array/result set, this can be by id (like /table/1) or with a
	query (like /table/?name=foo).
	PUT - This should modify a object, the URL will correspond to the id (like /table/1), and the body will
	provide the modified object
	POST - This should create a new object. The URL will correspond to the target store (like /table/)
	and the body should be the properties of the new object. The server's response should include a
	Location header that indicates the id of the newly created object. This id will be used for subsequent
	PUT and DELETE requests. JsonRestStore also includes a Content-Location header that indicates
	the temporary randomly generated id used by client, and this location is used for subsequent
	PUT/DELETEs if no Location header is provided by the server or if a modification is sent prior
	to receiving a response from the server.
	DELETE - This should delete an object by id.
	These articles include more detailed information on using the JsonRestStore:
	http://www.sitepen.com/blog/2008/06/13/restful-json-dojo-data/
	http://blog.medryx.org/2008/07/24/jsonreststore-overview/</description>
        <examples>
          <example>A JsonRestStore takes a REST service or a URL and uses it the remote communication for a
	read/write dojo.data implementation. A JsonRestStore can be created with a simple URL like:
		new JsonRestStore({target:"/MyData/"});</example>
          <example>To use a JsonRestStore with a service, you should create a
	service with a REST transport. This can be configured with an SMD:
		{
			services: {
				jsonRestStore: {
					transport: "REST",
					envelope: "URL",
					target: "store.php",
					contentType:"application/json",
					parameters: [
						{name: "location", type: "string", optional: true}
					]
				}
			}
		}
	The SMD can then be used to create service, and the service can be passed to a JsonRestStore. For example:
		var myServices = new dojox.rpc.Service(dojo.moduleUrl("dojox.rpc.tests.resources", "test.smd"));
		var jsonStore = new dojox.data.JsonRestStore({service:myServices.jsonRestStore});</example>
          <example>The JsonRestStore also supports lazy loading. References can be made to objects that have not been loaded.
	For example if a service returned:
		{"name":"Example","lazyLoadedObject":{"$ref":"obj2"}}
	And this object has accessed using the dojo.data API:
		var obj = jsonStore.getValue(myObject,"lazyLoadedObject");
	The object would automatically be requested from the server (with an object id of "obj2").</example>
        </examples>
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <description>arguments
	The *schema* parameter
	This is a schema object for this store. This should be JSON Schema format.
	The *service* parameter
	This is the service object that is used to retrieve lazy data and save results
	The function should be directly callable with a single parameter of an object id to be loaded
	The function should also have the following methods:
	put(id,value) - puts the value at the given id
	post(id,value) - posts (appends) the value at the given id
	delete(id) - deletes the value corresponding to the given id
	Note that it is critical that the service parses responses as JSON.
	If you are using dojox.rpc.Service, the easiest way to make sure this
	happens is to make the responses have a content type of
	application/json. If you are creating your own service, make sure you
	use handleAs: &amp;quot;json&amp;quot; with your XHR requests.
	The *target* parameter
	This is the target URL for this Service store. This may be used in place
	of a service parameter to connect directly to RESTful URL without
	using a dojox.rpc.Service object.
	The *idAttribute* parameter
	Defaults to 'id'. The name of the attribute that holds an objects id.
	This can be a preexisting id provided by the server.
	If an ID isn't already provided when an object
	is fetched or added to the store, the autoIdentity system
	will generate an id for it and add it to the index.
	The *syncMode* parameter
	Setting this to true will set the store to using synchronous calls by default.
	Sync calls return their data immediately from the calling function, so
	callbacks are unnecessary</description>
          </parameter>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <parameters>
          <parameter name="data" type="object" usage="required">
            <description>The data to be added in as an item.</description>
          </parameter>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>to delete</description>
          </parameter>
        </parameters>
      </method>
      <method name="changing" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="_deleting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>The value to test for being an item</description>
          </parameter>
          <parameter name="anyStore" type="boolean" usage="required">
            <description>If true, this will return true if the value is an item for any JsonRestStore,
	not just this instance</description>
          </parameter>
        </parameters>
      </method>
      <method name="_doQuery" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="don't change anything, and deal with the stupid post-commit lint complaints"/>
        </return-types>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="deferred" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getConstructor" scope="instance"/>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="instance"/>
      <method name="onNew" scope="instance"/>
      <method name="onDelete" scope="instance"/>
      <method name="getFeatures" scope="instance"/>
      <method name="getParent" scope="instance">
        <parameters>
          <parameter name="item" type="The" usage="required">
            <description>item to find the parent of</description>
          </parameter>
        </parameters>
      </method>
      <method name="_constructor" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStore" scope="instance">
        <parameters>
          <parameter name="options" type="See" usage="required">
            <description>the JsonRestStore constructor</description>
          </parameter>
          <parameter name="Class" type="Constructor" usage="required">
            <description>to use (for creating stores from JsonRestStore subclasses).
	This is optional and defaults to JsonRestStore.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.ServiceStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="loadReferencedSchema" scope="instance" type="Object"/>
      <property name="idAsRef" scope="instance" type="bool"/>
      <property name="referenceIntegrity" scope="instance" type="Object"/>
      <property name="target" scope="instance" type="String"/>
      <property name="allowNoTrailingSlash" scope="instance" type="bool"/>
      <property name="serverVersion" scope="instance" type="Object"/>
      <property name="idAttribute" scope="instance" type="String"/>
      <property name="_index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.JsonRestStore.service">
    <properties>
      <property name="_schema" scope="instance" type="Object"/>
      <property name="_store" scope="instance" type="Object"/>
      <property name="idAsRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.JsonRestStore.schema">
    <properties>
      <property name="_idAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.json.ref">
    <methods>
      <method name="fromJson" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>a string literal of a JSON item, for instance:
	'{ &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 1, { &amp;quot;baz&amp;quot;: &amp;quot;thud&amp;quot; } ] }'</description>
          </parameter>
          <parameter name="args" type="Object" usage="optional">
            <description>See resolveJson
	return:
	An object, the result of the evaluation</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addProp" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_useRefs" scope="instance" type="bool"/>
      <property name="serializeFunctions" scope="instance" type="bool"/>
      <property name="refAttribute" scope="instance" type="String">
        <description>This indicates what property is the reference property. This acts like the idAttribute
	except that this is used to indicate the current object is a reference or only partially
	loaded. This defaults to &amp;quot;$ref&amp;quot;.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.data.KeyValueStore" superclass="dojo.data.util.simpleFetch">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>dataVar: jsonObject}</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <description>The KeyValueStore always loads all items, so if it's an item, then it's loaded.
	From the dojo.data.api.Read.loadItem docs:
	If a call to isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke
	the callback handlers.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="_processData" scope="instance">
        <parameters>
          <parameter name="data" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_createItem" scope="instance">
        <parameters>
          <parameter name="something" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_finishFetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="request" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="data" scope="instance" type="String"/>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean">
        <description>Controls if urlPreventCache should be used with underlying xhrGet.</description>
      </property>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_keyValueString" scope="instance-prototype" type="Object"/>
      <property name="_keyValueVar" scope="instance-prototype" type="Object"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance" type="Array"/>
      <property name="_loadFinished" scope="instance" type="Object"/>
      <property name="_keyAttribute" scope="instance" type="String"/>
      <property name="_valueAttribute" scope="instance" type="String"/>
      <property name="_storeProp" scope="instance" type="String"/>
      <property name="_features" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.OpenSearchStore" superclass="dojo.data.util.simpleFetch">
    <description>The OpenSearchStore is a Datastore interface to any search
	engine that implements the open search specifications.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The OpenSearchStore is a Datastore interface to any search
	engine that implements the open search specifications.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="process" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createSearchUrl" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_processOSDxml" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemxml" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDatom" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItematom" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDrss" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemrss" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDfeed" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemfeed" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getNodeXml" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="skipFirst" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processOsdd" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="itemPath" scope="instance-prototype" type="String"/>
      <property name="_storeRef" scope="instance" type="String"/>
      <property name="iframeElement" scope="instance" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean">
        <description>Flag denoting if xhrGet calls should use the preventCache option.</description>
      </property>
      <property name="ATOM_CONTENT_TYPE" scope="instance" type="Number"/>
      <property name="ATOM_CONTENT_TYPE_STRING" scope="instance" type="String"/>
      <property name="RSS_CONTENT_TYPE" scope="instance" type="Number"/>
      <property name="RSS_CONTENT_TYPE_STRING" scope="instance" type="String"/>
      <property name="XML_CONTENT_TYPE" scope="instance" type="Number"/>
      <property name="XML_CONTENT_TYPE_STRING" scope="instance" type="String"/>
      <property name="contentType" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.OpenSearchStore.urlElement">
    <properties>
      <property name="attributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.OpmlStore" superclass="dojo.data.util.simpleFetch">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <description>url: String, label: String}  Where label is optional and configures what should be used as the return from getLabel()</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="item" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_removeChildNodesThatAreNotElementNodes" scope="instance">
        <parameters>
          <parameter name="node" type="node" usage="required"/>
          <parameter name="recursive" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_processRawXmlTree" scope="instance">
        <parameters>
          <parameter name="rawXmlTree" type="xmlDoc" usage="required"/>
        </parameters>
      </method>
      <method name="_checkChildNodes" scope="instance">
        <description>Internal function to recurse over all child nodes from the store and add them
	As non-toplevel items</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The child node to walk.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getItemsArray" scope="instance">
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional">
            <description>The query options parameter, if any.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <description>|| attribute-name-string</description>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_containsValue" scope="instance">
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The data item to examine for attribute values.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>The attribute to inspect.</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>The value to match.</description>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <description>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <description>Four things are verified to ensure that "something" is an item:
	something can not be null, the nodeType must be an XML Element,
	the tagName must be "outline", and the node must be a member of
	XML document for this datastore.</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <description>The OpmlStore always loads all items, so if it's an item, then it's loaded.
	From the dojo.data.api.Read.loadItem docs:
	If a call to isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke the callback handlers.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="instance"/>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="label" scope="instance-prototype" type="string">
        <description>The attribute of the Opml item to act as a label.</description>
      </property>
      <property name="url" scope="instance-prototype" type="string">
        <description>The location from which to fetch the Opml document.</description>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean">
        <description>Flag to denote if the underlying xhrGet call should set preventCache.</description>
      </property>
      <property name="_loadFinished" scope="instance-prototype" type="bool"/>
      <property name="_xmlData" scope="instance-prototype" type="Object"/>
      <property name="_metadataNodes" scope="instance-prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_opmlData" scope="instance-prototype" type="Object"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfTopLevelItems" scope="instance" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance" type="Array"/>
      <property name="_identityMap" scope="instance" type="Object"/>
      <property name="_identCount" scope="instance" type="Number"/>
      <property name="_idProp" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.PersevereStore" superclass="dojox.data.JsonQueryRestStore">
    <methods>
      <method name="getStores" scope="instance">
        <parameters>
          <parameter name="path" type="String" usage="optional">
            <description>URL of the Persevere server's root, this normally just &amp;quot;/&amp;quot;
	which is the default value if the target is not provided</description>
          </parameter>
          <parameter name="sync" type="Boolean" usage="optional">
            <description>Indicates that the operation should happen synchronously.
	return:
	A map/object of datastores will be returned if it is performed asynchronously,
	otherwise it will return a Deferred object that will provide the map/object.
	The name of each property is a the name of a store,
	and the value is the actual data store object.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addProxy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonQueryRestStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="useFullIdInQueries" scope="instance" type="Object"/>
      <property name="jsonQueryPagination" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.rpc">
    <methods>
      <method name="getTarget" scope="instance">
        <parameters>
          <parameter name="smd" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toOrdered" scope="instance">
        <parameters>
          <parameter name="parameters" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_sync" scope="instance" type="Object"/>
      <property name="JsonRPC" scope="instance" type="Object"/>
      <property name="ProxiedPath" scope="instance" type="Object"/>
      <property name="transportRegistry" scope="instance" type="Object"/>
      <property name="envelopeRegistry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.PicasaStore" superclass="dojo.data.util.simpleFetch">
    <description>The PicasaStore is a Datastore interface to one of the basic services
	of the Picasa service, the public photo feed.  This does not provide
	access to all the services of Picasa.
	This store cannot do * and ? filtering as the picasa service
	provides no interface for wildcards.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>The PicasaStore is a Datastore interface to one of the basic services
	of the Picasa service, the public photo feed.  This does not provide
	access to all the services of Picasa.
	This store cannot do * and ? filtering as the picasa service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_processPicasaData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHtml" scope="instance">
        <description>Utility function to un-escape XML special characters in an HTML string.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>The string to un-escape</description>
          </parameter>
        </parameters>
        <return-description>HTML String converted back to the normal text (unescaped) characters (&lt;,&gt;,&amp;, ", etc,).
	TODO: Check to see if theres already compatible escape() in dojo.string or dojo.html</return-description>
      </method>
    </methods>
    <properties>
      <property name="_picasaUrl" scope="instance" type="String"/>
      <property name="_storeRef" scope="instance" type="String"/>
      <property name="label" scope="instance-prototype" type="string">
        <description>The attribute to use from the picasa item as its label.</description>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean">
        <description>Flag denoting if preventCache should be passed to dojo.io.script.</description>
      </property>
      <property name="maxResults" scope="instance-prototype" type="Define">
        <description>out how many results to return for a fetch.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.data.QueryReadStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_xhrFetchHandler" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="fetchHandler" type="Object" usage="required"/>
          <parameter name="errorHandler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_filterResponse" scope="instance">
        <parameters>
          <parameter name="data" type="The" usage="required">
            <description>data received from server</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance" type="String"/>
      <property name="requestMethod" scope="instance" type="String"/>
      <property name="_className" scope="instance" type="String"/>
      <property name="_items" scope="instance" type="Array"/>
      <property name="_lastServerQuery" scope="instance" type="Object"/>
      <property name="_numRows" scope="instance" type="Number"/>
      <property name="lastRequestHash" scope="instance" type="String"/>
      <property name="doClientPaging" scope="instance" type="bool"/>
      <property name="doClientSorting" scope="instance" type="bool"/>
      <property name="_itemsByIdentity" scope="instance" type="Object"/>
      <property name="_identifier" scope="instance" type="Object"/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_labelAttr" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.QueryReadStore._features.dojo.data.api">
    <properties>
      <property name="Read" scope="instance" type="Object"/>
      <property name="Identity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.RailsStore" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="deferred" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonRestStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="rootAttribute" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.data.S3Store" superclass="dojox.data.JsonRestStore">
    <methods>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.JsonRestStore" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.data.ServiceStore">
    <description>ServiceStore can do client side caching and result set updating if
	dojox.data.ClientFilter is loaded. Do this add:
		dojo.require("dojox.data.ClientFilter")
	prior to loading the ServiceStore (ClientFilter must be loaded before ServiceStore).
	To utilize client side filtering with a subclass, you can break queries into
	client side and server side components by putting client side actions in
	clientFilter property in fetch calls. For example you could override fetch:
		fetch: function(args){
			// do the sorting and paging on the client side
			args.clientFilter = {start:args.start, count: args.count, sort: args.sort};
			// args.query will be passed to the service object for the server side handling
			return this.inherited(arguments);
		}
	When extending this class, if you would like to create lazy objects, you can follow
	the example from dojox.data.tests.stores.ServiceStore:
		var lazyItem = {
			_loadObject: function(callback){
				this.name="loaded";
				delete this._loadObject;
				callback(this);
			}
		};
	setup a byId alias to the api call</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>ServiceStore can do client side caching and result set updating if
	dojox.data.ClientFilter is loaded. Do this add:
		dojo.require("dojox.data.ClientFilter")
	prior to loading the ServiceStore (ClientFilter must be loaded before ServiceStore).
	To utilize client side filtering with a subclass, you can break queries into
	client side and server side components by putting client side actions in
	clientFilter property in fetch calls. For example you could override fetch:
		fetch: function(args){
			// do the sorting and paging on the client side
			args.clientFilter = {start:args.start, count: args.count, sort: args.sort};
			// args.query will be passed to the service object for the server side handling
			return this.inherited(arguments);
		}
	When extending this class, if you would like to create lazy objects, you can follow
	the example from dojox.data.tests.stores.ServiceStore:
		var lazyItem = {
			_loadObject: function(callback){
				this.name="loaded";
				delete this._loadObject;
				callback(this);
			}
		};
	setup a byId alias to the api call</description>
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <description>arguments
	The *schema* parameter
	This is a schema object for this store. This should be JSON Schema format.
	The *service* parameter
	This is the service object that is used to retrieve lazy data and save results
	The function should be directly callable with a single parameter of an object id to be loaded
	The *idAttribute* parameter
	Defaults to 'id'. The name of the attribute that holds an objects id.
	This can be a preexisting id provided by the server.
	If an ID isn't already provided when an object
	is fetched or added to the store, the autoIdentity system
	will generate an id for it and add it to the index.
	The *estimateCountFactor* parameter
	This parameter is used by the ServiceStore to estimate the total count. When
	paging is indicated in a fetch and the response includes the full number of items
	requested by the fetch's count parameter, then the total count will be estimated
	to be estimateCountFactor multiplied by the provided count. If this is 1, then it is assumed that the server
	does not support paging, and the response is the full set of items, where the
	total count is equal to the numer of items returned. If the server does support
	paging, an estimateCountFactor of 2 is a good value for estimating the total count
	It is also possible to override _processResults if the server can provide an exact
	total count.
	The *syncMode* parameter
	Setting this to true will set the store to using synchronous calls by default.
	Sync calls return their data immediately from the calling function, so
	callbacks are unnecessary. This will only work with a synchronous capable service.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getSchema" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <description>The item to get the value from</description>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <description>property to look up value for</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>the default value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="return the plain value since it was found"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="property" type="string" usage="required">
            <description>property to look up value for</description>
          </parameter>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required">
            <description>attribute: /* string</description>
          </parameter>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="instance">
        <examples>
          <example>store.loadItem({
	item: item, // this item may or may not be loaded
	onItem: function(item){
	// do something with the item
	}
	});</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="deferred" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doQuery" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="service" scope="instance" type="Object"/>
      <property name="schema" scope="instance" type="Object"/>
      <property name="idAttribute" scope="instance-prototype" type="Object"/>
      <property name="labelAttribute" scope="instance" type="String"/>
      <property name="syncMode" scope="instance" type="bool"/>
      <property name="estimateCountFactor" scope="instance" type="Number"/>
      <property name="loadLazyValues" scope="instance" type="Object"/>
      <property name="_currentId" scope="instance" type="Number"/>
      <property name="byId" scope="instance" type="Object"/>
      <property name="_index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.SnapLogicStore">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>An object that contains properties for initializing the new data store object. The
	following properties are understood:</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="instance">
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <description>The attribute to test for being contained by the store.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="defaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchHandler" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_partHandler" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>The request/handle object used with the original fetch() call.</description>
          </parameter>
          <parameter name="part" type="String" usage="required">
            <description>A value indicating which request this handler call is for (this.Parts).</description>
          </parameter>
          <parameter name="response" type="Object" usage="required">
            <description>Response received from the underlying IO transport.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>See dojo.data.api.Read.close() for generic interface.
	In addition to the standard Read API fetch support, this store supports an optimization for
	for retrieving the total count of records in the Pipeline without retrieving the data. To
	use this optimization, simply provide an onBegin handler without an onItem or onComplete handler.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="A">
        <description>URL to the SnapLogic pipeline's output routed through PipeToHttp. Typically, this
	will look like &amp;quot;http://&amp;lt;server-host&amp;gt;:&amp;lt;port&amp;gt;/pipe/&amp;lt;pipeline-url&amp;gt;/&amp;lt;pipeline-output-view&amp;gt;&amp;quot;.
	parameters:
	An object whose properties define parameters to the pipeline. The values of these
	properties will be sent to the pipeline as parameters when it run.</description>
      </property>
      <property name="_parameters" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.SnapLogicStore.Parts">
    <properties>
      <property name="DATA" scope="instance" type="String"/>
      <property name="COUNT" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.StoreExplorer" superclass="dijit.layout.BorderContainer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="setItemName" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setQuery" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_formatCell" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createNew" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.BorderContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="columnWidth" scope="instance" type="String"/>
      <property name="stringQueries" scope="instance" type="bool"/>
      <property name="showAllColumns" scope="instance" type="bool"/>
      <property name="tree" scope="instance" type="Object"/>
      <property name="gridOnFetchComplete" scope="instance" type="Object"/>
      <property name="queryOptions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.StoreExplorer.grid._pending_requests">
    <properties>
      <property name="0" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.data.StoreExplorer.grid">
    <methods>
      <method name="_onFetchComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.WikipediaStore" superclass="dojox.data.ServiceStore">
    <description>The WikipediaStore is a data store interface to Wikipedia, using the
	Wikipedia SMD spec from dojox.rpc. It currently is useful only for
	finding articles that contain some particular text or grabbing single
	articles by full name; no wildcards or other filtering are supported.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <examples>
          <example>Loading a page:
		store.fetch({
			query: {title:"Dojo Toolkit"},
			// define your handlers here
		});</example>
          <example>Searching for pages containing "dojo":
		store.fetch({
			query: {
				action: "query",
				text: "dojo"
			},
			// define your handlers here
		});</example>
          <example>Searching for the next 50 pages containing "dojo":
		store.fetch({
			query: {
				action: "query",
				text: "dojo",
				start: 10,
				count: 50 // max 500; will be capped if necessary
			},
			// define your handlers here
		});</example>
        </examples>
        <parameters>
          <parameter name="request" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="def" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.data.ServiceStore" scope="instance"/>
    </mixins>
    <properties>
      <property name="service" scope="instance" type="Object"/>
      <property name="idAttribute" scope="instance" type="String"/>
      <property name="labelAttribute" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.data.XmlStore" superclass="dojo.data.util.simpleFetch">
    <description>A data store for XML based services or documents</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="object" usage="required">
            <description>An anonymous object to initialize properties.  It expects the following values:</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", the tag name of the element is
	returned.
	If 'attribute' specifies "childNodes", the first element child is
	returned.
	If 'attribute' specifies "text()", the value of the first text
	child is returned.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the value of the XML
	attribute is returned.
	Otherwise, the first child element of the tag name specified with
	'attribute' is returned.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <description>A default value</description>
          </parameter>
        </parameters>
        <return-description>An attribute value found, otherwise 'defaultValue'</return-description>
        <return-types>
          <return-type type="object"/>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getValues" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", the tag name of the element is
	returned.
	If 'attribute' specifies "childNodes", child elements are returned.
	If 'attribute' specifies "text()", the values of child text nodes
	are returned.
	For generic attributes, if 'attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the value of the XML
	attribute is returned.
	Otherwise, child elements of the tag name specified with
	'attribute' are returned.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of child elements, An XML attribute name or one of
	special names</description>
          </parameter>
        </parameters>
        <return-description>An array of attribute values found, otherwise an empty array</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	tag names of child elements and XML attribute names of attributes
	specified to the element are returned along with special attribute
	names applicable to the element including "tagName", "childNodes"
	if the element has child elements, "text()" if the element has
	child text nodes, and attribute names in '_attributeMap' that match
	the tag name of the element.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element</description>
          </parameter>
        </parameters>
        <return-description>An array of attributes found</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
        </parameters>
        <return-description>True if the element has the attribute, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the attribute values contain the value, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="instance">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>containing the args for loadItem.  See dojo.data.api.Read.loadItem()</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="instance">
        <return-description>"dojo.data.api.Read" and "dojo.data.api.Write"</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getLabel" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="instance">
        <description>If 'sendQuery' is true, an XML document is loaded from
	'url' with a query string.
	Otherwise, an XML document is loaded and list XML elements that
	match to a query (set of element names and their text attribute
	values that the items to contain).
	A wildcard, "*" can be used to query values to match all
	occurrences.
	If 'rootItem' is specified, it is used to fetch items.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <description>function to call for fetched items</description>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <description>function to call on error</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getFetchUrl" scope="instance">
        <description>This default implementation generates a query string in the form of
	"?name1=value1&amp;name2=value2..." off properties of 'query' object
	specified in 'request' and appends it to 'url', if 'sendQuery'
	is set to false.
	Otherwise, 'url' is returned as is.
	Sub-classes may override this method for the custom URL generation.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
        </parameters>
        <return-description>A fetch URL</return-description>
      </method>
      <method name="_getItems" scope="instance">
        <description>This default implementation walks through child elements of
	the document element to see if all properties of 'query' object
	match corresponding attributes of the element (item).
	If 'request' is not specified, all child elements are returned.
	Sub-classes may override this method for the custom search in
	an XML document.</description>
        <parameters>
          <parameter name="document" type="An" usage="required">
            <description>XML document</description>
          </parameter>
          <parameter name="request" type="A" usage="required">
            <description>request object</description>
          </parameter>
        </parameters>
        <return-description>An array of items</return-description>
      </method>
      <method name="_flattenNodes" scope="instance">
        <parameters>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <description>|| keywordArgs || null</description>
          </parameter>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <description>At least, 'keywordArgs' must contain "tagName" to be used for
	the new	element.
	Other attributes in 'keywordArgs' are set to the new element,
	including "text()", but excluding "childNodes".</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="optional">
            <description>An object containing initial attributes</description>
          </parameter>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
        <return-description>An XML element</return-description>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element to delete</description>
          </parameter>
        </parameters>
        <return-description>True</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", nothing is set and false is
	returned.
	If 'attribute' specifies "childNodes", the value (XML element) is
	added to the element.
	If 'attribute' specifies "text()", a text node is created with
	the value and set it to the element as a child.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the value is set to the XML
	attribute.
	Otherwise, a text node is created with the value and set it to
	the first child element of the tag name specified with 'attribute'.
	If the child element does not exist, it is created.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of a child element, An XML attribute name or one of
	special names</description>
          </parameter>
          <parameter name="value" type="almost" usage="required">
            <description>A attribute value to set</description>
          </parameter>
        </parameters>
        <return-description>False for "tagName", otherwise true</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", nothing is set and false is
	returned.
	If 'attribute' specifies "childNodes", the value (array of XML
	elements) is set to the element's childNodes.
	If 'attribute' specifies "text()", a text node is created with
	the values and set it to the element as a child.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the first value is set to
	the XML attribute.
	Otherwise, child elements of the tag name specified with
	'attribute' are replaced with new child elements and their
	child text nodes of values.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of child elements, an XML attribute name or one of
	special names
	value:
	A attribute value to set
	notify:
	A non-API optional argument, used to indicate if notification API should be called
	or not.</description>
          </parameter>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-description>False for "tagName", otherwise true</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="instance">
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	'attribute' can be an XML attribute name of the element or one of
	special names described below.
	If 'attribute' specifies "tagName", nothing is removed and false is
	returned.
	If 'attribute' specifies "childNodes" or "text()", all child nodes
	are removed.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the XML attribute is removed.
	Otherwise, child elements of the tag name specified with
	'attribute' are removed.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>An XML element that holds the attribute</description>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <description>A tag name of child elements, an XML attribute name or one of
	special names</description>
          </parameter>
        </parameters>
        <return-description>False for "tagName", otherwise true</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <description>'url' is used to save XML documents for new, modified and/or
	deleted XML elements.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <description>An object for callbacks</description>
          </parameter>
        </parameters>
      </method>
      <method name="revert" scope="instance">
        <return-description>True</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="instance">
        <description>If 'item' is specified, true is returned if the item is new,
	modified or deleted.
	Otherwise, true is returned if there are any new, modified
	or deleted items.</description>
        <parameters>
          <parameter name="item" type="item" usage="optional">
            <description>An item (XML element) to check</description>
          </parameter>
        </parameters>
        <return-description>True if an item or items are new, modified or deleted, otherwise
	false</return-description>
      </method>
      <method name="_saveItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPostUrl" scope="instance">
        <description>This default implementation just returns 'url'.
	Sub-classes may override this method for the custom URL.</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to save</description>
          </parameter>
        </parameters>
        <return-description>A post URL</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getPutUrl" scope="instance">
        <description>This default implementation just returns 'url'.
	Sub-classes may override this method for the custom URL.</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to save</description>
          </parameter>
        </parameters>
        <return-description>A put URL</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getDeleteUrl" scope="instance">
        <description>This default implementation returns 'url' with 'keyAttribute'
	as a query string.
	Sub-classes may override this method for the custom URL based on
	changes (new, deleted, or modified).</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to delete</description>
          </parameter>
        </parameters>
        <return-description>A delete URL</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getPostContent" scope="instance">
        <description>This default implementation generates an XML document for one
	(the first only) new or modified element.
	Sub-classes may override this method for the custom post content
	generation.</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to save</description>
          </parameter>
        </parameters>
        <return-description>A post content</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getPutContent" scope="instance">
        <description>This default implementation generates an XML document for one
	(the first only) new or modified element.
	Sub-classes may override this method for the custom put content
	generation.</description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <description>item to save</description>
          </parameter>
        </parameters>
        <return-description>A post content</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getAttribute" scope="instance">
        <parameters>
          <parameter name="tagName" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getItem" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getItemIndex" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="_backupItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="new or already modified"/>
        </return-types>
      </method>
      <method name="_restoreItems" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_forgetItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getDocument" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_getRootElement" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMElement"/>
        </return-types>
      </method>
      <method name="_getXPath" scope="instance">
        <description>A function to compute the xpath of a node in a DOM document.  Used for
	Client side query handling and identity.</description>
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The XML Item from the store from which to obtain its identifier.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="instance">
        <description>For XmlStore, if sendQuery is false and no keyAttribute was set, then this function
	returns null, as xpath is used for the identity, which is not a public attribute of
	the item.  If sendQuery is true and keyAttribute is set, then this function
	returns an array of one attribute name: keyAttribute.   This means the server side
	implementation must apply a keyAttribute to a returned node that always allows
	it to be looked up again.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <description>The item from the store from which to obtain the array of public attributes that
	compose the identifier, if any.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="instance">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <description>url to a service or an XML document that represents the store</description>
      </property>
      <property name="rootItem" scope="instance-prototype" type="A">
        <description>tag name for root items</description>
      </property>
      <property name="keyAttribute" scope="instance-prototype" type="An">
        <description>attribute name for a key or an identity (unique identifier)
	Required for serverside fetchByIdentity, etc.  Not required for
	client side fetchItemBIdentity, as it will use an XPath-like
	structure if keyAttribute was not specified.  Recommended to always
	set this, though, for consistent identity behavior.
	attributeMap:   An anonymous object contains properties for attribute mapping,
	{&amp;quot;tag_name.item_attribute_name&amp;quot;: &amp;quot;@xml_attribute_name&amp;quot;, ...}</description>
      </property>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="sendQuery" scope="instance-prototype" type="A">
        <description>boolean indicate to add a query string to the service URL.
	Default is false.</description>
      </property>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="Parameter">
        <description>to indicate whether or not URL calls should apply
	the preventCache option to the xhr request.</description>
      </property>
      <property name="_newItems" scope="instance-prototype" type="Array"/>
      <property name="_deletedItems" scope="instance-prototype" type="Array"/>
      <property name="_modifiedItems" scope="instance-prototype" type="Array"/>
      <property name="_attributeMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.XmlItem">
    <description>This class represents an item of 'XmlStore' holding an XML element.
	'element'
	element:
	An XML element</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="element" type="An" usage="required">
            <description>XML element</description>
          </parameter>
          <parameter name="store" type="The" usage="required">
            <description>containing store, if any.</description>
          </parameter>
          <parameter name="query" type="The" usage="required">
            <description>query to use to look up a specific element.
	Usually an XPath or dojo.query statement.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <return-description>a value of the first text child of the element</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="element" scope="instance" type="An">
        <description>XML element</description>
      </property>
      <property name="store" scope="instance" type="The">
        <description>containing store, if any.
	query:
	The query to use to look up a specific element.
	Usually an XPath or dojo.query statement.</description>
      </property>
      <property name="q" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.css">
    <methods>
      <method name="findStyleSheets" scope="instance">
        <parameters>
          <parameter name="sheets" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findStyleSheet" scope="instance">
        <parameters>
          <parameter name="sheet" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array&lt;IE stylesheet has imports&gt; containing @import'ed rules"/>
        </return-types>
      </method>
      <method name="determineContext" scope="instance">
        <parameters>
          <parameter name="initialStylesheets" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.css.rules">
    <methods>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="Object" usage="required"/>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.data.dom">
    <methods>
      <method name="createDocument" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="optional">
            <description>Optional text to create the document from.  If not provided, an empty XML document will be created.
	If str is empty string &amp;quot;&amp;quot;, then a new empty document will be created.</description>
          </parameter>
          <parameter name="mimetype" type="string" usage="optional">
            <description>Optional mimetype of the text.  Typically, this is text/xml.  Will be defaulted to text/xml if not provided.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
        </return-types>
      </method>
      <method name="textContent" scope="instance">
        <description>Implementation of the DOM Level 3 attribute; scan node for text
	This function can also update the text of a node by replacing all child
	content of the node.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The node to get the text off of or set the text on.</description>
          </parameter>
          <parameter name="text" type="string" usage="optional">
            <description>Optional argument of the text to apply to the node.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="replaceChildren" scope="instance">
        <description>Removes all children of node and appends newChild. All the existing
	children will be destroyed.</description>
        <parameters>
          <parameter name="node" type="Element" usage="required">
            <description>The node to modify the children on</description>
          </parameter>
          <parameter name="newChildren" type="Node" usage="required">
            <description>The children to add to the node.  It can either be a single Node or an
	array of Nodes.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeChildren" scope="instance">
        <parameters>
          <parameter name="node" type="Element" usage="required">
            <description>The node to remove all the children from.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="innerXML" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The node from which to generate the XML text representation.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
          <return-type type="Object"/>
          <return-type type="null"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.rpc.Rest">
    <methods>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="server error, let the error propagate"/>
        </return-types>
      </method>
      <method name="_change" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="serializedContent" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.data.util"/>
  <class type="dojox.data.util.JsonQuery">
    <methods>
      <method name="_toJsonQuery" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="jsonQueryPagination" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isUpdateable" scope="instance"/>
      <method name="matchesQuery" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clientSideFetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="baseResults" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="querySuperSet" scope="instance">
        <parameters>
          <parameter name="argsSuper" type="Object" usage="required"/>
          <parameter name="argsSub" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="useFullIdInQueries" scope="instance" type="bool"/>
      <property name="jsonQueryPagination" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.buddhist">
    <methods>
      <method name="getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="dateObject" type="buddhist.Date" usage="required"/>
        </parameters>
      </method>
      <method name="isLeapYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="buddhist.Date" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="date1" type="buddhist.Date" usage="required"/>
          <parameter name="date2" type="buddhist.Date" usage="required"/>
          <parameter name="portion" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="FIXME"/>
        </return-types>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="date" type="dojox.date.buddhist.Date" usage="required">
            <description>buddhist.Date Date object to start with</description>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</description>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <description>How much to add to the date.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.date.buddhist.Date"/>
        </return-types>
      </method>
      <method name="difference" scope="instance">
        <parameters>
          <parameter name="date1" type="dojox.date.buddhist.Date" usage="required"/>
          <parameter name="date2" type="dojox.date.buddhist.Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;,  &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.date.buddhist.Date">
    <description>This fucntion initialize the date object values</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>This fucntion initialize the date object values</description>
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			var date2 = new dojox.date.buddhist.Date(date1);
			var date3 = new dojox.date.buddhist.Date(2552,2,12);</example>
        </examples>
      </method>
      <method name="getDate" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			console.log(date1.getDate());</example>
        </examples>
        <parameters>
          <parameter name="isNumber" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="getMonth" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			console.log(date1.getMonth()+1);</example>
        </examples>
      </method>
      <method name="getFullYear" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			console.log(date1.getFullYear());</example>
        </examples>
      </method>
      <method name="getHours" scope="instance"/>
      <method name="getMinutes" scope="instance"/>
      <method name="getSeconds" scope="instance"/>
      <method name="getMilliseconds" scope="instance"/>
      <method name="setDate" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			date1.setDate(2);</example>
        </examples>
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setFullYear" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			date1.setFullYear(2552);
			date1.setFullYear(2552, 1, 1);</example>
        </examples>
        <parameters>
          <parameter name="year" type="number" usage="required"/>
          <parameter name="month" type="number" usage="optional"/>
          <parameter name="date" type="number" usage="optional"/>
        </parameters>
      </method>
      <method name="setMonth" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			date1.setMonth(0); //first month</example>
        </examples>
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="instance"/>
      <method name="setMinutes" scope="instance">
        <parameters>
          <parameter name="minutes" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setSeconds" scope="instance">
        <parameters>
          <parameter name="seconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="instance">
        <parameters>
          <parameter name="milliseconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="month" type="number" usage="required"/>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="fromGregorian" scope="instance">
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="toGregorian" scope="instance">
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="getDay" scope="instance">
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="valueOf" scope="instance"/>
    </methods>
    <properties>
      <property name="_date" scope="instance-prototype" type="Object"/>
      <property name="_month" scope="instance-prototype" type="Number"/>
      <property name="_year" scope="instance-prototype" type="Number"/>
      <property name="_hours" scope="instance-prototype" type="Object"/>
      <property name="_minutes" scope="instance-prototype" type="Object"/>
      <property name="_seconds" scope="instance-prototype" type="Object"/>
      <property name="_milliseconds" scope="instance-prototype" type="Object"/>
      <property name="_day" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date"/>
  <class type="dojox.date.buddhist.locale">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="dateObject" type="buddhist.Date" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="instance">
        <parameters>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="oblect" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="addCustomFormats" scope="instance">
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getBuddhistBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNames" scope="instance">
        <parameters>
          <parameter name="item" type="String" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="date" type="buddhist" usage="required">
            <description>Date Object?</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.hebrew">
    <methods>
      <method name="getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="month" type="hebrew.Date" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="instance">
        <description>Returns 0 if equal, positive if a &gt; b, else negative.
	date1:
	hebrew.Date object
	date2:
	hebrew.Date object.  If not specified, the current hebrew.Date is used.</description>
        <parameters>
          <parameter name="dateheb1" type="hebrew.Date" usage="required"/>
          <parameter name="dateheb2" type="hebrew.Date" usage="required"/>
          <parameter name="portion" type="String" usage="optional">
            <description>A string indicating the &amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; portion of a Date object.
	Compares both &amp;quot;date&amp;quot; and &amp;quot;time&amp;quot; by default.  One of the following:
	&amp;quot;date&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;datetime&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="date" type="dojox.date.hebrew.Date" usage="required">
            <description>hebrew.Date Date object to start with</description>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</description>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <description>How much to add to the date.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.date.hebrew.Date"/>
        </return-types>
      </method>
      <method name="difference" scope="instance">
        <parameters>
          <parameter name="date1" type="dojox.date.hebrew.Date" usage="required"/>
          <parameter name="date2" type="dojox.date.hebrew.Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;,  &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.date.hebrew.Date">
    <description>A Date-like object which implements the Hebrew Calendar.  Because this object
	implements many of the same methods as the native JavaScript Date object, which
	implements the Gregorian calendar, it can often be used its place.  Note that
	this object does not extend Date or use its prototype.</description>
    <methods>
      <method name="constructor" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			var date2 = new dojox.date.hebrew.Date(date1);
			var date3 = new dojox.date.hebrew.Date(5768,2,12);</example>
        </examples>
      </method>
      <method name="getDate" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			console.log(date1.getDate());</example>
        </examples>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getDateLocalized" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			console.log(date1.getDate());</example>
        </examples>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getMonth" scope="instance">
        <description>the result is the index in the month array:
	0. Tishri
	1. Heshvan
	2. Kislev
	3. Tevet
	4. Shevat
	5. Adar I (leap years only)
	6. Adar
	7. Nisan
	8. Iyar
	9. Sivan
	10. Tammuz
	11.	Av
	12. Elul - 12
	For non leap years, for months after Shevat, the actual position of
	the month in the year (used for short format) is less than
	the "absolute" index by 1.</description>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date(5769, 6, 1);
			console.log(date1.getMonth()+1);
			&gt;&gt; 7</example>
        </examples>
      </method>
      <method name="getFullYear" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date(5769, 6, 1);
			console.log(date1.getFullYear());
			&gt;&gt; 5769</example>
        </examples>
      </method>
      <method name="getHours" scope="instance"/>
      <method name="getMinutes" scope="instance"/>
      <method name="getSeconds" scope="instance"/>
      <method name="getMilliseconds" scope="instance"/>
      <method name="setDate" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date(5769, 6, 1);
			date1.setDate(2);</example>
        </examples>
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setFullYear" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			date1.setFullYear(5768);
			date1.setFullYear(5768, 1, 1);</example>
        </examples>
        <parameters>
          <parameter name="year" type="number" usage="required"/>
          <parameter name="month" type="number" usage="optional"/>
          <parameter name="date" type="number" usage="optional"/>
        </parameters>
      </method>
      <method name="setMonth" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			date1.setMonth(0); //first month</example>
        </examples>
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="instance">
        <description>Sets the hour and optionally minutes, seconds, milliseconds also.</description>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			date1.setHours(12, 30, 0, 0);</example>
        </examples>
      </method>
      <method name="setMinutes" scope="instance">
        <parameters>
          <parameter name="minutes" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setSeconds" scope="instance">
        <parameters>
          <parameter name="seconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="instance">
        <parameters>
          <parameter name="milliseconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setDay" scope="instance"/>
      <method name="toString" scope="instance">
        <description>returns a string representation of the date in "dd, MM, yyyy HH:mm:ss" format (all numeric)
	For user presentation, use dojox.date.hebrew.locale.format which will present in the appropriate language
	and format.  toString() language- and culturally-specific conventions to keep this module free of
	dependencies on dojox.date.locale and dojo.cldr.</description>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date(5769, 6, 1);
			console.log(date1.toString());
			&gt;&gt;&gt; "1, 6, 5769 0:0:0"</example>
        </examples>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getDaysInHebrewMonth" scope="instance">
        <parameters>
          <parameter name="month" type="Number" usage="required"/>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_yearType" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_handleGetYearLength" scope="instance">
        <parameters>
          <parameter name="eyear" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="_startOfYear" scope="instance">
        <parameters>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="isLeapYear" scope="instance">
        <description>The Leap year contains additional month adar sheni
	return (year * 12 + 17) % 19 &gt;= 12;</description>
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="fromGregorian" scope="instance">
        <examples>
          <example>		var dateHebrew = new dojox.date.hebrew.Date();
			var dateGregorian = new Date(2008,10,12);
			dateHebrew.fromGregorian(dateGregorian);</example>
        </examples>
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_computeHebrewFields" scope="instance">
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="toGregorian" scope="instance">
        <examples>
          <example>		var dateHebrew = new dojox.date.hebrew.Date(5768,11,20);
			var dateGregorian = dateHebrew.toGregorian();</example>
        </examples>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="_floorDivide" scope="instance">
        <parameters>
          <parameter name="numerator" type="Object" usage="required"/>
          <parameter name="denominator" type="Object" usage="required"/>
          <parameter name="remainder" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDay" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			console.log(date1.getDay());</example>
        </examples>
      </method>
      <method name="_getJulianDayFromGregorianDate" scope="instance">
        <parameters>
          <parameter name="gdate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="valueOf" scope="instance"/>
    </methods>
    <properties>
      <property name="_MONTH_LENGTH" scope="instance" type="Array"/>
      <property name="_MONTH_START" scope="instance" type="Array"/>
      <property name="_LEAP_MONTH_START" scope="instance" type="Array"/>
      <property name="_GREGORIAN_MONTH_COUNT" scope="instance" type="Array"/>
      <property name="_date" scope="instance-prototype" type="Object"/>
      <property name="_month" scope="instance-prototype" type="Number"/>
      <property name="_year" scope="instance-prototype" type="String"/>
      <property name="_hours" scope="instance-prototype" type="Object"/>
      <property name="_minutes" scope="instance-prototype" type="Object"/>
      <property name="_seconds" scope="instance-prototype" type="Object"/>
      <property name="_milliseconds" scope="instance-prototype" type="Object"/>
      <property name="_day" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.date.hebrew.locale">
    <methods>
      <method name="format" scope="instance">
        <description>Create a string from a hebrew.Date object using a known pattern.
	By default, this method formats both date and time from dateObject.
	Default formatting lengths is 'short'</description>
        <parameters>
          <parameter name="dateObject" type="hebrew.Date" usage="required">
            <description>the date and/or time to be formatted.  If a time only is formatted,
	the values in the year, month, and day fields are irrelevant.  The
	opposite is true when formatting only dates.</description>
          </parameter>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="instance">
        <parameters>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="oblect" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <examples>
          <example>		var dateHebrew = dojox.date.hebrew.locale.parse('11/10/5740', {datePattern:'dd/MM/yy', selector:'date'});
			in Hebrew locale string for parsing contains Hebrew Numerals
		options = {datePattern:'dd MMMM yy', selector:'date'};
		 y - year
		 M, MM  - short month
		MMM, MMMM - long month
		d - date
		a - am, pm
		 E, EE, EEE, EEEE  - week day
			h, H, k, K, m, s, S,  -  time format</example>
        </examples>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="hebrew.Date"/>
        </return-types>
      </method>
      <method name="addCustomFormats" scope="instance">
        <description>The user may add custom localized formats where the bundle has properties following the
	same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	The pattern string should match the format used by the CLDR.
	See dojo.date.locale.format() for details.
	The resources must be loaded by dojo.requireLocalization() prior to use</description>
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getHebrewBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNames" scope="instance">
        <parameters>
          <parameter name="item" type="String" usage="required">
            <description>'months' || 'days'</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>'wide' || 'narrow' || 'abbr' (e.g. &amp;quot;Monday&amp;quot;, &amp;quot;Mon&amp;quot;, or &amp;quot;M&amp;quot; respectively, in English)
	use:
	'standAlone' || 'format' (default)</description>
          </parameter>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional">
            <description>override locale used to find the names</description>
          </parameter>
          <parameter name="date" type="dojox.date.hebrew.Date" usage="optional">
            <description>required for item=months to determine leap month name
	using  var monthNames = dojox.date.hebrew.locale.getNames('months', 'wide', 'format', 'he', new dojox.date.hebrew.Date(5768, 2, 12));</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.hebrew.numerals">
    <methods>
      <method name="getYearHebrewLetters" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			document.writeln(dojox.date.hebrew.numerals.getYearHebrewLetters(date1.getFullYear());</example>
        </examples>
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parseYearHebrewLetters" scope="instance">
        <examples>
          <example>		var date = new dojox.date.hebrew.Date();
						date.setFullYear(dojox.date.hebrew.numerals.parseYearHebrewLetters('\u05ea\u05e9\u05e1\u05f4\u05d7'));</example>
        </examples>
        <parameters>
          <parameter name="year" type="String" usage="required">
            <description>hebrew year</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getDayHebrewLetters" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			document.writeln(dojox.date.hebrew.numerals.getDayHebrewLetters(date1.getDay());</example>
        </examples>
        <parameters>
          <parameter name="day" type="Object" usage="required"/>
          <parameter name="nogrsh" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parseDayHebrewLetters" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			date1.setDate(dojox.date.hebrew.numerals.parseDayHebrewLetters('\u05d0')); // ALEPH</example>
        </examples>
        <parameters>
          <parameter name="day" type="String" usage="required">
            <description>hebrew</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getMonthHebrewLetters" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			document.writeln(dojox.date.hebrew.numerals.getMonthHebrewLetters(date1.getMonth());</example>
        </examples>
        <parameters>
          <parameter name="month" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parseMonthHebrewLetters" scope="instance">
        <examples>
          <example>		var date = new dojox.date.hebrew.Date();
							var number = dojox.date.hebrew.numerals.parseMonthHebrewLetters("\u05ea\u05de\u05d5\u05d6"); // Tammuz
			date.setMonth(number);</example>
        </examples>
        <parameters>
          <parameter name="monthStr" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.islamic">
    <methods>
      <method name="getDaysInMonth" scope="instance">
        <parameters>
          <parameter name="month" type="islamic.Date" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="instance">
        <description>Returns 0 if equal, positive if a &gt; b, else negative.</description>
        <parameters>
          <parameter name="date1" type="islamic.Date" usage="required">
            <description>object</description>
          </parameter>
          <parameter name="date2" type="islamic.Date" usage="required">
            <description>object.  If not specified, the current islamic.Date is used.</description>
          </parameter>
          <parameter name="portion" type="String" usage="optional">
            <description>A string indicating the &amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; portion of a Date object.
	Compares both &amp;quot;date&amp;quot; and &amp;quot;time&amp;quot; by default.  One of the following:
	&amp;quot;date&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;datetime&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="date" type="dojox.date.islamic.Date" usage="required">
            <description>islamic.Date Date object to start with</description>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</description>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <description>How much to add to the date.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.date.islamic.Date"/>
        </return-types>
      </method>
      <method name="difference" scope="instance">
        <parameters>
          <parameter name="date1" type="dojox.date.islamic.Date" usage="required"/>
          <parameter name="date2" type="dojox.date.islamic.Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional">
            <description>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;,  &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.date.islamic.Date">
    <description>This module is similar to the Date() object provided by JavaScript</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>This function initialize the date object values</description>
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			var date2 = new dojox.date.islamic.Date("12\2\1429");
			var date3 = new dojox.date.islamic.Date(date2);
			var date4 = new dojox.date.islamic.Date(1429,2,12);</example>
        </examples>
      </method>
      <method name="getDate" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			document.writeln(date1.getDate);</example>
        </examples>
      </method>
      <method name="getMonth" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			document.writeln(date1.getMonth()+1);</example>
        </examples>
      </method>
      <method name="getFullYear" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			document.writeln(date1.getFullYear());</example>
        </examples>
      </method>
      <method name="getDay" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			document.writeln(date1.getDay());</example>
        </examples>
      </method>
      <method name="getHours" scope="instance"/>
      <method name="getMinutes" scope="instance"/>
      <method name="getSeconds" scope="instance"/>
      <method name="getMilliseconds" scope="instance"/>
      <method name="setDate" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			date1.setDate(2);</example>
        </examples>
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setFullYear" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			date1.setYear(1429);</example>
        </examples>
        <parameters>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMonth" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			date1.setMonth(2);</example>
        </examples>
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="instance"/>
      <method name="setMinutes" scope="instance">
        <parameters>
          <parameter name="minutes" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setSeconds" scope="instance">
        <parameters>
          <parameter name="seconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="instance">
        <parameters>
          <parameter name="milliseconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			document.writeln(date1.toString());</example>
        </examples>
      </method>
      <method name="toGregorian" scope="instance">
        <examples>
          <example>		var dateIslamic = new dojox.date.islamic.Date(1429,11,20);
			var dateGregorian = dateIslamic.toGregorian();</example>
        </examples>
      </method>
      <method name="fromGregorian" scope="instance">
        <examples>
          <example>		var dateIslamic = new dojox.date.islamic.Date();
			var dateGregorian = new Date(2008,10,12);
			dateIslamic.fromGregorian(dateGregorian);</example>
        </examples>
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="valueOf" scope="instance"/>
      <method name="_yearStart" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_monthStart" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
          <parameter name="month" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_civilLeapYear" scope="instance">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="getDaysInIslamicMonth" scope="instance">
        <parameters>
          <parameter name="month" type="Number" usage="required">
            <description>dojox.date.islamic.Date</description>
          </parameter>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.date.islamic.Date"/>
        </return-types>
      </method>
      <method name="_mod" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_date" scope="instance-prototype" type="Object"/>
      <property name="_month" scope="instance-prototype" type="Object"/>
      <property name="_year" scope="instance-prototype" type="String"/>
      <property name="_hours" scope="instance-prototype" type="Object"/>
      <property name="_minutes" scope="instance-prototype" type="Object"/>
      <property name="_seconds" scope="instance-prototype" type="Object"/>
      <property name="_milliseconds" scope="instance-prototype" type="Object"/>
      <property name="_day" scope="instance" type="Object"/>
      <property name="_GREGORIAN_EPOCH" scope="instance" type="Number"/>
      <property name="_ISLAMIC_EPOCH" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.date.islamic.locale">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="dateObject" type="islamic.Date" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="instance">
        <parameters>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="instance">
        <parameters>
          <parameter name="options" type="oblect" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="addCustomFormats" scope="instance">
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getIslamicBundle" scope="instance">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNames" scope="instance">
        <parameters>
          <parameter name="item" type="String" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="date" type="islamic" usage="required">
            <description>Date Object?</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="weekDays" scope="instance" type="Object"/>
      <property name="months" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.php">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.php.DateFormat">
    <methods>
      <method name="d" scope="instance"/>
      <method name="D" scope="instance"/>
      <method name="j" scope="instance"/>
      <method name="l" scope="instance"/>
      <method name="N" scope="instance"/>
      <method name="S" scope="instance"/>
      <method name="w" scope="instance"/>
      <method name="z" scope="instance"/>
      <method name="W" scope="instance"/>
      <method name="F" scope="instance"/>
      <method name="m" scope="instance"/>
      <method name="M" scope="instance"/>
      <method name="n" scope="instance"/>
      <method name="t" scope="instance"/>
      <method name="L" scope="instance"/>
      <method name="o" scope="instance"/>
      <method name="Y" scope="instance"/>
      <method name="y" scope="instance"/>
      <method name="a" scope="instance"/>
      <method name="b" scope="instance"/>
      <method name="B" scope="instance"/>
      <method name="g" scope="instance"/>
      <method name="G" scope="instance"/>
      <method name="h" scope="instance"/>
      <method name="H" scope="instance"/>
      <method name="i" scope="instance"/>
      <method name="s" scope="instance"/>
      <method name="e" scope="instance"/>
      <method name="I" scope="instance"/>
      <method name="O" scope="instance"/>
      <method name="P" scope="instance"/>
      <method name="T" scope="instance"/>
      <method name="Z" scope="instance"/>
      <method name="c" scope="instance"/>
      <method name="r" scope="instance"/>
      <method name="U" scope="instance"/>
    </methods>
    <properties>
      <property name="weekdays" scope="instance" type="Array"/>
      <property name="weekdays_3" scope="instance" type="Array"/>
      <property name="months" scope="instance" type="Array"/>
      <property name="months_3" scope="instance" type="Array"/>
      <property name="monthdays" scope="instance" type="Array"/>
      <property name="tokens" scope="instance" type="Object"/>
      <property name="replacements" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.php.DateFormat.format">
    <methods/>
    <properties>
      <property name="date" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.php.DateFormat.constructor.prototype">
    <properties>
      <property name="regex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.date.posix">
    <methods>
      <method name="strftime" scope="instance">
        <description>see http://www.opengroup.org/onlinepubs/007908799/xsh/strftime.html</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getStartOfWeek" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="firstDay" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="setIsoWeekOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="week" type="Number" usage="required">
            <description>can be positive or negative: -1 is the year's last week.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="getIsoWeekOfYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getIsoWeeksInYear" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.date.relative">
    <methods>
      <method name="format" scope="instance">
        <description>Create a string from a Date object using the most significant information
	and a known localized pattern.  This method formats both the date and
	time from dateObject.  Formatting patterns are chosen appropriate to
	the locale.
	If the day portion of the date falls within the current date (or the
	relativeDate option, if present), then the time will be all that
	is displayed
	If the day portion of the date falls within the past week (or the
	week preceeding relativeDate, if present), then the display will show
	day of week and time.  This functionality can be turned off by setting
	weekCheck to false.
	If the year portion of the date falls within the current year (or the
	year portion of relativeDate, if present), then the display will show
	month and day.
	Otherwise, this function is equivalent to calling dojo.date.format with
	formatLength of "medium"</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <description>the date and time to be formatted.</description>
          </parameter>
          <parameter name="options" type="dojox.date.relative.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.relative.__FormatOptions">
    <methods/>
    <properties>
      <property name="locale" scope="instance" type="String">
        <description>override the locale used to determine formatting rules</description>
      </property>
      <property name="relativeDate" scope="instance" type="Date">
        <description>Date to calculate relation to (defaults to new Date())</description>
      </property>
      <property name="weekCheck" scope="instance" type="boolean">
        <description>Whether or not to display the day of week (defaults true)</description>
      </property>
    </properties>
  </class>
  <class type="dojo._contentHandlers">
    <methods>
      <method name="olson-zoneinfo" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="auto" scope="instance">
        <parameters>
          <parameter name="xhr" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.date.timezone">
    <description>mix-in to dojo.date to provide timezones based on
	the Olson timezone data.
	If you pass "timezone" as a parameter to your format options,
	then you get the date formatted (and offset) for that timezone</description>
    <methods>
      <method name="getTzInfo" scope="instance">
        <parameters>
          <parameter name="dt" type="Date" usage="required">
            <description>The Date - a &amp;quot;proxyDate&amp;quot;</description>
          </parameter>
          <parameter name="tz" type="String" usage="required">
            <description>String representation of the timezone you want to get info
	for date</description>
          </parameter>
        </parameters>
      </method>
      <method name="loadZoneData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required">
            <description>The data to load - contains &amp;quot;zones&amp;quot; and &amp;quot;rules&amp;quot; parameters</description>
          </parameter>
        </parameters>
      </method>
      <method name="getAllZones" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dnd"/>
  <class type="dojox.dnd.BoundingBoxController">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="sources" type="Array" usage="required">
            <description>an array of dojox.dnd.Selectors which need to be aware of
	the positioning of the bounding box.</description>
          </parameter>
          <parameter name="domNode" type="String|DomNode" usage="required">
            <description>the DOM node or id which represents the bounding box on the page.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="boundingBoxIsViable" scope="instance"/>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required">
            <description>the mouse event which caused this callback to fire.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onMouseMove" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required">
            <description>the mouse event which caused this callback to fire.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onMouseUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required">
            <description>the mouse event which caused this callback to fire.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_finishSelecting" scope="instance"/>
      <method name="_drawBoundingBox" scope="instance"/>
    </methods>
    <properties>
      <property name="_startX" scope="instance" type="Object"/>
      <property name="_startY" scope="instance" type="Object"/>
      <property name="_endX" scope="instance" type="Object"/>
      <property name="_endY" scope="instance" type="Object"/>
      <property name="domNode" scope="instance-prototype" type="String|DomNode">
        <description>the DOM node or id which represents the bounding box on the page.</description>
      </property>
      <property name="events" scope="instance" type="Array"/>
      <property name="subscriptions" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.dnd.Selector" superclass="dojo.dnd.Selector">
    <methods>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>Node to check (id or DOM Node)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="selectNode" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>Node to select (id or DOM Node)</description>
          </parameter>
          <parameter name="add" type="Boolean" usage="optional">
            <description>If true, node is added to selection, otherwise current
	selection is removed, and node will be the only selection.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="deselectNode" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>Node to deselect (id or DOM Node)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="selectByBBox" scope="instance">
        <parameters>
          <parameter name="left" type="Number" usage="required">
            <description>Left coordinate of the bounding box</description>
          </parameter>
          <parameter name="top" type="Number" usage="required">
            <description>Top coordinate of the bounding box</description>
          </parameter>
          <parameter name="right" type="Number" usage="required">
            <description>Right coordinate of the bounding box</description>
          </parameter>
          <parameter name="bottom" type="Number" usage="required">
            <description>Bottom coordinate of the bounding box</description>
          </parameter>
          <parameter name="add" type="Boolean" usage="optional">
            <description>If true, node is added to selection, otherwise current
	selection is removed, and node will be the only selection.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_isBoundedByBox" scope="instance">
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>Node to check (id or DOM Node)</description>
          </parameter>
          <parameter name="left" type="Number" usage="required">
            <description>Left coordinate of the bounding box</description>
          </parameter>
          <parameter name="top" type="Number" usage="required">
            <description>Top coordinate of the bounding box</description>
          </parameter>
          <parameter name="right" type="Number" usage="required">
            <description>Right coordinate of the bounding box</description>
          </parameter>
          <parameter name="bottom" type="Number" usage="required">
            <description>Bottom coordinate of the bounding box</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="shift" scope="instance">
        <parameters>
          <parameter name="toNext" type="Boolean" usage="required">
            <description>If true, we select the next node, otherwise the previous one.</description>
          </parameter>
          <parameter name="add" type="Boolean" usage="optional">
            <description>If true, add to selection, otherwise current selection is
	removed before adding any nodes.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getNodeId" scope="instance">
        <parameters>
          <parameter name="nodeId" type="String" usage="required">
            <description>the id of the node to use as the base node</description>
          </parameter>
          <parameter name="toNext" type="Boolean" usage="required">
            <description>If true, we select the next node, otherwise the previous one.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Selector" scope="instance"/>
    </mixins>
    <properties>
      <property name="anchor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing">
    <methods>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRegistered" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.Drawing">
    <description>Drawing is similar to DojoX Sketch, but is designed to be more versatile
	extendable and customizable.
	Drawing currently only initiates from HTML although it's technically not
	a Dijit to keep the file size light. But if Dijit is available, Drawing
	will register itself with it and can be accessed dijit.byId('myDrawing')
	NOTES:
	Although not Drawing and Toolbar, all other objects are created with a custom
	declare. See dojox.drawing.util.oo
	The files are laid out as such:
	- Drawing
	The master class. More than one instance of a Drawing can be placed
	on a page at one time (although this has not yet been tested). Plugins
	can be added in markup.
	- Toolbar
	Like Drawing, Toolbar is a psudeo Dijit that does not need Dijit. It is
	optional. It can be oriented horizontal or vertical by placing one of
	those params in the class (at least one is required).  Plugins
	can be added in markup. A drawingId is required to point toolbar to
	the drawing.
	- defaults
	Contains the default styles and dimensions for Stencils. An individual
	Stencil can be changed by calling stencil.att({color obj}); To change
	all styles, a custom defaults file should be used.
	-Stencils
	Drawing uses a concept of 'Stencils' to avoid confusion between a
	Dojox Shape and a Drawing Shape. The classes in the 'stencils' package
	are display only, they are not used for actually drawing (see 'tools').
	This package contains _Base from which stencils inherit most of their
	methods.(Path and Image are display only and not found in Tools)
	- Tools
	The Tools package contains Stencils that are attached to mouse events
	and can be used for drawing. Items in this package can also be selected
	and modified.
	- Tools / Custom
	Holds tools that do not directly extend Stencil base classes and often
	have very custom code.
	- Library (not implemented)
	The Library package, which is not yet implemented, will be the place to
	hold stencils that have very specific data points that result in a picture.
	Flag-like-banners, fancy borders, or other complex shapes would go here.
	- Annotations
	Annotations 'decorate' and attach to other Stencils, such as a 'Label'
	that can show text on a stencil, or an 'Angle' that shows while dragging
	or modifying a Vector, or an Arrow head that is attached to the beginning
	or end of a line.
	- Manager
	Contains classes that control functionality of a Drawing.
	- Plugins
	Contains optional classes that are 'plugged into' a Drawing. There are two
	types: 'drawing' plugins that modify the canvas, and 'tools' which would
	show in the toolbar.
	- Util
	A collection of common tasks.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="HTMLNode" usage="required"/>
        </parameters>
      </method>
      <method name="_createCanvas" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="box" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="getShapeProps" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="mode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addPlugin" scope="instance">
        <parameters>
          <parameter name="plugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initPlugins" scope="instance"/>
      <method name="onSurfaceReady" scope="instance"/>
      <method name="addUI" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>Object The parameters used to draw the object. See stencil._Base and each
	tool for specific parameters of teh data or points objects.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addStencil" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>Object The parameters used to draw the object. See stencil._Base and each
	tool for specific parameters of teh data or points objects.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeStencil" scope="instance">
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeAll" scope="instance"/>
      <method name="selectAll" scope="instance"/>
      <method name="toSelected" scope="instance">
        <examples>
          <example>	myDrawing.toSelected('attr', {x:10})</example>
        </examples>
        <parameters>
          <parameter name="func" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="exporter" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="importer" scope="instance">
        <parameters>
          <parameter name="objects" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="changeDefaults" scope="instance">
        <examples>
          <example>	myDrawing.changeDefaults({
			norm:{
				fill:"#0000ff",
				width:5,
				color:"#ffff00"
			}
		});
	console.log("-----&gt;&gt;&gt; changeDefault: ",newStyle, " value?: ",value);</example>
        </examples>
        <parameters>
          <parameter name="newStyle" type="Object" usage="required">
            <description>An object that represents one of the objects in
	drawing.style that will be mixed in. Not all
	properties are necessary. Only one object may
	be changed at a time. The object boolean parameter
	is not required and if not set objects will automatically
	be changed.
	Changing non-objects like angleSnap requires value
	to be true.</description>
          </parameter>
          <parameter name="value" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onRenderStencil" scope="instance">
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteStencil" scope="instance">
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerTool" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getConstructor" scope="instance">
        <parameters>
          <parameter name="abbr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setTool" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="unSetTool" scope="instance"/>
    </methods>
    <properties>
      <property name="ready" scope="instance" type="Boolean">
        <description>Whether or not the canvas has been created and Stencils can be added</description>
      </property>
      <property name="mode" scope="instance-prototype" type="String">
        <description>Changes the functionality of the drawing</description>
      </property>
      <property name="width" scope="instance-prototype" type="Number">
        <description>Width of the canvas</description>
      </property>
      <property name="height" scope="instance-prototype" type="Number">
        <description>Height of the canvas
	defaults : Object
	Optional replacements for native defaults.
	plugins: Object
	Key values of plugins that apply to canvas.</description>
      </property>
      <property name="canvas" scope="instance" type="Object"/>
      <property name="plugins" scope="instance-prototype" type="Array"/>
      <property name="undo" scope="instance" type="Object"/>
      <property name="anchors" scope="instance" type="Object"/>
      <property name="uiStencils" scope="instance" type="Object"/>
      <property name="stencils" scope="instance" type="Object"/>
      <property name="currentType" scope="instance" type="Array"/>
      <property name="currentStencil" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="util" scope="instance" type="Object"/>
      <property name="keys" scope="instance" type="Object"/>
      <property name="mouse" scope="instance" type="Object"/>
      <property name="tools" scope="instance" type="Object"/>
      <property name="stencilTypes" scope="instance" type="Object"/>
      <property name="stencilTypeMap" scope="instance" type="Object"/>
      <property name="srcRefNode" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="widgetId" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.Drawing.defaults">
    <properties>
      <property name="clickable" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.drawing.annotations">
    <properties>
      <property name="Angle" scope="instance" type="Object"/>
      <property name="Arrow" scope="instance" type="Object"/>
      <property name="BoxShadow" scope="instance" type="Object"/>
      <property name="Label" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults">
    <description>This object contains defaults for objects used in Drawing.
	To change one item's style, use item.attr();
	To change all these styles, create a copy of this file
	and point to it in the Drawing properties:
		&lt;div dojoType="dojox.drawing.Drawing" id="drawing" defaults="MyCustom.defaults"&gt;&lt;/div&gt;
	See:
	Drawing.changeDefaults
	Determines whether in draw or edit mode (whether stencils
	are clickable.  If clickMode is false, the original
	functionality of silently switching between select modes
	is enabled.  If clickMode is true, it allows powerpoint-
	like functionality.  Clickable is used by powerpoint to
	distinguish when things can be selected and when they can't</description>
    <methods>
      <method name="copy" scope="instance"/>
    </methods>
    <properties>
      <property name="clickMode" scope="instance" type="Object"/>
      <property name="clickable" scope="instance" type="Object"/>
      <property name="current" scope="instance" type="Object">
        <description>current will point to either null or selected</description>
      </property>
      <property name="currentHit" scope="instance" type="Object">
        <description>currentHit will point to either hitNorm or hitSelected</description>
      </property>
      <property name="angleSnap" scope="instance" type="Number">
        <description>Line, arrows, vector and axes will all snap to this angle on mouse up
	shown angle also reflects the snap
	currently cannot accept less than 1 degree</description>
      </property>
      <property name="zAxis" scope="instance" type="Boolean">
        <description>If true, draw current object in z-direction.</description>
      </property>
      <property name="zAxisEnabled" scope="instance" type="Boolean">
        <description>If true, render axes with Z-axis included, allow objects drawn in z-direction.
	If false the z-axis button will not show up.</description>
      </property>
      <property name="zAngle" scope="instance" type="Number"/>
      <property name="renderHitLines" scope="instance" type="Boolean">
        <description>If true, renders a second, larger layer for lines to make
	them more easily clickable.</description>
      </property>
      <property name="renderHitLayer" scope="instance" type="If">
        <description>true, renders a second layer for each Stencil, one
	acting as a 'hit' object for a wider mouse-click area.
	It also doubles as a hilight. If true, overrides
	renderHitLines setting.</description>
      </property>
      <property name="labelSameColor" scope="instance" type="If">
        <description>true, the label text color will be the same as the
	Stencil's line color.</description>
      </property>
      <property name="useSelectedStyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.norm">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.selected">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.highlighted">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.disabled">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
      <property name="fill" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitNorm">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="style" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitNorm.color">
    <properties>
      <property name="r" scope="instance" type="Number"/>
      <property name="g" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitNorm.fill">
    <properties>
      <property name="r" scope="instance" type="Number"/>
      <property name="g" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitSelected">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitSelected.fill">
    <properties>
      <property name="r" scope="instance" type="Number"/>
      <property name="g" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitHighlighted">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.hitHighlighted.fill">
    <properties>
      <property name="r" scope="instance" type="Number"/>
      <property name="g" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.anchors">
    <properties>
      <property name="size" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="fill" scope="instance" type="String"/>
      <property name="cap" scope="instance" type="String"/>
      <property name="minSize" scope="instance" type="Number"/>
      <property name="marginZero" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.arrows">
    <properties>
      <property name="length" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.text">
    <properties>
      <property name="minWidth" scope="instance" type="Number"/>
      <property name="deleteEmptyCreate" scope="instance" type="Object"/>
      <property name="deleteEmptyModify" scope="instance" type="Object"/>
      <property name="pad" scope="instance" type="Number"/>
      <property name="size" scope="instance" type="String"/>
      <property name="family" scope="instance" type="String"/>
      <property name="weight" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.textDisabled">
    <properties>
      <property name="size" scope="instance" type="String"/>
      <property name="family" scope="instance" type="String"/>
      <property name="weight" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.textMode"/>
  <class type="dojox.drawing.defaults.textMode.create">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="style" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
      <property name="fill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.textMode.edit">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="style" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
      <property name="fill" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button"/>
  <class type="dojox.drawing.defaults.button.norm">
    <properties>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.norm.fill">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.over">
    <properties>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.over.fill">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.down">
    <properties>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.down.fill">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.selected">
    <properties>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.selected.fill">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.icon"/>
  <class type="dojox.drawing.defaults.button.icon.norm">
    <properties>
      <property name="fill" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.defaults.button.icon.selected">
    <properties>
      <property name="fill" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.library"/>
  <class type="dojox.drawing.library.greek">
    <description>These are used to convert between the character and
	the written version of greek letters.  Any character
	can be included here and it will automatically be added
	to the palette and converted by typesetter</description>
    <properties>
      <property name="alpha" scope="instance" type="Number"/>
      <property name="beta" scope="instance" type="Number"/>
      <property name="gamma" scope="instance" type="Number"/>
      <property name="delta" scope="instance" type="Number"/>
      <property name="epsilon" scope="instance" type="Number"/>
      <property name="zeta" scope="instance" type="Number"/>
      <property name="eta" scope="instance" type="Number"/>
      <property name="theta" scope="instance" type="Number"/>
      <property name="iota" scope="instance" type="Number"/>
      <property name="kappa" scope="instance" type="Number"/>
      <property name="lambda" scope="instance" type="Number"/>
      <property name="mu" scope="instance" type="Number"/>
      <property name="nu" scope="instance" type="Number"/>
      <property name="xi" scope="instance" type="Number"/>
      <property name="omicron" scope="instance" type="Number"/>
      <property name="pi" scope="instance" type="Number"/>
      <property name="rho" scope="instance" type="Number"/>
      <property name="sigmaf" scope="instance" type="Number"/>
      <property name="sigma" scope="instance" type="Number"/>
      <property name="tau" scope="instance" type="Number"/>
      <property name="upsilon" scope="instance" type="Number"/>
      <property name="phi" scope="instance" type="Number"/>
      <property name="chi" scope="instance" type="Number"/>
      <property name="psi" scope="instance" type="Number"/>
      <property name="omega" scope="instance" type="Number"/>
      <property name="thetasym" scope="instance" type="Number"/>
      <property name="upsih" scope="instance" type="Number"/>
      <property name="piv" scope="instance" type="Number"/>
      <property name="Alpha" scope="instance" type="Number"/>
      <property name="Beta" scope="instance" type="Number"/>
      <property name="Gamma" scope="instance" type="Number"/>
      <property name="Delta" scope="instance" type="Number"/>
      <property name="Epsilon" scope="instance" type="Number"/>
      <property name="Zeta" scope="instance" type="Number"/>
      <property name="Eta" scope="instance" type="Number"/>
      <property name="Theta" scope="instance" type="Number"/>
      <property name="Iota" scope="instance" type="Number"/>
      <property name="Kappa" scope="instance" type="Number"/>
      <property name="Lambda" scope="instance" type="Number"/>
      <property name="Mu" scope="instance" type="Number"/>
      <property name="Nu" scope="instance" type="Number"/>
      <property name="Xi" scope="instance" type="Number"/>
      <property name="Omicron" scope="instance" type="Number"/>
      <property name="Pi" scope="instance" type="Number"/>
      <property name="Rho" scope="instance" type="Number"/>
      <property name="Sigma" scope="instance" type="Number"/>
      <property name="Tau" scope="instance" type="Number"/>
      <property name="Upsilon" scope="instance" type="Number"/>
      <property name="Phi" scope="instance" type="Number"/>
      <property name="Chi" scope="instance" type="Number"/>
      <property name="Psi" scope="instance" type="Number"/>
      <property name="Omega" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons">
    <description>Each icon name coresponds to a Stencil or a Plugin. One can be inserted
	into a button by adding the property: 'icon', which points to one of
	these Stencil objects.</description>
  </class>
  <class type="dojox.drawing.library.icons.line">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.ellipse">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="cx" scope="instance" type="Number"/>
      <property name="cy" scope="instance" type="Number"/>
      <property name="rx" scope="instance" type="Number"/>
      <property name="ry" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.rect">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.triangle">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.path">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.arrow">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.textBlock">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.equation">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.axes">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.vector">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.pan">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.plus">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.zoomIn">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.zoomOut">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="bool"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.zoom100">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="text" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.iconize">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.library.icons.pencil">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="borderWidth" scope="instance" type="Number"/>
      <property name="closePath" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.manager">
    <properties>
      <property name="Anchors" scope="instance" type="Object"/>
      <property name="Anchor" scope="instance" type="Object"/>
      <property name="Canvas" scope="instance" type="Object"/>
      <property name="Mouse" scope="instance" type="Object"/>
      <property name="Stencil" scope="instance" type="Object"/>
      <property name="StencilUI" scope="instance" type="Object"/>
      <property name="Undo" scope="instance" type="Object"/>
      <property name="_registry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.manager.keys">
    <methods>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onEsc" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onEnter" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onArrow" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLetter" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixin" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="editMode" scope="instance">
        <parameters>
          <parameter name="_isedit" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enable" scope="instance">
        <parameters>
          <parameter name="_enabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance"/>
    </methods>
    <properties>
      <property name="arrowIncrement" scope="instance" type="Number">
        <description>The amount, in pixels, a selected Stencil will
	move on an arrow key event</description>
      </property>
      <property name="arrowShiftIncrement" scope="instance" type="Number">
        <description>The amount, in pixels, a selected Stencil will
	move on an arrow key + SHIFT event</description>
      </property>
      <property name="shift" scope="instance" type="Boolean">
        <description>Indicates whether the Shift key is currently pressed</description>
      </property>
      <property name="ctrl" scope="instance" type="Boolean">
        <description>Indicates whether the Control key is currently pressed</description>
      </property>
      <property name="alt" scope="instance" type="Boolean">
        <description>Indicates whether the Alt or Option key is currently pressed</description>
      </property>
      <property name="cmmd" scope="instance" type="Boolean">
        <description>Indicates whether the Apple Command key is currently pressed
	apple key</description>
      </property>
      <property name="meta" scope="instance" type="Boolean">
        <description>Indicates whether any 'meta' key is currently pressed:
	shift || ctrl || cmmd || alt
	any meta key</description>
      </property>
      <property name="listeners" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.manager.keys.scanForFields">
    <methods/>
    <properties>
      <property name="_fieldCons" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins">
    <properties>
      <property name="_Plugin" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.drawing">
    <properties>
      <property name="Grid" scope="instance" type="Object"/>
      <property name="Silverlight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.drawing.GreekPalette" superclass="dijit._Widget">
    <description>Grid showing all available entity options which the
	user can pick from.  The library loaded for use by the picker
	is found in dojox.drawing.library.greek.  Adding characters
	there will automatically add them to the palette.
	This works as a popup and as such its onChange and onCancel
	close it.  TextBlock manages it, since it's what uses the assist
	so opening it happens there.  In order to activate the plugin
	add it to the dojox.drawing.Drawing node as shown below:</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance">
        <parameters>
          <parameter name="closeAll" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="_onCellMouseEnter" scope="instance">
        <parameters>
          <parameter name="e" type="The" usage="required">
            <description>event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_setCurrent" scope="instance">
        <description>At any point in time there's exactly one
	cell with tabIndex != -1.   If focus is inside the palette then
	focus is on that cell.
	After calling this method, arrow key handlers and mouse click handlers
	should focus the cell in a setTimeout().</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_displayDetails" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_preparePalette" scope="instance">
        <parameters>
          <parameter name="choices" type="Array&lt;Array&lt;String&gt;&gt;" usage="required">
            <description>id's for each cell of the palette, used to create Dye JS object for each cell</description>
          </parameter>
          <parameter name="titles" type="Array&lt;String&gt;" usage="required">
            <description>Localized tooltip for each cell</description>
          </parameter>
        </parameters>
      </method>
      <method name="_navigateByArrow" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._PaletteMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._PaletteMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_palette" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String">
        <description>The template of this widget.  Using dojoxEntityPalette classes
	in order to allow easy transfer of css</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="showPreview" scope="instance" type="Boolean">
        <description>Whether the preview pane will be displayed, to show details about the selected entity.</description>
      </property>
      <property name="dyeClass" scope="instance" type="String"/>
      <property name="paletteClass" scope="instance" type="String"/>
      <property name="cellClass" scope="instance" type="String"/>
      <property name="_currentFocus" scope="instance" type="Object"/>
      <property name="_cells" scope="instance" type="Array"/>
      <property name="_blankGif" scope="instance" type="Object"/>
      <property name="_xDim" scope="instance" type="Object"/>
      <property name="_yDim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.drawing.GreekPalette._textBlock">
    <properties>
      <property name="_dropMode" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.drawing.GreekPalette.previewNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.drawing.GreekPalette.descNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.Greeks">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_alias" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools">
    <properties>
      <property name="Zoom" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.Iconize"/>
  <class type="dojox.drawing.plugins.tools.Iconize.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.Pan"/>
  <class type="dojox.drawing.plugins.tools.Pan.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
      <property name="button" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.ZoomIn"/>
  <class type="dojox.drawing.plugins.tools.ZoomIn.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.Zoom100"/>
  <class type="dojox.drawing.plugins.tools.Zoom100.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.plugins.tools.ZoomOut"/>
  <class type="dojox.drawing.plugins.tools.ZoomOut.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="__StencilData">
    <properties>
      <property name="cx" scope="instance" type="Number">
        <description>Center point x</description>
      </property>
      <property name="cy" scope="instance" type="Number">
        <description>Center point y</description>
      </property>
      <property name="rx" scope="instance" type="Number">
        <description>Horizontal radius</description>
      </property>
      <property name="ry" scope="instance" type="Number">
        <description>Vertical radius</description>
      </property>
    </properties>
  </class>
  <class type="dojox.drawing.stencil">
    <properties>
      <property name="Ellipse" scope="instance" type="Object"/>
      <property name="Image" scope="instance" type="Object"/>
      <property name="Line" scope="instance" type="Object"/>
      <property name="Path" scope="instance" type="Object"/>
      <property name="Rect" scope="instance" type="Object"/>
      <property name="Text" scope="instance" type="Object"/>
      <property name="_Base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="StencilArgs">
    <properties>
      <property name="container" scope="instance" type="dojo.gfx.group">
        <description>The parent shape that contains all
	shapes used in a Stencil</description>
      </property>
      <property name="anchorType" scope="instance" type="String">
        <description>Optionally blank or 'group'. 'group' tells
	an anchor point that it must constrain
	itself to other anchor points.</description>
      </property>
      <property name="isText" scope="instance" type="Boolean">
        <description>Whether this is a text object or not
	(either stencil.text or tools.TextBlock)</description>
      </property>
      <property name="shortType" scope="instance" type="String">
        <description>The type of stencil that corresponds with the types and
	constructors used in Drawing.registerTool</description>
      </property>
      <property name="annotation" scope="instance" type="Boolean">
        <description>A Stencil used within a Stencil. An annotation
	is not selectable or clickable. A Label would
	be one example.</description>
      </property>
      <property name="subShape" scope="instance" type="Boolean">
        <description>A Stencil used within a Stencil. A subShape
	is clickable. An arrow head would be an example.</description>
      </property>
      <property name="style" scope="instance" type="Object">
        <description>An instance of the styles and defaults used within
	the Stencil.</description>
      </property>
      <property name="util" scope="instance" type="Object">
        <description>Pointer to util.common</description>
      </property>
      <property name="mouse" scope="instance" type="Object">
        <description>Pointer to the mouse instance</description>
      </property>
      <property name="keys" scope="instance" type="Object">
        <description>Pointer to the keys class</description>
      </property>
      <property name="points" scope="instance" type="StencilPoints">
        <description>Points is an array of objects that make up the
	description of a Stencil. The points to a Rect
	that is 100x100 and at x:10 and y:10 would look like:
	[{x:10,y:10}, {x:110, y:10}, {x:110, y:110}, {x:10, y:110}]
	Points go clockwise from the top left. In the case of Paths,
	they would go in the order that the Stencil would be drawn.
	Always when the points Array is set, a data Object is created
	as well. So never set points directly, always use setPoints().
	See:
	setPoints()</description>
      </property>
      <property name="data" scope="instance" type="StencilData">
        <description>A data object typically (but not always) resembles the data
	that is used to create the dojox.gfx Shape. The same Rect
	example shown in points above would look like:
	{x:10, y:10, width:100, height:100}
	And an Ellipse with the same coordinates:
	{cx:55, cy:55, rx:50, ry:50}
	The only Stencil that does not support data (at this time)
	is the Path. While x1,x2,x3... culd be used in a data object
	it doesn't provide much benefit.
	Always when a data object is set, a set of points is created
	as well. So never set data directly, always use setData().
	See:
	setData()
	marginZero [readonly] Number
	How closely shape can get to y:0 or x:0. Less than zero has
	bugs in VML. This is set with defaults, and should be equal
	to half the size of an anchor point (5 px)
	created [readonly] Boolean
	Whether the Stencil has been rendered for the first time or
	not.
	highlighted [readonly] Boolean
	Whether the Stencil is highlighted or not.
	selected [readonly] Boolean
	Whether the Stencil is selected or not.
	draws [readonly] Boolean
	Whether the Stencil can draw with a mouse drag or can just
	be created programmtically. If the Stencil comes from the
	stencil package, it should be draw:false. If it comes from
	the tools package it should be draw:true.</description>
      </property>
      <property name="marginZero" scope="instance" type="Number"/>
      <property name="created" scope="instance" type="bool"/>
      <property name="highlighted" scope="instance" type="bool"/>
      <property name="selected" scope="instance" type="bool"/>
      <property name="draws" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools"/>
  <class type="dojox.drawing.tools.Arrow"/>
  <class type="dojox.drawing.tools.Arrow.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Ellipse"/>
  <class type="dojox.drawing.tools.Ellipse.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Line"/>
  <class type="dojox.drawing.tools.Line.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Path"/>
  <class type="dojox.drawing.tools.Path.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Pencil"/>
  <class type="dojox.drawing.tools.Pencil.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.Rect"/>
  <class type="dojox.drawing.tools.Rect.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.TextBlock"/>
  <class type="dojox.drawing.tools.TextBlock.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom"/>
  <class type="dojox.drawing.tools.custom.Axes"/>
  <class type="dojox.drawing.tools.custom.Axes.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Equation"/>
  <class type="dojox.drawing.tools.custom.Equation.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Vector"/>
  <class type="dojox.drawing.tools.custom.Vector.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Vector.setup.secondary">
    <description>See Toolbar.js makeButtons function.  The toolbar
	checks Vector.setup for a secondary tool and requires
	name, label, and funct.  Currently it doesn't accept icon
	and only uses text from label for the button.  Funct is the
	function that fires when the button is clicked.
	Setup and postSetup are optional
	and allow tool specific functions to be added to the
	Toolbar object as if they were written there.</description>
    <methods>
      <method name="postSetup" scope="instance">
        <parameters>
          <parameter name="btn" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Vector.setup.secondary.funct">
    <methods/>
  </class>
  <class type="dojox.drawing.tools.custom.Vector.setup.secondary.funct.drawing.stencils">
    <properties>
      <property name="selectedStencils" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.tools.custom.Vector.setup.secondary.setup">
    <methods>
      <method name="zSelect" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zDeselect" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="vectorTest" scope="instance"/>
    </methods>
    <properties>
      <property name="zSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui">
    <properties>
      <property name="Button" scope="instance" type="Object"/>
      <property name="Tooltip" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui.Toolbar">
    <description>Creates a GFX-based toobar that holds GFX-based buttons. Can be either created
	within the actual drawing or within a seperate DOM element. When within the
	drawing, the toolbar will cover a portion of the drawing; hence the option.
	A Toolbar can be created programmtically or in markup. Currently markup is as
	a separate DOM element and programmtic is within the drawing.
	examples:
		dojo.connect(myDrawing, "onSurfaceReady", function(){
			new dojox.drawing.ui.Toolbar({
				drawing:myDrawing,
				tools:"all",
				plugs:"all",
				selected:"ellipse"
			});
		});
	 &lt;div dojoType="dojox.drawing.ui.Toolbar" id="gfxToolbarNode" drawingId="drawingNode"
			class="gfxToolbar" tools="all" plugs="all" selected="ellipse" orient="H"&gt;&lt;/div&gt;</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeButtons" scope="instance"/>
      <method name="onRenderStencil" scope="instance">
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addTool" scope="instance"/>
      <method name="addPlugin" scope="instance"/>
      <method name="addBack" scope="instance"/>
      <method name="onToolClick" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlugClick" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixprops" scope="instance">
        <parameters>
          <parameter name="props" type="Array" usage="required"/>
          <parameter name="objNode" type="Object" usage="required">
            <description>| Node</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="padding" scope="instance" type="Number">
        <description>The amount of spce between the top and left of the toolbar and the buttons.</description>
      </property>
      <property name="margin" scope="instance" type="Number">
        <description>The space between each button.</description>
      </property>
      <property name="size" scope="instance" type="Number">
        <description>The width and height of the button</description>
      </property>
      <property name="radius" scope="instance" type="Number">
        <description>The size of the button's rounded corner</description>
      </property>
      <property name="toolPlugGap" scope="instance" type="number">
        <description>The distnce between the tool buttons and plug buttons</description>
      </property>
      <property name="strSelected" scope="instance-prototype" type="Object"/>
      <property name="strTools" scope="instance-prototype" type="Object"/>
      <property name="strPlugs" scope="instance-prototype" type="Object"/>
      <property name="buttons" scope="instance" type="Array"/>
      <property name="plugins" scope="instance" type="Array"/>
      <property name="selected" scope="instance" type="Object"/>
      <property name="util" scope="instance" type="Object"/>
      <property name="toolDrawing" scope="instance" type="Object"/>
      <property name="drawing" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="orient" scope="instance" type="Object"/>
      <property name="horizontal" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui.dom">
    <properties>
      <property name="Zoom" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui.dom.Pan"/>
  <class type="dojox.drawing.ui.dom.Pan.setup">
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="tooltip" scope="instance" type="String"/>
      <property name="iconClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.drawing.ui.dom.Toolbar">
    <description>Currently works in markup only. A class is required with
	either horizontal or vertical as a class (IE prevented using
	either as a default). Assign an attribute of 'drawingId' with
	the id of the DojoX Drawing to which this is assigned.
	The node children will be assigned as the Tools in the toolbar.
	Plugins can also be assigned.
	The Toolbar is largely self contained and has no real public
	methods or events. the Drawing object should be used.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createIcon" scope="instance">
        <parameters>
          <parameter name="node" type="HTMLNode" usage="required">
            <description>The button node.</description>
          </parameter>
          <parameter name="constr" type="Object" usage="required">
            <description>Function Optional. If not supplied, an icon is not created.
	Information for each icon is derived from
	the ToolsSetup object defined at the end
	of each tool. See: stencil._Base</description>
          </parameter>
        </parameters>
      </method>
      <method name="createTool" scope="instance">
        <parameters>
          <parameter name="node" type="HTMLNode" usage="required">
            <description>The button node.</description>
          </parameter>
        </parameters>
      </method>
      <method name="parse" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>Fully qualified name of class. ex:
	dojox.drawing.tools.Ellipse</description>
          </parameter>
        </parameters>
      </method>
      <method name="onSetTool" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="baseClass" scope="instance" type="String">
        <description>The CSS style to apply to the toolbar node</description>
      </property>
      <property name="buttonClass" scope="instance" type="String">
        <description>The CSS style to apply to each button node</description>
      </property>
      <property name="iconClass" scope="instance" type="String">
        <description>The CSS style to apply to each button icon node</description>
      </property>
      <property name="drawing" scope="instance" type="Object"/>
      <property name="toolNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.util"/>
  <class type="dojox.drawing.util.common">
    <methods>
      <method name="radToDeg" scope="instance">
        <parameters>
          <parameter name="n" type="Numer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="degToRad" scope="instance">
        <parameters>
          <parameter name="n" type="Numer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="angle" scope="instance">
        <parameters>
          <parameter name="obj" type="EventObject" usage="required">
            <description>Manager.Mouse event.</description>
          </parameter>
          <parameter name="snap" type="Object" usage="required">
            <description>Float Returns nearest angle within snap limits
	obj = this.argsToObj.apply(this, arguments);</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="oppAngle" scope="instance">
        <parameters>
          <parameter name="ang" type="Angle" usage="required"/>
        </parameters>
      </method>
      <method name="radians" scope="instance">
        <parameters>
          <parameter name="o" type="EventObject" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="instance">
        <parameters>
          <parameter name="o" type="EventObject" usage="required"/>
        </parameters>
      </method>
      <method name="lineSub" scope="instance">
        <description>x1,y1,x2,y2 represents the Line. 'amt' represents the amount
	to subtract from it.</description>
        <parameters>
          <parameter name="x1" type="Number" usage="required"/>
          <parameter name="y1" type="Number" usage="required"/>
          <parameter name="x2" type="Number" usage="required"/>
          <parameter name="y2" type="Number" usage="required"/>
          <parameter name="amt" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="argsToObj" scope="instance"/>
      <method name="distance" scope="instance">
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="slope" scope="instance">
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="pointOnCircle" scope="instance">
        <parameters>
          <parameter name="cx" type="Number" usage="required"/>
          <parameter name="cy" type="Number" usage="required"/>
          <parameter name="radius" type="Number" usage="required"/>
          <parameter name="angle" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="constrainAngle" scope="instance">
        <parameters>
          <parameter name="obj" type="EventObject" usage="required"/>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="snapAngle" scope="instance">
        <parameters>
          <parameter name="obj" type="EventObject" usage="required">
            <description>Mouse object (see dojox.drawing.Mouse)</description>
          </parameter>
          <parameter name="ca" type="Float" usage="required">
            <description>Fractional amount to snap to
	A decimal number fraction of a half circle
	.5 would snap to 90 degrees
	.25  would snap to 45 degrees
	.125 would snap to 22.5 degrees, etc.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="idSetStart" scope="instance">
        <parameters>
          <parameter name="num" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uid" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required">
            <description>String If provided, kept in a map, incremented
	and used in the id. Otherwise 'shape' is used.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="abbr" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mixin" scope="instance">
        <parameters>
          <parameter name="o1" type="Object" usage="required"/>
          <parameter name="o2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="byId" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="prop" type="property" usage="required"/>
          <parameter name="value" type="Object" usage="required">
            <description>value</description>
          </parameter>
          <parameter name="squelchErrors" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="objects" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.drawing.util.oo">
    <description>Inheritance utilities used in DojoX Drawing.
	There were designed in a effort to make Drawing as
	fast as possible - especially in a case where thousands
	of objects are being loaded. Drawing declare performs
	about 3 times faster than Dojo declare and 2 times
	faster than Dojox declare. This is not to say Drawing
	declare is wthout limitations. It doesn't have the same
	syntatic sugar and extensibility of the other two. You
	can't inhert methods. It won't work with Dijit. But it
	is simple and effective.</description>
    <methods>
      <method name="declare" scope="instance">
        <description>Similar in look and feel to Dojo declare as
	far as order and number of arguments, although
	constructed a little closer to prototypical
	inheritance. All arguments passed into the
	constructor are passed into all sub constructors.
	arguments:
	Function, [Object|Function....]
	The first argument is always the base
	constructor. The last argument is always
	an object of methods (or empty object) to
	be mixed in (in the future would like to
	make that object optional). Remaining
	arguments are other constructors mixed in
	using extend() (See below).</description>
        <examples>
          <example>	MyFunction = dojox.drawing.util.oo.declare(
			MyOtherFunction,
			YetAnotherFunction,
			function(options){
				// This is my constructor. It will fire last.
				// The other constructors will fire before this.
			},
			{
				customType:"equation", // mixed in property
				doThing: function(){   // mixed in method
				}
			}
		);
		var f = new MyFunction();</example>
        </examples>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="extend" scope="instance">
        <description>Typically not used by itself - it's used as
	part of declare(). Could be used by itself
	however, to mix together two or more
	constructors.
	arguments:
	Function, [ Function...]
	Any number of arguments, all must be
	function constructors. The first is
	considered the base object and its
	constructor will fire first.</description>
        <examples>
          <example>	var A = function(){};
		var B = function(){};
		var C = function(){};
		var D = dojox.drawing.util.oo.extend(A, B, C);
		var e = new D();</example>
        </examples>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.util.positioning">
    <methods>
      <method name="label" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="angle" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.drawing.util.typeset">
    <methods>
      <method name="convertHTML" scope="instance">
        <parameters>
          <parameter name="inText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="convertLaTeX" scope="instance">
        <parameters>
          <parameter name="inText" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl">
    <methods>
      <method name="quickFilter" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="TOKEN_BLOCK" scope="instance" type="Number"/>
      <property name="TOKEN_VAR" scope="instance" type="Number"/>
      <property name="TOKEN_COMMENT" scope="instance" type="Number"/>
      <property name="TOKEN_TEXT" scope="instance" type="Number"/>
      <property name="_Context" scope="instance" type="Object"/>
      <property name="Template" scope="instance" type="Object"/>
      <property name="_QuickNodeList" scope="instance" type="Object"/>
      <property name="_Filter" scope="instance" type="Object"/>
      <property name="_TextNode" scope="instance" type="Object"/>
      <property name="_Node" scope="instance" type="Object"/>
      <property name="_NodeList" scope="instance" type="Object"/>
      <property name="_VarNode" scope="instance" type="Object"/>
      <property name="_Parser" scope="instance" type="Object"/>
      <property name="mark_safe" scope="instance" type="Object"/>
      <property name="TOKEN_CHANGE" scope="instance" type="Number"/>
      <property name="TOKEN_ATTR" scope="instance" type="Number"/>
      <property name="TOKEN_CUSTOM" scope="instance" type="Number"/>
      <property name="TOKEN_NODE" scope="instance" type="Number"/>
      <property name="DomTemplate" scope="instance" type="Object"/>
      <property name="DomBuffer" scope="instance" type="Object"/>
      <property name="_DomNode" scope="instance" type="Object"/>
      <property name="_DomNodeList" scope="instance" type="Object"/>
      <property name="_DomVarNode" scope="instance" type="Object"/>
      <property name="ChangeNode" scope="instance" type="Object"/>
      <property name="AttributeNode" scope="instance" type="Object"/>
      <property name="_DomTextNode" scope="instance" type="Object"/>
      <property name="_DomParser" scope="instance" type="Object"/>
      <property name="HtmlTemplate" scope="instance" type="Object"/>
      <property name="html" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Context" superclass="dojox.dtl._Context.prototype">
    <methods>
      <method name="getKeys" scope="instance"/>
      <method name="extend" scope="instance">
        <parameters>
          <parameter name="obj" type="dojox.dtl.Context|Object" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="filter" type="dojox.dtl.Context|Object|String" usage="one-or-more"/>
        </parameters>
      </method>
      <method name="getThis" scope="instance"/>
      <method name="hasKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_this" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Context.setThis">
    <methods/>
    <properties>
      <property name="_this" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.DomInline" superclass="dijit._Widget.prototype">
    <methods/>
    <properties>
      <property name="context" scope="instance" type="Object"/>
      <property name="declaredClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.dtl.DomInline.render">
    <methods/>
    <properties>
      <property name="context" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.DomInline.buildRendering">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="template" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.DomInline.postMixInProperties">
    <methods/>
    <properties>
      <property name="context" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.HtmlInline">
    <properties>
      <property name="declaredClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.dtl.Inline" superclass="dijit._Widget.prototype">
    <methods/>
    <properties>
      <property name="context" scope="instance" type="Object"/>
      <property name="declaredClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.dtl.Inline.render">
    <methods/>
    <properties>
      <property name="context" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Inline.render.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Inline.buildRendering">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="template" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Inline.postMixInProperties">
    <methods/>
    <properties>
      <property name="context" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomTemplated">
    <methods>
      <method name="_getContext" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_dijitTemplateCompat" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomTemplated.buildRendering">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="template" scope="instance" type="Object"/>
      <property name="_render" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomTemplated.setTemplate">
    <methods/>
    <properties>
      <property name="template" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomTemplated.render">
    <methods/>
    <properties>
      <property name="template" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._DomTemplated._getCachedTemplate">
    <methods/>
    <properties>
      <property name="_templates" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib">
    <properties>
      <property name="html" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.dijit">
    <methods>
      <method name="dojoAttachPoint" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dojoAttachEvent" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dojoType" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="on" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="AttachNode" scope="instance" type="Object"/>
      <property name="EventNode" scope="instance" type="Object"/>
      <property name="DojoTypeNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl._HtmlTemplated">
    <properties>
      <property name="declaredClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.dtl._Templated" superclass="dijit._Templated">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="getCachedTemplate" scope="instance">
        <parameters>
          <parameter name="templatePath" type="Object" usage="required"/>
          <parameter name="templateString" type="Object" usage="required"/>
          <parameter name="alwaysUseString" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="startup" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="_dijitTemplateCompat" scope="instance" type="bool"/>
      <property name="_template" scope="instance" type="Object"/>
      <property name="_startupWidgets" scope="instance" type="Object"/>
      <property name="_supportingWidgets" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_templateCache" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.parser">
    <properties>
      <property name="_query" scope="instance" type="String"/>
      <property name="_attrName" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.dtl.Token">
    <methods>
      <method name="split" scope="instance"/>
      <method name="split_contents" scope="instance">
        <parameters>
          <parameter name="limit" type="Integer" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="token_type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.Token.contents">
    <properties>
      <property name="split" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.text">
    <methods>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="module" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="errorless" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTag" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="errorless" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFilter" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="errorless" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplate" scope="instance">
        <parameters>
          <parameter name="file" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplateString" scope="instance">
        <parameters>
          <parameter name="file" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveLazy" scope="instance">
        <parameters>
          <parameter name="location" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
          <parameter name="json" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveTemplateArg" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isTemplate" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveContextArg" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
          <parameter name="sync" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tokenize" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parseDelims" scope="instance">
        <parameters>
          <parameter name="varr" type="Object" usage="required"/>
          <parameter name="load" type="Object" usage="required"/>
          <parameter name="tag" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_re" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojox.dtl._noOpNode">
    <methods>
      <method name="render" scope="instance"/>
      <method name="unrender" scope="instance"/>
      <method name="clone" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.dtl.register">
    <methods>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributeTags" scope="instance"/>
      <method name="_any" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="base" type="Object" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tags" scope="instance">
        <parameters>
          <parameter name="base" type="String" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filters" scope="instance">
        <parameters>
          <parameter name="base" type="String" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.register._registry">
    <properties>
      <property name="attributes" scope="instance" type="Array"/>
      <property name="tags" scope="instance" type="Array"/>
      <property name="filters" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.dtl._base">
    <methods>
      <method name="escape" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="safe" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.contrib.data">
    <methods>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bind_data" scope="instance">
        <examples>
          <example>`contextItems` and `contextStore` should be an item list
	and a data store that get assigned to `newVariable`
		{% bind_data contextItems to contextStore as newVariable %}</example>
        </examples>
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bind_query" scope="instance">
        <examples>
          <example>You can only use this with data stores that work in a synchronous
	way (meaning that `onComplete` is fired during the `fetch` call).
	A `sync` flag is sent to the fetch call so that stores that usually
	work asynchronously make themselves syncrhonous if possible.
		{% bind_query contextQuery to contextStore as newVariable %}</example>
        </examples>
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_BoundItem" scope="instance" type="Object"/>
      <property name="BindDataNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.data._BoundItem.get">
    <properties>
      <property name="safe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.dom">
    <methods>
      <method name="buffer" scope="instance">
        <description>When using DomTemplate, wrap any content
	that you expect to change often during
	re-rendering. It will then remove its parent
	from the main document while it re-renders that
	section of code. It will only remove it from
	the main document if a mainpulation of somes sort
	happens. ie It won't swap out if it diesn't have to.</description>
        <examples>
          <example>By default, it considers only node addition/removal
	to be "changing"
		{% buffer %}{% for item in items %}&lt;li&gt;{{ item }}&lt;/li&gt;{% endfor %}{% endbuffer %}</example>
          <example>You can explicitly declare options:
	* node: Watch node removal/addition
	* class: Watch for a classname to be changed
	* text: Watch for any text to be changed
		{% buffer node class %}{% for item in items %}&lt;li&gt;{{ item }}&lt;/li&gt;{% endfor %}{% endbuffer %}</example>
        </examples>
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="html" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="style_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="StyleNode" scope="instance" type="Object"/>
      <property name="BufferNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.contrib.objects">
    <methods>
      <method name="key" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.BOOLS">
    <properties>
      <property name="checked" scope="instance" type="Number"/>
      <property name="disabled" scope="instance" type="Number"/>
      <property name="readonly" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.dtl.dom">
    <methods>
      <method name="tokenize" scope="instance">
        <parameters>
          <parameter name="nodes" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_tokenize" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="tokens" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="__tokenize" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="tokens" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_attributes" scope="instance" type="Object"/>
      <property name="_uppers" scope="instance" type="Object"/>
      <property name="_re4" scope="instance" type="RegExp"/>
      <property name="_reTrim" scope="instance" type="RegExp"/>
      <property name="_reSplit" scope="instance" type="RegExp"/>
      <property name="_swallowed" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.dtl.dom.getTemplate">
    <methods/>
    <properties>
      <property name="_commentable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.ext-dojo">
    <properties>
      <property name="NodeList" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.dates">
    <methods>
      <method name="_toDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="date" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="time" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="timesince" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="timeuntil" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter"/>
  <class type="dojox.dtl.filter.htmlstrings">
    <methods>
      <method name="linebreaks" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="linebreaksbr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removetags" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="striptags" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_linebreaksrn" scope="instance" type="RegExp"/>
      <property name="_linebreaksn" scope="instance" type="RegExp"/>
      <property name="_linebreakss" scope="instance" type="RegExp"/>
      <property name="_linebreaksbr" scope="instance" type="RegExp"/>
      <property name="_removetagsfind" scope="instance" type="RegExp"/>
      <property name="_striptags" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.integers">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get_digit" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.lists">
    <methods>
      <method name="_dictsort" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dictsort" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dictsortreversed" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="first" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="join" scope="instance">
        <description>Django throws a compile error, but JS can't do arg checks
	so we're left with run time errors, which aren't wise for something
	as trivial here as an empty arg.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length_is" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="random" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slice" scope="instance">
        <description>Uses the same syntax as Python's list slicing; see
	http://diveintopython.org/native_data_types/lists.html#odbchelper.list.slice
	for an introduction.
	Also uses the optional third value to denote every X item.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unordered_list" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="tabs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unordered_list" scope="instance">
        <description>The list is assumed to be in the proper format. For example, if ``var`` contains
	``['States', [['Kansas', [['Lawrence', []], ['Topeka', []]]], ['Illinois', []]]]``,
	then ``{{ var|unordered_list }}`` would return::
		&lt;li&gt;States
		&lt;ul&gt;
			&lt;li&gt;Kansas
			&lt;ul&gt;
				&lt;li&gt;Lawrence&lt;/li&gt;
				&lt;li&gt;Topeka&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
			&lt;li&gt;Illinois&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.logic">
    <methods>
      <method name="default_" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="default_if_none" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="divisibleby" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="yesno" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_yesno" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.misc">
    <methods>
      <method name="filesizeformat" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pluralize" scope="instance">
        <description>By default, 's' is used as a suffix; if an argument is provided, that string
	is used instead. If the provided argument contains a comma, the text before
	the comma is used for the singular case.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="phone2numeric" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pprint" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.filter.misc._phone2numeric">
    <properties>
      <property name="a" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="c" scope="instance" type="Number"/>
      <property name="d" scope="instance" type="Number"/>
      <property name="e" scope="instance" type="Number"/>
      <property name="f" scope="instance" type="Number"/>
      <property name="g" scope="instance" type="Number"/>
      <property name="h" scope="instance" type="Number"/>
      <property name="i" scope="instance" type="Number"/>
      <property name="j" scope="instance" type="Number"/>
      <property name="k" scope="instance" type="Number"/>
      <property name="l" scope="instance" type="Number"/>
      <property name="m" scope="instance" type="Number"/>
      <property name="n" scope="instance" type="Number"/>
      <property name="o" scope="instance" type="Number"/>
      <property name="p" scope="instance" type="Number"/>
      <property name="r" scope="instance" type="Number"/>
      <property name="s" scope="instance" type="Number"/>
      <property name="t" scope="instance" type="Number"/>
      <property name="u" scope="instance" type="Number"/>
      <property name="v" scope="instance" type="Number"/>
      <property name="w" scope="instance" type="Number"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.strings">
    <methods>
      <method name="_urlquote" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="safe" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="addslashes" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="capfirst" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="center" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cut" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fix_ampersands" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="floatformat" scope="instance">
        <description>If called without an argument, displays a floating point
	number as 34.2 -- but only if there's a point to be displayed.
	With a positive numeric argument, it displays that many decimal places
	always.
	With a negative numeric argument, it will display that many decimal
	places -- but only if there's places to be displayed.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iriencode" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="linenumbers" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ljust" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="lower" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="make_list" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rjust" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slugify" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="stringformat" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="title" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="truncatewords" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Integer" usage="required">
            <description>Number of words to truncate after</description>
          </parameter>
        </parameters>
      </method>
      <method name="truncatewords_html" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="upper" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlencode" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlize" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlizetrunc" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="' + middle + '&quot; rel=&quot;nofollow&quot;&gt;' + trimmed + '&lt;/a&gt;'"/>
        </return-types>
      </method>
      <method name="wordcount" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wordwrap" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_fix_ampersands" scope="instance" type="RegExp"/>
      <property name="_strings" scope="instance" type="Object"/>
      <property name="_truncatewords" scope="instance" type="RegExp"/>
      <property name="_truncate_words" scope="instance" type="RegExp"/>
      <property name="_truncate_tag" scope="instance" type="RegExp"/>
      <property name="_urlize" scope="instance" type="RegExp"/>
      <property name="_urlize2" scope="instance" type="RegExp"/>
    </properties>
  </class>
  <class type="dojox.dtl.filter.strings._truncate_singlets">
    <properties>
      <property name="br" scope="instance" type="Object"/>
      <property name="col" scope="instance" type="Object"/>
      <property name="link" scope="instance" type="Object"/>
      <property name="base" scope="instance" type="Object"/>
      <property name="img" scope="instance" type="Object"/>
      <property name="param" scope="instance" type="Object"/>
      <property name="area" scope="instance" type="Object"/>
      <property name="hr" scope="instance" type="Object"/>
      <property name="input" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.render.dom"/>
  <class type="dojox.dtl.render.dom.Render">
    <methods/>
    <properties>
      <property name="_tpl" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.render.dom.Render.setAttachPoint">
    <methods/>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.render.dom.Render.render">
    <methods/>
    <properties>
      <property name="_tpl" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.render"/>
  <class type="dojox.dtl.render.html">
    <properties>
      <property name="Render" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.date">
    <methods>
      <method name="now" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.tag.date.NowNode">
    <methods>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_format" scope="instance" type="Object"/>
      <property name="format" scope="instance" type="Object"/>
      <property name="contents" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag"/>
  <class type="dojox.dtl.tag.loader">
    <methods>
      <method name="block" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="extends_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="include" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ssi" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="BlockNode" scope="instance" type="Object"/>
      <property name="ExtendsNode" scope="instance" type="Object"/>
      <property name="IncludeNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.logic">
    <methods>
      <method name="if_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ifequal" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
          <parameter name="negate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ifequal" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ifnotequal" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="for_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="IfNode" scope="instance" type="Object"/>
      <property name="IfEqualNode" scope="instance" type="Object"/>
      <property name="ForNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.loop">
    <methods>
      <method name="cycle" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ifchanged" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="regroup" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="CycleNode" scope="instance" type="Object"/>
      <property name="IfChangedNode" scope="instance" type="Object"/>
      <property name="RegroupNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.tag.misc">
    <methods>
      <method name="comment" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="debug" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="firstof" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="spaceless" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="templatetag" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="widthratio" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="with_" scope="instance">
        <parameters>
          <parameter name="parser" type="Object" usage="required"/>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="DebugNode" scope="instance" type="Object"/>
      <property name="FilterNode" scope="instance" type="Object"/>
      <property name="FirstOfNode" scope="instance" type="Object"/>
      <property name="SpacelessNode" scope="instance" type="Object"/>
      <property name="TemplateTagNode" scope="instance" type="Object"/>
      <property name="WidthRatioNode" scope="instance" type="Object"/>
      <property name="WithNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.dtl.utils.date">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="timesince" scope="instance">
        <description>Adapted from http://blog.natbat.co.uk/archive/2003/Jun/14/time_since</description>
        <parameters>
          <parameter name="d" type="Object" usage="required"/>
          <parameter name="now" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_chunks" scope="instance" type="Array"/>
      <property name="_months_ap" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.dtl.utils.date.DateFormat" superclass="dojox.date.php.DateFormat.prototype">
    <methods>
      <method name="f" scope="instance">
        <description>Examples: '1', '1:30', '2:05', '2'
	Proprietary extension.</description>
      </method>
      <method name="N" scope="instance"/>
      <method name="P" scope="instance">
        <description>Examples: '1 a.m.', '1:30 p.m.', 'midnight', 'noon', '12:30 p.m.'
	Proprietary extension.</description>
      </method>
    </methods>
  </class>
  <class type="dojox.dtl.utils"/>
  <class type="dojox.editor.plugins"/>
  <class type="dojox.editor.plugins._AutoSaveSettingDialog" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="onOk" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onChange" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required">
            <description>The invertal value</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_isValidValue" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="dialogTitle" scope="instance" type="String"/>
      <property name="dialogDescription" scope="instance" type="String"/>
      <property name="paramName" scope="instance" type="String"/>
      <property name="paramLabel" scope="instance" type="String"/>
      <property name="btnOk" scope="instance" type="String"/>
      <property name="btnCancel" scope="instance" type="String"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="dialogId" scope="instance" type="String"/>
      <property name="textBoxId" scope="instance" type="String"/>
      <property name="_value" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.AutoSave" superclass="dojox.editor.plugins.Save">
    <methods>
      <method name="_setIntervalAttr" scope="instance">
        <parameters>
          <parameter name="val" type="The" usage="required">
            <description>interval value.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getIntervalAttr" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="_showAutSaveSettingDialog" scope="instance"/>
      <method name="_onDialogOk" scope="instance"/>
      <method name="_onStopClick" scope="instance"/>
      <method name="_setSaveInterval" scope="instance">
        <parameters>
          <parameter name="interval" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_clearSaveInterval" scope="instance"/>
      <method name="onSuccess" scope="instance">
        <parameters>
          <parameter name="resp" type="The" usage="required">
            <description>response from the server, if any, in text format.</description>
          </parameter>
          <parameter name="ioargs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="error" type="Object" usage="required"/>
          <parameter name="ioargs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.Save" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance" type="String"/>
      <property name="logResults" scope="instance" type="Object"/>
      <property name="interval" scope="instance" type="Number"/>
      <property name="_iconClassPrefix" scope="instance" type="String"/>
      <property name="_MIN" scope="instance" type="Number"/>
      <property name="editor" scope="instance" type="Object"/>
      <property name="_strings" scope="instance" type="Object"/>
      <property name="_saveSettingDialog" scope="instance" type="Object"/>
      <property name="_promDialog" scope="instance" type="Object"/>
      <property name="_menuItemAutoSave" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_menuItemAutoSaveClickHandler" scope="instance" type="Object"/>
      <property name="_intervalHandler" scope="instance" type="Object"/>
      <property name="_promDialogTimeout" scope="instance" type="Object"/>
      <property name="_isWorking" scope="instance" type="bool"/>
      <property name="_destroyRecursive" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor"/>
  <class type="dojox.editor.plugins.AutoUrlLink" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required">
            <description>The editor it belongs to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_keyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="The" usage="required">
            <description>keypress event object.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_recognize" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_inLink" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to be examed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_findLastEditingNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The current node that the cursor is at.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_findUrls" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="bm" type="DomNode" usage="required"/>
          <parameter name="bmOff" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_template" scope="instance" type="String"/>
      <property name="_saved" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.AutoUrlLink.editor">
    <properties>
      <property name="editNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Blockquote" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_toggleQuote" scope="instance">
        <parameters>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="_findBlockQuotes" scope="instance">
        <parameters>
          <parameter name="nodeList" type="The" usage="required">
            <description>list of nodes.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getTagName" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to look at.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isRootInline" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to start at.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isTextElement" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to check.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to check.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isInlineFormat" scope="instance">
        <parameters>
          <parameter name="tag" type="The" usage="required">
            <description>tag to examine</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="instance" type="String">
        <description>The CSS class name for the button node icon.</description>
      </property>
      <property name="_nlsResources" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._BreadcrumbMenuTitle" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setMenuTitleAttr" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMenuTitleAttr" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="menuTitle" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._BreadcrumbMenuTitle.title">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Breadcrumb" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_selectContents" scope="instance"/>
      <method name="_deleteContents" scope="instance"/>
      <method name="_selectElement" scope="instance"/>
      <method name="_deleteElement" scope="instance"/>
      <method name="_moveCToStart" scope="instance"/>
      <method name="_moveCToEnd" scope="instance"/>
      <method name="_updateBreadcrumb" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_menu" scope="instance" type="The">
        <description>popup menu that is displayed.</description>
      </property>
      <property name="breadcrumbBar" scope="instance" type="The">
        <description>toolbar containing the breadcrumb.</description>
      </property>
      <property name="editor" scope="instance" type="Object"/>
      <property name="_buttons" scope="instance" type="Object"/>
      <property name="_titleTemplate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Breadcrumb.breadcrumbBar.domNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._CollapsibleToolbarButton" superclass="dijit._Widget">
    <methods>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="title" scope="instance" type="String"/>
      <property name="buttonClass" scope="instance" type="String"/>
      <property name="text" scope="instance" type="String"/>
      <property name="textClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.CollapsibleToolbar" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_constructContainer" scope="instance"/>
      <method name="_onClose" scope="instance">
        <parameters>
          <parameter name="e" type="The" usage="required">
            <description>click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onOpen" scope="instance">
        <parameters>
          <parameter name="e" type="The" usage="required">
            <description>click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_myWidgets" scope="instance" type="array">
        <description>Container for widgets I allocate that will need to be destroyed.</description>
      </property>
      <property name="editor" scope="instance" type="Object"/>
      <property name="openTd" scope="instance" type="Object"/>
      <property name="closeTd" scope="instance" type="Object"/>
      <property name="menu" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.CollapsibleToolbar.editor.header">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.CollapsibleToolbar.editor.footer">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EntityPalette" superclass="dijit._Widget">
    <description>Grid showing various entities, so the user can pick a certain entity.
	Can be used standalone, or as a popup.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="_onCellMouseEnter" scope="instance">
        <parameters>
          <parameter name="e" type="The" usage="required">
            <description>event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_setCurrent" scope="instance">
        <description>Removes highlight of the old entity, and highlights
	the new entity.</description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_displayDetails" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._PaletteMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._PaletteMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>The basic template used to render the palette.
	Should generally be over-ridden to define different classes.</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="showPreview" scope="instance" type="Boolean">
        <description>Whether the preview pane will be displayed, to show details about the selected entity.</description>
      </property>
      <property name="showCode" scope="instance" type="boolean">
        <description>Show the character code for the entity.</description>
      </property>
      <property name="showEntityName" scope="instance" type="bool"/>
      <property name="palette" scope="instance" type="String">
        <description>The symbol pallete to display.  The only current one is 'latin'.</description>
      </property>
      <property name="dyeClass" scope="instance" type="String"/>
      <property name="paletteClass" scope="instance" type="String"/>
      <property name="cellClass" scope="instance" type="String"/>
      <property name="_palette" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EntityPalette.previewNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EntityPalette.codeNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EntityPalette.entityNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EntityPalette.descNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.LatinEntity">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="alias" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_alias" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._FindReplaceCloseBox" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="onClick" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="btnId" scope="instance" type="String"/>
      <property name="widget" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._FindReplaceTextBox" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required">
            <description>The boolean value to indicate if the textbox should be disabled or not</description>
          </parameter>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>object passed to this handler</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="textId" scope="instance" type="String">
        <description>The id of the enhanced textbox</description>
      </property>
      <property name="label" scope="instance" type="String">
        <description>The label of the enhanced textbox</description>
      </property>
      <property name="toolTip" scope="instance" type="String"/>
      <property name="widget" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="disabled" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._FindReplaceCheckBox" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required">
            <description>The flag that indicates if the checkbox is disabled or not.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="checkId" scope="instance" type="String">
        <description>The id of the enhanced checkbox</description>
      </property>
      <property name="label" scope="instance" type="String">
        <description>The label of the enhanced checkbox</description>
      </property>
      <property name="tooltip" scope="instance" type="String">
        <description>The tooltip of the enhanced checkbox when the mouse is hovering it</description>
      </property>
      <property name="widget" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="disabled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._FindReplaceCheckBox.checkBox">
    <methods>
      <method name="isFocusable" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.editor.plugins._FindReplaceToolbar" superclass="dijit.Toolbar">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="_onToolbarEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The Event object
	tages:
	private</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Toolbar" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins.FindReplace" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="instance"/>
      <method name="_toggleFindReplace" scope="instance">
        <parameters>
          <parameter name="show" type="Boolean" usage="required">
            <description>Indicate if the toolbar is shown or not</description>
          </parameter>
          <parameter name="ignoreState" type="Boolean" usage="optional">
            <description>Indicate if the status should be ignored or not
	blurEditor:
	Indicate if the focus should be removed from the editor or not</description>
          </parameter>
          <parameter name="buttonDisabled" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_populateFindField" scope="instance"/>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="dijit.Toolbar" usage="required">
            <description>The current toolbar of the editor</description>
          </parameter>
        </parameters>
      </method>
      <method name="_checkButtons" scope="instance"/>
      <method name="_onFindKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onReplaceKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_find" scope="instance">
        <parameters>
          <parameter name="showMessage" type="Boolean" usage="optional">
            <description>Indicated whether the tooltip is shown or not when the search reaches the end</description>
          </parameter>
        </parameters>
        <return-description>Boolean indicating if the content was found or not.</return-description>
      </method>
      <method name="_replace" scope="instance">
        <parameters>
          <parameter name="showMessage" type="Boolean" usage="optional">
            <description>Indicate if the prompt message is shown or not when the replacement
	reaches the end</description>
          </parameter>
        </parameters>
        <return-description>Boolean indicating if the content was replaced or not.</return-description>
      </method>
      <method name="_replaceAll" scope="instance">
        <parameters>
          <parameter name="showMessage" type="Boolean" usage="optional">
            <description>Indicate if the prompt message is shown or not when the action is done.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_findText" scope="instance">
        <parameters>
          <parameter name="txt" type="String" usage="required">
            <description>The text to locate in the document.</description>
          </parameter>
          <parameter name="caseSensitive" type="Boolean" usage="required">
            <description>Whether or ot to search case-sensitively.</description>
          </parameter>
          <parameter name="backwards" type="Boolean" usage="required">
            <description>Whether or not to search backwards in the document.</description>
          </parameter>
        </parameters>
        <return-description>Boolean indicating if the content was found or not.</return-description>
      </method>
      <method name="_filterRegexp" scope="instance">
        <description>Returns a regular expression object that conforms to the defined conversion rules.
	For example:
	ca*   -&gt; /^ca.*$/
	*ca*  -&gt; /^.*ca.*$/
	*c\*a*  -&gt; /^.*c\*a.*$/
	*c\*a?*  -&gt; /^.*c\*a..*$/
	and so on.</description>
        <parameters>
          <parameter name="pattern" type="String" usage="required">
            <description>string A simple matching pattern to convert that follows basic rules:
	* Means match anything, so ca* means match anything starting with ca
	? Means match single character.  So, b?b will match to bob and bab, and so on.
	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	represented by \\ to be treated as an ordinary \ character instead of an escape.</description>
          </parameter>
          <parameter name="ignoreCase" type="Boolean" usage="required">
            <description>An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	By default, it is assumed case sensitive.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="RegExp"/>
        </return-types>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="buttonClass" scope="instance" type="Define">
        <description>the class of button the editor uses.</description>
      </property>
      <property name="iconClassPrefix" scope="instance" type="String">
        <description>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;</description>
      </property>
      <property name="button" scope="instance" type="The">
        <description>toggle button</description>
      </property>
      <property name="_frToolbar" scope="instance" type="The">
        <description>toolbar that contain all the entries and buttons</description>
      </property>
      <property name="_closeBox" scope="instance" type="The">
        <description>close button of the F/R toolbar</description>
      </property>
      <property name="_findField" scope="instance" type="The">
        <description>Find field of the F/R toolbar</description>
      </property>
      <property name="_replaceField" scope="instance" type="The">
        <description>Replace field of the F/R toolbar</description>
      </property>
      <property name="_findButton" scope="instance" type="The">
        <description>Find button of the F/R toolbar</description>
      </property>
      <property name="_replaceButton" scope="instance" type="The">
        <description>Replace button of the F/R toolbar</description>
      </property>
      <property name="_replaceAllButton" scope="instance" type="The">
        <description>ReplaceAll button of the F/R toolbar</description>
      </property>
      <property name="_caseSensitive" scope="instance" type="The">
        <description>case sensitive checkbox</description>
      </property>
      <property name="_backwards" scope="instance" type="The">
        <description>backwards checkbox</description>
      </property>
      <property name="_promDialog" scope="instance" type="The">
        <description>prompt message box that shows the user some messages
	such as the end of a search, the end of a replacement, etc.</description>
      </property>
      <property name="_promDialogTimeout" scope="instance" type="Object"/>
      <property name="_strings" scope="instance" type="The">
        <description>array that contains globalized strings</description>
      </property>
      <property name="_displayed" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.FindReplace.editor">
    <properties>
      <property name="window" scope="instance" type="Object"/>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.FindReplace._findButton.titleNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.FindReplace._replaceButton.titleNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.FindReplace._replaceAllButton.titleNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.InsertAnchor" superclass="dijit._editor._Plugin">
    <description>The command provided by this plugin is:
	* insertAnchor</description>
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_checkInput" scope="instance"/>
      <method name="_setup" scope="instance"/>
      <method name="getAnchorStyle" scope="instance"/>
      <method name="_applyStyles" scope="instance"/>
      <method name="_calcBaseUrl" scope="instance">
        <parameters>
          <parameter name="fullUrl" type="String" usage="required">
            <description>The full url to tear down to the base.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_checkValues" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Content being set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onCloseDialog" scope="instance"/>
      <method name="_getCurrentValues" scope="instance">
        <parameters>
          <parameter name="a" type="The" usage="required">
            <description>anchor/link to process for data for the dropdown.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_onOpenDialog" scope="instance"/>
      <method name="_onDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <description>The double-click event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_preDomFilter" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to search from.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_postDomFilter" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to search from.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="htmlTemplate" scope="instance" type="String">
        <description>String used for templating the HTML to insert at the desired point.</description>
      </property>
      <property name="iconClassPrefix" scope="instance" type="String">
        <description>The CSS class name for the button node icon.</description>
      </property>
      <property name="_template" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_uniqueId" scope="instance" type="Object"/>
      <property name="_anchorInput" scope="instance" type="Object"/>
      <property name="_textInput" scope="instance" type="Object"/>
      <property name="_setButton" scope="instance" type="Object"/>
      <property name="_styled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.InsertAnchor.editor">
    <properties>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.InsertEntity" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* insertEntity - inserts the selected HTML entity character</description>
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_preFilterEntities" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="required">
            <description>content passed in</description>
          </parameter>
        </parameters>
      </method>
      <method name="_postFilterEntities" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="required">
            <description>content passed in</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="instance" type="String">
        <description>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;</description>
      </property>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.LocalImage" superclass="dijit._editor.plugins.ImgLinkDialog">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="_initialFileUploader" scope="instance"/>
      <method name="_checkAndFixInput" scope="instance"/>
      <method name="_isValid" scope="instance"/>
      <method name="_cancelFileUpload" scope="instance"/>
      <method name="_checkAndSetValue" scope="instance"/>
      <method name="_setDialogStatus" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor.plugins.ImgLinkDialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="uploadable" scope="instance" type="bool"/>
      <property name="uploadUrl" scope="instance" type="String"/>
      <property name="baseImageUrl" scope="instance" type="String"/>
      <property name="fileMask" scope="instance" type="String"/>
      <property name="urlRegExp" scope="instance" type="Object"/>
      <property name="_fileUploader" scope="instance" type="Object"/>
      <property name="htmlFieldName" scope="instance" type="String"/>
      <property name="_isLocalFile" scope="instance" type="bool"/>
      <property name="_messages" scope="instance" type="Object"/>
      <property name="_cssPrefix" scope="instance" type="String"/>
      <property name="_closable" scope="instance" type="Object"/>
      <property name="linkDialogTemplate" scope="instance" type="Object"/>
      <property name="tag" scope="instance" type="String"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_uniqueId" scope="instance" type="Object"/>
      <property name="_urlInput" scope="instance" type="Object"/>
      <property name="_textInput" scope="instance" type="Object"/>
      <property name="_setButton" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.NormalizeIndentOutdent" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_queryCommandEnabled" scope="instance">
        <parameters>
          <parameter name="command" type="The" usage="required">
            <description>command passed in to check enablement.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_indentImpl" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_indentElement" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node who's content to indent.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Return the node that was indented"/>
        </return-types>
      </method>
      <method name="_outdentElement" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node who's content to outdent.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_outdentImpl" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_indentList" scope="instance">
        <parameters>
          <parameter name="listItem" type="The" usage="required">
            <description>list item to indent.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_outdentList" scope="instance">
        <parameters>
          <parameter name="listItem" type="The" usage="required">
            <description>list item to outdent.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isEmpty" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to check.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isIndentableElement" scope="instance">
        <parameters>
          <parameter name="tag" type="The" usage="required">
            <description>tag to check</description>
          </parameter>
        </parameters>
      </method>
      <method name="_convertIndent" scope="instance">
        <parameters>
          <parameter name="indent" type="The" usage="required">
            <description>indent amount to convert.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isLtr" scope="instance"/>
      <method name="_isInlineFormat" scope="instance">
        <parameters>
          <parameter name="tag" type="The" usage="required">
            <description>tag to examine</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getTagName" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to look at.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isRootInline" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to start at.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isTextElement" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to check.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="indentBy" scope="instance" type="number">
        <description>The amount to indent by.  Valid values are 1+.  This is combined with
	the indentUnits parameter to determine how much to indent or outdent
	by for regular text.  It does not affect lists.</description>
      </property>
      <property name="indentUnits" scope="instance" type="String">
        <description>The units to apply to the indent amount.  Usually 'px', but can also
	be em.</description>
      </property>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.NormalizeIndentOutdent.editor.document">
    <properties>
      <property name="body" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.NormalizeStyle" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_convertToSemantic" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node to process.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_normalizeTags" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to search from.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_convertToCss" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node to process</description>
          </parameter>
        </parameters>
      </method>
      <method name="_condenseSpans" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node (and its children), to process.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_isInline" scope="instance">
        <parameters>
          <parameter name="tag" type="The" usage="required">
            <description>tag to examine</description>
          </parameter>
        </parameters>
      </method>
      <method name="_inserthtmlImpl" scope="instance">
        <parameters>
          <parameter name="html" type="The" usage="required">
            <description>HTML string to insert.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="mode" scope="instance" type="String"/>
      <property name="condenseSpans" scope="instance" type="Object"/>
      <property name="_browserFilter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.NormalizeStyle.editor">
    <properties>
      <property name="_oldInsertHtmlImpl" scope="instance" type="Object"/>
      <property name="_inserthtmlImpl" scope="instance" type="Object"/>
      <property name="window" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.PageBreak" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_style" scope="instance"/>
      <method name="_insertPageBreak" scope="instance"/>
      <method name="_allowBreak" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="iconClassPrefix" scope="instance" type="String">
        <description>The CSS class name for the button node is formed from
	&lt;code&gt;iconClassPrefix&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;</description>
      </property>
      <property name="_unbreakableNodes" scope="instance" type="Array">
        <description>The nodes that should not allow page breaks to be inserted into them.</description>
      </property>
      <property name="_pbContent" scope="instance" type="String">
        <description>The markup used for the pagebreak insert.</description>
      </property>
      <property name="button" scope="instance" type="Object"/>
      <property name="_styled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.PageBreak.editor">
    <properties>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.PasteFromWord" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_openDialog" scope="instance"/>
      <method name="_paste" scope="instance"/>
      <method name="_cancel" scope="instance"/>
      <method name="_clearDialog" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="instance" type="String">
        <description>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt;
	and &lt;code&gt;command&lt;/code&gt;</description>
      </property>
      <property name="width" scope="instance" type="String">
        <description>The width to use for the rich text area in the copy/pate dialog, in px.  Default is 400px.</description>
      </property>
      <property name="height" scope="instance" type="String">
        <description>The height to use for the rich text area in the copy/pate dialog, in px.  Default is 300px.</description>
      </property>
      <property name="_template" scope="instance" type="Object"/>
      <property name="_filters" scope="instance" type="Array">
        <description>The filters is an array of regular expressions to try and strip out a lot
	of style data MS Word likes to insert when pasting into a contentEditable.
	Prettymuch all of it is junk and not good html.  The hander is a place to put a function
	for match handling.  In most cases, it just handles it as empty string.  But the option is
	there for more complex handling.</description>
      </property>
      <property name="button" scope="instance" type="Object"/>
      <property name="_uId" scope="instance" type="Object"/>
      <property name="_dialog" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.PrettyPrint" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="indentBy" scope="instance" type="Number"/>
      <property name="lineLength" scope="instance" type="Number"/>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="entityMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Preview" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateState" scope="instance"/>
      <method name="_preview" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="styles" scope="instance" type="String">
        <description>A string of CSS styles to apply to the previewed content, if any.</description>
      </property>
      <property name="stylesheets" scope="instance" type="Array">
        <description>An array of stylesheets to import into the preview, if any.</description>
      </property>
      <property name="iconClassPrefix" scope="instance" type="String">
        <description>The CSS class name for the button node icon.</description>
      </property>
      <property name="_nlsResources" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ResizeTableColumn" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="The" usage="required">
            <description>editor which this plugin belongs to</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
    <properties>
      <property name="ruleDiv" scope="instance-prototype" type="Object"/>
      <property name="isLtr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ResizeTableColumn.editor">
    <properties>
      <property name="customUndo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Save" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_save" scope="instance"/>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSuccess" scope="instance">
        <parameters>
          <parameter name="resp" type="The" usage="required">
            <description>response from the server, if any, in text format.</description>
          </parameter>
          <parameter name="ioargs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="error" type="Object" usage="required"/>
          <parameter name="ioargs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="instance" type="String">
        <description>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt;
	and &lt;code&gt;command&lt;/code&gt;</description>
      </property>
      <property name="url" scope="instance" type="String"/>
      <property name="logResults" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ShowBlockNodes" superclass="dijit._editor._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toggle" scope="instance"/>
      <method name="_showBlocks" scope="instance">
        <parameters>
          <parameter name="show" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcBaseUrl" scope="instance">
        <parameters>
          <parameter name="fullUrl" type="String" usage="required">
            <description>The full url to tear down to the base.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="iconClassPrefix" scope="instance" type="String">
        <description>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;</description>
      </property>
      <property name="_styled" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ShowBlockNodes.editor">
    <properties>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Smiley" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* smiley - inserts the selected emoticon</description>
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_preFilterEntities" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>content passed in</description>
          </parameter>
        </parameters>
      </method>
      <method name="_postFilterEntities" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>content passed in</description>
          </parameter>
        </parameters>
      </method>
      <method name="_decode" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
          <parameter name="ascii" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_encode" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="instance" type="String">
        <description>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;</description>
      </property>
      <property name="emoticonMarker" scope="instance" type="String"/>
      <property name="emoticonImageClass" scope="instance" type="String"/>
      <property name="dropDown" scope="instance" type="Object"/>
      <property name="i18n" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="emoticonImageRegexp" scope="instance" type="Object"/>
      <property name="editor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._spellCheckControl" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onSkip" scope="instance"/>
      <method name="onSkipAll" scope="instance"/>
      <method name="onAddToDic" scope="instance"/>
      <method name="onReplace" scope="instance"/>
      <method name="onReplaceAll" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="onEnter" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="_cancel" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_enter" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_unfoundTextBoxChange" scope="instance"/>
      <method name="_setUnfoundWordAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The value of the Not Found textbox</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getUnfoundWordAttr" scope="instance"/>
      <method name="_setSuggestionListAttr" scope="instance">
        <parameters>
          <parameter name="values" type="Array" usage="required">
            <description>The list of the suggestion items</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getSelectedWordAttr" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setInProgressAttr" scope="instance">
        <parameters>
          <parameter name="show" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="textId" scope="instance" type="String"/>
      <property name="selectId" scope="instance" type="String"/>
      <property name="isChanged" scope="instance-prototype" type="bool"/>
      <property name="ignoreChange" scope="instance" type="bool"/>
      <property name="isOpen" scope="instance" type="bool"/>
      <property name="closable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._spellCheckControl.suggestionSelect">
    <methods>
      <method name="addItems" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required">
            <description>An array of items be added to the select</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeItems" scope="instance"/>
      <method name="deselectAll" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.editor.plugins._spellCheckControl.containerNode">
    <properties>
      <property name="selectedIndex" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._SpellCheckScriptMultiPart">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="send" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required">
            <description>The text to be sent</description>
          </parameter>
          <parameter name="action" type="String" usage="optional">
            <description>The action the service should take. Current support actions are
	ACTION_QUERY and ACTION_UPDATE</description>
          </parameter>
        </parameters>
      </method>
      <method name="_finalizeCollection" scope="instance">
        <parameters>
          <parameter name="action" type="The" usage="required">
            <description>action token</description>
          </parameter>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setWaitingTime" scope="instance">
        <parameters>
          <parameter name="seconds" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="ACTION_QUERY" scope="instance" type="Object"/>
      <property name="ACTION_UPDATE" scope="instance" type="String"/>
      <property name="callbackHandle" scope="instance" type="String"/>
      <property name="maxBufferLength" scope="instance" type="Number"/>
      <property name="delimiter" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="_timeout" scope="instance" type="Number"/>
      <property name="SEC" scope="instance" type="Number"/>
      <property name="serviceEndPoint" scope="instance-prototype" type="String"/>
      <property name="exArgs" scope="instance-prototype" type="Object"/>
      <property name="_result" scope="instance" type="Array"/>
      <property name="_counter" scope="instance-prototype" type="Number"/>
      <property name="_queue" scope="instance" type="Array"/>
      <property name="isWorking" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck" superclass="dijit._editor._Plugin">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="_setNetwork" scope="instance"/>
      <method name="_connectUp" scope="instance"/>
      <method name="_disabled" scope="instance">
        <parameters>
          <parameter name="name" type="Command" usage="required">
            <description>name</description>
          </parameter>
          <parameter name="disabled" type="Command" usage="required">
            <description>argument</description>
          </parameter>
        </parameters>
      </method>
      <method name="_keyPress" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadData" scope="instance">
        <parameters>
          <parameter name="data" type="Array" usage="required">
            <description>The result of the query</description>
          </parameter>
        </parameters>
      </method>
      <method name="_openDialog" scope="instance"/>
      <method name="_skip" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="optional">
            <description>The event object</description>
          </parameter>
          <parameter name="noUpdate" type="Boolean" usage="optional">
            <description>Indicate whether to update the status of the span list or not</description>
          </parameter>
        </parameters>
      </method>
      <method name="_skipAll" scope="instance"/>
      <method name="_add" scope="instance"/>
      <method name="_replace" scope="instance"/>
      <method name="_replaceAll" scope="instance"/>
      <method name="_cancel" scope="instance"/>
      <method name="_enter" scope="instance"/>
      <method name="_query" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The html value of the editor</description>
          </parameter>
        </parameters>
      </method>
      <method name="_html2Text" scope="instance">
        <parameters>
          <parameter name="html" type="The" usage="required">
            <description>html code</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getBookmark" scope="instance">
        <parameters>
          <parameter name="eValue" type="String" usage="required">
            <description>The html value of the editor</description>
          </parameter>
        </parameters>
      </method>
      <method name="_moveToBookmark" scope="instance"/>
      <method name="_submitContent" scope="instance">
        <parameters>
          <parameter name="delay" type="Boolean" usage="optional">
            <description>Indicate if the action is taken immediately or not</description>
          </parameter>
        </parameters>
      </method>
      <method name="_populateDialog" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>idex of the span list</description>
          </parameter>
        </parameters>
      </method>
      <method name="_markIncorrectWords" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The html value of the editor</description>
          </parameter>
          <parameter name="cache" type="Object" usage="required">
            <description>The local word cache</description>
          </parameter>
        </parameters>
      </method>
      <method name="_selectWord" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>index of the span list</description>
          </parameter>
        </parameters>
      </method>
      <method name="_replaceWord" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>index of the span list</description>
          </parameter>
          <parameter name="text" type="The" usage="required">
            <description>text to be replaced with</description>
          </parameter>
        </parameters>
      </method>
      <method name="_skipWord" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>index of the span list</description>
          </parameter>
        </parameters>
      </method>
      <method name="_skipWordAll" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>index of the span list</description>
          </parameter>
          <parameter name="word" type="String" usage="optional">
            <description>If this argument is given, skip all the words that have the same text
	as the word</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addWord" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>index of the span list</description>
          </parameter>
          <parameter name="word" type="String" usage="optional">
            <description>If this argument is given, add the word to the dictionary and
	skip all the words like it</description>
          </parameter>
        </parameters>
      </method>
      <method name="_findText" scope="instance">
        <parameters>
          <parameter name="txt" type="String" usage="required">
            <description>The text to locate in the document.</description>
          </parameter>
          <parameter name="caseSensitive" type="Boolean" usage="required">
            <description>Whether or ot to search case-sensitively.</description>
          </parameter>
          <parameter name="backwards" type="Boolean" usage="required">
            <description>Whether or not to search backwards in the document.</description>
          </parameter>
        </parameters>
        <return-description>Boolean indicating if the content was found or not.</return-description>
      </method>
      <method name="_spellCheckFilter" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The html value of the editor</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance" type="String"/>
      <property name="bufferLength" scope="instance" type="Number"/>
      <property name="interactive" scope="instance" type="bool"/>
      <property name="timeout" scope="instance" type="Number"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="exArgs" scope="instance" type="Object"/>
      <property name="_cursorSpan" scope="instance" type="String"/>
      <property name="_cursorSelector" scope="instance" type="String"/>
      <property name="_incorrectWordsSpan" scope="instance" type="String"/>
      <property name="_selector" scope="instance" type="String"/>
      <property name="_maxItemNumber" scope="instance" type="Number"/>
      <property name="_strings" scope="instance" type="Object"/>
      <property name="_dialog" scope="instance" type="Object"/>
      <property name="_service" scope="instance" type="Object"/>
      <property name="_iterator" scope="instance-prototype" type="Number"/>
      <property name="_enabled" scope="instance-prototype" type="Object"/>
      <property name="_cache" scope="instance-prototype" type="Object"/>
      <property name="_delayHandler" scope="instance" type="Object"/>
      <property name="parser" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._ignoredIncorrectStyle">
    <properties>
      <property name="cursor" scope="instance" type="String"/>
      <property name="borderBottom" scope="instance" type="String"/>
      <property name="backgroundColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._normalIncorrectStyle">
    <properties>
      <property name="cursor" scope="instance" type="String"/>
      <property name="borderBottom" scope="instance" type="String"/>
      <property name="backgroundColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._highlightedIncorrectStyle">
    <properties>
      <property name="borderBottom" scope="instance" type="String"/>
      <property name="backgroundColor" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._dialogContent">
    <properties>
      <property name="closable" scope="instance" type="Object"/>
      <property name="ignoreChange" scope="instance" type="Object"/>
      <property name="isOpen" scope="instance" type="Object"/>
      <property name="isChanged" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._spanList">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.SpellCheck._editor">
    <properties>
      <property name="_cursorToStart" scope="instance" type="bool"/>
      <property name="window" scope="instance" type="Object"/>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._StatusBar" superclass="dijit._Widget">
    <methods>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>The string to set as the status bar content.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>Template for the widget.  Currently using table to get the alignment behavior and
	bordering I wanted.  Would prefer not to use table, though.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.editor.plugins._StatusBar.barContent">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.StatusBar" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <description>The editor to configure for this plugin to use.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>The String value to set in the bar.</description>
          </parameter>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="attr" type="The" usage="required">
            <description>attribute to set.</description>
          </parameter>
          <parameter name="val" type="The" usage="required">
            <description>value to set it to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="attr" type="The" usage="required">
            <description>attribute to get.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="statusBar" scope="instance" type="The">
        <description>status bar and resizer.</description>
      </property>
      <property name="resizer" scope="instance" type="Boolean">
        <description>Flag indicating that a resizer should be shown or not.  Default is true.
	There are cases (such as using center pane border container to autoresize the editor
	That a resizer is not valued.</description>
      </property>
      <property name="resizeHandle" scope="instance" type="Object"/>
      <property name="_msgListener" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.StatusBar.editor">
    <properties>
      <property name="statusBar" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._TableHandler" superclass="dijit._editor._Plugin">
    <methods>
      <method name="doMixins" scope="instance"/>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTableInfo" scope="instance">
        <parameters>
          <parameter name="forceNewData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectDraggable" scope="instance"/>
      <method name="onDragStart" scope="instance"/>
      <method name="onDragEnd" scope="instance"/>
      <method name="checkAvailable" scope="instance"/>
      <method name="_prepareTable" scope="instance">
        <parameters>
          <parameter name="tbl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTimeStamp" scope="instance">
        <return-types>
          <return-type type="Fixed the bug that this method always returns the same timestamp"/>
        </return-types>
      </method>
      <method name="_tempStoreTableData" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_tempAvailability" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectTableKeys" scope="instance"/>
      <method name="disconnectTableKeys" scope="instance"/>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDisplayChanged" scope="instance"/>
      <method name="uninitialize" scope="instance">
        <parameters>
          <parameter name="editor" type="The" usage="required">
            <description>editor to detach from.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="tablesConnected" scope="instance" type="bool"/>
      <property name="currentlyAvailable" scope="instance" type="bool"/>
      <property name="alwaysAvailable" scope="instance" type="bool"/>
      <property name="availableCurrentlySet" scope="instance" type="Object"/>
      <property name="initialized" scope="instance" type="bool"/>
      <property name="tableData" scope="instance" type="Object"/>
      <property name="shiftKeyDown" scope="instance" type="bool"/>
      <property name="undoEnabled" scope="instance" type="Object"/>
      <property name="refCount" scope="instance" type="Number"/>
      <property name="cnKeyDn" scope="instance" type="Object"/>
      <property name="cnKeyUp" scope="instance" type="Object"/>
      <property name="stopEvent" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._TableHandler.editor">
    <properties>
      <property name="_tablePluginHandler" scope="instance" type="Object"/>
      <property name="window" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._TableHandler.editorDomNode">
    <properties>
      <property name="ondragstart" scope="instance" type="Object"/>
      <property name="ondragend" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TablePlugins" superclass="dijit._editor._Plugin">
    <methods>
      <method name="onDisplayChanged" scope="instance">
        <parameters>
          <parameter name="withinTable" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="instance">
        <parameters>
          <parameter name="editor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEditorLoaded" scope="instance"/>
      <method name="selectTable" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="modTable" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="begEdit" scope="instance"/>
      <method name="endEdit" scope="instance"/>
      <method name="makeColumnsEven" scope="instance"/>
      <method name="getTableInfo" scope="instance">
        <parameters>
          <parameter name="forceNewData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeTitle" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelectedCells" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="commandName" scope="instance" type="String"/>
      <property name="label" scope="instance" type="Object"/>
      <property name="alwaysAvailable" scope="instance" type="bool"/>
      <property name="undoEnabled" scope="instance" type="Object"/>
      <property name="available" scope="instance" type="Object"/>
      <property name="_availableTopic" scope="instance" type="Object"/>
      <property name="command" scope="instance" type="Object"/>
      <property name="valBeforeUndo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TablePlugins.editor">
    <properties>
      <property name="customUndo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TableContextMenu" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="_createContextMenu" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
    <properties>
      <property name="menu" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TableContextMenu.button.domNode">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.InsertTable" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="modTable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
    <properties>
      <property name="alwaysAvailable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ModifyTable" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="modTable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.editor.plugins._CellColorDropDown" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The value to set in the color picker</description>
          </parameter>
          <parameter name="priorityChange" type="Value" usage="required">
            <description>to indicate whether or not to trigger an onChange event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="setColor" scope="instance">
        <parameters>
          <parameter name="color" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The value from the color picker.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>The template used to create the ColorPicker.</description>
      </property>
      <property name="widgetsInTemplate" scope="instance" type="Boolean">
        <description>Flag denoting widgets are contained in the template.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ColorTableCell" superclass="dojox.editor.plugins.TablePlugins">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_initButton" scope="instance"/>
      <method name="modTable" scope="instance">
        <parameters>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.editor.plugins.TablePlugins" scope="instance"/>
    </mixins>
    <properties>
      <property name="command" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
      <property name="closable" scope="instance" type="Object"/>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EditorTableDialog" superclass="dijit.Dialog">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onInsert" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="onBuildTable" scope="instance">
        <parameters>
          <parameter name="tableText" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Dialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.EditorModifyTableDialog" superclass="dijit.Dialog">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="setBrdColor" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setBkColor" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="onSetTable" scope="instance">
        <parameters>
          <parameter name="tableText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Dialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="table" scope="instance" type="Object"/>
      <property name="tableAtts" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_cleanupWidgets" scope="instance" type="Array"/>
      <property name="brdColor" scope="instance" type="Object"/>
      <property name="bkColor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._TextColorDropDown" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The value to set in the color picker</description>
          </parameter>
          <parameter name="priorityChange" type="Value" usage="required">
            <description>to indicate whether or not to trigger an onChange event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The value from the color picker.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>The template used to create the ColorPicker.</description>
      </property>
      <property name="widgetsInTemplate" scope="instance" type="Boolean">
        <description>Flag denoting widgets are contained in the template.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.editor.plugins.TextColor" superclass="dijit._editor._Plugin">
    <description>The commands provided by this plugin are:
	* foreColor - sets the text color
	* hiliteColor - sets the background color</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="useDefaultCommand" scope="instance" type="Boolean">
        <description>False as we do not use the default editor command/click behavior.</description>
      </property>
      <property name="editor" scope="instance" type="Object"/>
      <property name="command" scope="instance" type="Object"/>
      <property name="_picker" scope="instance" type="Object"/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.ToolbarLineBreak" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="isFocusable" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.UploadImage" superclass="dijit._editor._Plugin">
    <methods>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="updateState" scope="instance"/>
      <method name="createFileInput" scope="instance"/>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="ioArgs" type="Object" usage="required"/>
          <parameter name="widgetRef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertTempImage" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._editor._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="tempImageUrl" scope="instance" type="String"/>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="useDefaultCommand" scope="instance" type="bool"/>
      <property name="uploadUrl" scope="instance" type="String"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="String"/>
      <property name="command" scope="instance" type="String"/>
      <property name="currentImageId" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._SmileyPalette" superclass="dijit._Widget">
    <description>Grid showing various emoticons.
	Can be used standalone, or as a popup.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._PaletteMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._PaletteMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_palette" scope="instance" type="Array"/>
      <property name="dyeClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Emoticon">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="imgHtml" scope="instance">
        <parameters>
          <parameter name="clazz" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="fillCell" scope="instance">
        <parameters>
          <parameter name="cell" type="DOMNode" usage="required"/>
          <parameter name="blankGif" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="fromAscii" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins.Emoticon.ascii">
    <properties>
      <property name="smile" scope="instance" type="String"/>
      <property name="laughing" scope="instance" type="String"/>
      <property name="wink" scope="instance" type="String"/>
      <property name="grin" scope="instance" type="String"/>
      <property name="cool" scope="instance" type="String"/>
      <property name="angry" scope="instance" type="String"/>
      <property name="half" scope="instance" type="String"/>
      <property name="eyebrow" scope="instance" type="String"/>
      <property name="frown" scope="instance" type="String"/>
      <property name="shy" scope="instance" type="String"/>
      <property name="goofy" scope="instance" type="String"/>
      <property name="oops" scope="instance" type="String"/>
      <property name="tongue" scope="instance" type="String"/>
      <property name="idea" scope="instance" type="String"/>
      <property name="yes" scope="instance" type="String"/>
      <property name="no" scope="instance" type="String"/>
      <property name="angel" scope="instance" type="String"/>
      <property name="crying" scope="instance" type="String"/>
      <property name="happy" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.editor.plugins._SpellCheckParser">
    <methods>
      <method name="parseIntoWords" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>Plain text without html tags</description>
          </parameter>
        </parameters>
        <return-description>Array holding all the words</return-description>
      </method>
      <method name="getIndices" scope="instance">
        <return-description>Index array</return-description>
      </method>
    </methods>
    <properties>
      <property name="lang" scope="instance" type="String"/>
      <property name="words" scope="instance" type="Array"/>
      <property name="indices" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.embed.Flash">
    <description>Creates a wrapper object around a Flash movie.  Wrapper object will
	insert the movie reference in node; when the browser first starts
	grabbing the movie, onReady will be fired; when the movie has finished
	loading, it will fire onLoad.
	If your movie uses ExternalInterface, you should use the onLoad event
	to do any kind of proxy setup (see dojox.embed.Flash.proxy); this seems
	to be the only consistent time calling EI methods are stable (since the
	Flash movie will shoot several methods into the window object before
	EI callbacks can be used properly).
	*Important note*:  this code includes a workaround for the Eolas "fix" from
	Microsoft; in order to work around the "click to activate this control" message
	on any embedded Flash movie, this code will load a separate, non-dojo.require
	javascript file in order to write the Flash movie into the document.  As such
	it cannot be used with Dojo's scope map techniques for working with multiple
	versions of Dojo on the same page.</description>
    <methods>
      <method name="onInitialize" scope="instance"/>
      <method name="__ie_markup__" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="proxy" scope="instance">
        <examples>
          <example>Create "setMessage" and "getMessage" methods on foo.
		var foo = new dojox.embed.Flash(args, someNode);
		dojo.connect(foo, "onLoad", dojo.hitch(foo, function(){
			dojox.embed.Flash.proxy(this, [ "setMessage", "getMessage" ]);
			this.setMessage("dojox.embed.Flash.proxy is pretty cool...");
			console.log(this.getMessage());
		}));</example>
        </examples>
        <parameters>
          <parameter name="obj" type="dojox.embed.Flash" usage="required"/>
          <parameter name="methods" type="Array|String" usage="required"/>
        </parameters>
      </method>
      <method name="onReady" scope="instance">
        <parameters>
          <parameter name="movie" type="HTMLObject" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="movie" type="HTMLObject" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onload" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="byId" scope="instance">
        <description>Probably includes methods for outdated
	browsers, but this should catch all cases.
	arguments:</description>
        <examples>
          <example> var movie = dojox.embed.Flash.byId("myId");</example>
        </examples>
        <parameters>
          <parameter name="movieName" type="String" usage="required">
            <description>The name of the SWF</description>
          </parameter>
          <parameter name="doc" type="Object" usage="required">
            <description>The document, if not current window
	(not fully supported)</description>
          </parameter>
        </parameters>
      </method>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="minSupported" scope="instance" type="Number">
        <description>The minimum supported version of the Flash Player, defaults to 8.</description>
      </property>
      <property name="available" scope="instance" type="Number">
        <description>Used as both a detection (i.e. if(dojox.embed.Flash.available){ })
	and as a variable holding the major version of the player installed.</description>
      </property>
      <property name="supported" scope="instance" type="Boolean">
        <description>Whether or not the Flash Player installed is supported by dojox.embed.</description>
      </property>
      <property name="minimumRequired" scope="instance" type="Object"/>
      <property name="version" scope="instance" type="Object">
        <description>The version of the installed Flash Player; takes the form of
	{ major, minor, rev }.  To get the major version, you'd do this:
	var v=dojox.embed.Flash.version.major;</description>
      </property>
      <property name="initialized" scope="instance" type="Boolean">
        <description>Whether or not the Flash engine is available for use.</description>
      </property>
      <property name="minimumVersion" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="movie" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed"/>
  <class type="dojox.embed.Flash.init">
    <methods/>
    <properties>
      <property name="_poller" scope="instance" type="Object"/>
      <property name="_pollCount" scope="instance" type="Number"/>
      <property name="_pollMax" scope="instance" type="Number"/>
      <property name="pollTime" scope="instance" type="Number"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.Flash._destroy">
    <methods/>
    <properties>
      <property name="id" scope="instance" type="Object"/>
      <property name="movie" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.__flashArgs">
    <methods/>
    <properties>
      <property name="id" scope="instance" type="String">
        <description>A unique key that will be used as the id of the created markup.  If you don't
	provide this, a unique key will be generated.</description>
      </property>
      <property name="path" scope="instance" type="String">
        <description>The URL of the movie to embed.</description>
      </property>
      <property name="width" scope="instance" type="Number">
        <description>The width of the embedded movie; the default value is 320px.</description>
      </property>
      <property name="minimumVersion" scope="instance" type="Number">
        <description>?
	The minimum targeted version of the Flash Player (defaults to 9)</description>
      </property>
      <property name="height" scope="instance" type="Number">
        <description>The height of the embedded movie; the default value is 240px</description>
      </property>
      <property name="style" scope="instance" type="String">
        <description>Any CSS style information (i.e. style=&amp;quot;background-color:transparent&amp;quot;) you want
	to define on the markup.</description>
      </property>
      <property name="params" scope="instance" type="Object">
        <description>A set of key/value pairs that you want to define in the resultant markup.</description>
      </property>
      <property name="vars" scope="instance" type="Object">
        <description>A set of key/value pairs that the Flash movie will interpret as FlashVars.</description>
      </property>
      <property name="expressInstall" scope="instance" type="Boolean">
        <description>Whether or not to include any kind of expressInstall info. Default is false.</description>
      </property>
      <property name="redirect" scope="instance" type="String">
        <description>A url to redirect the browser to if the current Flash version is not supported.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.embed.Object" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="Number">
        <description>The width of the movie. If not provided, the width of this.domNode is used.</description>
      </property>
      <property name="height" scope="instance" type="Number">
        <description>The height of the movie. If not provided, the height of this.domNode is used.</description>
      </property>
      <property name="src" scope="instance" type="String">
        <description>The URL of the movie to embed.</description>
      </property>
      <property name="movie" scope="instance" type="HTMLEmbed">
        <description>The eventual reference to the movie embedded.  If you are looking to script
	control over the movie, you'd access it this way.</description>
      </property>
      <property name="params" scope="instance" type="Object">
        <description>A property bag that is created postCreate.  Any additional attributes you
	define on your domNode will be collected and placed into this, which will
	then be passed to the movie constructor.</description>
      </property>
      <property name="reFlash" scope="instance" type="RegExp">
        <description>Expression used on the src property to determine if this is Flash or Quicktime.</description>
      </property>
      <property name="reQtMovie" scope="instance" type="RegExp">
        <description>Expression used on the src property to determine if this is Flash or Quicktime.</description>
      </property>
      <property name="reQtAudio" scope="instance" type="RegExp">
        <description>Expression used on the src property to determine if this is Flash or Quicktime.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.embed.Object.domNode"/>
  <class type="dojox.embed.Object.domNode.attributes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.embed.Quicktime">
    <methods>
      <method name="onInitialize" scope="instance"/>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="QuickTimeObject"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="minSupported" scope="instance" type="Number">
        <description>The minimum supported version of the QuickTime Player, defaults to
	6.</description>
      </property>
      <property name="available" scope="instance" type="Boolean">
        <description>Whether or not QuickTime is available.</description>
      </property>
      <property name="supported" scope="instance" type="Boolean">
        <description>Whether or not the QuickTime Player installed is supported by
	dojox.embed.</description>
      </property>
      <property name="version" scope="instance" type="Object">
        <description>The version of the installed QuickTime Player; takes the form of
	{ major, minor, rev }.  To get the major version, you'd do this:
	var v=dojox.embed.Quicktime.version.major;</description>
      </property>
      <property name="initialized" scope="instance" type="Boolean">
        <description>Whether or not the QuickTime engine is available for use.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.embed.__QTArgs">
    <methods/>
    <properties>
      <property name="id" scope="instance" type="String">
        <description>A unique key that will be used as the id of the created markup.  If you don't
	provide this, a unique key will be generated.</description>
      </property>
      <property name="path" scope="instance" type="String">
        <description>The URL of the movie to embed.</description>
      </property>
      <property name="width" scope="instance" type="Number">
        <description>The width of the embedded movie; the default value is 320px.</description>
      </property>
      <property name="height" scope="instance" type="Number">
        <description>The height of the embedded movie; the default value is 240px</description>
      </property>
      <property name="params" scope="instance" type="Object">
        <description>A set of key/value pairs that you want to define in the resultant markup.</description>
      </property>
      <property name="redirect" scope="instance" type="String">
        <description>A url to redirect the browser to if the current QuickTime version is not supported.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.embed.flashVars">
    <description>JSON could be done, but Deft does not yet have a JSON parser, and quotes are
	very problematic since Flash cannot use eval(); JSON parsing was successful
	when it was fully escaped, but that made it very large anyway. flashvar
	serialization at most is 200% larger than JSON.
	See:
	Deft/common/flashVars.as</description>
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="n" type="String" usage="required">
            <description>The name for the object, such as: &amp;quot;button&amp;quot;</description>
          </parameter>
          <parameter name="o" type="Object" usage="required">
            <description>The object to serialize</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding">
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.ascii85">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="input" type="Array" usage="required">
            <description>an array of numbers (0-255) to encode</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="input" type="String" usage="required">
            <description>the input string to decode</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.base64">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="ba" type="Array&lt;byte&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array&lt;byte&gt;"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.bits"/>
  <class type="dojox.encoding.bits.OutputStream">
    <methods>
      <method name="getWidth" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.encoding.bits.OutputStream.reset">
    <methods/>
    <properties>
      <property name="buffer" scope="instance" type="Array"/>
      <property name="accumulator" scope="instance" type="Number"/>
      <property name="available" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.bits.OutputStream.putBits">
    <methods/>
    <properties>
      <property name="accumulator" scope="instance" type="Number"/>
      <property name="available" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.bits.OutputStream.getBuffer">
    <methods/>
    <properties>
      <property name="buffer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.bits.InputStream">
    <methods>
      <method name="getWidth" scope="instance"/>
    </methods>
    <properties>
      <property name="buffer" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="bbyte" scope="instance" type="Number"/>
      <property name="bit" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.bits.InputStream.getBits">
    <methods/>
    <properties>
      <property name="bit" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw"/>
  <class type="dojox.encoding.compression.lzw.Encoder">
    <methods/>
    <properties>
      <property name="size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Encoder.init">
    <methods/>
    <properties>
      <property name="dict" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="code" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Encoder.encode">
    <methods/>
    <properties>
      <property name="p" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Encoder.flush">
    <methods/>
    <properties>
      <property name="p" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Decoder">
    <methods/>
    <properties>
      <property name="size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Decoder.init">
    <methods/>
    <properties>
      <property name="codes" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.lzw.Decoder.decode">
    <methods/>
    <properties>
      <property name="p" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression">
    <properties>
      <property name="splay" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.compression.Splay">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="splay" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="stream" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="up" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="right" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto">
    <properties>
      <property name="Blowfish" scope="instance" type="Object"/>
      <property name="RSAKey-ext" scope="instance" type="Object"/>
      <property name="SimpleAES" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto.RSAKey">
    <methods>
      <method name="decrypt" scope="instance">
        <parameters>
          <parameter name="ctext" type="String" usage="required">
            <description>an even-length hex string</description>
          </parameter>
        </parameters>
        <return-description>a plain string.</return-description>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rngf" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPublic" scope="instance">
        <parameters>
          <parameter name="N" type="Object" usage="required"/>
          <parameter name="E" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encrypt" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="n" scope="instance-prototype" type="Object"/>
      <property name="e" scope="instance-prototype" type="Number"/>
      <property name="rngf" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
      <property name="q" scope="instance" type="Object"/>
      <property name="dmp1" scope="instance" type="Object"/>
      <property name="dmq1" scope="instance" type="Object"/>
      <property name="coeff" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto.RSAKey.setPrivate">
    <methods/>
    <properties>
      <property name="n" scope="instance" type="Object"/>
      <property name="e" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto.RSAKey.setPrivateEx">
    <methods/>
    <properties>
      <property name="n" scope="instance" type="Object"/>
      <property name="e" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
      <property name="q" scope="instance" type="Object"/>
      <property name="dmp1" scope="instance" type="Object"/>
      <property name="dmq1" scope="instance" type="Object"/>
      <property name="coeff" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto.RSAKey.generate">
    <methods/>
    <properties>
      <property name="e" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
      <property name="q" scope="instance" type="Object"/>
      <property name="n" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
      <property name="dmp1" scope="instance" type="Object"/>
      <property name="dmq1" scope="instance" type="Object"/>
      <property name="coeff" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.BigInteger">
    <methods/>
    <properties>
      <property name="_nbi" scope="instance" type="Object"/>
      <property name="_nbv" scope="instance" type="Object"/>
      <property name="_nbits" scope="instance" type="Object"/>
      <property name="_Montgomery" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.random">
    <methods>
      <method name="prng4" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.math.random.Simple">
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="nextBytes" scope="instance">
        <parameters>
          <parameter name="byteArray" type="Array" usage="required">
            <description>Array: array to be filled in with random numbers, only existing
	elements will be filled.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.crypto.cipherModes">
    <properties>
      <property name="ECB" scope="instance" type="Number"/>
      <property name="CBC" scope="instance" type="Number"/>
      <property name="PCBC" scope="instance" type="Number"/>
      <property name="CFB" scope="instance" type="Number"/>
      <property name="OFB" scope="instance" type="Number"/>
      <property name="CTR" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.crypto.outputTypes">
    <properties>
      <property name="Base64" scope="instance" type="Number"/>
      <property name="Hex" scope="instance" type="Number"/>
      <property name="String" scope="instance" type="Number"/>
      <property name="Raw" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.digests">
    <methods>
      <method name="addWords" scope="instance">
        <parameters>
          <parameter name="a" type="word" usage="required"/>
          <parameter name="b" type="word" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="word"/>
        </return-types>
      </method>
      <method name="stringToWord" scope="instance">
        <parameters>
          <parameter name="s" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array&lt;word&gt;"/>
        </return-types>
      </method>
      <method name="wordToString" scope="instance">
        <parameters>
          <parameter name="wa" type="Array&lt;word&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="wordToHex" scope="instance">
        <parameters>
          <parameter name="wa" type="Array&lt;word&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="wordToBase64" scope="instance">
        <parameters>
          <parameter name="wa" type="Array&lt;word&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.encoding.digests.MD5">
    <methods>
      <method name="_hmac" scope="instance">
        <parameters>
          <parameter name="data" type="string" usage="required"/>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="outputType" type="dojox.encoding.digests.outputTypes" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array&lt;word&gt;"/>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.digests.SHA1">
    <methods>
      <method name="_hmac" scope="instance">
        <parameters>
          <parameter name="data" type="string" usage="required"/>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="outputType" type="dojox.encoding.digests.outputTypes" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array&lt;word&gt;"/>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.encoding.digests.outputTypes">
    <properties>
      <property name="Base64" scope="instance" type="Number"/>
      <property name="Hex" scope="instance" type="Number"/>
      <property name="String" scope="instance" type="Number"/>
      <property name="Raw" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.encoding.easy64">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="input" type="Array" usage="required">
            <description>an array of numbers (0-255) to encode</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="input" type="String" usage="required">
            <description>the input string to decode</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.flash">
    <description>The goal of dojox.flash is to make it easy to extend Flash's capabilities
	into an Ajax/DHTML environment.
	dojox.flash provides an easy object for interacting with the Flash plugin.
	This object provides methods to determine the current version of the Flash
	plugin (dojox.flash.info); write out the necessary markup to
	dynamically insert a Flash object into the page (dojox.flash.Embed; and
	do dynamic installation and upgrading of the current Flash plugin in
	use (dojox.flash.Install). If you want to call methods on the Flash object
	embedded into the page it is your responsibility to use Flash's ExternalInterface
	API and get a reference to the Flash object yourself.
	To use dojox.flash, you must first wait until Flash is finished loading
	and initializing before you attempt communication or interaction.
	To know when Flash is finished use dojo.connect:
		dojo.connect(dojox.flash, "loaded", myInstance, "myCallback");
	Then, while the page is still loading provide the file name:
		dojox.flash.setSwf(dojo.moduleUrl("dojox", "_storage/storage.swf"));
	If no SWF files are specified, then Flash is not initialized.
	Your Flash must use Flash's ExternalInterface to expose Flash methods and
	to call JavaScript.
	setSwf can take an optional 'visible' attribute to control whether
	the Flash object is visible or not on the page; the default is visible:
		dojox.flash.setSwf(dojo.moduleUrl("dojox", "_storage/storage.swf"),
	false);
	Once finished, you can query Flash version information:
		dojox.flash.info.version
	Or can communicate with Flash methods that were exposed:
		var f = dojox.flash.get();
		var results = f.sayHello("Some Message");
	Your Flash files should use DojoExternalInterface.as to register methods;
	this file wraps Flash's normal ExternalInterface but correct various
	serialization bugs that ExternalInterface has.
	Note that dojox.flash is not meant to be a generic Flash embedding
	mechanism; it is as generic as necessary to make Dojo Storage's
	Flash Storage Provider as clean and modular as possible. If you want
	a generic Flash embed mechanism see [SWFObject](http://blog.deconcept.com/swfobject/).
	Notes:
	Note that dojox.flash can currently only work with one Flash object
	on the page; it does not yet support multiple Flash objects on
	the same page.
	Your code can detect whether the Flash player is installing or having
	its version revved in two ways. First, if dojox.flash detects that
	Flash installation needs to occur, it sets dojox.flash.info.installing
	to true. Second, you can detect if installation is necessary with the
	following callback:
		dojo.connect(dojox.flash, "installing", myInstance, "myCallback");
	You can use this callback to delay further actions that might need Flash;
	when installation is finished the full page will be refreshed and the
	user will be placed back on your page with Flash installed.
	-------------------
	Todo/Known Issues
	-------------------
	* On Internet Explorer, after doing a basic install, the page is
	not refreshed or does not detect that Flash is now available. The way
	to fix this is to create a custom small Flash file that is pointed to
	during installation; when it is finished loading, it does a callback
	that says that Flash installation is complete on IE, and we can proceed
	to initialize the dojox.flash subsystem.
	* Things aren't super tested for sending complex objects to Flash
	methods, since Dojo Storage only needs strings
	Author- Brad Neuberg, http://codinginparadise.org</description>
    <methods>
      <method name="addLoadedListener" scope="instance">
        <parameters>
          <parameter name="listener" type="Function" usage="required">
            <description>A function that will be called when Flash is done loading.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addInstallingListener" scope="instance">
        <parameters>
          <parameter name="listener" type="Function" usage="required">
            <description>A function that will be called if Flash is being
	installed</description>
          </parameter>
        </parameters>
      </method>
      <method name="loaded" scope="instance">
        <description>A callback when the Flash subsystem is finished loading and can be
	worked with. To be notified when Flash is finished loading, add a
	loaded listener:
	dojox.flash.addLoadedListener(loadedListener);</description>
      </method>
      <method name="installing" scope="instance">
        <description>A callback to know if Flash is currently being installed or
	having its version revved. To be notified if Flash is installing, connect
	your callback to this method using the following:
	dojo.event.connect(dojox.flash, "installing", myInstance, "myCallback");</description>
      </method>
      <method name="_initialize" scope="instance"/>
    </methods>
    <properties>
      <property name="ready" scope="instance" type="bool"/>
      <property name="url" scope="instance" type="Object"/>
      <property name="_visible" scope="instance" type="Object"/>
      <property name="_loadedListeners" scope="instance" type="Array"/>
      <property name="_installingListeners" scope="instance" type="Array"/>
      <property name="info" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.flash.setSwf">
    <methods/>
    <properties>
      <property name="url" scope="instance" type="String">
        <description>The URL to this Flash file.
	visible: boolean?
	Whether the Flash file is visible or not. If it is not visible we hide
	it off the screen. This defaults to true (i.e. the Flash file is
	visible).</description>
      </property>
      <property name="_visible" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.flash.Info">
    <description>A class that helps us determine whether Flash is available,
	it's major and minor versions, and what Flash version features should
	be used for Flash/JavaScript communication. Parts of this code
	are adapted from the automatic Flash plugin detection code autogenerated
	by the Macromedia Flash 8 authoring environment.
	An instance of this class can be accessed on dojox.flash.info after
	the page is finished loading.</description>
    <methods>
      <method name="isVersionOrAbove" scope="instance">
        <description>Asserts that this environment has the given major, minor, and revision
	numbers for the Flash player.
	Example- To test for Flash Player 7r14:
	dojox.flash.info.isVersionOrAbove(7, 0, 14)</description>
        <parameters>
          <parameter name="reqMajorVer" type="int" usage="required"/>
          <parameter name="reqMinorVer" type="int" usage="required"/>
          <parameter name="reqVer" type="int" usage="required"/>
        </parameters>
        <return-description>Returns true if the player is equal
	or above the given version, false otherwise.</return-description>
      </method>
      <method name="_JSFlashInfo" scope="instance">
        <parameters>
          <parameter name="testVersion" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="version" scope="instance" type="String">
        <description>The full version string, such as &amp;quot;8r22&amp;quot;.</description>
      </property>
      <property name="versionMajor" scope="instance" type="Number"/>
      <property name="versionMinor" scope="instance" type="Number"/>
      <property name="versionRevision" scope="instance" type="Number"/>
      <property name="capable" scope="instance" type="Boolean">
        <description>Whether this platform has Flash already installed.</description>
      </property>
      <property name="installing" scope="instance" type="Boolean">
        <description>Set if we are in the middle of a Flash installation session.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.flash.Info._detectVersion">
    <methods/>
    <properties>
      <property name="capable" scope="instance" type="Object"/>
      <property name="versionMajor" scope="instance" type="Object"/>
      <property name="versionMinor" scope="instance" type="Object"/>
      <property name="versionRevision" scope="instance" type="Object"/>
      <property name="version" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.flash.Embed">
    <description>Writes out the necessary tags to embed a Flash file into the page. Note that
	these tags are written out as the page is loaded using document.write, so
	you must call this class before the page has finished loading.</description>
    <methods>
      <method name="protocol" scope="instance"/>
      <method name="write" scope="instance">
        <description>This must be called before the page
	is finished loading.</description>
        <parameters>
          <parameter name="doExpressInstall" type="Boolean" usage="optional">
            <description>Whether to write out Express Install
	information. Optional value; defaults to false.</description>
          </parameter>
        </parameters>
      </method>
      <method name="get" scope="instance"/>
      <method name="setVisible" scope="instance">
        <parameters>
          <parameter name="visible" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_visible" scope="instance-prototype" type="Object"/>
      <property name="width" scope="instance" type="int">
        <description>The width of this Flash applet. The default is the minimal width
	necessary to show the Flash settings dialog. Current value is
	215 pixels.</description>
      </property>
      <property name="height" scope="instance" type="int">
        <description>The height of this Flash applet. The default is the minimal height
	necessary to show the Flash settings dialog. Current value is
	138 pixels.</description>
      </property>
      <property name="id" scope="instance" type="String">
        <description>The id of the Flash object. Current value is 'flashObject'.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.flash.Embed.center">
    <methods/>
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.flash.Communicator">
    <description>This class helps mediate Flash and JavaScript communication. Internally
	it uses Flash 8's ExternalInterface API, but adds functionality to fix
	various encoding bugs that ExternalInterface has.</description>
    <methods>
      <method name="_addExternalInterfaceCallback" scope="instance">
        <parameters>
          <parameter name="methodName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_encodeData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decodeData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_execFlash" scope="instance">
        <parameters>
          <parameter name="methodName" type="Object" usage="required"/>
          <parameter name="methodArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.flash.Install">
    <description>Figures out the best way to automatically install the Flash plugin
	for this browser and platform. Also determines if installation or
	revving of the current plugin is needed on this platform.</description>
    <methods>
      <method name="needed" scope="instance"/>
      <method name="install" scope="instance"/>
      <method name="_onInstallStatus" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.form">
    <methods>
      <method name="addUploaderPlugin" scope="instance">
        <parameters>
          <parameter name="plug" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="DropDownSelect" scope="instance" type="Object"/>
      <property name="RangeSlider" scope="instance" type="Object"/>
      <property name="UploaderOrg" scope="instance" type="Object"/>
      <property name="_FormSelectWidget" scope="instance" type="Object"/>
      <property name="_HasDropDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._BusyButtonMixin">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="makeBusy" scope="instance"/>
      <method name="cancel" scope="instance"/>
      <method name="resetTimeout" scope="instance">
        <parameters>
          <parameter name="timeout" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="content" type="String" usage="required"/>
          <parameter name="timeout" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="_clicked" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="isBusy" scope="instance" type="bool"/>
      <property name="busyLabel" scope="instance" type="String"/>
      <property name="timeout" scope="instance" type="Object"/>
      <property name="useIcon" scope="instance" type="Object"/>
      <property name="_label" scope="instance" type="Object"/>
      <property name="_initTimeout" scope="instance" type="Object"/>
      <property name="_timeout" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._BusyButtonMixin.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._BusyButtonMixin.titleNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.BusyButton" superclass="dijit.form.Button">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._BusyButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Button" scope="instance"/>
      <mixin type="dojox.form._BusyButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.BusyComboButton" superclass="dijit.form.ComboButton">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._BusyButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboButton" scope="instance"/>
      <mixin type="dojox.form._BusyButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.BusyDropDownButton" superclass="dijit.form.DropDownButton">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._BusyButtonMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.DropDownButton" scope="instance"/>
      <mixin type="dojox.form._BusyButtonMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._CheckedMultiSelectItem" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_changeBox" scope="instance"/>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateBox" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="parent" scope="instance" type="Object"/>
      <property name="disabled" scope="instance" type="boolean">
        <description>Whether or not this widget is disabled</description>
      </property>
      <property name="readOnly" scope="instance" type="boolean">
        <description>Whether or not this widget is readOnly</description>
      </property>
      <property name="_type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._CheckedMultiSelectItem.option">
    <properties>
      <property name="disabled" scope="instance" type="bool"/>
      <property name="selected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._CheckedMultiSelectItem.labelNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.CheckedMultiSelect" superclass="dijit.form._FormSelectWidget">
    <methods>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="validator" scope="instance"/>
      <method name="validate" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getErrorMessage" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="displayMessage" scope="instance">
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterAddOptionItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="option" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addOptionItem" scope="instance">
        <parameters>
          <parameter name="option" type="dojox.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_updateSelection" scope="instance"/>
      <method name="_getChildren" scope="instance"/>
      <method name="invertSelection" scope="instance">
        <parameters>
          <parameter name="onChange" type="Boolean" usage="required">
            <description>If null, onChange is not fired.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormSelectWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="required" scope="instance" type="Boolean">
        <description>User is required to check at least one item.</description>
      </property>
      <property name="invalidMessage" scope="instance" type="String">
        <description>The message to display if value is invalid.</description>
      </property>
      <property name="_message" scope="instance" type="String">
        <description>Currently displayed message</description>
      </property>
      <property name="tooltipPosition" scope="instance" type="Array&lt;String&gt;">
        <description>See description of &lt;code&gt;dijit.Tooltip.defaultPosition&lt;/code&gt; for details on this parameter.</description>
      </property>
      <property name="readOnly" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.DateTextBox" superclass="dijit.form._DateTimeTextBox">
    <methods>
      <method name="openDropDown" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._DateTimeTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="popupClass" scope="instance" type="String">
        <description>The popup widget to use. In this case, a calendar with Day, Month and Year views.</description>
      </property>
      <property name="_selector" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.DayTextBox" superclass="dojox.form.DateTextBox">
    <methods>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="displayVal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="validator" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openDropDown" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.DateTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="popupClass" scope="instance" type="String">
        <description>The popup widget to use. In this case, a calendar with just a Month view.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form.DayTextBox.dropDown">
    <properties>
      <property name="onValueSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.MonthTextBox" superclass="dojox.form.DateTextBox">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="validator" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openDropDown" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.DateTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="popupClass" scope="instance" type="String">
        <description>The popup widget to use. In this case, a calendar with just a Year view.</description>
      </property>
      <property name="selector" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.MonthTextBox.constraints">
    <properties>
      <property name="datePattern" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.MonthTextBox.dropDown">
    <properties>
      <property name="onValueSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.YearTextBox" superclass="dojox.form.DateTextBox">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="validator" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openDropDown" scope="instance"/>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.DateTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="popupClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.YearTextBox.dropDown">
    <properties>
      <property name="onValueSelected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.DropDownStack" superclass="dijit.form.Select">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._SelectStackMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.Select" scope="instance"/>
      <mixin type="dojox.form._SelectStackMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.FileInput" superclass="dijit.form._FormWidget">
    <description>A input type="file" form widget, with a button for uploading to be styled via css,
	a cancel button to clear selection, and FormWidget mixin to provide standard dijit.form.Form
	support (FIXME: maybe not fully implemented)</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_matchValue" scope="instance"/>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="cssClass" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="String">
        <description>the title text of the &amp;quot;Browse&amp;quot; button</description>
      </property>
      <property name="cancelText" scope="instance" type="String">
        <description>the title of the &amp;quot;Cancel&amp;quot; button</description>
      </property>
      <property name="name" scope="instance" type="String">
        <description>ugh, this should be pulled from this.domNode</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_listener" scope="instance" type="Object"/>
      <property name="_keyListener" scope="instance" type="Object"/>
      <property name="fileInput" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInput.inputNode">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FileInput.cancelNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FileInput.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputAuto" superclass="dojox.form.FileInput">
    <description>An extended version of FileInput - when the user focuses away from the input
	the selected file is posted via dojo.io.iframe to the url. example implementation
	comes with PHP solution for handling upload, and returning required data.
	notes: the return data from the io.iframe is used to populate the input element with
	data regarding the results. it will be a JSON object, like:
	results = { size: "1024", filename: "file.txt" }
	all the parameters allowed to dojox.form.FileInput apply</description>
    <methods>
      <method name="onBeforeSend" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_onFocus" scope="instance"/>
      <method name="_onBlur" scope="instance"/>
      <method name="setMessage" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_sendFile" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleSend" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="data" type="the" usage="required">
            <description>raw data found in the first [TEXTAREA] tag of the post url</description>
          </parameter>
          <parameter name="ioArgs" type="the" usage="required">
            <description>dojo.Deferred data being passed from the handle: callback</description>
          </parameter>
          <parameter name="widgetRef" type="this" usage="required">
            <description>widget pointer, so you can set this.overlay to a completed/error message easily</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.FileInput" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance" type="String">
        <description>the URL where our background FileUpload will be sent</description>
      </property>
      <property name="blurDelay" scope="instance" type="Integer">
        <description>time in ms before an un-focused widget will wait before uploading the file to the url=&amp;quot;&amp;quot; specified
	default: 2 seconds</description>
      </property>
      <property name="duration" scope="instance" type="Integer">
        <description>The time in ms to use as the generic timing mechanism for the animations
	set to 1 or 0 for &amp;quot;immediate respose&amp;quot;</description>
      </property>
      <property name="uploadMessage" scope="instance" type="String">
        <description>FIXME: i18n somehow?</description>
      </property>
      <property name="triggerEvent" scope="instance" type="String">
        <description>Event which triggers the upload. Defaults to onblur, sending the file selected
	'blurDelay' milliseconds after losing focus. Set to &amp;quot;onchange&amp;quot; with a low blurDelay
	to send files immediately after uploading.</description>
      </property>
      <property name="_sent" scope="instance" type="bool"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_blurListener" scope="instance" type="Object"/>
      <property name="_focusListener" scope="instance" type="Object"/>
      <property name="_blurTimer" scope="instance" type="Object"/>
      <property name="_sending" scope="instance" type="bool"/>
      <property name="fileInput" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputAuto.overlay.style">
    <properties>
      <property name="backgroundImage" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputAuto.fileInput.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputAuto.fakeNodeHolder.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputBlind" superclass="dojox.form.FileInputAuto">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_fixPosition" scope="instance"/>
      <method name="reset" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.FileInputAuto" scope="instance"/>
    </mixins>
    <properties>
      <property name="_off" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileInputBlind.inputNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FilePickerTextBox" superclass="dijit.form.ValidationTextBox">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="string" usage="required"/>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="fromWidget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onWidgetChange" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="openDropDown" scope="instance"/>
      <method name="toggleDropDown" scope="instance"/>
      <method name="_focusBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_focusFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="instance"/>
      <method name="_setBlurValue" scope="instance"/>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearchFromInput" scope="instance"/>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._HasDropDown.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
      <mixin type="dijit._HasDropDown" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="searchDelay" scope="instance" type="Integer">
        <description>Delay in milliseconds between when user types something and we start
	searching based on that value</description>
      </property>
      <property name="valueItem" scope="instance" type="item">
        <description>The item, in our store, of the directory relating to our value</description>
      </property>
      <property name="numPanes" scope="instance" type="number">
        <description>The number of panes to display in our box (if we don't have any
	minPaneWidth specified by our constraints)</description>
      </property>
      <property name="_skip" scope="instance" type="Object"/>
      <property name="_hasValidPath" scope="instance" type="bool"/>
      <property name="_menuFocus" scope="instance" type="Object"/>
      <property name="_allowBlur" scope="instance" type="Object"/>
      <property name="_settingBlurValue" scope="instance" type="Object"/>
      <property name="_hasSelection" scope="instance" type="bool"/>
      <property name="_searchTimer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FilePickerTextBox.focusNode">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FilePickerTextBox.dropDown.domNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FilePickerTextBox.dropDown">
    <properties>
      <property name="topDir" scope="instance" type="Object"/>
      <property name="pathSeparator" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader" superclass="dijit._Widget">
    <description>If the correct version of Flash Player is available (&gt; 9.0) , a SWF
	is used. If Flash Player is not installed or is outdated, a typical
	html fileInput is used. This process can be overridden with</description>
    <methods>
      <method name="flashMovie" scope="instance"/>
      <method name="log" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="getHiddenWidget" scope="instance"/>
      <method name="getHiddenNode" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getButtonStyle" scope="instance"/>
      <method name="setButtonStyle" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onProgress" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="evtObject" type="Object" usage="required">
            <description>or String</description>
          </parameter>
        </parameters>
      </method>
      <method name="onReady" scope="instance">
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="submit" scope="instance">
        <parameters>
          <parameter name="form" type="form" usage="required">
            <description>node ?</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="upload" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required">
            <description>postData to be sent to server</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeFile" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name of the file to be removed. Typically the file name,
	such as: picture01.png</description>
          </parameter>
          <parameter name="noListEdit" type="Boolean" usage="required">
            <description>Internal. If true don't remove files from list.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_displayProgress" scope="instance">
        <parameters>
          <parameter name="display" type="Boolean" usage="required">
            <description>or Number</description>
          </parameter>
        </parameters>
      </method>
      <method name="_animateProgress" scope="instance"/>
      <method name="_error" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addToFileList" scope="instance"/>
      <method name="_change" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_complete" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_progress" scope="instance">
        <parameters>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getDisabledAttr" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFlashBlur" scope="instance"/>
      <method name="_disconnect" scope="instance"/>
      <method name="uploadHTML" scope="instance"/>
      <method name="createHtmlUploader" scope="instance"/>
      <method name="_connectInput" scope="instance"/>
      <method name="_checkHtmlCancel" scope="instance">
        <parameters>
          <parameter name="mouseType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_styleContent" scope="instance"/>
      <method name="_resetHTML" scope="instance"/>
      <method name="_buildForm" scope="instance"/>
      <method name="_buildFileInput" scope="instance"/>
      <method name="_renumberInputs" scope="instance"/>
      <method name="_setFormStyle" scope="instance"/>
      <method name="_setHtmlPostData" scope="instance"/>
      <method name="uploadFlash" scope="instance"/>
      <method name="createFlashUploader" scope="instance"/>
      <method name="_connectFlash" scope="instance">
        <description>Sacrificing some readbilty for compactness. this.id
	will be on the beginning of the topic, so more than
	one uploader can be on a page and can have unique calls.</description>
      </method>
      <method name="_doSub" scope="instance">
        <parameters>
          <parameter name="subStr" type="Object" usage="required"/>
          <parameter name="funcStr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="urlencode" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isButton" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextStyle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getText" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getStyle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTempNodeStyle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="_class" type="Object" usage="required"/>
          <parameter name="isDijitButton" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="swfPath" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="uploadUrl" scope="instance" type="String">
        <description>The url targeted for upload. An absolute URL is preferred. Relative URLs are
	changed to absolute.</description>
      </property>
      <property name="isDebug" scope="instance" type="Boolean">
        <description>If true, outputs traces from the SWF to console. What exactly gets passed
	is very relative, and depends upon what traces have been left in the DEFT SWF.</description>
      </property>
      <property name="devMode" scope="instance" type="Boolean">
        <description>Re-implemented. devMode increases the logging, adding style tracing from the SWF.
	id: String
	The object id, just like any other widget in Dojo. However, this id
	is also used as a reference for the SWF
	id: &amp;quot;&amp;quot;,</description>
      </property>
      <property name="baseClass" scope="instance" type="String">
        <description>The name of the class that will style the button in a &amp;quot;normal&amp;quot; state.
	If baseClass is not defined, 'class' will be used.
	NOTE: By default the uploader will be styled like a dijit buttons and
	adhere to the the themes. Tundra, Soria, and Nihilo are supported.
	You can cascade the existing style by using 'class' or 'style'. If you
	overwrite baseClass, you should overwrite the remaing state classes
	that follow) as well.</description>
      </property>
      <property name="hoverClass" scope="instance" type="String">
        <description>The name of the class that will style the button in a &amp;quot;hover&amp;quot; state. A specific
	class should be made to do this. Do not rely on a target like button:hover{...}</description>
      </property>
      <property name="activeClass" scope="instance" type="String">
        <description>The name of the class that will style the button in a &amp;quot;press&amp;quot; state. A specific
	class should be made to do this. Do not rely on a target like button:active{...}</description>
      </property>
      <property name="disabledClass" scope="instance" type="String">
        <description>The name of the class that will style the button when its disabled.</description>
      </property>
      <property name="force" scope="instance" type="String">
        <description>Use &amp;quot;flash&amp;quot; to always use Flash (and hopefully force the user to download the plugin
	if they don't have it). Use &amp;quot;html&amp;quot; to always use the HTML uploader. An empty string
	(default) will check for the right version of Flash and use HTML if not available.</description>
      </property>
      <property name="uploaderType" scope="instance" type="String">
        <description>Internal. What type of uploader is being used: &amp;quot;flash&amp;quot; or &amp;quot;html&amp;quot;</description>
      </property>
      <property name="deferredUploading" scope="instance" type="Number">
        <description>(1 - X)
	(Flash only) throttles the upload to a certain amount of files at a time.
	By default, Flash uploads file one at a time to the server, but in parallel.
	Firefox will try to queue all files at once, leading to problems. Set this
	to the amount to upload in parallel at a time.
	Generally, 1 should work fine, but you can experiment with queuing more than
	one at a time.
	This is of course ignored if selectMultipleFiles equals false.</description>
      </property>
      <property name="fileListId" scope="instance" type="String">
        <description>The id of a dom node to be used as a container for the pending file list.</description>
      </property>
      <property name="uploadOnChange" scope="instance" type="Boolean">
        <description>If true, uploads imediately after a file has been selected. If false,
	waits for upload() to be called.</description>
      </property>
      <property name="selectMultipleFiles" scope="instance" type="Boolean">
        <description>If true and flash mode, multiple files may be selected from the dialog.
	If html mode, files are not uploaded until upload() is called. The references
	to each file is incremented:uploadedfile0, uploadedfile1, uploadedfile2... etc.</description>
      </property>
      <property name="htmlFieldName" scope="instance" type="String">
        <description>The name of the field of the fileInput that the server is expecting</description>
      </property>
      <property name="flashFieldName" scope="instance" type="String">
        <description>The name of the field of the flash uploaded files that the server is expecting</description>
      </property>
      <property name="fileMask" scope="instance" type="Array&lt;Array&gt;">
        <description>Array[Description, FileTypes], Array[...]...]
	(an array, or an array of arrays)
	Restrict file selection to certain file types
	Empty array defaults to &amp;quot;All Files&amp;quot;</description>
      </property>
      <property name="minFlashVersion" scope="instance" type="Number">
        <description>The minimum of version of Flash player to target. 0 would always install Flash, 100
	would never install it. The Flash Player has supported multiple uploads since
	version 8, so it could go as low as that safely.</description>
      </property>
      <property name="tabIndex" scope="instance" type="Number|String">
        <description>The tab order in the DOM. Only supported by Flash. HTML Uploaders have security
	protection to prevent you from tabbing to the uploader. Stupid.</description>
      </property>
      <property name="showProgress" scope="instance" type="Boolean">
        <description>If true, the button changes to a progress bar during upload.</description>
      </property>
      <property name="progressMessage" scope="instance" type="String">
        <description>The message shown while the button is changed to a progress bar</description>
      </property>
      <property name="progressBackgroundUrl" scope="instance" type="String|Uri">
        <description>The background image to use for the button-progress</description>
      </property>
      <property name="progressBackgroundColor" scope="instance" type="String|Number">
        <description>The background color to use for the button-progress</description>
      </property>
      <property name="progressWidgetId" scope="instance" type="String">
        <description>The widget id of a Dijit Progress bar. The Uploader will bind to it and update it
	automatically.</description>
      </property>
      <property name="skipServerCheck" scope="instance" type="Boolean">
        <description>If true, will not verify that the server was sent the correct format.
	This can be safely set to true. The purpose of the server side check
	is mainly to show the dev if they've implemented the different returns
	correctly.</description>
      </property>
      <property name="serverTimeout" scope="instance" type="Number">
        <description>(milliseconds)
	The amount of time given to the uploaded file
	to wait for a server response. After this amount
	of time, the onComplete is fired but with a 'server timeout'
	error in the returned item.</description>
      </property>
      <property name="fileList" scope="instance" type="Array"/>
      <property name="_cons" scope="instance" type="Array"/>
      <property name="fileInputs" scope="instance" type="Array"/>
      <property name="fileCount" scope="instance" type="Number"/>
      <property name="flashReady" scope="instance" type="bool"/>
      <property name="_disabled" scope="instance" type="bool"/>
      <property name="_refNode" scope="instance" type="Object"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="_hiddenNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="pressClass" scope="instance" type="String"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="over" scope="instance" type="Object"/>
      <property name="down" scope="instance" type="Object"/>
      <property name="dsbl" scope="instance" type="Object"/>
      <property name="restoreProgDisplay" scope="instance" type="String"/>
      <property name="postData" scope="instance" type="Object"/>
      <property name="nextFocusObject" scope="instance" type="Object"/>
      <property name="dialogIsOpen" scope="instance" type="bool"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="_subs" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.norm">
    <properties>
      <property name="lh" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.progTextNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.insideNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.fhtml"/>
  <class type="dojox.form.FileUploader._formNode">
    <properties>
      <property name="encoding" scope="instance" type="String"/>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader._fileInput">
    <properties>
      <property name="id" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.fhtml.nr">
    <properties>
      <property name="w" scope="instance" type="Object"/>
      <property name="h" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.FileUploader.flashObject">
    <properties>
      <property name="onError" scope="instance" type="Object"/>
      <property name="onReady" scope="instance" type="Object"/>
      <property name="onLoad" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.ListInput" superclass="dijit.form._FormValueWidget">
    <description>you can add value to list with add method.
	you can only remove by clicking close button</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setReadOnlyInputAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyItemAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_createInputBox" scope="instance"/>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="val1" type="Array" usage="required"/>
          <parameter name="val2" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="values" type="String" usage="required">
            <description>|| Array</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setReadOnlyWhenMaxItemsReached" scope="instance"/>
      <method name="_setSelectNode" scope="instance"/>
      <method name="_placeItem" scope="instance">
        <parameters>
          <parameter name="node" type="domNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getCursorPos" scope="instance">
        <parameters>
          <parameter name="node" type="domNode" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemClose" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemKeyDown" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_editBefore" scope="instance">
        <parameters>
          <parameter name="item" type="widget" usage="required"/>
        </parameters>
      </method>
      <method name="_editAfter" scope="instance">
        <parameters>
          <parameter name="item" type="widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChange" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemEdit" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_testItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget.
	If the value has changed, then fire onChange event, unless priorityChange
	is specified as null (or false?)</description>
        <parameters>
          <parameter name="newValue" type="Array" usage="required">
            <description>|| String</description>
          </parameter>
        </parameters>
      </method>
      <method name="_parseValue" scope="instance">
        <parameters>
          <parameter name="newValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="regExpGen" scope="instance">
        <parameters>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandler" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_focusInput" scope="instance"/>
      <method name="_inputOnKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_inputOnBlur" scope="instance"/>
      <method name="_getMatchedValueAttr" scope="instance"/>
      <method name="_getMismatchedValueAttr" scope="instance"/>
      <method name="_getValues" scope="instance">
        <parameters>
          <parameter name="validator" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="_nullValidator" scope="instance">
        <parameters>
          <parameter name="itemValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_matchValidator" scope="instance">
        <parameters>
          <parameter name="itemValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_mismatchValidator" scope="instance">
        <parameters>
          <parameter name="itemValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getLastItemAttr" scope="instance"/>
      <method name="_getSomeItem" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getPreviousItem" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_getNextItem" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyItem" scope="instance">
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="updateValue" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_updateValues" scope="instance"/>
      <method name="_destroyAllItems" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputClass" scope="instance" type="String">
        <description>Class which will be used to create the input box. You can implements yours.
	It must be a widget, focusNode or domNode must have &amp;quot;onkeydown&amp;quot; event
	It must have .attr(&amp;quot;value&amp;quot;) to get value
	It also must impement an (or more) handler for the &amp;quot;onChange&amp;quot; method</description>
      </property>
      <property name="inputHandler" scope="instance" type="String">
        <description>|| Array
	The widget will connect on all handler to check input value
	You can use comma separated list</description>
      </property>
      <property name="submitOnlyValidValue" scope="instance" type="Boolean">
        <description>If true, only valid value will be submited with form</description>
      </property>
      <property name="useOnBlur" scope="instance" type="Boolean">
        <description>If true, onBlur event do a validate (like pressing ENTER)</description>
      </property>
      <property name="readOnlyInput" scope="instance" type="Boolean">
        <description>if false, the list will be editable
	Can only be set when instanciate</description>
      </property>
      <property name="maxItems" scope="instance" type="Int">
        <description>Specify max item the list can have
	null = infiny</description>
      </property>
      <property name="showCloseButtonWhenValid" scope="instance" type="Boolean">
        <description>if true, a close button will be added on valid item</description>
      </property>
      <property name="showCloseButtonWhenInvalid" scope="instance" type="Boolean">
        <description>if true, a close button will be added on invalid item</description>
      </property>
      <property name="regExp" scope="instance-prototype" type="String">
        <description>regular expression string used to validate the input
	Do not specify both regExp and regExpGen
	&amp;quot;[a-zA-Z.-_]+@[a-zA-Z.-_]+.[a-zA-Z]+&amp;quot;,</description>
      </property>
      <property name="delimiter" scope="instance-prototype" type="String">
        <description>|| Array
	delimiter for the string. Every match will be splitted
	The string can contain only one delimiter</description>
      </property>
      <property name="constraints" scope="instance" type="dijit.form.ValidationTextBox.__Constraints">
        <description>user-defined object needed to pass parameters to the validator functions</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="useAnim" scope="instance" type="Boolean">
        <description>If true, then item will use an anime to show hide itself</description>
      </property>
      <property name="duration" scope="instance" type="Integer">
        <description>Animation duration</description>
      </property>
      <property name="easingIn" scope="instance" type="function">
        <description>function used to easing on fadeIn end</description>
      </property>
      <property name="easingOut" scope="instance" type="function">
        <description>function used to easing on fadeOut end</description>
      </property>
      <property name="readOnlyItem" scope="instance" type="Boolean">
        <description>If true, items can be edited
	Can only be set when instanciate</description>
      </property>
      <property name="useArrowForEdit" scope="instance" type="Boolean">
        <description>If true, arraow left and right can be used for editing
	Can only be set when instanciate</description>
      </property>
      <property name="_items" scope="instance-prototype" type="Array">
        <description>Array of widget.
	Contain all reference to _ListInputInputItem</description>
      </property>
      <property name="_currentItem" scope="instance" type="Widget">
        <description>Widget currently in edition</description>
      </property>
      <property name="_input" scope="instance" type="Widget">
        <description>Widget use for input box</description>
      </property>
      <property name="_count" scope="instance" type="Int">
        <description>Count items</description>
      </property>
      <property name="_lastValueReported" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.ListInput.inputProperties">
    <properties>
      <property name="minWidth" scope="instance" type="Number"/>
      <property name="regExp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.ListInput._lastAddedItem">
    <properties>
      <property name="onClose" scope="instance" type="Object"/>
      <property name="onChange" scope="instance" type="Object"/>
      <property name="onEdit" scope="instance" type="Object"/>
      <property name="onKeyDown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.ListInput._selectNode.options">
    <properties>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.form._ListInputInputItem" superclass="dijit._Widget">
    <description>Simple &lt;li&gt; with close button added to ListInputInput when delimiter is found</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setReadOnlyItemAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_createInlineEditBox" scope="instance"/>
      <method name="edit" scope="instance"/>
      <method name="_onCloseEdit" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onEdit" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_onCloseEnter" scope="instance"/>
      <method name="_onCloseLeave" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="onEdit" scope="instance"/>
      <method name="onClick" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="closeButtonNode" scope="instance" type="domNode">
        <description>ref to the close button node</description>
      </property>
      <property name="readOnlyItem" scope="instance" type="Boolean">
        <description>if true, item is editable</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="value" scope="instance" type="String">
        <description>value of item</description>
      </property>
      <property name="regExp" scope="instance" type="String">
        <description>regular expression string used to validate the input
	Do not specify both regExp and regExpGen</description>
      </property>
      <property name="_editBox" scope="instance" type="Widget">
        <description>inline edit box</description>
      </property>
      <property name="_handleKeyDown" scope="instance" type="handle">
        <description>handle for the keyDown connect</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form._ListInputInputItem.attributeMap"/>
  <class type="dojox.form._ListInputInputItem.attributeMap.value">
    <properties>
      <property name="node" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form._ListInputInputBox" superclass="dijit.form.ValidationTextBox">
    <description>Auto sized textbox based on dijit.form.TextBox</description>
    <methods>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="minWidth" scope="instance" type="Integer">
        <description>Min width of the input box</description>
      </property>
      <property name="intermediateChanges" scope="instance" type="Boolean">
        <description>Fires onChange for each value change or only on demand
	Force to true in order to get onChanged called</description>
      </property>
      <property name="regExp" scope="instance" type="String">
        <description>regular expression string used to validate the input
	Do not specify both regExp and regExpGen</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form._ListInputInputBox._sizer">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.Manager" superclass="dijit._Widget">
    <description>This widget hosts dojox.form.manager mixins.
	See dojox.form.manager._Mixin for more info.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="destroyRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.manager._Mixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._NodeMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._FormMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._ValueMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._EnableMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._DisplayMixin.prototype" scope="instance"/>
      <mixin type="dojox.form.manager._ClassMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dojox.form.manager._Mixin" scope="instance"/>
      <mixin type="dojox.form.manager._NodeMixin" scope="instance"/>
      <mixin type="dojox.form.manager._FormMixin" scope="instance"/>
      <mixin type="dojox.form.manager._ValueMixin" scope="instance"/>
      <mixin type="dojox.form.manager._EnableMixin" scope="instance"/>
      <mixin type="dojox.form.manager._DisplayMixin" scope="instance"/>
      <mixin type="dojox.form.manager._ClassMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_attachPoints" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.form.MultiComboBox" superclass="dijit.form.ValidationTextBox">
    <methods>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addPreviousMatches" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_cleanupDelimiters" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_autoCompleteText" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearch" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboBoxMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
      <mixin type="dijit.form.ComboBoxMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="delimiter" scope="instance" type="String">
        <description>The character to use to separate items in the ComboBox input</description>
      </property>
      <property name="_previousMatches" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._ChildTextBox" superclass="dijit.form.ValidationTextBox">
    <methods>
      <method name="reset" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_onChildKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ValidationTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="containerWidget" scope="instance" type="widget">
        <description>Our parent (the PasswordValidator)</description>
      </property>
      <property name="type" scope="instance" type="string">
        <description>Don't override this - we are all &amp;quot;password&amp;quot; types</description>
      </property>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.form._OldPWBox" superclass="dojox.form._ChildTextBox">
    <methods>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="newVal" type="anything" usage="required"/>
          <parameter name="priority" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_setBlurValue" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form._ChildTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="_isPWValid" scope="instance" type="boolean">
        <description>Whether or not the password is valid</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form._NewPWBox" superclass="dojox.form._ChildTextBox">
    <methods>
      <method name="onChange" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form._ChildTextBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="required" scope="instance" type="boolean">
        <description>Whether or not this widget is required (default: true)</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form._VerifyPWBox" superclass="dojox.form._ChildTextBox">
    <methods>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form._ChildTextBox" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form.PasswordValidator" superclass="dijit.form._FormValueWidget">
    <methods>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="validate" scope="instance">
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_createSubWidgets" scope="instance"/>
      <method name="pwCheck" scope="instance">
        <parameters>
          <parameter name="password" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_childValueAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setRequiredAttribute" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="focus" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="required" scope="instance" type="boolean">
        <description>Whether or not it is required for form submission</description>
      </property>
      <property name="_inputWidgets" scope="instance" type="Array"/>
      <property name="oldName" scope="instance" type="string">
        <description>The name to send our old password as (when form is posted)</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.RadioStack" superclass="dojox.form.CheckedMultiSelect">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._SelectStackMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.form.CheckedMultiSelect" scope="instance"/>
      <mixin type="dojox.form._SelectStackMixin" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.form._RangeSliderMixin">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandleClickMax" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClkIncBumper" scope="instance"/>
      <method name="_bumpValue" scope="instance">
        <parameters>
          <parameter name="signedChange" type="Object" usage="required"/>
          <parameter name="useMaxValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBumpValue" scope="instance">
        <parameters>
          <parameter name="signedChange" type="Object" usage="required"/>
          <parameter name="useMaxValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBarClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRemainingBarClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPixelValue" scope="instance">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
          <parameter name="isMaxVal" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueByPixelValue" scope="instance">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Array" usage="required">
            <description>or Number</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="required">
            <description>optional</description>
          </parameter>
          <parameter name="isMaxVal" type="Boolean" usage="required">
            <description>optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="_printSliderBar" scope="instance">
        <parameters>
          <parameter name="priorityChange" type="Object" usage="required"/>
          <parameter name="isMaxVal" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="value" scope="instance" type="Object"/>
      <property name="_movableMax" scope="instance" type="Object"/>
      <property name="_movableBar" scope="instance" type="Object"/>
      <property name="_lastValueReported" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form._RangeSliderMixin.valueNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._SliderMoverMax" superclass="dijit.form._SliderMover">
    <methods>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._SliderMover" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._SliderMoverMax.widget">
    <properties>
      <property name="_abspos" scope="instance" type="Object"/>
      <property name="_setPixelValue_" scope="instance" type="Object"/>
      <property name="_isReversed_" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dijit.form._SliderBarMover" superclass="dojo.dnd.Mover">
    <methods>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Mover" scope="instance"/>
    </mixins>
  </class>
  <class type="dijit.form._SliderBarMover.widget">
    <properties>
      <property name="_abspos" scope="instance" type="Object"/>
      <property name="_setPixelValue_" scope="instance" type="Object"/>
      <property name="_getValueByPixelValue_" scope="instance" type="Object"/>
      <property name="_isReversed_" scope="instance" type="Object"/>
      <property name="_bar" scope="instance" type="Object"/>
      <property name="_mouseOffset" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.HorizontalRangeSlider" superclass="dijit.form.HorizontalSlider">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._RangeSliderMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.HorizontalSlider" scope="instance"/>
      <mixin type="dojox.form._RangeSliderMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.VerticalRangeSlider" superclass="dijit.form.VerticalSlider">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.form._RangeSliderMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.form.VerticalSlider" scope="instance"/>
      <mixin type="dojox.form._RangeSliderMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.Rating" superclass="dijit.form._FormWidget">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_onMouse" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderStars" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="hover" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStarClick" scope="instance">
        <examples>
          <example>dojo.connect(widget, "onStarClick", function(event){ ... })</example>
        </examples>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOver" scope="instance"/>
      <method name="setAttribute" scope="instance">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance-prototype" type="Object"/>
      <property name="numStars" scope="instance" type="Number">
        <description>The number of stars to show, default is 3.</description>
      </property>
      <property name="value" scope="instance" type="Number">
        <description>The current value of the Rating</description>
      </property>
    </properties>
  </class>
  <class type="dojox.form.TimeSpinner" superclass="dijit.form._Spinner">
    <description>This widget is the same as a normal NumberSpinner, but for the time component of a date object instead</description>
    <methods>
      <method name="adjust" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="instance"/>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
          <parameter name="locale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="time" type="Object" usage="required"/>
          <parameter name="locale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._Spinner" scope="instance"/>
    </mixins>
    <properties>
      <property name="required" scope="instance" type="bool"/>
      <property name="smallDelta" scope="instance" type="Number"/>
      <property name="largeDelta" scope="instance" type="Number"/>
      <property name="timeoutChangeRate" scope="instance" type="Number"/>
      <property name="serialize" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.Uploader" superclass="dojox.form.uploader.Base">
    <description>A bare-bones, stylable file-input button, with optional multi-file selection. The list
	of files is not displayed, that is for you to handle by connecting to the onChange
	event, or use the dojox.form.uploader.FileList.
	Uploader without plugins does not have any ability to upload - it is for use in forms
	where you handle the upload either by a standard POST or with Ajax using an iFrame. This
	class is for convenience of multiple files only. No progress events are available.
	If the browser supports a file-input with the "multiple" attribute, that will be used.
	If the browser does not support "multiple" (ergo, IE) multiple inputs are used,
	one for each selection.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onBegin" scope="instance">
        <parameters>
          <parameter name="dataArray" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onProgress" scope="instance">
        <parameters>
          <parameter name="customEvent" type="Object" usage="required">
            <description>bytesLoaded: Number
	Amount of bytes uploaded so far of entire payload (all files)
	bytesTotal: Number
	Amount of bytes of entire payload (all files)
	type: String
	Type of event (progress or load)
	timeStamp: Number
	Timestamp of when event occurred</description>
          </parameter>
        </parameters>
      </method>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="customEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance"/>
      <method name="onAbort" scope="instance"/>
      <method name="onError" scope="instance">
        <parameters>
          <parameter name="evtObject" type="Object" usage="required">
            <description>or String</description>
          </parameter>
        </parameters>
      </method>
      <method name="upload" scope="instance">
        <parameters>
          <parameter name="formData" type="Object" usage="required">
            <description>?</description>
          </parameter>
        </parameters>
      </method>
      <method name="submit" scope="instance">
        <parameters>
          <parameter name="form" type="form" usage="required">
            <description>Node ?</description>
          </parameter>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="getFileList" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getDisabledAttr" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getNodePosition" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getButtonStyle" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setButtonStyle" scope="instance"/>
      <method name="_createInput" scope="instance"/>
      <method name="_connectButton" scope="instance"/>
      <method name="_disconnectButton" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.uploader.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="uploadOnSelect" scope="instance" type="Boolean">
        <description>If true, uploads imediately after a file has been selected. If false,
	waits for upload() to be called.</description>
      </property>
      <property name="tabIndex" scope="instance" type="Number|String">
        <description>The tab order in the DOM.</description>
      </property>
      <property name="multiple" scope="instance" type="Boolean">
        <description>If true and flash mode, multiple files may be selected from the dialog.</description>
      </property>
      <property name="label" scope="instance" type="String">
        <description>The text used in the button that when clicked, opens a system Browse Dialog.</description>
      </property>
      <property name="url" scope="instance" type="String">
        <description>The url targeted for upload. An absolute URL is preferred. Relative URLs are
	changed to absolute.</description>
      </property>
      <property name="name" scope="instance" type="String">
        <description>The name attribute needs to end with square brackets: [] as this is the standard way
	of handling an attribute &amp;quot;array&amp;quot;. This requires a slightly different technique on the
	server.</description>
      </property>
      <property name="flashFieldName" scope="instance" type="String">
        <description>If set, this will be the name of the field of the flash uploaded files that the server
	is expecting. If not set, &amp;quot;Flash&amp;quot; is appended to the &amp;quot;name&amp;quot; property.</description>
      </property>
      <property name="uploadType" scope="instance" type="String">
        <description>[readonly]
	The type of uploader being used. As an alternative to determining the upload type on the
	server based on the fieldName, this property could be sent to the server to help
	determine what type of parsing should be used.</description>
      </property>
      <property name="_nameIndex" scope="instance" type="Number"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_inputs" scope="instance" type="Array"/>
      <property name="btnSize" scope="instance" type="Object"/>
      <property name="inputNodeFontSize" scope="instance" type="Object"/>
      <property name="_cons" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.form.Uploader.domNode">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.Uploader.inputNode">
    <properties>
      <property name="tabIndex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form._SelectStackMixin">
    <methods>
      <method name="_paneIdFromOption" scope="instance">
        <parameters>
          <parameter name="oVal" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_optionValFromPane" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_togglePane" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
          <parameter name="shown" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_connectTitle" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onAddChild" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="instance">
        <parameters>
          <parameter name="name" type="String|Object" usage="required"/>
          <parameter name="value" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectChild" scope="instance">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onStartup" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_handleSelfOnChange" scope="instance">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="stackId" scope="instance" type="string">
        <description>The id of the stack that this widget is supposed to control</description>
      </property>
      <property name="stackPrefix" scope="instance" type="string">
        <description>A prefix to remove from our stack pane ids when setting our options.
	This exists so that we won't run into unique ID constraints.  For
	example, if stackPrefix is set to &amp;quot;foo_&amp;quot;, and there are three panes
	in our stack with ids of &amp;quot;foo_a&amp;quot;, &amp;quot;foo_b&amp;quot;, and &amp;quot;foo_c&amp;quot;, then the values
	of the options created for the stack controller widget will be &amp;quot;a&amp;quot;,
	&amp;quot;b&amp;quot;, and &amp;quot;c&amp;quot;.  This allows you to have multiple select stack widgets
	with the same values - without having to have the panes require the
	same ids.</description>
      </property>
      <property name="_savedValue" scope="instance" type="Object"/>
      <property name="_panes" scope="instance" type="Object"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.form.manager">
    <methods>
      <method name="actionAdapter" scope="instance">
        <parameters>
          <parameter name="action" type="Function" usage="required">
            <description>Function that takes three parameters: a name, an object
	(usually node or widget), and a value. This action will
	be applied to all elements of array.</description>
          </parameter>
        </parameters>
      </method>
      <method name="inspectorAdapter" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function" usage="required">
            <description>Function that takes three parameters: a name, an object
	(usually node or widget), and a value.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_keys" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changeEvent" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>Form node.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._ClassMixin">
    <description>This mixin provides unified way to check/add/remove a class
	of controlled elements.
	It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="gatherClassState" scope="instance">
        <parameters>
          <parameter name="className" type="String" usage="required">
            <description>The class name to test for.</description>
          </parameter>
          <parameter name="names" type="Object" usage="optional">
            <description>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known form elements are to be processed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="addClass" scope="instance">
        <parameters>
          <parameter name="className" type="String" usage="required">
            <description>Class name to add.</description>
          </parameter>
          <parameter name="names" type="Object" usage="optional">
            <description>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known form elements are to be processed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="removeClass" scope="instance">
        <parameters>
          <parameter name="className" type="String" usage="required">
            <description>Class name to remove.</description>
          </parameter>
          <parameter name="names" type="Object" usage="optional">
            <description>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known form elements are to be processed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._DisplayMixin">
    <description>This mixin provides unified show/hide functionality for
	controlled elements (indicated by dojoAttachPoint attribute).
	Essentially it provides a way to change "style.display"
	parameter of controlled nodes.
	It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="gatherDisplayState" scope="instance">
        <parameters>
          <parameter name="names" type="Object" usage="optional">
            <description>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known attach point nodes are to be processed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary, the value is true
	to show and false to hide. If an array, all names in the
	array will be set to defaultState. If omitted, all form
	elements will be set to defaultState.</description>
          </parameter>
          <parameter name="defaultState" type="Boolean" usage="optional">
            <description>The default state (true, if omitted).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary, the value is true
	to show and false to hide. If an array, all names in the
	array will be hidden. If omitted, all form elements
	will be hidden.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._EnableMixin">
    <description>This mixin provides unified enable/disable functionality for
	form widgets and form elements. It should be used together
	with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="gatherEnableState" scope="instance">
        <parameters>
          <parameter name="names" type="Object" usage="optional">
            <description>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known form elements are to be processed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="enable" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary, the value is true
	to enable and false to disable. If an array, all names in the
	array will be set to defaultState. If omitted, all form
	elements will be set to defaultState.</description>
          </parameter>
          <parameter name="defaultState" type="Boolean" usage="required">
            <description>The default state (true, if omitted).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="disable" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary, the value is true
	to enable and false to disable. If an array, all names in the
	array will be disabled. If omitted, disables all.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.form.manager._FormMixin">
    <description>This mixin adds automated "onreset", and "onsubmit" event processing
	if we are based on a form node, defines onReset(), onSubmit(),
	reset(), submit(), and isValid() methods like dijit.form.Form.
	It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_onReset" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onReset" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_onSubmit" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSubmit" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="submit" scope="instance"/>
      <method name="isValid" scope="instance"/>
      <method name="validate" scope="instance"/>
    </methods>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="action" scope="instance" type="String"/>
      <property name="method" scope="instance" type="String"/>
      <property name="encType" scope="instance" type="String"/>
      <property name="accept-charset" scope="instance" type="String"/>
      <property name="accept" scope="instance" type="String"/>
      <property name="target" scope="instance" type="String"/>
      <property name="isForm" scope="instance" type="bool"/>
      <property name="formWidgets" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.manager._Mixin">
    <description>This mixin provideas a foundation for an enhanced form
	functionality: unified access to individual form elements,
	unified "onchange" event processing, general event
	processing, I/O orchestration, and common form-related
	functionality. See additional mixins in dojox.form.manager
	namespace.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="registerWidget" scope="instance">
        <parameters>
          <parameter name="widget" type="String|Node|dijit.form._FormWidget" usage="required">
            <description>A widget, or its widgetId, or its DOM node</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="unregisterWidget" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Name of the to unregister</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="registerWidgetDescendants" scope="instance">
        <parameters>
          <parameter name="widget" type="String|Node|dijit._Widget" usage="required">
            <description>A widget, or its widgetId, or its DOM node</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="unregisterWidgetDescendants" scope="instance">
        <parameters>
          <parameter name="widget" type="String|Node|dijit._Widget" usage="required">
            <description>A widget, or its widgetId, or its DOM node</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="formWidgetValue" scope="instance">
        <parameters>
          <parameter name="elem" type="String|Object|Array" usage="required">
            <description>Form element's name, widget object, or array or radio widgets.</description>
          </parameter>
          <parameter name="value" type="Object" usage="optional">
            <description>Optional. The value to set.</description>
          </parameter>
        </parameters>
        <return-description>Object:
	For a getter it returns the value, for a setter it returns
	self. If the elem is not valid, null will be returned.</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="self"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="formPointValue" scope="instance">
        <parameters>
          <parameter name="elem" type="String|Object|Array" usage="required">
            <description>A node.</description>
          </parameter>
          <parameter name="value" type="Object" usage="optional">
            <description>Optional. The value to set.</description>
          </parameter>
        </parameters>
        <return-description>Object:
	For a getter it returns the value, for a setter it returns
	self. If the elem is not valid, null will be returned.</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="self"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="inspectFormWidgets" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function" usage="required">
            <description>A function to be called on a widget. Takes three arguments: a name, a widget object
	or an array of widget objects, and a supplied value. Runs in the context of
	the form manager. Returns a value that will be collected and returned as a state.</description>
          </parameter>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary --- only listed names will be processed.
	If an array, all names in the array will be processed with defaultValue.
	If omitted or null, all widgets will be processed with defaultValue.</description>
          </parameter>
          <parameter name="defaultValue" type="Object" usage="optional">
            <description>Optional. The default state (true, if omitted).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="inspectAttachedPoints" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function" usage="required">
            <description>A function to be called on a node. Takes three arguments: a name, a node or
	an array of nodes, and a supplied value. Runs in the context of the form manager.
	Returns a value that will be collected and returned as a state.</description>
          </parameter>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary --- only listed names will be processed.
	If an array, all names in the array will be processed with defaultValue.
	If omitted or null, all attached point nodes will be processed with defaultValue.</description>
          </parameter>
          <parameter name="defaultValue" type="Object" usage="optional">
            <description>Optional. The default state (true, if omitted).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="inspect" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function" usage="required">
            <description>A function to be called on a widget, form element, and an attached node.
	Takes three arguments: a name, a node (domNode in the case of widget) or
	an array of such objects, and a supplied value. Runs in the context of
	the form manager. Returns a value that will be collected and returned as a state.</description>
          </parameter>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary --- only listed names will be processed.
	If an array, all names in the array will be processed with defaultValue.
	If omitted or null, all controlled elements will be processed with defaultValue.</description>
          </parameter>
          <parameter name="defaultValue" type="Object" usage="optional">
            <description>Optional. The default state (true, if omitted).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="watching" scope="instance" type="Object"/>
      <property name="formWidgets" scope="instance" type="Object"/>
      <property name="formNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.manager._NodeMixin">
    <description>This mixin provideas a foundation for an enhanced form
	functionality: unified access to individual form elements,
	unified "onchange" event processing, and general event
	processing. It complements dojox.form.manager._Mixin
	extending the functionality to DOM nodes.</description>
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="registerNode" scope="instance">
        <parameters>
          <parameter name="node" type="String|Node" usage="required">
            <description>A node, or its id</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="unregisterNode" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Name of the to unregister</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="registerNodeDescendants" scope="instance">
        <parameters>
          <parameter name="node" type="String|Node" usage="required">
            <description>A widget, or its widgetId, or its DOM node</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="unregisterNodeDescendants" scope="instance">
        <parameters>
          <parameter name="node" type="String|Node" usage="required">
            <description>A widget, or its widgetId, or its DOM node</description>
          </parameter>
        </parameters>
        <return-description>Object:
	Returns self</return-description>
      </method>
      <method name="formNodeValue" scope="instance">
        <parameters>
          <parameter name="elem" type="String|Node|Array" usage="required">
            <description>Form element's name, DOM node, or array or radio nodes.</description>
          </parameter>
          <parameter name="value" type="Object" usage="optional">
            <description>Optional. The value to set.</description>
          </parameter>
        </parameters>
        <return-description>Object:
	For a getter it returns the value, for a setter it returns
	self. If the elem is not valid, null will be returned.</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="self"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="inspectFormNodes" scope="instance">
        <parameters>
          <parameter name="inspector" type="Function" usage="required">
            <description>A function to be called on a form element. Takes three arguments: a name, a node or
	an array of nodes, and a supplied value. Runs in the context of the form manager.
	Returns a value that will be collected and returned as a state.</description>
          </parameter>
          <parameter name="state" type="Object" usage="optional">
            <description>Optional. If a name-value dictionary --- only listed names will be processed.
	If an array, all names in the array will be processed with defaultValue.
	If omitted or null, all form elements will be processed with defaultValue.</description>
          </parameter>
          <parameter name="defaultValue" type="Object" usage="optional">
            <description>Optional. The default state (true, if omitted).</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="formNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.manager._ValueMixin">
    <description>This mixin adds unified access to form widgets and form elements
	in terms of name-value regardless of the underlying type of
	an element. It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method name="elementValue" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>The name.</description>
          </parameter>
          <parameter name="value" type="Object" usage="optional">
            <description>Optional. The value to set.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="gatherFormValues" scope="instance">
        <parameters>
          <parameter name="names" type="Object" usage="optional">
            <description>If it is an array, it is a list of names of form elements to be collected.
	If it is an object, dictionary keys are names to be collected.
	If it is omitted, all known form elements are to be collected.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setFormValues" scope="instance">
        <parameters>
          <parameter name="values" type="Object" usage="required">
            <description>A dictionary of key-value pairs.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.form.uploader"/>
  <class type="dojox.form.uploader.Base" superclass="dijit._Widget">
    <description>Should not be used as a standalone. To be mixed in with other classes.</description>
    <methods>
      <method name="getForm" scope="instance">
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="getUrl" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="connectForm" scope="instance"/>
      <method name="supports" scope="instance">
        <parameters>
          <parameter name="what" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="IE will be undefined"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getMimeType" scope="instance">
        <return-types>
          <return-type type="image/gif"/>
        </return-types>
      </method>
      <method name="getFileType" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="convertBytes" scope="instance">
        <parameters>
          <parameter name="bytes" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="form" scope="instance" type="Object"/>
      <property name="url" scope="instance" type="Object"/>
      <property name="_fcon" scope="instance" type="Object"/>
      <property name="_hascache" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.FileList" superclass="dojox.form.uploader.Base">
    <description>There is a required CSS file: resources/UploaderFileList.css.
	This is a very simple widget, and not beautifully styled. It is here mainly for test
	cases, but could very easily be used, extended, modified, or copied.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="setUploader" scope="instance"/>
      <method name="hideProgress" scope="instance">
        <parameters>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="showProgress" scope="instance">
        <parameters>
          <parameter name="animate" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_progress" scope="instance">
        <parameters>
          <parameter name="customEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideShowProgress" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUploaderChange" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addRow" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.form.uploader.Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="uploaderId" scope="instance" type="String">
        <description>The id of the dojox.form.Uploader to connect to.</description>
      </property>
      <property name="uploader" scope="instance" type="dojox.form.Uploader">
        <description>The dojox.form.Uploader to connect to. Use either this property of unploaderId. This
	property is populated if uploaderId is used.</description>
      </property>
      <property name="headerIndex" scope="instance" type="String">
        <description>The label for the index column.</description>
      </property>
      <property name="headerType" scope="instance" type="String">
        <description>The label for the file type column.</description>
      </property>
      <property name="headerFilename" scope="instance" type="String">
        <description>The label for the file name column.</description>
      </property>
      <property name="headerFilesize" scope="instance" type="String">
        <description>The label for the file size column.</description>
      </property>
      <property name="_upCheckCnt" scope="instance" type="Number"/>
      <property name="rowAmt" scope="instance" type="Number"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="progressNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.FileList.percentTextNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.plugins"/>
  <class type="dojox.form.uploader.plugins.Flash">
    <description>Inherits all properties from dojox.form.Uploader and dojox.form.uploader.plugins.HTML5.
	All properties and methods listed here are specific to the Flash plugin only.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onReady" scope="instance">
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="onFileChange" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFileProgress" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFlashFileList" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="flashReset" scope="instance"/>
      <method name="uploadFlash" scope="instance"/>
      <method name="submitFlash" scope="instance">
        <parameters>
          <parameter name="formParams" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_change" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_complete" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_progress" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_error" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFlashBlur" scope="instance">
        <parameters>
          <parameter name="fileArray" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCustomEvent" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_connectFlash" scope="instance">
        <description>Sacrificing some readbilty for compactness. this.id
	will be on the beginning of the topic, so more than
	one uploader can be on a page and can have unique calls.</description>
      </method>
      <method name="_createFlashUploader" scope="instance"/>
    </methods>
    <properties>
      <property name="swfPath" scope="instance" type="String">
        <description>Path to SWF. Can be overwritten or provided in djConfig.</description>
      </property>
      <property name="skipServerCheck" scope="instance" type="Boolean">
        <description>If true, will not verify that the server was sent the correct format.
	This can be safely set to true. The purpose of the server side check
	is mainly to show the dev if they've implemented the different returns
	correctly.</description>
      </property>
      <property name="serverTimeout" scope="instance" type="Number">
        <description>(milliseconds)
	The amount of time given to the uploaded file
	to wait for a server response. After this amount
	of time, the onComplete is fired but with a 'server timeout'
	error in the returned item.</description>
      </property>
      <property name="isDebug" scope="instance" type="Boolean">
        <description>If true, outputs traces from the SWF to console. What exactly gets passed
	is very relative, and depends upon what traces have been left in the DEFT SWF.</description>
      </property>
      <property name="devMode" scope="instance" type="Boolean">
        <description>Re-implemented. devMode increases the logging, adding style tracing from the SWF.</description>
      </property>
      <property name="deferredUploading" scope="instance" type="Number">
        <description>(1 - X)
	(Flash only) throttles the upload to a certain amount of files at a time.
	By default, Flash uploads file one at a time to the server, but in parallel.
	Firefox will try to queue all files at once, leading to problems. Set this
	to the amount to upload in parallel at a time.
	Generally, 1 should work fine, but you can experiment with queuing more than
	one at a time.
	This is of course ignored if selectMultipleFiles equals false.</description>
      </property>
      <property name="force" scope="instance" type="String">
        <description>Use &amp;quot;flash&amp;quot; to always use Flash (and hopefully force the user to download the plugin
	if they don't have it).</description>
      </property>
      <property name="uploadType" scope="instance" type="String"/>
      <property name="_files" scope="instance" type="Object"/>
      <property name="_fileMap" scope="instance" type="Object"/>
      <property name="_createInput" scope="instance" type="Object"/>
      <property name="getFileList" scope="instance" type="Object"/>
      <property name="reset" scope="instance" type="Object"/>
      <property name="upload" scope="instance" type="Object"/>
      <property name="submit" scope="instance" type="Object"/>
      <property name="fieldname" scope="instance" type="String"/>
      <property name="_subs" scope="instance" type="Array"/>
      <property name="_cons" scope="instance" type="Array"/>
      <property name="inputNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.plugins.Flash.btnSize">
    <properties>
      <property name="w" scope="instance" type="Object"/>
      <property name="h" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.plugins.Flash.flashObject">
    <properties>
      <property name="onError" scope="instance" type="Object"/>
      <property name="onReady" scope="instance" type="Object"/>
      <property name="onLoad" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.plugins.HTML5">
    <description>Add this plugin to have HTML5 capabilities in the Uploader. Note that it does not add
	these capabilities to browsers that don't support them. For IE or older browsers, add
	additional plugins: IFrame or Flash.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="upload" scope="instance">
        <parameters>
          <parameter name="formData" type="Object" usage="required">
            <description>?</description>
          </parameter>
        </parameters>
      </method>
      <method name="submit" scope="instance">
        <parameters>
          <parameter name="form" type="form" usage="required">
            <description>Node ?</description>
          </parameter>
        </parameters>
      </method>
      <method name="sendAsBinary" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uploadWithFormData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xhrProgress" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createXhr" scope="instance"/>
      <method name="_buildRequestBody" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="boundary" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="errMsg" scope="instance" type="String"/>
      <property name="uploadType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.form.uploader.plugins.IFrame">
    <description>Only supported by IE, due to the specifc iFrame hack used. The
	dojox.form.uploader.plugins.HTML5 plugin should be used along with this to add HTML5
	capabilities to browsers that support them. Progress events are not supported.
	Inherits all properties from dojox.form.Uploader and dojox.form.uploader.plugins.HTML5.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="upload" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required">
            <description>?</description>
          </parameter>
        </parameters>
      </method>
      <method name="uploadIFrame" scope="instance"/>
    </methods>
    <properties>
      <property name="force" scope="instance" type="String"/>
      <property name="uploadType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.fx">
    <description>A package of animations, and FX-related code, extending Dojo Core fx.
	Including this package includes all the Base and Core fx packages.</description>
    <methods>
      <method name="animateTimeline" scope="instance">
        <description>The Timeline is a replacement for the default dojo._Line.
	Instead of _Line.getValue returning a float between 0-1,
	_Timeline.getValue returns an object with all properties and
	their current values.
	A property does not have to appear in every keyframe.
	As in the example below, "height" is transitioned from the first
	keyframe to the third. "width" is transitioned from the first
	to the second to the third.
	Each keyframe can accept the following custom properties:
	step: String
	The start, finish or percentage that this keyframe represents.
	Allowed parameters are:
	0%-100%
	from (same as 0%, used to conform with the Webkit animation spec)
	to (same as 100%, used to conform with the Webkit animation spec)
	ease: String
	The string name of a dojo.fx.easing ease. Defaults to "linear". Use
	the suffix name of the ease, like: "quadIn", not: "dojo.fx.quadIn".</description>
        <examples>
          <example>	var keys = [
		{
			step:"0px",
			ease:"quadInOut",
			width:"50px",
			height:"50px",
		},{
			step:"25%",
			width:"190px"
		},{
			step:"100%",
			width:"10px",
			height:"200px",
		}
		];
		ani = dojox.fx.animateTimeline({keys:keys, duration:2000}, "myDiv").play();</example>
        </examples>
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <description>The paramters passed to the timeline animation. Includes:
	keys: Array
	An array of objects, with style properties and values.
	duration:
	Duration of the animation in milliseconds.
	Defaults to 1000.</description>
          </parameter>
          <parameter name="node" type="DomNode|String" usage="required">
            <description>DomNode The DomNode or id to be animated.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="anim" scope="instance"/>
      <method name="animateProperty" scope="instance"/>
      <method name="fadeTo" scope="instance"/>
      <method name="fadeIn" scope="instance"/>
      <method name="fadeOut" scope="instance"/>
      <method name="combine" scope="instance"/>
      <method name="chain" scope="instance"/>
      <method name="slideTo" scope="instance"/>
      <method name="wipeIn" scope="instance"/>
      <method name="wipeOut" scope="instance"/>
      <method name="sizeTo" scope="instance">
        <description>Returns an animation that will size the target node
	defined in args Object about it's center to
	a width and height defined by (args.width, args.height),
	supporting an optional method: chain||combine mixin
	(defaults to chain).
	- works best on absolutely or relatively positioned elements</description>
        <examples>
          <example>	// size #myNode to 400px x 200px over 1 second
		dojo.fx.sizeTo({
			node:'myNode',
			duration: 1000,
			width: 400,
			height: 200,
			method: "combine"
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="slideBy" scope="instance">
        <description>Returns an animation that will slide a node (args.node) from it's
	current position to it's current posision plus the numbers defined
	in args.top and args.left. standard dojo.fx mixin's apply.</description>
        <examples>
          <example>	// slide domNode 50px down, and 22px left
		dojox.fx.slideBy({
			node: domNode, duration:400,
			top: 50, left: -22
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="crossFade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.nodes: Array - two element array of domNodes, or id's
	all other standard animation args mixins apply. args.node ignored.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="highlight" scope="instance">
        <description>Returns an animation that sets the node background to args.color
	then gradually fades back the original node background color</description>
        <examples>
          <example>	dojox.fx.highlight({ node:"foo" }).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="wipeTo" scope="instance">
        <description>Returns an animation that will expand the
	node defined in 'args' object from it's current to
	the height or width value given by the args object.
	default to height:, so leave height null and specify width:
	to wipeTo a width. note: this may be deprecated by a
	Note that the final value should not include
	units and should be an integer.  Thus a valid args object
	would look something like this:
		dojox.fx.wipeTo({ node: "nodeId", height: 200 }).play();
	Node must have no margin/border/padding, so put another
	node inside your target node for additional styling.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="flip" scope="instance">
        <description>Returns an animation that will flip the
	node around a central axis:
	if args.dir is "left" or "right" --&gt; y axis
	if args.dir is "top" or "bottom" --&gt; x axis
	This effect is obtained using a border distorsion applied to a helper node.
	The user can specify three background colors for the helper node:
	darkColor: the darkest color reached during the animation
	lightColor: the brightest color
	endColor: the final backgroundColor for the node
	depth: Float
	0 &lt;= depth &lt;= 1 overrides the computed "depth"
	(0: min distorsion, 1: max distorsion)
	whichAnim: String
	"first"          : the first half animation
	"last"           : the second one
	"both" (default) : both
	axis: String
	"center" (default)    : the node is flipped around his center
	"shortside"           : the node is flipped around his "short" (in perspective) side
	"longside"            : the node is flipped around his "long" (in perspective) side
	"cube"                : the node flips around the central axis of the cube
	shift: Integer
	node translation, perpendicular to the rotation axis</description>
        <examples>
          <example>	var anim = dojox.fx.flip({
			node: dojo.byId("nodeId"),
			dir: "top",
			darkColor: "#555555",
			lightColor: "#dddddd",
			endColor: "#666666",
			depth: .5,
			shift: 50,
			duration:300
		  });</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="flipCube" scope="instance">
        <description>An extension to `dojox.fx.flip` providing a more 3d-like rotation.
	Behaves the same as `dojox.fx.flip`, using the same attributes and
	other standard `dojo.Animation` properties.</description>
        <examples>
          <example>See `dojox.fx.flip`</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flipPage" scope="instance">
        <description>An extension to `dojox.fx.flip` providing a page flip effect.
	Behaves the same as `dojox.fx.flip`, using the same attributes and
	other standard `dojo.Animation` properties.</description>
        <examples>
          <example>See `dojox.fx.flip`</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flipGrid" scope="instance">
        <description>An extension to `dojox.fx.flip` providing a page flip effect.
	Behaves the same as `dojox.fx.flip`, using the same attributes and
	other standard `dojo.Animation` properties and
	cols: Integer columns
	rows: Integer rows
	duration: the single flip duration</description>
        <examples>
          <example>See `dojox.fx.flip`</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="smoothScroll" scope="instance">
        <description>This implementation support either horizontal or vertical scroll, as well as
	both. In addition, element in iframe can be scrolled to correctly.
	offset: {x: int, y: int} this will be added to the target position
	duration: Duration of the animation in milliseconds.
	win: a node or window object to scroll</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_split" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that move independently.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.crop: Boolean - If true, pieces will only be visible inside node's boundries
	args.rows: Integer - The number of horizontal pieces (default is 3)
	args.columns: Integer - The number of vertical pieces (default is 3)
	args.pieceAnimation: Function(piece, x, y, coords) - Returns either the dojo.Animation
	or an array of dojo.Animation objects for the piece at location (x, y) in the node's grid;
	coords is the result of dojo.coords(args.node, true);</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="explode" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that fly away from the center.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.rows: Integer - The number of horizontal pieces (default is 3)
	args.columns: Integer - The number of vertical pieces (default is 3)
	args.random: Float - If set, pieces fly to random distances, for random durations,
	and in slightly random directions.  The value defines how much
	randomness is introduced.
	args.distance: Float - Multiplier for the distance the pieces fly (even when random)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.fadeEasing: Function - If args.fade is true, the fade animations use this easing function
	args.unhide: Boolean - If true, the animation is reversed
	args.sync: Boolean - If args.unhide is true, all the pieces converge at the same time
	(default is true)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="converge" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disintegrate" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that drop.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.rows: Integer - The number of horizontal pieces (default is 5)
	args.columns: Integer - The number of vertical pieces (default is 5)
	args.interval: Float - The number of milliseconds between each piece's animation
	args.distance: Float - The number of the node's heights to drop (default is 1.5)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.random: Float - If set, pieces fall in random order. The value defines how much
	randomness is introduced.
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the peices fall from above and land in place</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="build" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shear" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that slide in alternating directions.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.rows: Integer - The number of horizontal pieces (default is 6)
	args.columns: Integer - The number of vertical pieces (default is 6)
	args.interval: Float - The number of milliseconds between each piece's animation (default is 0)
	args.distance: Float - The multiple of the node's dimensions to slide (default is 1)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the animation is reversed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="unShear" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pinwheel" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that wipe in alternating directions.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.rows: Integer - The number of horizontal pieces (default is 4)
	args.columns: Integer - The number of vertical pieces (default is 4)
	args.interval: Float - The number of milliseconds between each piece's animation (default is 0)
	args.distance: Float - The percentage of the piece's dimensions the piece should wipe
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced.
	args.unhide: Boolean - If true, the animation is reversed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="unPinwheel" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="blockFadeOut" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that fade in or out.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.rows: Integer - The number of horizontal pieces (default is 5)
	args.columns: Integer - The number of vertical pieces (default is 5)
	args.interval: Float - The number of milliseconds between each piece's animation (default is 0)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the animation is reversed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="blockFadeIn" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="addClass" scope="instance">
        <description>Creates an animation that will animate
	the properties of a node to the properties
	defined in a standard CSS .class definition.
	(calculating the differences itself)</description>
        <examples>
          <example>	.bar { line-height: 12px; }
		.foo { line-height: 40px; }
		&lt;div class="bar" id="test"&gt;
		Multi&lt;br&gt;line&lt;br&gt;text
		&lt;/div&gt;
		// animate to line-height:40px
		dojo.fx.addClass("test", "foo").play();</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>A String ID or DomNode referce to animate</description>
          </parameter>
          <parameter name="cssClass" type="String" usage="required">
            <description>The CSS class name to add to the node</description>
          </parameter>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional optional &lt;code&gt;dojo.animateProperty&lt;/code&gt; arguments, such as
	duration, easing and so on.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="removeClass" scope="instance">
        <description>Creates an animation that will animate the properties of a
	node (args.node) to the properties calculated after removing
	a standard CSS className from a that node.
	calls dojo.removeClass(args.cssClass) onEnd of animation
	standard dojo.Animation object rules apply.</description>
        <examples>
          <example>	// animate the removal of "foo" from a node with id="bar"
		dojox.fx.removeClass("bar", "foo").play()</example>
        </examples>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cssClass" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="toggleClass" scope="instance">
        <description>creates an animation that will animate the effect of
	toggling a class on or off of a node.
	Adds a class to node if not present, or removes if present.
	Pass a boolean condition if you want to explicitly add or remove.</description>
        <examples>
          <example>	// add the class "sampleClass" to a node id="theNode"
		dojox.fx.toggleClass("theNode","sampleClass",true).play();</example>
          <example>	// toggle the class "sampleClass" on the node id="theNode"
		dojox.fx.toggleClass("theNode","sampleClass").play();</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <description>The domNode (or string of the id) to toggle</description>
          </parameter>
          <parameter name="cssClass" type="String" usage="required">
            <description>String of the classname to add to the node</description>
          </parameter>
          <parameter name="condition" type="Boolean" usage="optional">
            <description>If passed, true means to add the class, false means to remove.</description>
          </parameter>
          <parameter name="args" type="Object" usage="optional">
            <description>Additional &lt;code&gt;dojo.Animation&lt;/code&gt; args to pass along.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="Timeline" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="_core" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object">
        <description>An Alias to &lt;code&gt;dojo.fx.easing&lt;/code&gt;. Moved to Core in Dojo 1.2.</description>
      </property>
      <property name="scroll" scope="instance" type="Object">
        <description>Module to provide scroll-related FX</description>
      </property>
      <property name="split" scope="instance" type="Object"/>
      <property name="_allowedProperties" scope="instance" type="Array"/>
      <property name="style" scope="instance" type="Object">
        <description>Module to provide CSS animations</description>
      </property>
    </properties>
  </class>
  <class type="dojox.fx.Shadow" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_makePiece" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="vertAttach" type="Object" usage="required"/>
          <parameter name="vertCoord" type="Object" usage="required"/>
          <parameter name="horzAttach" type="Object" usage="required"/>
          <parameter name="horzCoord" type="Object" usage="required"/>
          <parameter name="sizing" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOpacity" scope="instance">
        <parameters>
          <parameter name="n" type="Float" usage="required"/>
          <parameter name="animArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.fx._arg.ShadowResizeArgs" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="shadowPng" scope="instance" type="String">
        <description>Base location for drop-shadow images</description>
      </property>
      <property name="shadowThickness" scope="instance" type="Integer">
        <description>How wide (in px) to make the shadow</description>
      </property>
      <property name="shadowOffset" scope="instance" type="Integer">
        <description>How deep to make the shadow appear to be</description>
      </property>
      <property name="opacity" scope="instance" type="Float">
        <description>Overall opacity of the shadow</description>
      </property>
      <property name="animate" scope="instance" type="Boolean">
        <description>A toggle to disable animated transitions</description>
      </property>
      <property name="node" scope="instance" type="DomNode">
        <description>The node we will be applying this shadow to</description>
      </property>
      <property name="pieces" scope="instance" type="Object"/>
      <property name="nodeList" scope="instance" type="Object"/>
      <property name="disabled" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.fx.Shadow.node.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.fx._Timeline">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="p" type="float" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="keys" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx._Timeline.flatten">
    <methods/>
    <properties>
      <property name="_properties" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx._arg"/>
  <class type="dojox.fx._arg.StyleArgs">
    <methods/>
    <properties>
      <property name="node" scope="instance" type="DOMNode">
        <description>The node to manipulate</description>
      </property>
      <property name="cssClass" scope="instance" type="String">
        <description>The class to use during the manipulation</description>
      </property>
    </properties>
  </class>
  <class type="dojox.fx._arg.ShadowResizeArgs">
    <methods/>
    <properties>
      <property name="x" scope="instance" type="Integer">
        <description>the width to set</description>
      </property>
      <property name="y" scope="instance" type="Integer">
        <description>the height to set</description>
      </property>
    </properties>
  </class>
  <class type="dojox.fx._Line">
    <description>a normal dojo._Line is the curve, and does Line(start,end)
	for propertyAnimation. as we make more complicatied animations, we realize
	some properties can have 2, or 4 values relevant (x,y) or (t,l,r,b) for example
	this function provides support for those Lines, and is ported directly from 0.4
	this is a lot of extra code for something so seldom used, so we'll put it here as
	and optional core addition. you can create a new line, and use it during onAnimate
	as you see fit.</description>
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="float" usage="required">
            <description>a floating point number greater than 0 and less than 1</description>
          </parameter>
        </parameters>
        <return-description>Mixed</return-description>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="start" scope="instance" type="Integer|Array">
        <description>An Integer (or an Array of integers) to use as a starting point</description>
      </property>
      <property name="end" scope="instance" type="Integer|Array">
        <description>An Integer (or an Array of integers) to use as an ending point</description>
      </property>
    </properties>
  </class>
  <class type="dojox.fx.ext-dojo">
    <properties>
      <property name="NodeList-style" scope="instance" type="Object"/>
      <property name="NodeList" scope="instance" type="Object">
        <description>module to include to support dojox.fx animations in dojo.query()</description>
      </property>
      <property name="complex" scope="instance" type="Object"/>
      <property name="reverse" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx._Complex">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="r" type="Float" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="makePropObject" scope="instance">
        <parameters>
          <parameter name="beg" type="String" usage="required"/>
          <parameter name="end" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getProps" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getNumAndUnits" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="PROP" scope="instance" type="RegExp"/>
      <property name="_properties" scope="instance" type="Object"/>
      <property name="strProp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Animation.reverse">
    <methods/>
    <properties>
      <property name="_reversed" scope="instance" type="bool"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="properties" scope="instance" type="Object"/>
      <property name="_endTime" scope="instance" type="String"/>
      <property name="_startTime" scope="instance" type="Number"/>
      <property name="fEase" scope="instance" type="Object"/>
      <property name="rEase" scope="instance" type="Object"/>
      <property name="easing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.Animation.reverse.curve">
    <properties>
      <property name="_properties" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.fx.text">
    <methods>
      <method name="_split" scope="instance">
        <description>Returns an animation that will split the node into a grid
	of pieces that move independently.
	NOTE:
	In some rendering engines, the text will appear to "jump" from its initial position
	when the animation begins.	To work around this bug, enclose the node's text in a &lt;p&gt; or &lt;div&gt;.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.crop: Boolean - If true, pieces will be positioned relatively rather than absolutely
	args.text: String - Text to place inside the node (otherwise node.innerHTML is used)
	args.words: Boolean - If true, the text will be split into words rather than characters
	args.pieceAnimation: Function(piece, pieceCoords, nodeCoords, number, numPieces)
	- Returns either the dojo.Animation or an array of dojo.Animation objects for the piece;
	pieceCoords is the result of dojo.coords(piece, true);
	nodeCoords is the result of dojo.coords(args.node, true);
	number is the piece's position in the array of pieces, and numPieces is the array.length</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="explode" scope="instance">
        <description>Returns an animation that will split the text into a spans
	of words or characters that fly away from the center.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.crop: Boolean - If true, pieces will be positioned relatively rather than absolutely
	args.words: Boolean - If true, text will be split into words rather than characters
	args.random: Float - If set, pieces fly to random distances, for random durations,
	and in slightly random directions. The value defines how much
	randomness is introduced.
	args.distance: Float - Multiplier for the distance the pieces fly (even when random)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.fadeEasing: Function - If args.fade is true, the fade animations use this easing function
	args.unhide: Boolean - If true, the animation is reversed
	args.sync: Boolean - If args.unhide is true, all the pieces converge at the same time
	(default is true)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="converge" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disintegrate" scope="instance">
        <description>Returns an animation that will split the text into spans of words
	or characters that drop.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.crop: Boolean - If true, pieces will be positioned relatively rather than absolutely
	args.words: Boolean - If true, text will be split into words rather than characters
	args.interval: Float - The number of milliseconds between each piece's animation
	args.distance: Float - The number of the node's heights to drop (default is 1.5)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.random: Float - If set, pieces fall in random order. The value defines how much
	randomness is introduced
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the peices fall from above and land in place</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="build" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="blockFadeOut" scope="instance">
        <description>Returns an animation that will split the text into spans of words
	or characters that fade in or out.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.words: Boolean - If true, text will be split into words rather than characters
	args.interval: Float - The number of milliseconds between each piece's animation (default is 0)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the animation is reversed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="blockFadeIn" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="backspace" scope="instance">
        <description>Returns an animation that will split the text into spans of words
	or characters that appear as if they were being backspaced (or typed) in real-time.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>args.interval: Float - The number of milliseconds between each piece's animation
	(default is determined by text length and args.duration);
	args.wordDelay: Integer - The number of milliseconds between each word
	(only effective when args.unhide = true)
	args.fixed: Boolean - If true, only style.opacity changes; otherwise, style.display
	changes between none and inline, adding realism (default = false)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced (only effective when args.unhide = true)
	args.unhide: Boolean - If true, the animation is reversed</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="type" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gantt"/>
  <class type="dojox.gantt.GanttChart">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="configuration" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getProject" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkPosPreviousTask" scope="instance">
        <parameters>
          <parameter name="predTask" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="correctPosPreviousTask" scope="instance">
        <parameters>
          <parameter name="predTask" type="Object" usage="required"/>
          <parameter name="ctask" type="Object" usage="required"/>
          <parameter name="ctaskObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="correctPosParentTask" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
          <parameter name="ctask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkPosParentTaskInTree" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPreviousTask" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPreviousTaskInTree" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkPosParentTask" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addProject" scope="instance">
        <parameters>
          <parameter name="projectItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteProject" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertProject" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="startDate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openTree" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="openNode" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastCloseParent" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getProjectItemById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearAll" scope="instance"/>
      <method name="clearEvents" scope="instance"/>
      <method name="clearData" scope="instance"/>
      <method name="clearItems" scope="instance"/>
      <method name="buildUIContent" scope="instance"/>
      <method name="loadJSONData" scope="instance">
        <parameters>
          <parameter name="filename" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadJSONString" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildChildTasksData" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
          <parameter name="childTaskItems" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getJSONData" scope="instance"/>
      <method name="getChildTasksData" scope="instance">
        <parameters>
          <parameter name="childTasks" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saveJSONData" scope="instance">
        <parameters>
          <parameter name="fileName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sortTaskStartTime" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sortProjStartDate" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStartTimeChild" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createPanelTasks" scope="instance"/>
      <method name="refreshParams" scope="instance">
        <parameters>
          <parameter name="pixelsPerDay" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createPanelNamesTasksHeader" scope="instance"/>
      <method name="createPanelNamesTasks" scope="instance"/>
      <method name="createPanelTime" scope="instance"/>
      <method name="adjustPanelTime" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addYearInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="year" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addMonthInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="month" type="Object" usage="required"/>
          <parameter name="year" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addWeekInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="week" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addDayInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addHourInPanelTime" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="incHeightPanelTasks" scope="instance">
        <parameters>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="incHeightPanelNames" scope="instance">
        <parameters>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkPosition" scope="instance"/>
      <method name="checkHeighPanelTasks" scope="instance"/>
      <method name="sortTasksByStartTime" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sortChildTasks" scope="instance">
        <parameters>
          <parameter name="parenttask" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance">
        <parameters>
          <parameter name="count" type="Object" usage="required"/>
          <parameter name="current" type="Object" usage="required"/>
          <parameter name="multi" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="switchTeleMicroView" scope="instance">
        <parameters>
          <parameter name="dip" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshController" scope="instance"/>
      <method name="init" scope="instance"/>
      <method name="postLoadData" scope="instance"/>
      <method name="postBindEvents" scope="instance"/>
      <method name="getStartDate" scope="instance"/>
      <method name="getCountDays" scope="instance"/>
      <method name="createTasks" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createChildItemControls" scope="instance">
        <parameters>
          <parameter name="arrChildTasks" type="Object" usage="required"/>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPosOnDate" scope="instance">
        <parameters>
          <parameter name="startTime" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidthOnDuration" scope="instance">
        <parameters>
          <parameter name="duration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastChildTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeCell" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="project" scope="instance-prototype" type="Array"/>
      <property name="contentDataHeight" scope="instance-prototype" type="Number"/>
      <property name="startDate" scope="instance-prototype" type="Object"/>
      <property name="_events" scope="instance-prototype" type="Array"/>
      <property name="arrProjects" scope="instance-prototype" type="Array"/>
      <property name="pixelsPerDay" scope="instance-prototype" type="Number"/>
      <property name="pixelsPerWorkHour" scope="instance-prototype" type="Number"/>
      <property name="pixelsPerHour" scope="instance-prototype" type="Number"/>
      <property name="zoomInClickEvent" scope="instance" type="Object"/>
      <property name="zoomInKeyEvent" scope="instance" type="Object"/>
      <property name="zoomOutClickEvent" scope="instance" type="Object"/>
      <property name="zoomOutKeyEvent" scope="instance" type="Object"/>
      <property name="microClickEvent" scope="instance" type="Object"/>
      <property name="microKeyEvent" scope="instance" type="Object"/>
      <property name="teleClickEvent" scope="instance" type="Object"/>
      <property name="teleKeyEvent" scope="instance" type="Object"/>
      <property name="saveClickEvent" scope="instance" type="Object"/>
      <property name="saveKeyEvent" scope="instance" type="Object"/>
      <property name="loadClickEvent" scope="instance" type="Object"/>
      <property name="loadKeyEvent" scope="instance" type="Object"/>
      <property name="totalDays" scope="instance-prototype" type="Number"/>
      <property name="maxTaskEndPos" scope="instance" type="Object"/>
      <property name="tempDayInPixels" scope="instance-prototype" type="Number"/>
      <property name="tableControl" scope="instance" type="Object"/>
      <property name="countDays" scope="instance-prototype" type="Number"/>
      <property name="panelTime" scope="instance-prototype" type="Object"/>
      <property name="panelNameHeaders" scope="instance" type="Object"/>
      <property name="tabMenu" scope="instance-prototype" type="Object"/>
      <property name="resource" scope="instance-prototype" type="Object"/>
      <property name="panelNameHeadersCover" scope="instance" type="Object"/>
      <property name="initialPos" scope="instance-prototype" type="Number"/>
      <property name="resourceChartHeight" scope="instance" type="Object"/>
      <property name="withResource" scope="instance" type="Object"/>
      <property name="correctError" scope="instance" type="Object"/>
      <property name="isShowConMenu" scope="instance" type="bool"/>
      <property name="isContentEditable" scope="instance" type="bool"/>
      <property name="withTaskId" scope="instance" type="Object"/>
      <property name="animation" scope="instance" type="Object"/>
      <property name="saveProgramPath" scope="instance" type="String"/>
      <property name="dataFilePath" scope="instance" type="String"/>
      <property name="contentHeight" scope="instance" type="Number"/>
      <property name="contentWidth" scope="instance" type="Number"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="scrollBarWidth" scope="instance" type="Number"/>
      <property name="panelTimeHeight" scope="instance" type="Number"/>
      <property name="maxWidthPanelNames" scope="instance" type="Number"/>
      <property name="maxWidthTaskNames" scope="instance" type="Number"/>
      <property name="minWorkLength" scope="instance" type="Number"/>
      <property name="heightTaskItem" scope="instance" type="Number"/>
      <property name="heightTaskItemExtra" scope="instance" type="Number"/>
      <property name="hsPerDay" scope="instance" type="Number"/>
      <property name="panelTimeExpandDelta" scope="instance" type="Number"/>
      <property name="divTimeInfo" scope="instance" type="Object"/>
      <property name="xmlLoader" scope="instance" type="Object"/>
      <property name="isMoving" scope="instance" type="bool"/>
      <property name="isResizing" scope="instance" type="bool"/>
      <property name="animationNodes" scope="instance" type="Array"/>
      <property name="scale" scope="instance" type="Number"/>
      <property name="months" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelTime.firstChild.firstChild">
    <properties>
      <property name="rows" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelTime.firstChild.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.contentData.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.contentData">
    <methods>
      <method name="onscroll" scope="instance"/>
    </methods>
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelNames">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelNames.firstChild.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttChart.panelTime.firstChild"/>
  <class type="dojox.gantt.GanttChart.panelTime.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="ganttChart" type="Object" usage="required"/>
          <parameter name="projectItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkWidthProjectNameItem" scope="instance"/>
      <method name="refreshProjectItem" scope="instance">
        <parameters>
          <parameter name="projectItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshDescrProject" scope="instance">
        <parameters>
          <parameter name="divDesc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postLoadData" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="getTaskById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="searchTaskInTree" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftProjectItem" scope="instance"/>
      <method name="adjustPanelTime" scope="instance"/>
      <method name="resizeProjectItem" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftDescrProject" scope="instance"/>
      <method name="showDescrProject" scope="instance"/>
      <method name="hideDescrProject" scope="instance"/>
      <method name="getDescStr" scope="instance"/>
      <method name="createDescrProject" scope="instance"/>
      <method name="createProjectItem" scope="instance"/>
      <method name="createProjectNameItem" scope="instance"/>
      <method name="getPercentCompleted" scope="instance"/>
      <method name="getDuration" scope="instance"/>
      <method name="deleteTask" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setName" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPercentCompleted" scope="instance">
        <parameters>
          <parameter name="percentage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteChildTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertTask" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="startTime" type="Object" usage="required"/>
          <parameter name="duration" type="Object" usage="required"/>
          <parameter name="percentage" type="Object" usage="required"/>
          <parameter name="previousTaskId" type="Object" usage="required"/>
          <parameter name="taskOwner" type="Object" usage="required"/>
          <parameter name="parentTaskId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftNextProject" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftProject" scope="instance">
        <parameters>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftNextParentTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftChildTasks" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="percentage" scope="instance-prototype" type="Number"/>
      <property name="posX" scope="instance-prototype" type="Number"/>
      <property name="posY" scope="instance-prototype" type="Number"/>
      <property name="duration" scope="instance-prototype" type="Number"/>
      <property name="nextProject" scope="instance" type="Object"/>
      <property name="previousProject" scope="instance" type="Object"/>
      <property name="arrTasks" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectNameItem">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.descrProject.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.ganttChart.contentData">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.ganttChart.panelNames">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.project">
    <properties>
      <property name="startDate" scope="instance" type="Object"/>
      <property name="name" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
      <property name="width" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells.0.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells.1.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.lastChild.firstChild">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.descrProject">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells"/>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells.0">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectItem.0.firstChild.rows.0.cells.1">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.ganttChart">
    <properties>
      <property name="minWorkLength" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectControl.projectNameItem.style">
    <properties>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttProjectItem">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="configuration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTaskById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTaskByIdInTree" scope="instance">
        <parameters>
          <parameter name="parentTask" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteTask" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="id" scope="instance" type="Object"/>
      <property name="name" scope="instance" type="Object"/>
      <property name="startDate" scope="instance" type="Object"/>
      <property name="parentTasks" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttResourceItem">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="ganttchart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearAll" scope="instance"/>
      <method name="clearData" scope="instance"/>
      <method name="clearItems" scope="instance"/>
      <method name="buildResource" scope="instance"/>
      <method name="buildOwnerTimeConsume" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="reConstruct" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="postAdjustment" scope="instance"/>
      <method name="refreshOwnerEntry" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createOwnerEntry" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createOwnerNameItem" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="posY" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshOwnerItem" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createOwnerItem" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="posY" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshDetailedTaskEntry" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createDetailedTaskEntry" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="parentNode" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createTaskNameItem" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="posY" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshTaskItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createTaskItem" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="posY" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createConnectingLinesPN" scope="instance">
        <parameters>
          <parameter name="parentNode" type="Object" usage="required"/>
          <parameter name="currentNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createTreeImg" scope="instance">
        <parameters>
          <parameter name="ownerNameItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleOwnerItem" scope="instance">
        <parameters>
          <parameter name="tItem" type="Object" usage="required"/>
          <parameter name="owner" type="Object" usage="required"/>
          <parameter name="displayType" type="Object" usage="required"/>
          <parameter name="topOffset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkWidthTaskNameItem" scope="instance">
        <parameters>
          <parameter name="taskNameItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createPanelOwners" scope="instance"/>
      <method name="createPanelNamesOwners" scope="instance"/>
    </methods>
    <properties>
      <property name="ownerItem" scope="instance-prototype" type="Array"/>
      <property name="ownerNameItem" scope="instance-prototype" type="Array"/>
      <property name="ownerTaskNodeMapping" scope="instance-prototype" type="Object"/>
      <property name="ownerTaskNodeMapping_time" scope="instance-prototype" type="Object"/>
      <property name="resourceInfo" scope="instance-prototype" type="Object"/>
      <property name="ownerTimeConsume" scope="instance-prototype" type="Object"/>
      <property name="tableControl" scope="instance" type="Object"/>
      <property name="contentHeight" scope="instance" type="Object"/>
      <property name="contentWidth" scope="instance" type="Object"/>
      <property name="panelNames" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="ganttChart" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttResourceItem.contentData.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttResourceItem.contentData.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttResourceItem.contentData">
    <methods>
      <method name="onscroll" scope="instance"/>
    </methods>
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttResourceItem.panelNames.firstChild.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="taskInfo" type="Object" usage="required"/>
          <parameter name="project" type="Object" usage="required"/>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createConnectingLinesPN" scope="instance"/>
      <method name="createConnectingLinesDS" scope="instance"/>
      <method name="showChildTasks" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="isOpen" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hideChildTasks" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftCurrentTasks" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftNextTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shiftChildTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endMove" scope="instance"/>
      <method name="checkPos" scope="instance">
        <parameters>
          <parameter name="startTime" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMaxPosPredChildTaskItem" scope="instance"/>
      <method name="getMaxPosPredChildTaskItemInTree" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveCurrentTaskItem" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="moveChild" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveChildTaskItems" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="moveChild" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjustPanelTime" scope="instance"/>
      <method name="getDateOnPosition" scope="instance">
        <parameters>
          <parameter name="position" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveItem" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveTaskItem" scope="instance">
        <parameters>
          <parameter name="posX" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resizeItem" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resizeTaskItem" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="endResizeItem" scope="instance"/>
      <method name="startMove" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showDescTask" scope="instance"/>
      <method name="hideDescTask" scope="instance"/>
      <method name="buildResourceInfo" scope="instance">
        <parameters>
          <parameter name="resourceInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="objKeyToStr" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="delm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTaskOwner" scope="instance"/>
      <method name="moveDescTask" scope="instance"/>
      <method name="getMoveInfo" scope="instance"/>
      <method name="startResize" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getResizeInfo" scope="instance"/>
      <method name="createTaskItem" scope="instance"/>
      <method name="createTaskNameItem" scope="instance"/>
      <method name="createTaskDescItem" scope="instance"/>
      <method name="checkWidthTaskNameItem" scope="instance"/>
      <method name="refreshTaskItem" scope="instance">
        <parameters>
          <parameter name="itemControl" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshTaskDesc" scope="instance">
        <parameters>
          <parameter name="divDesc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refreshConnectingLinesDS" scope="instance">
        <parameters>
          <parameter name="arrLines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postLoadData" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="checkPosition" scope="instance"/>
      <method name="createTreeImg" scope="instance"/>
      <method name="setPreviousTask" scope="instance">
        <parameters>
          <parameter name="previousTaskId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearPredTask" scope="instance"/>
      <method name="setStartTime" scope="instance">
        <parameters>
          <parameter name="startTime" type="Object" usage="required"/>
          <parameter name="shiftChild" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setDuration" scope="instance">
        <parameters>
          <parameter name="duration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTaskOwner" scope="instance">
        <parameters>
          <parameter name="owner" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPercentCompleted" scope="instance">
        <parameters>
          <parameter name="percentage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setName" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="checkMove" scope="instance-prototype" type="bool"/>
      <property name="posX" scope="instance-prototype" type="Number"/>
      <property name="maxPosXMove" scope="instance-prototype" type="Number"/>
      <property name="minPosXMove" scope="instance-prototype" type="Number"/>
      <property name="checkResize" scope="instance-prototype" type="bool"/>
      <property name="taskItemWidth" scope="instance-prototype" type="Number"/>
      <property name="mouseX" scope="instance-prototype" type="Number"/>
      <property name="moveChild" scope="instance-prototype" type="bool"/>
      <property name="minWidthResize" scope="instance-prototype" type="Number"/>
      <property name="maxWidthResize" scope="instance-prototype" type="Number"/>
      <property name="posY" scope="instance-prototype" type="Number"/>
      <property name="parentTask" scope="instance-prototype" type="Object"/>
      <property name="taskIdentifier" scope="instance" type="Object"/>
      <property name="ganttChart" scope="instance" type="Object"/>
      <property name="project" scope="instance" type="Object"/>
      <property name="isHide" scope="instance" type="bool"/>
      <property name="hideTasksHeight" scope="instance" type="Number"/>
      <property name="isExpanded" scope="instance" type="Object"/>
      <property name="childTask" scope="instance" type="Array"/>
      <property name="childPredTask" scope="instance" type="Array"/>
      <property name="nextChildTask" scope="instance" type="Object"/>
      <property name="nextParentTask" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskNameItem"/>
  <class type="dojox.gantt.GanttTaskControl.parentTask.cTaskNameItem">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.ganttChart.contentData">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem">
    <properties>
      <property name="1" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.1.firstChild.rows.0.cells.0">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.taskItem">
    <properties>
      <property name="startTime" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Object"/>
      <property name="previousTask" scope="instance" type="Object"/>
      <property name="parentTask" scope="instance" type="Object"/>
      <property name="previousTaskId" scope="instance" type="Object"/>
      <property name="taskOwner" scope="instance" type="Object"/>
      <property name="percentage" scope="instance" type="Object"/>
      <property name="name" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.1.2.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.1.1.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells"/>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells.0.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells.1.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.1.firstChild">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes">
    <properties>
      <property name="2" scope="instance" type="Object"/>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.2.childNodes.0.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.2.childNodes.1.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0">
    <properties>
      <property name="offsetLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.descrTask.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.descrTask">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskNameItem.0">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.ganttChart.panelNames">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.previousParentTask">
    <properties>
      <property name="nextParentTask" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.previousChildTask">
    <properties>
      <property name="nextChildTask" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskNameItem.0.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.predTask">
    <properties>
      <property name="childPredTask" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells.0">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskControl.cTaskItem.0.childNodes.0.firstChild.rows.0.cells.1">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.GanttTaskItem">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="configuration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChildTask" scope="instance">
        <parameters>
          <parameter name="task" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setProject" scope="instance">
        <parameters>
          <parameter name="project" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="project" scope="instance-prototype" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="name" scope="instance" type="Object"/>
      <property name="startTime" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Number"/>
      <property name="percentage" scope="instance" type="Number"/>
      <property name="previousTaskId" scope="instance" type="String"/>
      <property name="taskOwner" scope="instance" type="String"/>
      <property name="cldTasks" scope="instance" type="Array"/>
      <property name="cldPreTasks" scope="instance" type="Array"/>
      <property name="parentTask" scope="instance" type="Object"/>
      <property name="previousTask" scope="instance" type="Object"/>
      <property name="nextChildTask" scope="instance" type="Object"/>
      <property name="previousChildTask" scope="instance" type="Object"/>
      <property name="nextParentTask" scope="instance" type="Object"/>
      <property name="previousParentTask" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="chart" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildContent" scope="instance"/>
      <method name="createMenuPanel" scope="instance"/>
      <method name="createTabPanel" scope="instance"/>
      <method name="addItemMenuPanel" scope="instance">
        <parameters>
          <parameter name="tab" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="object" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="clear" scope="instance"/>
      <method name="createTab" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="desc" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="showOInfo" type="Object" usage="required"/>
          <parameter name="menu" type="Object" usage="required"/>
          <parameter name="withDefaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tabPanelDlgId" scope="instance-prototype" type="Object"/>
      <property name="paneActionBar" scope="instance-prototype" type="Object"/>
      <property name="ok" scope="instance" type="Object"/>
      <property name="cancel" scope="instance" type="Object"/>
      <property name="isShow" scope="instance-prototype" type="bool"/>
      <property name="ganttChart" scope="instance" type="Object"/>
      <property name="arrTabs" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.menuPanel.firstChild">
    <properties>
      <property name="cellPadding" scope="instance" type="Number"/>
      <property name="cellSpacing" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.tabPanelDlg.closeButtonNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.tabPanelDlg">
    <properties>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.paneContentArea">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.paneContentArea.firstChild.rows.0.cells"/>
  <class type="dojox.gantt.TabMenu.paneContentArea.firstChild.rows.0.cells.0">
    <properties>
      <property name="colSpan" scope="instance" type="Number"/>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.paneContentArea.firstChild.rows.1.cells"/>
  <class type="dojox.gantt.TabMenu.paneContentArea.firstChild.rows.1.cells.0">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
      <property name="align" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.menuPanel.style">
    <properties>
      <property name="top" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.TabMenu.menuPanel">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="description" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="showOInfo" type="Object" usage="required"/>
          <parameter name="tabMenu" type="Object" usage="required"/>
          <parameter name="withDefaultValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="preValueValidation" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encodeDate" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decodeDate" scope="instance">
        <parameters>
          <parameter name="dateStr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renameTaskAction" scope="instance"/>
      <method name="deleteAction" scope="instance"/>
      <method name="durationUpdateAction" scope="instance"/>
      <method name="cpUpdateAction" scope="instance"/>
      <method name="ownerUpdateAction" scope="instance"/>
      <method name="ptUpdateAction" scope="instance"/>
      <method name="renameProjectAction" scope="instance"/>
      <method name="deleteProjectAction" scope="instance"/>
      <method name="cpProjectAction" scope="instance"/>
      <method name="addTaskAction" scope="instance"/>
      <method name="addSuccessorTaskAction" scope="instance"/>
      <method name="addChildTaskAction" scope="instance"/>
      <method name="addProjectAction" scope="instance"/>
      <method name="addAction" scope="instance">
        <parameters>
          <parameter name="handler" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addItem" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="required" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="insertData" scope="instance">
        <parameters>
          <parameter name="content" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="actionFunc" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="arrItems" scope="instance" type="Array"/>
      <property name="TabItemContainer" scope="instance" type="Object"/>
      <property name="Description" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
      <property name="showObjectInfo" scope="instance" type="Object"/>
      <property name="withDefaultValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.0.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.1.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.3.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.4.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.5.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.6.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.arrItems.7.control.textbox">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.object">
    <properties>
      <property name="project" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.object.taskItem">
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu">
    <properties>
      <property name="tabPanelDlg" scope="instance" type="Object"/>
      <property name="paneActionBar" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu.tabPanelDlg.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu.paneContentArea.firstChild.rows.1.cells.0">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu.ok">
    <properties>
      <property name="onClick" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu.cancel">
    <properties>
      <property name="onClick" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gantt.contextMenuTab.tabMenu.paneContentArea.firstChild.rows.1.cells"/>
  <class type="dojox.geo.charting">
    <methods>
      <method name="showTooltip" scope="instance">
        <parameters>
          <parameter name="innerHTML" type="String" usage="required"/>
          <parameter name="gfxObject" type="dojox.gfx.shape" usage="required"/>
          <parameter name="position" type="Array&lt;String&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="hideTooltip" scope="instance">
        <parameters>
          <parameter name="gfxObject" type="dojox.gfx.shape" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeArround" scope="instance">
        <parameters>
          <parameter name="gfxObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getGfxContainer" scope="instance">
        <parameters>
          <parameter name="gfxObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRealBBox" scope="instance">
        <parameters>
          <parameter name="gfxObject" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.Map">
    <description>Support rendering Americas, AsiaPacific, ContinentalEurope, EuropeMiddleEastAfrica,
	USStates, WorldCountries, and WorldCountriesMercator by default.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="container" type="HTML" usage="required">
            <description>map container html node/id</description>
          </parameter>
          <parameter name="shapeFile" type="String" usage="required">
            <description>map shape data url, handled as json style
	data format:</description>
          </parameter>
        </parameters>
      </method>
      <method name="setMarkerData" scope="instance">
        <parameters>
          <parameter name="markerFile" type="String" usage="required">
            <description>outside marker data url, handled as json style.
	data format: {&amp;quot;NY&amp;quot;:&amp;quot;New York&amp;quot;,.....}</description>
          </parameter>
        </parameters>
      </method>
      <method name="setDataStore" scope="instance">
        <parameters>
          <parameter name="dataStore" type="ItemFileReadStore" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addSeries" scope="instance">
        <parameters>
          <parameter name="series" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_init" scope="instance">
        <parameters>
          <parameter name="shapeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_appendMarker" scope="instance">
        <parameters>
          <parameter name="markerData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createZoomingCursor" scope="instance"/>
      <method name="onFeatureClick" scope="instance">
        <parameters>
          <parameter name="feature" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFeatureOver" scope="instance">
        <parameters>
          <parameter name="feature" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onZoomEnd" scope="instance">
        <parameters>
          <parameter name="feature" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="defaultColor" scope="instance" type="String">
        <description>Default map feature color, e.g: &amp;quot;#B7B7B7&amp;quot;</description>
      </property>
      <property name="highlightColor" scope="instance" type="String">
        <description>Map feature color when mouse over it, e.g: &amp;quot;#&amp;quot;</description>
      </property>
      <property name="series" scope="instance" type="Array">
        <description>stack to data range, e.g: [{name:'label 1', min:20, max:70, color:'#DDDDDD'},{...},...]</description>
      </property>
      <property name="dataStore" scope="instance" type="Object"/>
      <property name="containerSize" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="container" scope="instance" type="map">
        <description>container html node/id
	shapeFile:
	map shape data url, handled as json style
	data format:</description>
      </property>
    </properties>
  </class>
  <class type="dojox.geo.charting.Map.mapObj">
    <properties>
      <property name="scale" scope="instance" type="Object"/>
      <property name="currentScale" scope="instance" type="Object"/>
      <property name="boundBox" scope="instance" type="Object"/>
      <property name="currentBBox" scope="instance" type="Object"/>
      <property name="marker" scope="instance" type="Object"/>
      <property name="features" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo"/>
  <class type="dojox.geo.charting._Feature">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="parent" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="shapeData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setFillWith" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStrokeWith" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeStrokeWeight" scope="instance">
        <parameters>
          <parameter name="weight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onmouseoverHandler" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onmouseoutHandler" scope="instance"/>
      <method name="_onmousemoveHandler" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onclickHandler" scope="instance"/>
      <method name="_focus" scope="instance"/>
      <method name="_zoomIn" scope="instance"/>
      <method name="_zoomOut" scope="instance"/>
      <method name="init" scope="instance"/>
    </methods>
    <properties>
      <property name="_isZoomIn" scope="instance" type="bool"/>
      <property name="_isFocused" scope="instance" type="Object"/>
      <property name="markerText" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="_defaultFill" scope="instance-prototype" type="Object"/>
      <property name="tooltip" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
      <property name="_bbox" scope="instance" type="Object"/>
      <property name="_center" scope="instance" type="Object"/>
      <property name="_highlightFill" scope="instance" type="Object"/>
      <property name="_defaultStroke" scope="instance" type="Object"/>
      <property name="_scale" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting._Feature.mapObj">
    <properties>
      <property name="currentScale" scope="instance" type="Object"/>
      <property name="currentBBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting._Feature.shape.rawNode">
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting._Marker">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="markerData" type="Object" usage="required"/>
          <parameter name="map" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="featureId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="_getGroupBoundingBox" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toWindowCoords" scope="instance">
        <parameters>
          <parameter name="arround" type="Object" usage="required"/>
          <parameter name="coords" type="Object" usage="required"/>
          <parameter name="containerSize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="markerText" scope="instance" type="Object"/>
      <property name="currentFeature" scope="instance" type="Object"/>
      <property name="_arround" scope="instance" type="Object"/>
      <property name="features" scope="instance" type="Object"/>
      <property name="markerData" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.geo.charting.widget"/>
  <class type="dojox.geo.charting.widget.Legend" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="_addLabel" scope="instance">
        <parameters>
          <parameter name="color" type="Object" usage="required"/>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="horizontal" scope="instance" type="Object"/>
      <property name="legendNode" scope="instance" type="Object"/>
      <property name="legendBody" scope="instance" type="Object"/>
      <property name="swatchSize" scope="instance" type="Number"/>
      <property name="series" scope="instance" type="Object"/>
      <property name="_tr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Moveable">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>a shape object to be moved</description>
          </parameter>
          <parameter name="params" type="Object" usage="required">
            <description>an optional object with additional parameters;
	following parameters are recognized:</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMoveStart" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoving" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoved" scope="instance">
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="shape" scope="instance-prototype" type="dojox.gfx.Shape">
        <description>a shape object to be moved
	params: Object: an optional object with additional parameters;
	following parameters are recognized:</description>
      </property>
      <property name="_lastX" scope="instance" type="Object"/>
      <property name="_lastY" scope="instance" type="Object"/>
      <property name="delay" scope="instance" type="Number">
        <description>delay move by this number of pixels</description>
      </property>
      <property name="mover" scope="instance" type="Object">
        <description>a constructor of custom Mover</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.Mover">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>a shape object to be moved</description>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <description>a mouse event, which started the move;
	only clientX and clientY properties are used</description>
          </parameter>
          <parameter name="host" type="Object" usage="optional">
            <description>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="lastX" scope="instance-prototype" type="Object"/>
      <property name="lastY" scope="instance-prototype" type="Object"/>
      <property name="host" scope="instance-prototype" type="Object">
        <description>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</description>
      </property>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="shape" scope="instance-prototype" type="dojox.gfx.Shape">
        <description>a shape object to be moved
	e: Event: a mouse event, which started the move;
	only clientX and clientY properties are used</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.vectorFontFitting">
    <properties>
      <property name="NONE" scope="instance" type="Number"/>
      <property name="FLOW" scope="instance" type="Number"/>
      <property name="FIT" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultVectorText">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="String"/>
      <property name="align" scope="instance" type="String"/>
      <property name="decoration" scope="instance" type="String"/>
      <property name="fitting" scope="instance" type="Number"/>
      <property name="leading" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultVectorFont">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="size" scope="instance" type="String"/>
      <property name="family" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.VectorFont">
    <methods>
      <method name="_decodeEntitySequence" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parse" scope="instance">
        <parameters>
          <parameter name="svg" type="String" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_clean" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="url" type="String|dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="url" type="String|dojo._Url" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.VectorFont"/>
        </return-types>
      </method>
      <method name="initialized" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_round" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_leading" scope="instance">
        <parameters>
          <parameter name="unit" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalize" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getWidth" scope="instance">
        <parameters>
          <parameter name="glyphs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLongestLine" scope="instance">
        <parameters>
          <parameter name="lines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_trim" scope="instance">
        <parameters>
          <parameter name="lines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_split" scope="instance">
        <parameters>
          <parameter name="chars" type="Object" usage="required"/>
          <parameter name="nLines" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getSizeFactor" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getFitFactor" scope="instance">
        <parameters>
          <parameter name="lines" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
          <parameter name="l" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBestFit" scope="instance">
        <parameters>
          <parameter name="chars" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
          <parameter name="ldng" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBestFlow" scope="instance">
        <parameters>
          <parameter name="chars" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="scale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
      </method>
      <method name="getLineHeight" scope="instance">
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="getCenterline" scope="instance">
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
      </method>
      <method name="getBaseline" scope="instance">
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="draw" scope="instance">
        <description>The main method of a VectorFont, draw() will take a text fragment
	and render it in a set of groups and paths based on the parameters
	passed.
	The basics of drawing text are simple enough: pass it your text as
	part of the textArgs object, pass size and family info as part of
	the fontArgs object, pass at least a color as the fillArgs object,
	and if you are looking to create an outline, pass the strokeArgs
	object as well. fillArgs and strokeArgs are the same as any other
	gfx fill and stroke arguments; they are simply applied to any path
	object generated by this method.
	Resulting GFX structure
	-----------------------
	The result of this function is a set of gfx objects in the following
	structure:
		dojox.gfx.Group 			//	the parent group generated by this function
		+	dojox.gfx.Group[]		//	a group generated for each line of text
			+	dojox.gfx.Path[]	//	each glyph/character in the text
	Scaling transformations (i.e. making the generated text the correct size)
	are always applied to the parent Group that is generated (i.e. the top
	node in the above example).  In theory, if you are looking to do any kind
	of other transformations (such as a translation), you should apply it to
	the group reference you pass to this method.  If you find that you need
	to apply transformations to the group that is returned by this method,
	you will need to reapply the scaling transformation as the *last* transform,
	like so:
		textGroup.setTransform(new dojox.gfx.Matrix2D([
			dojox.gfx.matrix.translate({ dx: dx, dy: dy }),
			textGroup.getTransform()
		]));
	In general, this should never be necessary unless you are doing advanced
	placement of your text.
	Advanced Layout Functionality
	-----------------------------
	In addition to straight text fragments, draw() supports a few advanced
	operations not normally available with vector graphics:
	* Flow operations (i.e. wrap to a given width)
	* Fitting operations (i.e. find a best fit to a given rectangle)
	To enable either, pass a `fitting` property along with the textArgs object.
	The possible values are contained in the dojox.gfx.vectorFontFitting enum
	(NONE, FLOW, FIT).
	`Flow fitting`
	Flow fitting requires both a passed size (in the fontArgs object) and a
	width (passed with the textArgs object).  draw() will attempt to split the
	passed text up into lines, at the closest whitespace according to the
	passed width.  If a width is missing, it will revert to NONE.
	`Best fit fitting`
	Doing a "best fit" means taking the passed text, and finding the largest
	size and line breaks so that it is the closest fit possible.  With best
	fit, any size arguments are ignored; if a height is missing, it will revert
	to NONE.
	Other notes
	-----------
	`a11y`
	Since the results of this method are rendering using pure paths (think
	"convert to outlines" in Adobe Illustrator), any text rendered by this
	code is NOT considered a11y-friendly.  If a11y is a requirement, we
	suggest using other, more a11y-friendly methods.
	`Font sources`
	Always make sure that you are legally allowed to use any fonts that you
	convert to SVG format; we claim no responsibility for any licensing
	infractions that may be caused by the use of this code.</description>
        <parameters>
          <parameter name="group" type="dojox.gfx.Container" usage="required"/>
          <parameter name="textArgs" type="dojox.gfx.__TextArgs" usage="required"/>
          <parameter name="fontArgs" type="dojox.gfx.__FontArgs" usage="required"/>
          <parameter name="fillArgs" type="dojox.gfx.__FillArgs" usage="required"/>
          <parameter name="strokeArgs" type="dojox.gfx.__StrokeArgs" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Group"/>
        </return-types>
      </method>
      <method name="onLoadBegin" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="font" type="dojox.gfx.VectorFont" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_entityRe" scope="instance" type="RegExp"/>
      <property name="name" scope="instance" type="Object"/>
      <property name="family" scope="instance" type="Object"/>
      <property name="_defaultLeading" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.VectorFont.viewbox">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultPath">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="path" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultPolyline">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultRect">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="r" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultEllipse">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="cx" scope="instance" type="Number"/>
      <property name="cy" scope="instance" type="Number"/>
      <property name="rx" scope="instance" type="Number"/>
      <property name="ry" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultCircle">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="cx" scope="instance" type="Number"/>
      <property name="cy" scope="instance" type="Number"/>
      <property name="r" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultLine">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultImage">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="src" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultText">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="text" scope="instance" type="String"/>
      <property name="align" scope="instance" type="String"/>
      <property name="decoration" scope="instance" type="String"/>
      <property name="rotated" scope="instance" type="bool"/>
      <property name="kerning" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultTextPath">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="text" scope="instance" type="String"/>
      <property name="align" scope="instance" type="String"/>
      <property name="decoration" scope="instance" type="String"/>
      <property name="rotated" scope="instance" type="bool"/>
      <property name="kerning" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultStroke">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="color" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="cap" scope="instance" type="String"/>
      <property name="join" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultLinearGradient">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x1" scope="instance" type="Number"/>
      <property name="y1" scope="instance" type="Number"/>
      <property name="x2" scope="instance" type="Number"/>
      <property name="y2" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultRadialGradient">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="cx" scope="instance" type="Number"/>
      <property name="cy" scope="instance" type="Number"/>
      <property name="r" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultPattern">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="src" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.defaultFont">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="style" scope="instance" type="String"/>
      <property name="variant" scope="instance" type="String"/>
      <property name="weight" scope="instance" type="String"/>
      <property name="size" scope="instance" type="String"/>
      <property name="family" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx._base">
    <methods>
      <method name="_getFontMeasurements" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getCachedFontMeasurements" scope="instance">
        <parameters>
          <parameter name="recalculate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getTextBox" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
          <parameter name="className" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getUniqueId" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gfx.arc">
    <methods>
      <method name="arcAsBezier" scope="instance">
        <parameters>
          <parameter name="last" type="Object" usage="required">
            <description>a point-like object as a start of the arc</description>
          </parameter>
          <parameter name="rx" type="Number" usage="required">
            <description>a horizontal radius for the virtual ellipse</description>
          </parameter>
          <parameter name="ry" type="Number" usage="required">
            <description>a vertical radius for the virtual ellipse</description>
          </parameter>
          <parameter name="xRotg" type="Number" usage="required">
            <description>a rotation of an x axis of the virtual ellipse in degrees</description>
          </parameter>
          <parameter name="large" type="Boolean" usage="required">
            <description>which part of the ellipse will be used (the larger arc if true)</description>
          </parameter>
          <parameter name="sweep" type="Boolean" usage="required">
            <description>direction of the arc (CW if true)</description>
          </parameter>
          <parameter name="x" type="Number" usage="required">
            <description>the x coordinate of the end point of the arc</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>the y coordinate of the end point of the arc</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="unitArcAsBezier" scope="instance" type="Object"/>
      <property name="curvePI4" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojo.gfx">
    <properties>
      <property name="attachSurface" scope="instance" type="Object"/>
      <property name="attachNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas">
    <methods>
      <method name="createSurface" scope="instance">
        <parameters>
          <parameter name="parentNode" type="Node" usage="required">
            <description>a parent node</description>
          </parameter>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachSurface" scope="instance"/>
      <method name="attachNode" scope="instance">
        <return-types>
          <return-type type="for now"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.canvas.Group" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_render" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvas.Surface" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_render" scope="instance"/>
      <method name="makeDirty" scope="instance"/>
      <method name="downloadImage" scope="instance">
        <parameters>
          <parameter name="img" type="Image" usage="required">
            <description>the image object</description>
          </parameter>
          <parameter name="url" type="String" usage="required">
            <description>the url of the image</description>
          </parameter>
        </parameters>
      </method>
      <method name="onImageLoad" scope="instance"/>
      <method name="getEventSource" scope="instance"/>
      <method name="connect" scope="instance"/>
      <method name="disconnect" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="pendingRender" scope="instance" type="Object"/>
      <property name="pendingImageCount" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Shape" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="_render" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderTransform" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderFill" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="apply" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_renderStroke" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="apply" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getEventSource" scope="instance"/>
      <method name="connect" scope="instance"/>
      <method name="disconnect" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasTransform" scope="instance" type="Object"/>
      <property name="canvasFill" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Shape.fillStyle">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Shape.canvasFillImage">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Rect" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Rect" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.gfx.canvas.Rect.shape">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Ellipse" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="setShape" scope="instance"/>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Ellipse" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="canvasEllipse" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Circle" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Circle" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Line" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Line" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Polyline" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="setShape" scope="instance"/>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasPolyline" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Polyline.shape"/>
  <class type="dojox.gfx.canvas.Polyline.shape.points">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Image" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="setShape" scope="instance"/>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Image" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasImage" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Text" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="_setFont" scope="instance"/>
      <method name="getTextWidth" scope="instance"/>
      <method name="_render" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasFont" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Path" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setShape" scope="instance"/>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToA" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToR" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_arcTo" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_closePath" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="canvasPath" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Path.last">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Path.lastControl">
    <properties>
      <property name="x" scope="instance" type="String"/>
      <property name="y" scope="instance" type="String"/>
      <property name="type" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.TextPath" superclass="dojox.gfx.canvas.Shape">
    <methods>
      <method name="_renderShape" scope="instance">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="instance"/>
      <method name="_setFont" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.canvas.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.TextPath" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.canvas.Surface.rawNode">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.matrix">
    <methods>
      <method name="multiplyPoint" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix object to be applied</description>
          </parameter>
          <parameter name="a" type="Number|Point" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Point"/>
        </return-types>
      </method>
      <method name="translate" scope="instance">
        <description>The resulting matrix is used to translate (move) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>an x coordinate value</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y coordinate value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="scale" scope="instance">
        <description>The resulting matrix is used to scale (magnify) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>a scaling factor used for the x coordinate</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a scaling factor used for the y coordinate</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotate" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotateg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx.matrix.rotate() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewX" scope="instance">
        <description>The resulting matrix is used to skew points in the x dimension
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an skewing angle in radians</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewXg" scope="instance">
        <description>The resulting matrix is used to skew points in the x dimension
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx.matrix.skewX() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an skewing angle in degrees</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewY" scope="instance">
        <description>The resulting matrix is used to skew points in the y dimension
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an skewing angle in radians</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewYg" scope="instance">
        <description>The resulting matrix is used to skew points in the y dimension
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx.matrix.skewY() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an skewing angle in degrees</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="reflect" scope="instance">
        <description>The resulting matrix is used to reflect points around a vector,
	which goes through the origin.</description>
        <parameters>
          <parameter name="a" type="dojox.gfx.Point" usage="required">
            <description>a point-like object, which specifies a vector of reflection</description>
          </parameter>
          <parameter name="b" type="null" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="project" scope="instance">
        <description>The resulting matrix is used to project points orthogonally on a vector,
	which goes through the origin.</description>
        <parameters>
          <parameter name="a" type="dojox.gfx.Point" usage="required">
            <description>a point-like object, which specifies a vector of projection</description>
          </parameter>
          <parameter name="b" type="null" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="normalize" scope="instance">
        <description>Converts any 2D matrix-like object or an array of
	such objects to a valid dojox.gfx.matrix.Matrix2D object.</description>
        <parameters>
          <parameter name="matrix" type="Object" usage="required">
            <description>an object, which is converted to a matrix, if necessary</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix-like object to be cloned</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="invert" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix-like object to be inverted</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="_multiplyPoint" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix object to be applied</description>
          </parameter>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Point"/>
        </return-types>
      </method>
      <method name="multiply" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="one-or-more">
            <description>a 2D matrix-like object,
	all subsequent arguments are matrix-like objects too</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="_sandwich" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D" usage="required">
            <description>a 2D matrix-like object, which is applied at a central point</description>
          </parameter>
          <parameter name="x" type="Number" usage="required">
            <description>an x component of the central point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y component of the central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="scaleAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.scale().</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>a scaling factor used for the x coordinate</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a scaling factor used for the y coordinate</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>an x component of a central point</description>
          </parameter>
          <parameter name="d" type="Number" usage="required">
            <description>a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotateAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.rotate().</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
          <parameter name="a" type="Number" usage="required">
            <description>an x component of a central point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotategAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.rotateg().</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
          <parameter name="a" type="Number" usage="required">
            <description>an x component of a central point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewXAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.skewX().</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an skewing angle in radians</description>
          </parameter>
          <parameter name="a" type="Number" usage="required">
            <description>an x component of a central point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewXgAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.skewXg().</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an skewing angle in degrees</description>
          </parameter>
          <parameter name="a" type="Number" usage="required">
            <description>an x component of a central point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewYAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.skewY().</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an skewing angle in radians</description>
          </parameter>
          <parameter name="a" type="Number" usage="required">
            <description>an x component of a central point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewYgAt" scope="instance">
        <description>Compare with dojox.gfx.matrix.skewYg().</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>Number: an skewing angle in degrees</description>
          </parameter>
          <parameter name="a" type="Number|Point" usage="required">
            <description>Number: an x component of a central point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>Number: a y component of a central point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="_degToRad" scope="instance">
        <parameters>
          <parameter name="degree" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_radToDeg" scope="instance">
        <parameters>
          <parameter name="radian" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="identity" scope="instance" type="dojox.gfx.matrix.Matrix2D">
        <description>an identity matrix constant: identity * (x, y) == (x, y)</description>
      </property>
      <property name="flipX" scope="instance" type="dojox.gfx.matrix.Matrix2D">
        <description>a matrix, which reflects points at x = 0 line: flipX * (x, y) == (-x, y)</description>
      </property>
      <property name="flipY" scope="instance" type="dojox.gfx.matrix.Matrix2D">
        <description>a matrix, which reflects points at y = 0 line: flipY * (x, y) == (x, -y)</description>
      </property>
      <property name="flipXY" scope="instance" type="dojox.gfx.matrix.Matrix2D">
        <description>a matrix, which reflects points at the origin of coordinates: flipXY * (x, y) == (-x, -y)</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape"/>
  <class type="dojox.gfx.fx">
    <methods>
      <method name="animateStroke" scope="instance">
        <examples>
          <example>	dojox.gfx.fx.animateStroke{{
			shape: shape,
			duration: 500,
			color: {start: "red", end: "green"},
			width: {end: 15},
			join:  {values: ["miter", "bevel", "round"]}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateFill" scope="instance">
        <examples>
          <example>	dojox.gfx.fx.animateFill{{
			shape: shape,
			duration: 500,
			color: {start: "red", end: "green"}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateFont" scope="instance">
        <examples>
          <example>	dojox.gfx.fx.animateFont{{
			shape: shape,
			duration: 500,
			variant: {values: ["normal", "small-caps"]},
			size:  {end: 10, units: "pt"}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateTransform" scope="instance">
        <examples>
          <example>	dojox.gfx.fx.animateTransform{{
			shape: shape,
			duration: 500,
			transform: [
				{name: "translate", start: [0, 0], end: [200, 200]},
				{name: "original"}
			]
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.gradient">
    <methods>
      <method name="rescale" scope="instance">
        <parameters>
          <parameter name="stops" type="Array" usage="required">
            <description>input gradient as a list of colors with offsets
	(see dojox.gfx.defaultLinearGradient and dojox.gfx.defaultRadialGradient)</description>
          </parameter>
          <parameter name="from" type="Number" usage="required">
            <description>the beginning of the window, should be less than &amp;quot;to&amp;quot;</description>
          </parameter>
          <parameter name="to" type="Number" usage="required">
            <description>the end of the window, should be more than &amp;quot;from&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="project" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D|Null" usage="required">
            <description>matrix to apply to a shape and its gradient</description>
          </parameter>
          <parameter name="grad" type="Object" usage="required">
            <description>a linear gradient object to be transformed</description>
          </parameter>
          <parameter name="tl" type="dojox.gfx.Point" usage="required">
            <description>top-left corner of shape's bounding box</description>
          </parameter>
          <parameter name="rb" type="dojox.gfx.Point" usage="required">
            <description>right-bottom corner of shape's bounding box</description>
          </parameter>
          <parameter name="ttl" type="dojox.gfx.Point" usage="required">
            <description>top-left corner of shape's transformed bounding box</description>
          </parameter>
          <parameter name="trb" type="dojox.gfx.Point" usage="required">
            <description>right-bottom corner of shape's transformed bounding box</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.gradutils">
    <methods>
      <method name="getColor" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>fill object</description>
          </parameter>
          <parameter name="pt" type="dojox.gfx.Point" usage="required">
            <description>point where to sample a color</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="reverse" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>fill object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.matrix.Matrix2D">
    <description>Normalizes a 2D matrix-like object. If arrays is passed,
	all objects of the array are normalized and multiplied sequentially.</description>
    <methods/>
    <properties>
      <property name="xx" scope="instance-prototype" type="Number"/>
      <property name="xy" scope="instance" type="Number"/>
      <property name="yx" scope="instance" type="Number"/>
      <property name="yy" scope="instance-prototype" type="Number"/>
      <property name="dx" scope="instance" type="Number"/>
      <property name="dy" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.path"/>
  <class type="dojox.gfx.path.Path" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM node to be used by this path object</description>
          </parameter>
        </parameters>
      </method>
      <method name="setAbsoluteMode" scope="instance">
        <parameters>
          <parameter name="mode" type="Boolean" usage="required">
            <description>true/false or &amp;quot;absolute&amp;quot;/&amp;quot;relative&amp;quot; to specify the mode</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getAbsoluteMode" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="_getRealBBox" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getLastPosition" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_applyTransform" scope="instance"/>
      <method name="_updateBBox" scope="instance">
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate</description>
          </parameter>
          <parameter name="matrix" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
          <parameter name="matrix" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pushSegment" scope="instance">
        <parameters>
          <parameter name="action" type="String" usage="required">
            <description>valid SVG code for a segment's type</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>a list of parameters for this segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="_collectArgs" scope="instance">
        <parameters>
          <parameter name="array" type="Array" usage="required">
            <description>an output argument (array of numbers)</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>an input argument (can be values of Boolean, Number, dojox.gfx.Point, or an embedded array of them)</description>
          </parameter>
        </parameters>
      </method>
      <method name="moveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="lineTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="hLineTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="vLineTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="curveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="smoothCurveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="qCurveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="qSmoothCurveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="arcTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="closePath" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_confirmSegmented" scope="instance"/>
      <method name="_setPath" scope="instance">
        <parameters>
          <parameter name="path" type="String" usage="required">
            <description>an SVG path string</description>
          </parameter>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an SVG path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="absolute" scope="instance-prototype" type="Object"/>
      <property name="tbbox" scope="instance-prototype" type="Object"/>
      <property name="segmented" scope="instance-prototype" type="bool"/>
      <property name="_2PI" scope="instance" type="Number"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM node to be used by this path object</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path.segments">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path.bbox">
    <properties>
      <property name="l" scope="instance" type="Object"/>
      <property name="r" scope="instance" type="Object"/>
      <property name="t" scope="instance" type="Object"/>
      <property name="b" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path.last">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path._validSegments">
    <properties>
      <property name="m" scope="instance" type="Number"/>
      <property name="l" scope="instance" type="Number"/>
      <property name="h" scope="instance" type="Number"/>
      <property name="v" scope="instance" type="Number"/>
      <property name="c" scope="instance" type="Number"/>
      <property name="s" scope="instance" type="Number"/>
      <property name="q" scope="instance" type="Number"/>
      <property name="t" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
      <property name="z" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.Path.shape">
    <properties>
      <property name="path" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.path.TextPath" superclass="dojox.gfx.path.Path">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM node to be used by this TextPath object</description>
          </parameter>
        </parameters>
      </method>
      <method name="getText" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setText" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getFont" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setFont" scope="instance">
        <parameters>
          <parameter name="newFont" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="text" scope="instance-prototype" type="Object"/>
      <property name="fontStyle" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Shape" superclass="dojox.gfx.shape._eventsProcessing">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="getNode" scope="instance">
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="getShape" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTransform" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="getFill" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getStroke" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getParent" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="getTransformedBoundingBox" scope="instance">
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getEventSource" scope="instance">
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required">
            <description>a shape object
	(see dojox.gfx.defaultPath,
	dojox.gfx.defaultPolyline,
	dojox.gfx.defaultRect,
	dojox.gfx.defaultEllipse,
	dojox.gfx.defaultCircle,
	dojox.gfx.defaultLine,
	or dojox.gfx.defaultImage)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	or dojo.Color)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required">
            <description>a stroke object
	(see dojox.gfx.defaultStroke)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_applyTransform" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="moveToFront" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="moveToBack" scope="instance"/>
      <method name="_moveToFront" scope="instance"/>
      <method name="_moveToBack" scope="instance"/>
      <method name="applyRightTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyLeftTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="removeShape" scope="instance">
        <parameters>
          <parameter name="silently" type="Boolean" usage="optional">
            <description>if true, do not redraw a picture yet</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setParent" scope="instance">
        <parameters>
          <parameter name="parent" type="Object" usage="required">
            <description>a parent or null
	(see dojox.gfx.Surface,
	dojox.gfx.shape.VirtualGroup,
	or dojox.gfx.Group)</description>
          </parameter>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a 2D matrix or a matrix-like object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_updateParentMatrix" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D" usage="required">
            <description>a 2D matrix or a matrix-like object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getRealMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="instance-prototype" type="Object"/>
      <property name="fillStyle" scope="instance-prototype" type="Object"/>
      <property name="strokeStyle" scope="instance-prototype" type="Object"/>
      <property name="matrix" scope="instance-prototype" type="Object"/>
      <property name="parent" scope="instance-prototype" type="Object"/>
      <property name="parentMatrix" scope="instance-prototype" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>underlying node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Surface" superclass="dojox.gfx.shape._eventsProcessing">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="getEventSource" scope="instance">
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_getRealMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="surface" type="dojox.gfx.Surface" usage="required"/>
        </parameters>
      </method>
      <method name="whenLoaded" scope="instance">
        <parameters>
          <parameter name="context" type="Object" usage="optional"/>
          <parameter name="method" type="Function|String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_nodes" scope="instance-prototype" type="Array"/>
      <property name="_events" scope="instance-prototype" type="Array"/>
      <property name="rawNode" scope="instance-prototype" type="Object"/>
      <property name="isLoaded" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Surface._parent">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.Point">
    <description>This object is defined for documentation purposes.
	You should use the naked object instead: {x: 1, y: 2}.</description>
    <methods/>
  </class>
  <class type="dojox.gfx.Rectangle">
    <description>This object is defined for documentation purposes.
	You should use the naked object instead: {x: 1, y: 2, width: 100, height: 200}.</description>
    <methods/>
  </class>
  <class type="dojox.gfx.shape.Rect" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Ellipse" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Circle" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Line" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Polyline" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required">
            <description>a polyline/polygon shape object</description>
          </parameter>
          <parameter name="closed" type="Boolean" usage="required">
            <description>close the polyline to make a polygon</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_normalizePoints" scope="instance"/>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Polyline.shape"/>
  <class type="dojox.gfx.shape.Polyline.shape.points">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Image" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="setStroke" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Text" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>a DOM Node</description>
          </parameter>
        </parameters>
      </method>
      <method name="getFont" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setFont" scope="instance">
        <parameters>
          <parameter name="newFont" type="Object" usage="required">
            <description>a font object (see dojox.gfx.defaultFont) or a font string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="fontStyle" scope="instance-prototype" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node">
        <description>a DOM Node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape._eventsProcessing">
    <methods>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.shape.Container">
    <methods>
      <method name="openBatch" scope="instance"/>
      <method name="closeBatch" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape" usage="required">
            <description>a shape</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="silently" type="Boolean" usage="optional">
            <description>if true, do not redraw a picture yet</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveChildToFront" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveChildToBack" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.shape.Container._init">
    <methods/>
    <properties>
      <property name="children" scope="instance" type="Array">
        <description>a list of children</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Container.clear">
    <methods/>
    <properties>
      <property name="children" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx.shape.Creator">
    <methods>
      <method name="createShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required">
            <description>a shape descriptor object</description>
          </parameter>
        </parameters>
      </method>
      <method name="createGroup" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Group"/>
        </return-types>
      </method>
      <method name="createRect" scope="instance">
        <parameters>
          <parameter name="rect" type="Object" usage="required">
            <description>a path object (see dojox.gfx.defaultRect)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Rect"/>
        </return-types>
      </method>
      <method name="createEllipse" scope="instance">
        <parameters>
          <parameter name="ellipse" type="Object" usage="required">
            <description>an ellipse object (see dojox.gfx.defaultEllipse)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Ellipse"/>
        </return-types>
      </method>
      <method name="createCircle" scope="instance">
        <parameters>
          <parameter name="circle" type="Object" usage="required">
            <description>a circle object (see dojox.gfx.defaultCircle)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Circle"/>
        </return-types>
      </method>
      <method name="createLine" scope="instance">
        <parameters>
          <parameter name="line" type="Object" usage="required">
            <description>a line object (see dojox.gfx.defaultLine)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Line"/>
        </return-types>
      </method>
      <method name="createPolyline" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required">
            <description>a points object (see dojox.gfx.defaultPolyline)
	or an Array of points</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Polyline"/>
        </return-types>
      </method>
      <method name="createImage" scope="instance">
        <parameters>
          <parameter name="image" type="Object" usage="required">
            <description>an image object (see dojox.gfx.defaultImage)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Image"/>
        </return-types>
      </method>
      <method name="createText" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required">
            <description>a text object (see dojox.gfx.defaultText)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Text"/>
        </return-types>
      </method>
      <method name="createPath" scope="instance">
        <parameters>
          <parameter name="path" type="Object" usage="required">
            <description>a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Path"/>
        </return-types>
      </method>
      <method name="createTextPath" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required">
            <description>a textpath object (see dojox.gfx.defaultTextPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.TextPath"/>
        </return-types>
      </method>
      <method name="createObject" scope="instance">
        <parameters>
          <parameter name="shapeType" type="Function" usage="required">
            <description>a class constructor to create an instance of</description>
          </parameter>
          <parameter name="rawShape" type="Object" usage="required">
            <description>properties to be passed in to the classes &amp;quot;setShape&amp;quot; method</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.silverlight">
    <methods>
      <method name="createSurface" scope="instance">
        <parameters>
          <parameter name="parentNode" type="Node" usage="required">
            <description>a parent node</description>
          </parameter>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachNode" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an Silverlight node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="not implemented"/>
        </return-types>
      </method>
      <method name="attachSurface" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an Silverlight node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx.silverlight.Text" superclass="Font">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a text shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_delayAlignment" scope="instance"/>
      <method name="_getAdjustedMatrix" scope="instance"/>
      <method name="setStroke" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setFillAttr" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextWidth" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text" scope="instance"/>
    </mixins>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="_delay" scope="instance" type="Object"/>
      <property name="_delta" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Group" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>an Silverlight node</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Surface" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="eventsProcessing" scope="instance"/>
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Shape" superclass="eventsProcessing">
    <methods>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	or dojo.Color)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setFillAttr" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required">
            <description>a stroke object
	(see dojox.gfx.defaultStroke)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getParentSurface" scope="instance"/>
      <method name="_applyTransform" scope="instance"/>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToFront" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveToBack" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="fillStyle" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Shape.rawNode">
    <properties>
      <property name="fill" scope="instance" type="Object"/>
      <property name="stroke" scope="instance" type="Object"/>
      <property name="strokeThickness" scope="instance" type="Object"/>
      <property name="strokeStartLineCap" scope="instance" type="Object"/>
      <property name="strokeEndLineCap" scope="instance" type="Object"/>
      <property name="strokeDashCap" scope="instance" type="Object"/>
      <property name="strokeLineJoin" scope="instance" type="String"/>
      <property name="strokeMiterLimit" scope="instance" type="Object"/>
      <property name="strokeDashArray" scope="instance" type="Object"/>
      <property name="renderTransform" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Shape.parent.rawNode">
    <properties>
      <property name="children" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Rect" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a rectangle shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Rect" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Rect.rawNode">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="radiusX" scope="instance" type="Object"/>
      <property name="radiusY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Ellipse" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an ellipse shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Ellipse" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Ellipse.rawNode">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Circle" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a circle shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Circle" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Circle.rawNode">
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="height" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Line" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a line shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Line" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Line.rawNode">
    <properties>
      <property name="x1" scope="instance" type="Object"/>
      <property name="y1" scope="instance" type="Object"/>
      <property name="x2" scope="instance" type="Object"/>
      <property name="y2" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Polyline" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required">
            <description>a polyline/polygon shape object</description>
          </parameter>
          <parameter name="closed" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Polyline.shape">
    <properties>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Polyline.rawNode">
    <properties>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Image" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an image shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Image" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Image.rawNode">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="source" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Text.rawNode">
    <properties>
      <property name="text" scope="instance" type="Object"/>
      <property name="textDecorations" scope="instance" type="Object"/>
      <property name="actualWidth" scope="instance" type="Object"/>
      <property name="actualHeight" scope="instance" type="Object"/>
      <property name="foreground" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Text.rawNode.Canvas">
    <properties>
      <property name="Left" scope="instance" type="Number"/>
      <property name="Top" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Text.shape">
    <properties>
      <property name="x" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Path" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an SVG path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Path.shape">
    <properties>
      <property name="path" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Path.rawNode">
    <properties>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.TextPath" superclass="dojox.gfx.silverlight.Shape">
    <methods>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an SVG path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.silverlight.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.TextPath" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.silverlight.Surface.rawNode">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg">
    <methods>
      <method name="getRef" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>an SVG external reference</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="createSurface" scope="instance">
        <parameters>
          <parameter name="parentNode" type="Node" usage="required">
            <description>a parent node</description>
          </parameter>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachNode" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an SVG node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="attachSurface" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an SVG node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="useSvgWeb" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Text" superclass="Font">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a text shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getTextWidth" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.TextPath" superclass="Font">
    <methods>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an SVG path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setTextPath" scope="instance"/>
      <method name="_setText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.TextPath" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Group" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Node" usage="required">
            <description>an SVG node</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Surface" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="_eventsProcessing" scope="instance"/>
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="defNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Shape" superclass="_eventsProcessing">
    <methods>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	or dojo.Color)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required">
            <description>a stroke object (see dojox.gfx.defaultStroke)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getParentSurface" scope="instance"/>
      <method name="_setFillObject" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="nodeType" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_applyTransform" scope="instance"/>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a shape object
	(see dojox.gfx.defaultPath,
	dojox.gfx.defaultPolyline,
	dojox.gfx.defaultRect,
	dojox.gfx.defaultEllipse,
	dojox.gfx.defaultCircle,
	dojox.gfx.defaultLine,
	or dojox.gfx.defaultImage)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveToFront" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveToBack" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="fillStyle" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
      <property name="matrix" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Rect" superclass="dojox.gfx.svg.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a rectangle shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Rect" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Ellipse" superclass="dojox.gfx.svg.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Ellipse" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Circle" superclass="dojox.gfx.svg.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Circle" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Line" superclass="dojox.gfx.svg.Shape">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Line" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Polyline" superclass="dojox.gfx.svg.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required">
            <description>a polyline/polygon shape object</description>
          </parameter>
          <parameter name="closed" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Polyline.shape">
    <properties>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Image" superclass="dojox.gfx.svg.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an image shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Image" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Text.rawNode.firstChild">
    <properties>
      <property name="nodeValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Text.rawNode">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.Path" superclass="dojox.gfx.svg.Shape">
    <methods>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an SVG path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.svg.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.xmlns">
    <properties>
      <property name="xlink" scope="instance" type="String"/>
      <property name="svg" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.svg.dasharray">
    <properties>
      <property name="solid" scope="instance" type="String"/>
      <property name="shortdash" scope="instance" type="Array"/>
      <property name="shortdot" scope="instance" type="Array"/>
      <property name="shortdashdot" scope="instance" type="Array"/>
      <property name="shortdashdotdot" scope="instance" type="Array"/>
      <property name="dot" scope="instance" type="Array"/>
      <property name="dash" scope="instance" type="Array"/>
      <property name="longdash" scope="instance" type="Array"/>
      <property name="dashdot" scope="instance" type="Array"/>
      <property name="longdashdot" scope="instance" type="Array"/>
      <property name="longdashdotdot" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx.utils">
    <methods>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="object" type="dojox.gfx.Surface" usage="required">
            <description>|| dojox.gfx.Shape</description>
          </parameter>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="object" type="dojox.gfx.Surface" usage="required">
            <description>|| dojox.gfx.Shape</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toJson" scope="instance">
        <parameters>
          <parameter name="object" type="dojox.gfx.Surface" usage="required">
            <description>|| dojox.gfx.Shape</description>
          </parameter>
          <parameter name="prettyPrint" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="deserialize" scope="instance">
        <parameters>
          <parameter name="parent" type="dojox.gfx.Surface" usage="required">
            <description>|| dojox.gfx.Shape</description>
          </parameter>
          <parameter name="object" type="dojox.gfx.Shape" usage="required">
            <description>|| Array</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="fromJson" scope="instance">
        <parameters>
          <parameter name="parent" type="dojox.gfx.Surface" usage="required">
            <description>|| dojox.gfx.Shape</description>
          </parameter>
          <parameter name="json" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Object"/>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="toSvg" scope="instance">
        <description>Function to serialize a GFX surface to SVG text.  The value of this output
	is that there are numerous serverside parser libraries that can render
	SVG into images in various formats.  This provides a way that GFX objects
	can be captured in a known format and sent serverside for serialization
	into an image.</description>
        <parameters>
          <parameter name="surface" type="GFX" usage="required">
            <description>The GFX surface to serialize.</description>
          </parameter>
        </parameters>
        <return-description>Deferred object that will be called when SVG serialization is complete.</return-description>
        <return-types>
          <return-type type="dojo.Deferred that will be called when serialization finishes"/>
        </return-types>
      </method>
      <method name="_svgSerializerInitialized" scope="instance"/>
      <method name="_initSvgSerializer" scope="instance"/>
      <method name="_innerXML" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The node from which to generate the XML text representation.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_cleanSvg" scope="instance">
        <parameters>
          <parameter name="svg" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Cleaned SVG text"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_gfxSvgProxy" scope="instance" type="Object"/>
      <property name="_initSvgSerializerDeferred" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml">
    <methods>
      <method name="_parseFloat" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required">
            <description>a representation of a floating-point number</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="createSurface" scope="instance">
        <parameters>
          <parameter name="parentNode" type="Node" usage="required">
            <description>a parent node</description>
          </parameter>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachNode" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an VML node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="attachSurface" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>an VML node</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="xmlns" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Group" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_applyTransform" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width in pixels</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height in pixels</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface" superclass="Container">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height of surface, e.g., &amp;quot;100px&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Creator" scope="instance"/>
      <mixin type="Creator" scope="instance"/>
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Surface" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape" superclass="dojox.gfx.shape.Shape">
    <methods>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	or dojo.Color)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required">
            <description>a stroke object
	(see dojox.gfx.defaultStroke)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_translate" scope="instance">
        <parameters>
          <parameter name="dict" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_applyTransform" scope="instance"/>
      <method name="_setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width in pixels</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height in pixels</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setRawNode" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToFront" scope="instance"/>
      <method name="_moveToBack" scope="instance"/>
      <method name="_getRealMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Shape" scope="instance"/>
    </mixins>
    <properties>
      <property name="fillStyle" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode">
    <properties>
      <property name="filled" scope="instance" type="Object"/>
      <property name="fillcolor" scope="instance" type="Object"/>
      <property name="stroked" scope="instance" type="Object"/>
      <property name="strokecolor" scope="instance" type="Object"/>
      <property name="strokeweight" scope="instance" type="String"/>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode.fill">
    <properties>
      <property name="opacity" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode.filters.DXImageTransform.Microsoft"/>
  <class type="dojox.gfx.vml.Shape.rawNode.filters.DXImageTransform.Microsoft.Alpha">
    <properties>
      <property name="opacity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode.stroke">
    <properties>
      <property name="opacity" scope="instance" type="Object"/>
      <property name="endcap" scope="instance" type="Object"/>
      <property name="joinstyle" scope="instance" type="String"/>
      <property name="miterlimit" scope="instance" type="Object"/>
      <property name="dashstyle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape._capMap">
    <properties>
      <property name="butt" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape._capMapReversed">
    <properties>
      <property name="flat" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Shape.rawNode.parentNode">
    <properties>
      <property name="firstChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Group.rawNode">
    <properties>
      <property name="coordsize" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Group.bgNode"/>
  <class type="dojox.gfx.vml.Group.rawNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Group.bgNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Rect" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a rectangle shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Rect.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Rect" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Rect.rawNode">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
      <property name="arcsize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Rect.rawNode.style">
    <properties>
      <property name="left" scope="instance" type="Object"/>
      <property name="top" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Ellipse" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an ellipse shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Ellipse.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Ellipse" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Ellipse.rawNode"/>
  <class type="dojox.gfx.vml.Ellipse.rawNode.style">
    <properties>
      <property name="left" scope="instance" type="Object"/>
      <property name="top" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Circle" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a circle shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Circle.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Circle" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Circle.rawNode"/>
  <class type="dojox.gfx.vml.Circle.rawNode.style">
    <properties>
      <property name="left" scope="instance" type="Object"/>
      <property name="top" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Line" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a line shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Line.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Line" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Line.rawNode.path">
    <properties>
      <property name="v" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Polyline" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required">
            <description>a polyline/polygon shape object</description>
          </parameter>
          <parameter name="closed" type="Boolean" usage="optional">
            <description>if true, close the polyline explicitely</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Polyline.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Polyline" scope="instance"/>
    </mixins>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Polyline.shape">
    <properties>
      <property name="points" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Polyline.rawNode.path">
    <properties>
      <property name="v" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an image shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_applyTransform" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setDimensions" scope="instance">
        <parameters>
          <parameter name="width" type="String" usage="required">
            <description>width in pixels</description>
          </parameter>
          <parameter name="height" type="String" usage="required">
            <description>height in pixels</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Image.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Image" scope="instance"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image.rawNode.firstChild">
    <properties>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image.rawNode"/>
  <class type="dojox.gfx.vml.Image.rawNode.style">
    <properties>
      <property name="filter" scope="instance" type="String"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image.rawNode.parentNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Image.rawNode.filters.DXImageTransform.Microsoft"/>
  <class type="dojox.gfx.vml.Image.rawNode.filters.DXImageTransform.Microsoft.Matrix">
    <properties>
      <property name="M11" scope="instance" type="Object"/>
      <property name="M12" scope="instance" type="Object"/>
      <property name="M21" scope="instance" type="Object"/>
      <property name="M22" scope="instance" type="Object"/>
      <property name="Dx" scope="instance" type="Object"/>
      <property name="Dy" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Text" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>a text shape object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setFont" scope="instance"/>
      <method name="_getRealMatrix" scope="instance">
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="getTextWidth" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.shape.Text.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.shape.Text" scope="instance"/>
    </mixins>
    <properties>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="fontStyle" scope="instance-prototype" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Text._alignment">
    <properties>
      <property name="start" scope="instance" type="String"/>
      <property name="middle" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Text.shape">
    <properties>
      <property name="x" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Text.rawNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Text.rawNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Path" superclass="dojox.gfx.vml.Shape">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateWithSegment" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required">
            <description>a segment</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="skip transfomed bbox calculations"/>
        </return-types>
      </method>
      <method name="setShape" scope="instance">
        <parameters>
          <parameter name="newShape" type="Object" usage="required">
            <description>an VML path string or a path object (see dojox.gfx.defaultPath)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addArgs" scope="instance">
        <parameters>
          <parameter name="path" type="Object" usage="required"/>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="upto" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustRelCrd" scope="instance">
        <parameters>
          <parameter name="last" type="Object" usage="required"/>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustRelPos" scope="instance">
        <parameters>
          <parameter name="last" type="Object" usage="required"/>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToA" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToR" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_arcTo" scope="instance">
        <parameters>
          <parameter name="segment" type="Object" usage="required"/>
          <parameter name="last" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_closePath" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.Path.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Shape" scope="instance"/>
      <mixin type="dojox.gfx.path.Path" scope="instance"/>
    </mixins>
    <properties>
      <property name="vmlPath" scope="instance-prototype" type="String"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Path.rawNode.path">
    <properties>
      <property name="v" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Path.lastControl">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Path._pathVmlToSvgMap">
    <properties>
      <property name="m" scope="instance" type="String"/>
      <property name="l" scope="instance" type="String"/>
      <property name="t" scope="instance" type="String"/>
      <property name="r" scope="instance" type="String"/>
      <property name="c" scope="instance" type="String"/>
      <property name="v" scope="instance" type="String"/>
      <property name="qb" scope="instance" type="String"/>
      <property name="x" scope="instance" type="String"/>
      <property name="e" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Path.renderers">
    <properties>
      <property name="M" scope="instance" type="String"/>
      <property name="m" scope="instance" type="String"/>
      <property name="L" scope="instance" type="String"/>
      <property name="l" scope="instance" type="String"/>
      <property name="H" scope="instance" type="String"/>
      <property name="h" scope="instance" type="String"/>
      <property name="V" scope="instance" type="String"/>
      <property name="v" scope="instance" type="String"/>
      <property name="C" scope="instance" type="String"/>
      <property name="c" scope="instance" type="String"/>
      <property name="S" scope="instance" type="String"/>
      <property name="s" scope="instance" type="String"/>
      <property name="Q" scope="instance" type="String"/>
      <property name="q" scope="instance" type="String"/>
      <property name="T" scope="instance" type="String"/>
      <property name="t" scope="instance" type="String"/>
      <property name="A" scope="instance" type="String"/>
      <property name="a" scope="instance" type="String"/>
      <property name="Z" scope="instance" type="String"/>
      <property name="z" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.TextPath" superclass="dojox.gfx.vml.Path">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="rawNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setText" scope="instance">
        <parameters>
          <parameter name="newText" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFont" scope="instance">
        <parameters>
          <parameter name="newFont" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setText" scope="instance"/>
      <method name="_setFont" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.path.TextPath.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.vml.Path" scope="instance"/>
      <mixin type="dojox.gfx.path.TextPath" scope="instance"/>
    </mixins>
    <properties>
      <property name="text" scope="instance-prototype" type="Object"/>
      <property name="fontStyle" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.TextPath.rawNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.clipNode"/>
  <class type="dojox.gfx.vml.Surface.rawNode">
    <properties>
      <property name="coordsize" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.bgNode"/>
  <class type="dojox.gfx.vml.Surface._parent"/>
  <class type="dojox.gfx.vml.Surface._parent.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.clipNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
      <property name="clip" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.rawNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.Surface.bgNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml.text_alignment">
    <properties>
      <property name="start" scope="instance" type="String"/>
      <property name="middle" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx.vml._bool">
    <properties>
      <property name="t" scope="instance" type="Number"/>
      <property name="true" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultEdges">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultTriangles">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultQuads">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="style" scope="instance" type="Object"/>
      <property name="points" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultOrbit">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="radius" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultOrbit.center">
    <properties>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="z" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultPath3d">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="path" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultPolygon">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="path" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCube">
    <properties>
      <property name="type" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCube.bottom">
    <properties>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="z" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCube.top">
    <properties>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="z" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCylinder">
    <properties>
      <property name="type" scope="instance" type="String"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="radius" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.defaultCylinder.center">
    <properties>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
      <property name="z" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting">
    <methods>
      <method name="black" scope="instance"/>
      <method name="white" scope="instance"/>
      <method name="toStdColor" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fromStdColor" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scaleColor" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addColor" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="multiplyColor" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saturateColor" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mixColor" scope="instance">
        <parameters>
          <parameter name="c1" type="Object" usage="required"/>
          <parameter name="c2" type="Object" usage="required"/>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="diff2Color" scope="instance">
        <parameters>
          <parameter name="c1" type="Object" usage="required"/>
          <parameter name="c2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length2Color" scope="instance">
        <parameters>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dot" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scale" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saturate" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="normalize" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="faceforward" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reflect" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="diffuse" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="specular" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="roughness" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="phong" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.lighting.Model">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="incident" type="Object" usage="required"/>
          <parameter name="lights" type="Object" usage="required"/>
          <parameter name="ambient" type="Object" usage="required"/>
          <parameter name="specular" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constant" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="matte" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="metal" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="plastic" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="npr" scope="instance">
        <parameters>
          <parameter name="normal" type="Object" usage="required"/>
          <parameter name="finish" type="Object" usage="required"/>
          <parameter name="pigment" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="incident" scope="instance" type="Object"/>
      <property name="lights" scope="instance" type="Array"/>
      <property name="npr_cool" scope="instance" type="Object"/>
      <property name="npr_warm" scope="instance" type="Object"/>
      <property name="npr_alpha" scope="instance" type="Number"/>
      <property name="npr_beta" scope="instance" type="Number"/>
      <property name="npr_scale" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.Model.ambient">
    <properties>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.Model.specular">
    <properties>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish"/>
  <class type="dojox.gfx3d.lighting.finish.defaults">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.dull">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.shiny">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.glossy">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.phong_dull">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="phong" scope="instance" type="Number"/>
      <property name="phong_size" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.phong_shiny">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="phong" scope="instance" type="Number"/>
      <property name="phong_size" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.phong_glossy">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="phong" scope="instance" type="Number"/>
      <property name="phong_size" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.luminous">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalA">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalB">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalC">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalD">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.lighting.finish.metalE">
    <properties>
      <property name="Ka" scope="instance" type="Number"/>
      <property name="Kd" scope="instance" type="Number"/>
      <property name="Ks" scope="instance" type="Number"/>
      <property name="roughness" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.matrix">
    <methods>
      <method name="translate" scope="instance">
        <description>The resulting matrix is used to translate (move) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>an x coordinate value</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y coordinate value</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>a z coordinate value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="scale" scope="instance">
        <description>The resulting matrix is used to scale (magnify) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>a scaling factor used for the x coordinate</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a scaling factor used for the y coordinate</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>a scaling factor used for the z coordinate</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateX" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateXg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateX() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateY" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateYg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateY() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateZ" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateZg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateZ() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraTranslate" scope="instance">
        <description>The resulting matrix is used to translate (move) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number" usage="required">
            <description>an x coordinate value</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>a y coordinate value</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>a z coordinate value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateX" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateXg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateX() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateY" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateYg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateY() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateZ" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>an angle of rotation in radians (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateZg" scope="instance">
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateZ() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <description>an angle of rotation in degrees (&amp;gt;0 for CW)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="normalize" scope="instance">
        <description>Converts any 3D matrix-like object or an array of
	such objects to a valid dojox.gfx3d.matrix.Matrix3D object.</description>
        <parameters>
          <parameter name="matrix" type="Object" usage="required">
            <description>an object, which is converted to a matrix, if necessary</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="clone" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D" usage="required">
            <description>a 3D matrix-like object to be cloned</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="invert" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix3D" usage="required">
            <description>a 2D matrix-like object to be inverted</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="_multiplyPoint" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="z" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="multiplyPoint" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D" usage="required">
            <description>a 3D matrix object to be applied</description>
          </parameter>
          <parameter name="a" type="Number|Point" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>Number: a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="multiply" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D" usage="one-or-more">
            <description>a 3D matrix-like object,
	all subsequent arguments are matrix-like objects too</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="_project" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="z" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="project" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D" usage="required">
            <description>a 3D matrix object to be applied</description>
          </parameter>
          <parameter name="a" type="Number|Point" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>Number: a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_degToRad" scope="instance">
        <parameters>
          <parameter name="degree" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_radToDeg" scope="instance">
        <parameters>
          <parameter name="radian" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="identity" scope="instance" type="dojox.gfx3d.matrix.Matrix3D">
        <description>an identity matrix constant: identity * (x, y, z) == (x, y, z)</description>
      </property>
    </properties>
  </class>
  <class type="dojox.gfx3d.matrix.Matrix3D">
    <description>Normalizes a 3D matrix-like object. If arrays is passed,
	all objects of the array are normalized and multiplied sequentially.</description>
    <methods/>
    <properties>
      <property name="xx" scope="instance-prototype" type="Number"/>
      <property name="xy" scope="instance" type="Number"/>
      <property name="xz" scope="instance" type="Number"/>
      <property name="yx" scope="instance" type="Number"/>
      <property name="yy" scope="instance-prototype" type="Number"/>
      <property name="yz" scope="instance" type="Number"/>
      <property name="zx" scope="instance" type="Number"/>
      <property name="zy" scope="instance" type="Number"/>
      <property name="zz" scope="instance-prototype" type="Number"/>
      <property name="dx" scope="instance" type="Number"/>
      <property name="dy" scope="instance" type="Number"/>
      <property name="dz" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Viewport" superclass="dojox.gfx3d._creators">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setCameraTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraRightTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraLeftTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setLights" scope="instance">
        <parameters>
          <parameter name="lights" type="Array" usage="required">
            <description>Array: an array of light object
	or lights object</description>
          </parameter>
          <parameter name="ambient" type="Color" usage="required">
            <description>Color: an ambient object</description>
          </parameter>
          <parameter name="specular" type="Color" usage="required">
            <description>Color: an specular object</description>
          </parameter>
        </parameters>
      </method>
      <method name="addLights" scope="instance">
        <parameters>
          <parameter name="lights" type="Array" usage="required">
            <description>|| light object: light object(s)</description>
          </parameter>
        </parameters>
      </method>
      <method name="addTodo" scope="instance">
        <parameters>
          <parameter name="newObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="setDimensions" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx.Group" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx.Group" scope="instance"/>
    </mixins>
    <properties>
      <property name="camera" scope="instance" type="Object"/>
      <property name="lights" scope="instance-prototype" type="Array"/>
      <property name="lighting" scope="instance-prototype" type="Object"/>
      <property name="deep" scope="instance-prototype" type="bool"/>
      <property name="todos" scope="instance-prototype" type="Array"/>
      <property name="dimension" scope="instance-prototype" type="Object">
        <description>the dimension of the canvas</description>
      </property>
      <property name="objects" scope="instance-prototype" type="Array"/>
      <property name="renderer" scope="instance" type="Object"/>
      <property name="schedule" scope="instance" type="Object"/>
      <property name="draw" scope="instance" type="Object"/>
      <property name="nodeType" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Scene" superclass="dojox.gfx3d._creators">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
          <parameter name="deep" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addTodo" scope="instance">
        <parameters>
          <parameter name="newObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="getZOrder" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="fillStyle" scope="instance" type="Object"/>
      <property name="strokeStyle" scope="instance" type="Object"/>
      <property name="todos" scope="instance-prototype" type="Array"/>
      <property name="objects" scope="instance-prototype" type="Array"/>
      <property name="schedule" scope="instance" type="Object"/>
      <property name="_draw" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx.Surface">
    <methods>
      <method name="createViewport" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyRightTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyLeftTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyTransform" scope="instance">
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix" usage="required">
            <description>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="instance">
        <parameters>
          <parameter name="fill" type="Object" usage="required">
            <description>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	dojo.Color
	or dojox.gfx.MODEL)</description>
          </parameter>
        </parameters>
      </method>
      <method name="setStroke" scope="instance">
        <parameters>
          <parameter name="stroke" type="Object" usage="required">
            <description>a stroke object
	(see dojox.gfx.defaultStroke)</description>
          </parameter>
        </parameters>
      </method>
      <method name="toStdFill" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
          <parameter name="normal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
      <method name="getOutline" scope="instance"/>
    </methods>
    <properties>
      <property name="object" scope="instance-prototype" type="Object">
        <description>an abstract Object object
	(see dojox.gfx3d.defaultEdges,
	dojox.gfx3d.defaultTriangles,
	dojox.gfx3d.defaultQuads
	dojox.gfx3d.defaultOrbit
	dojox.gfx3d.defaultCube
	or dojox.gfx3d.defaultCylinder)</description>
      </property>
      <property name="matrix" scope="instance-prototype" type="Object"/>
      <property name="fillStyle" scope="instance-prototype" type="Object"/>
      <property name="strokeStyle" scope="instance-prototype" type="Object"/>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="renderer" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Edges" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
          <parameter name="style" type="String" usage="required">
            <description>optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Orbit" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Path3d" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_collectArgs" scope="instance">
        <parameters>
          <parameter name="array" type="Array" usage="required">
            <description>an output argument (array of numbers)</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>an input argument (can be values of Boolean, Number, dojox.gfx.Point, or an embedded array of them)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_pushSegment" scope="instance">
        <parameters>
          <parameter name="action" type="String" usage="required">
            <description>valid SVG code for a segment's type</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>a list of parameters for this segment</description>
          </parameter>
        </parameters>
      </method>
      <method name="moveTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="lineTo" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="closePath" scope="instance">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_draw" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="cache" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
      <property name="segments" scope="instance" type="Array"/>
      <property name="absolute" scope="instance" type="Object"/>
      <property name="last" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Path3d._validSegments">
    <properties>
      <property name="m" scope="instance" type="Number"/>
      <property name="l" scope="instance" type="Number"/>
      <property name="z" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Triangles" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
          <parameter name="style" type="String" usage="required">
            <description>optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Quads" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
          <parameter name="style" type="String" usage="required">
            <description>optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Polygon" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
      <method name="getOutline" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cube" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setObject" scope="instance">
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="lighting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="polygons" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cube.cache.0">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cube.cache.1">
    <properties>
      <property name="2" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cylinder" superclass="dojox.gfx3d.Object">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="render" scope="instance">
        <parameters>
          <parameter name="camera" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.gfx3d.Object" scope="instance"/>
    </mixins>
    <properties>
      <property name="cache" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Cylinder.object">
    <properties>
      <property name="radius" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.Viewport.rawNode"/>
  <class type="dojox.gfx3d.Viewport.rawNode.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d._creators">
    <methods>
      <method name="createEdges" scope="instance">
        <parameters>
          <parameter name="edges" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createTriangles" scope="instance">
        <parameters>
          <parameter name="tris" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createQuads" scope="instance">
        <parameters>
          <parameter name="quads" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createPolygon" scope="instance">
        <parameters>
          <parameter name="points" type="Array" usage="required">
            <description>of points || Object</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Polygon"/>
        </return-types>
      </method>
      <method name="createOrbit" scope="instance">
        <parameters>
          <parameter name="orbit" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createCube" scope="instance">
        <parameters>
          <parameter name="cube" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createCylinder" scope="instance">
        <parameters>
          <parameter name="cylinder" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createPath3d" scope="instance">
        <parameters>
          <parameter name="path" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createScene" scope="instance">
        <return-types>
          <return-type type="dojox.gfx3d.Scene"/>
        </return-types>
      </method>
      <method name="create3DObject" scope="instance">
        <parameters>
          <parameter name="objectType" type="Object" usage="required"/>
          <parameter name="rawObject" type="Object" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Object"/>
        </return-types>
      </method>
      <method name="adopt" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="abandon" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="silently" type="Boolean" usage="optional">
            <description>if true, do not redraw a picture yet</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d._creators.setScheduler">
    <methods/>
    <properties>
      <property name="schedule" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d._creators.setDrawer">
    <methods/>
    <properties>
      <property name="draw" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.scheduler">
    <methods>
      <method name="zOrder" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="order" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bsp" scope="instance">
        <parameters>
          <parameter name="buffer" type="Object" usage="required"/>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="order" scope="instance">
        <parameters>
          <parameter name="it" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="outline" scope="instance">
        <parameters>
          <parameter name="it" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.drawer">
    <methods>
      <method name="conservative" scope="instance">
        <parameters>
          <parameter name="todos" type="Object" usage="required"/>
          <parameter name="objects" type="Object" usage="required"/>
          <parameter name="viewport" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="chart" scope="instance">
        <parameters>
          <parameter name="todos" type="Object" usage="required"/>
          <parameter name="objects" type="Object" usage="required"/>
          <parameter name="viewport" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.gfx3d.scheduler.BinarySearchTree">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required">
            <description>dojox.gfx3d.Object</description>
          </parameter>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iterate" scope="instance">
        <parameters>
          <parameter name="outline" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="normal" scope="instance-prototype" type="Object"/>
      <property name="orient" scope="instance-prototype" type="Object"/>
      <property name="minus" scope="instance-prototype" type="Object"/>
      <property name="plus" scope="instance-prototype" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.gfx3d.vector">
    <methods>
      <method name="sum" scope="instance"/>
      <method name="center" scope="instance"/>
      <method name="substract" scope="instance">
        <parameters>
          <parameter name="a" type="Pointer" usage="required"/>
          <parameter name="b" type="Pointer" usage="required"/>
        </parameters>
      </method>
      <method name="_crossProduct" scope="instance">
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="z" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
          <parameter name="u" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="v" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="w" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="crossProduct" scope="instance">
        <parameters>
          <parameter name="a" type="Number|Point" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number|Point" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>Number: a z coordinate of a point</description>
          </parameter>
          <parameter name="d" type="Number" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="e" type="Number" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
          <parameter name="f" type="Number" usage="required">
            <description>Number: a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_dotProduct" scope="instance">
        <parameters>
          <parameter name="x" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="z" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
          <parameter name="u" type="Number" usage="required">
            <description>an x coordinate of a point</description>
          </parameter>
          <parameter name="v" type="Number" usage="required">
            <description>a y coordinate of a point</description>
          </parameter>
          <parameter name="w" type="Number" usage="required">
            <description>a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="dotProduct" scope="instance">
        <parameters>
          <parameter name="a" type="Number|Point" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="b" type="Number|Point" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
          <parameter name="c" type="Number" usage="required">
            <description>Number: a z coordinate of a point</description>
          </parameter>
          <parameter name="d" type="Number" usage="required">
            <description>Number: an x coordinate of a point</description>
          </parameter>
          <parameter name="e" type="Number" usage="required">
            <description>Number: a y coordinate of a point</description>
          </parameter>
          <parameter name="f" type="Number" usage="required">
            <description>Number: a z coordinate of a point</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="normalize" scope="instance">
        <parameters>
          <parameter name="a" type="Point|Array" usage="required">
            <description>Object: a point</description>
          </parameter>
          <parameter name="b" type="Point" usage="required">
            <description>Object: a point</description>
          </parameter>
          <parameter name="c" type="Point" usage="required">
            <description>Object: a point</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid">
    <properties>
      <property name="_Builder" scope="instance" type="Object"/>
      <property name="_ContentBuilder" scope="instance" type="Object"/>
      <property name="_HeaderBuilder" scope="instance" type="Object"/>
      <property name="_TableMap" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.__DataCellDef" superclass="dojox.grid.__CellDef">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.__CellDef" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.__DataViewDef" superclass="dojox.grid.__ViewDef">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.__ViewDef" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.DataGrid" superclass="dojox.grid._Grid">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="createSelection" scope="instance"/>
      <method name="get" scope="instance">
        <description>Provides data to display in a grid cell. Called in grid cell context.
	So this.cell.index is the column index.</description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Row for which to provide data</description>
          </parameter>
          <parameter name="inItem" type="Object" usage="required"/>
        </parameters>
        <return-description>Data to display for a given grid cell.</return-description>
      </method>
      <method name="_checkUpdateStatus" scope="instance"/>
      <method name="_onSet" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="oldValue" type="Object" usage="required"/>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="noUpdate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRevert" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setQuery" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setItems" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setQuery" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchBegin" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFetchError" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clearData" scope="instance"/>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItemIndex" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemIndex" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="isDeleted" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="reRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemAttr" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_render" scope="instance"/>
      <method name="_requestsPending" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_rowToPage" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pageToRow" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_preparePage" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_requestPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellName" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refresh" scope="instance">
        <parameters>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sort" scope="instance"/>
      <method name="canSort" scope="instance"/>
      <method name="getSortProps" scope="instance"/>
      <method name="styleRowState" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="canEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_copyAttr" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStartEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inAttrName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doCancelEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inDataAttr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeSelectedRows" scope="instance"/>
      <method name="cell_markupFactory" scope="instance">
        <parameters>
          <parameter name="cellFunc" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cellDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
          <parameter name="cellFunc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._Grid" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="query" scope="instance" type="Object"/>
      <property name="queryOptions" scope="instance" type="Object"/>
      <property name="fetchText" scope="instance" type="String"/>
      <property name="sortFields" scope="instance" type="Object"/>
      <property name="updateDelay" scope="instance" type="int">
        <description>Time, in milliseconds, to delay updates automatically so that multiple
	calls to onSet/onNew/onDelete don't keep rerendering the grid.  Set
	to 0 to immediately cause updates.  A higher value will result in
	better performance at the expense of responsiveness of the grid.</description>
      </property>
      <property name="structure" scope="instance" type="dojox.grid.__DataViewDef|Array&lt;dojox.grid.__DataViewDef&gt;|Array&lt;dojox.grid.__DataCellDef&gt;|Array&lt;Array[dojox.grid.__DataCellDef&gt;]">
        <description>View layout defintion.</description>
      </property>
      <property name="items" scope="instance" type="Object"/>
      <property name="_store_connects" scope="instance" type="Array"/>
      <property name="_by_idty" scope="instance" type="Object"/>
      <property name="_cache" scope="instance" type="Array"/>
      <property name="_pages" scope="instance" type="Array"/>
      <property name="_pending_requests" scope="instance" type="Object"/>
      <property name="_bop" scope="instance" type="Number"/>
      <property name="_eop" scope="instance" type="String"/>
      <property name="_requests" scope="instance" type="Number"/>
      <property name="rowCount" scope="instance" type="Number"/>
      <property name="_isLoaded" scope="instance" type="bool"/>
      <property name="_isLoading" scope="instance" type="bool"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_endUpdateDelay" scope="instance" type="Object"/>
      <property name="_addingItem" scope="instance" type="bool"/>
      <property name="_canEdit" scope="instance" type="Object"/>
      <property name="_hasIdentity" scope="instance" type="bool"/>
      <property name="_skipRowRenormalize" scope="instance" type="bool"/>
      <property name="rowsPerPage" scope="instance" type="Object"/>
      <property name="_lastScrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.DataGrid.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.DataGrid._by_idx">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.DataSelection" superclass="dojox.grid.Selection">
    <methods>
      <method name="getFirstSelected" scope="instance"/>
      <method name="getNextSelected" scope="instance">
        <parameters>
          <parameter name="inPrev" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="instance"/>
      <method name="addToSelection" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.Selection" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.grid.DataSelection.selected">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.EnhancedGrid" superclass="dojox.grid.DataGrid">
    <description>EnhancedGrid features are implemented as plugins that could be loaded on demand.
	Explicit dojo.require() is needed to use these feature plugins.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="plugin" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="createSelection" scope="instance"/>
      <method name="canSort" scope="instance">
        <parameters>
          <parameter name="colIndex" type="Object" usage="required"/>
          <parameter name="field" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inAttrName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mixin" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="source" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_copyAttr" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getHeaderHeight" scope="instance"/>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_storeLayerFetch" scope="instance">
        <parameters>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellByField" scope="instance">
        <parameters>
          <parameter name="field" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createView" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
          <parameter name="cellFunc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerPlugin" scope="instance">
        <parameters>
          <parameter name="clazz" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.DataGrid" scope="instance"/>
    </mixins>
    <properties>
      <property name="plugins" scope="instance" type="Object">
        <description>Plugin properties, e.g. {nestedSorting: true, dnd: true, ...}</description>
      </property>
      <property name="pluginMgr" scope="instance" type="Object">
        <description>Singleton plugin manager</description>
      </property>
      <property name="keepSelection" scope="instance" type="Boolean">
        <description>Whether keep selection after sort, filter, pagination etc.</description>
      </property>
      <property name="_pluginMgrClass" scope="instance" type="Object">
        <description>Default plugin manager class</description>
      </property>
      <property name="_nls" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_isLoading" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.EnhancedGrid.focus">
    <properties>
      <property name="focusView" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced"/>
  <class type="dojox.grid.enhanced.DataSelection" superclass="dojox.grid.DataSelection">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_range" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.DataSelection" scope="instance"/>
    </mixins>
    <properties>
      <property name="preserver" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.DataSelection.grid">
    <properties>
      <property name="_selectingRange" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell"/>
  <class type="dojox.grid.cells.TreeCell.formatAtLevel">
    <methods/>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatAtLevel.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatIndexes">
    <methods/>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatIndexes.grid.edit">
    <properties>
      <property name="info" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._LazyExpando" superclass="dijit._Widget">
    <methods>
      <method name="onToggle" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOpen" scope="instance">
        <parameters>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateOpenState" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRowNode" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
          <parameter name="rowNode" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="itemId" scope="instance" type="String"/>
      <property name="cellIdx" scope="instance" type="Number"/>
      <property name="rowIdx" scope="instance" type="Number"/>
      <property name="expandoCell" scope="instance" type="Object"/>
      <property name="level" scope="instance" type="Number"/>
      <property name="open" scope="instance" type="bool"/>
      <property name="templatePath" scope="instance" type="Object"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_tableRow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._LazyExpando.view"/>
  <class type="dojox.grid._LazyExpando.view.grid">
    <properties>
      <property name="stateChangeNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._LazyExpando.expandoInner">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeGridContentBuilder" superclass="dojox.grid._ContentBuilder">
    <methods>
      <method name="generateHtml" scope="instance">
        <parameters>
          <parameter name="inDataIndex" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getColSpans" scope="instance">
        <parameters>
          <parameter name="level" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCellWidth" scope="instance">
        <parameters>
          <parameter name="cells" type="Object" usage="required"/>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._ContentBuilder" scope="instance"/>
    </mixins>
    <properties>
      <property name="view" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeGridContentBuilder.view.structure">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeGridContentBuilder.grid">
    <properties>
      <property name="colSpans" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeGridView" superclass="dojox.grid._View">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_cleanupExpandoCache" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="identity" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._View" scope="instance"/>
    </mixins>
    <properties>
      <property name="_contentBuilderClass" scope="instance" type="Object"/>
      <property name="_expandos" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._LazyTreeLayout" superclass="dojox.grid._Layout">
    <methods>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._Layout" scope="instance"/>
    </mixins>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
      <property name="_isCollapsable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGridItemCache">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_buildCache" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cacheItem" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="integer" usage="required"/>
          <parameter name="cacheObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertItem" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="integer" usage="required"/>
          <parameter name="cacheObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initCache" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItemByRowIndex" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="integer" usage="required"/>
        </parameters>
      </method>
      <method name="getItemByTreePath" scope="instance">
        <parameters>
          <parameter name="treePath" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTreePathByRowIndex" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="integer" usage="required"/>
        </parameters>
      </method>
      <method name="getExpandoStatusByRowIndex" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="integer" usage="required"/>
        </parameters>
      </method>
      <method name="getInfoByItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateCache" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="integer" usage="required"/>
          <parameter name="cacheObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cleanChildren" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="emptyCache" scope="instance"/>
      <method name="cleanupCache" scope="instance"/>
    </methods>
    <properties>
      <property name="unInit" scope="instance" type="Object"/>
      <property name="rowsPerPage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGridItemCache.items">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid" superclass="dojox.grid.TreeGrid">
    <description>LazyTreeGrid inherits from dojo.grid.TreeGrid, and applies virtual scrolling mechanism
	to nested children rows so that it's possible to deal with large data set specifically
	in tree structure with large number of children rows. It's also compatible with dijit.tree.ForestStoreModel
	Most methods and properties pertaining to the dojox.grid.DataGrid
	and dojox.grid.TreeGrid also apply here
	LazyTreeGrid does not support summary row/items aggregate for the
	lazy-loading reason.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="createManagers" scope="instance"/>
      <method name="createSelection" scope="instance"/>
      <method name="setModel" scope="instance">
        <parameters>
          <parameter name="treeModel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setQuery" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="queryOptions" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_cleanup" scope="instance"/>
      <method name="setSortIndex" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inAsc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refresh" scope="instance">
        <parameters>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupExpandoCache" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="identity" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="isRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="onBegin" type="Object" usage="required"/>
          <parameter name="onComplete" type="Object" usage="required"/>
          <parameter name="onError" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchBegin" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="expandoFetch" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onExpandoComplete" scope="instance">
        <parameters>
          <parameter name="childItems" type="Object" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleLoadingClass" scope="instance">
        <parameters>
          <parameter name="flag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dokeydown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
          <parameter name="cellFunc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.TreeGrid" scope="instance"/>
    </mixins>
    <properties>
      <property name="_layoutClass" scope="instance" type="Object"/>
      <property name="colSpans" scope="instance" type="Object">
        <description>a json object that defines column span of each level rows
	attributes:
	0/1/..: which level need to colspan
	start: start column index of colspan
	end: end column index of colspan
	primary: index of column which content will be displayed (default is value of start).</description>
      </property>
      <property name="rows" scope="instance" type="Object"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="edit" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_pages" scope="instance" type="Array"/>
      <property name="_bop" scope="instance" type="Number"/>
      <property name="_eop" scope="instance" type="Number"/>
      <property name="reqQueueIndex" scope="instance" type="Number"/>
      <property name="expandoRowIndex" scope="instance" type="Object"/>
      <property name="stateChangeNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid.treeModel">
    <properties>
      <property name="query" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid.treeModel.root">
    <properties>
      <property name="children" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid.cache"/>
  <class type="dojox.grid.LazyTreeGrid.reqQueue">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid.cache.items">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid.queryObj">
    <properties>
      <property name="startRowIdx" scope="instance" type="Object"/>
      <property name="count" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGrid._by_idx">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGridStoreModel" superclass="dijit.tree.ForestStoreModel">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="instance">
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="Function(items)" usage="required">
            <description>size)</description>
          </parameter>
          <parameter name="onError" type="function" usage="required"/>
          <parameter name="queryObj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_isChildrenLoaded" scope="instance">
        <parameters>
          <parameter name="parentItem" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.tree.ForestStoreModel" scope="instance"/>
    </mixins>
    <properties>
      <property name="serverStore" scope="instance-prototype" type="bool"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="childrenSize" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.LazyTreeGridStoreModel.root">
    <properties>
      <property name="size" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.Selection">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setMode" scope="instance">
        <parameters>
          <parameter name="mode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCanSelect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCanDeselect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeselected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChanging" scope="instance"/>
      <method name="onChanged" scope="instance"/>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstSelected" scope="instance"/>
      <method name="getNextSelected" scope="instance">
        <parameters>
          <parameter name="inPrev" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="instance"/>
      <method name="getSelectedCount" scope="instance"/>
      <method name="_beginUpdate" scope="instance"/>
      <method name="_endUpdate" scope="instance"/>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToSelection" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSelected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleSelect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_range" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
          <parameter name="func" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectRange" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectRange" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insert" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance">
        <parameters>
          <parameter name="inExcept" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clickSelect" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inCtrlKey" type="Object" usage="required"/>
          <parameter name="inShiftKey" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clickSelectEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
    </methods>
    <properties>
      <property name="mode" scope="instance" type="String"/>
      <property name="updating" scope="instance" type="Number"/>
      <property name="selectedIndex" scope="instance" type="Number"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.Selection.selected">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeAggregator">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cacheValue" scope="instance">
        <parameters>
          <parameter name="cache" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearSubtotalCache" scope="instance"/>
      <method name="cnt" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sum" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="value" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getForCell" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="level" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cells" scope="instance-prototype" type="Array"/>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="childFields" scope="instance-prototype" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeAggregator.store">
    <properties>
      <property name="_cachedAggregates" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeLayout" superclass="dojox.grid._Layout">
    <methods>
      <method name="_getInternalStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._Layout" scope="instance"/>
    </mixins>
    <properties>
      <property name="_isCollapsable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeLayout.grid">
    <properties>
      <property name="aggregator" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeLayout.grid.scroller">
    <properties>
      <property name="defaultRowHeight" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.TreePath">
    <methods>
      <method name="item" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="path" type="String|Array&lt;Integer&gt;|Integer|dojox.grid.TreePath" usage="required"/>
          <parameter name="grid" type="dojox.grid.TreeGrid" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="path" type="dojox.grid.TreePath|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="isOpen" scope="instance"/>
      <method name="previous" scope="instance"/>
      <method name="next" scope="instance"/>
      <method name="children" scope="instance">
        <parameters>
          <parameter name="alwaysReturn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="childPaths" scope="instance"/>
      <method name="parent" scope="instance"/>
      <method name="lastChild" scope="instance">
        <parameters>
          <parameter name="traverse" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="toString" scope="instance"/>
    </methods>
    <properties>
      <property name="level" scope="instance-prototype" type="Number"/>
      <property name="_str" scope="instance-prototype" type="Object"/>
      <property name="_arr" scope="instance-prototype" type="Object"/>
      <property name="store" scope="instance-prototype" type="Object"/>
      <property name="cell" scope="instance-prototype" type="Object"/>
      <property name="_item" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreePath.grid"/>
  <class type="dojox.grid.TreePath.grid.treeModel">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeFocusManager" superclass="dojox.grid._FocusManager">
    <methods>
      <method name="setFocusCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isLastFocusCell" scope="instance"/>
      <method name="next" scope="instance"/>
      <method name="previous" scope="instance"/>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="inRowDelta" type="Object" usage="required"/>
          <parameter name="inColDelta" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._FocusManager" scope="instance"/>
    </mixins>
    <properties>
      <property name="rowIndex" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeFocusManager.grid">
    <properties>
      <property name="scroller" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeFocusManager.cell">
    <properties>
      <property name="index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGrid" superclass="dojox.grid.DataGrid">
    <description>TreeGrid currently only works on "simple" structures.  That is,
	single-view structures with a single row in them.
	The TreeGrid works using the concept of "levels" - level 0 are the
	top-level items.</description>
    <methods>
      <method name="createSelection" scope="instance"/>
      <method name="_childItemSorter" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="descending" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSet" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="attribute" type="Object" usage="required"/>
          <parameter name="oldValue" type="Object" usage="required"/>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupExpandoCache" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="identity" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="noUpdate" type="Object" usage="required"/>
          <parameter name="dontUpdateRoot" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="idx" type="integer|Array|String" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemIndex" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="isDeleted" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="setModel" scope="instance">
        <parameters>
          <parameter name="treeModel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setModel" scope="instance">
        <parameters>
          <parameter name="treeModel" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createScroller" scope="instance"/>
      <method name="createManagers" scope="instance"/>
      <method name="_setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultOpenState" scope="instance">
        <parameters>
          <parameter name="cellDef" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCanSelect" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="canEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inAttrName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
          <parameter name="cellFunc" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.DataGrid" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultOpen" scope="instance" type="Boolean">
        <description>Whether or not we default to open (all levels).  This defaults to
	false for grids with a treeModel.</description>
      </property>
      <property name="sortChildItems" scope="instance" type="Boolean">
        <description>If true, child items will be returned sorted according to the sorting
	properties of the grid.</description>
      </property>
      <property name="openAtLevels" scope="instance" type="Array">
        <description>Which levels we are open at (overrides defaultOpen for the values
	that exist here).  Its values can be a boolean (true/false) or an
	integer (for the # of children to be closed if there are more than
	that)</description>
      </property>
      <property name="expandoCell" scope="instance" type="Integer">
        <description>When used in conjunction with a treeModel (see above), this is a 0-based
	index of the cell in which to place the actual expando</description>
      </property>
      <property name="_layoutClass" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="_by_idty_paths" scope="instance" type="Object"/>
      <property name="rows" scope="instance" type="Object"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="edit" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGrid.treeModel"/>
  <class type="dojox.grid.TreeGrid.treeModel.childrenAttrs">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGrid.scroller">
    <properties>
      <property name="_origDefaultRowHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGrid.treeModel.root">
    <properties>
      <property name="children" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeGrid.aggregator">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeSelection" superclass="dojox.grid.DataSelection">
    <methods>
      <method name="setMode" scope="instance">
        <parameters>
          <parameter name="mode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToSelection" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="instance"/>
      <method name="getSelectedCount" scope="instance"/>
      <method name="_bsearch" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_comparePaths" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_insertSortedSelection" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeSortedSelection" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstSelected" scope="instance"/>
      <method name="getNextSelected" scope="instance">
        <parameters>
          <parameter name="inPrev" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_range" scope="instance">
        <parameters>
          <parameter name="inFrom" type="Object" usage="required"/>
          <parameter name="inTo" type="Object" usage="required"/>
          <parameter name="func" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.DataSelection" scope="instance"/>
    </mixins>
    <properties>
      <property name="selected" scope="instance" type="Object"/>
      <property name="sorted_sel" scope="instance" type="Array"/>
      <property name="sorted_ltos" scope="instance" type="Object"/>
      <property name="sorted_stol" scope="instance" type="Object"/>
      <property name="selectedIndex" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeSelection.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.TreeSelection.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.util">
    <methods>
      <method name="fire" scope="instance">
        <parameters>
          <parameter name="ob" type="Object" usage="required"/>
          <parameter name="ev" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStyleHeightPx" scope="instance">
        <parameters>
          <parameter name="inElement" type="Object" usage="required"/>
          <parameter name="inHeight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="funnelEvents" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inObject" type="Object" usage="required"/>
          <parameter name="inMethod" type="Object" usage="required"/>
          <parameter name="inEvents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrayCompare" scope="instance">
        <parameters>
          <parameter name="inA" type="Object" usage="required"/>
          <parameter name="inB" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrayInsert" scope="instance">
        <parameters>
          <parameter name="inArray" type="Object" usage="required"/>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrayRemove" scope="instance">
        <parameters>
          <parameter name="inArray" type="Object" usage="required"/>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arraySwap" scope="instance">
        <parameters>
          <parameter name="inArray" type="Object" usage="required"/>
          <parameter name="inI" type="Object" usage="required"/>
          <parameter name="inJ" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="rowIndexTag" scope="instance" type="String"/>
      <property name="gridViewTag" scope="instance" type="String"/>
      <property name="na" scope="instance" type="String"/>
      <property name="mouseEvents" scope="instance" type="Array"/>
      <property name="keyEvents" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid._CheckBoxSelector" superclass="dojox.grid._Selector">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="renderHeader" scope="instance"/>
      <method name="_updateVisibility" scope="instance">
        <parameters>
          <parameter name="rowCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectionChanged" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._Selector" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputType" scope="instance" type="String"/>
      <property name="_headerBuilderClass" scope="instance" type="Object"/>
      <property name="_contentBuilderClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._EditManager">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="dojox.Grid" usage="required">
            <description>The dojox.Grid this editor should be attached to</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="cellFocus" scope="instance">
        <parameters>
          <parameter name="inCell" type="cell" usage="required">
            <description>object
	Grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="rowClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isEditing" scope="instance">
        <return-description>Boolean
	True if grid is actively editing</return-description>
      </method>
      <method name="isEditCell" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
          <parameter name="inCellIndex" type="Integer" usage="required">
            <description>Grid cell index</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if given cell is being edited</return-description>
      </method>
      <method name="isEditRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if given row is being edited</return-description>
      </method>
      <method name="setEditCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>Grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="_focusEditor" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusEditor" scope="instance"/>
      <method name="_shouldCatchBoomerang" scope="instance"/>
      <method name="_boomerangFocus" scope="instance"/>
      <method name="_doCatchBoomerang" scope="instance"/>
      <method name="start" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inEditing" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_editorDo" scope="instance">
        <parameters>
          <parameter name="inMethod" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="editorApply" scope="instance"/>
      <method name="editorCancel" scope="instance"/>
      <method name="applyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyRowEdit" scope="instance"/>
      <method name="apply" scope="instance"/>
      <method name="cancel" scope="instance"/>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
          <parameter name="inView" type="Object" usage="required">
            <description>Grid view</description>
          </parameter>
        </parameters>
      </method>
      <method name="restore" scope="instance">
        <parameters>
          <parameter name="inView" type="Object" usage="required">
            <description>Grid view</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Grid row index</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_boomerangWindow" scope="instance" type="Number"/>
      <property name="_catchBoomerang" scope="instance" type="String"/>
      <property name="grid" scope="instance" type="Object"/>
      <property name="connections" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid._EditManager.info">
    <properties>
      <property name="cell" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Events">
    <description>Default synthetic events dispatched for _Grid. dojo.connect to events to
	retain default implementation or override them for custom handling.</description>
    <methods>
      <method name="onKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onContentEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="instance">
        <examples>
          <example>onStyleRow({ selected: true, over:true, odd:false })</example>
        </examples>
        <parameters>
          <parameter name="inRow" type="Object" usage="required">
            <description>Object containing row state information: selected, true if the row is selcted; over:
	true of the mouse is over the row; odd: true if the row is odd. Use customClasses and
	customStyles to control row css classes and styles; both properties are strings.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOverRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOutRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDownRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellFocus" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>Cell object containing properties of the grid column.</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onStartEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <description>Cell object containing properties of the grid column.</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="String" usage="required">
            <description>Value from cell editor</description>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
          <parameter name="inFieldIndex" type="Integer" usage="required">
            <description>Index in the grid's data store</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCancelEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onApplyEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCanSelect" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	true if the row can be selected</return-description>
      </method>
      <method name="onCanDeselect" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	true if the row can be deselected</return-description>
      </method>
      <method name="onSelected" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDeselected" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the grid row</description>
          </parameter>
        </parameters>
      </method>
      <method name="onSelectionChanged" scope="instance"/>
    </methods>
    <properties>
      <property name="cellOverClass" scope="instance" type="String">
        <description>css class to apply to grid cells over which the cursor is placed.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid._Events.focus">
    <properties>
      <property name="focusView" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Events._click">
    <properties>
      <property name="0" scope="instance" type="Object"/>
      <property name="1" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._FocusManager">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="initFocusView" scope="instance"/>
      <method name="isFocusCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="object" usage="required">
            <description>grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>true of the given grid cell is focused</return-description>
      </method>
      <method name="isLastFocusCell" scope="instance"/>
      <method name="isFirstFocusCell" scope="instance"/>
      <method name="isNoFocusCell" scope="instance"/>
      <method name="isNavHeader" scope="instance">
        <return-description>true if focus is on a column header; false otherwise.</return-description>
      </method>
      <method name="getHeaderIndex" scope="instance">
        <return-description>index of the focused column header, or -1 if none have focus.</return-description>
      </method>
      <method name="_focusifyCellNode" scope="instance">
        <parameters>
          <parameter name="inBork" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_delayedCellFocus" scope="instance"/>
      <method name="_delayedHeaderFocus" scope="instance"/>
      <method name="_initColumnHeaders" scope="instance"/>
      <method name="_findHeaderCells" scope="instance"/>
      <method name="_setActiveColHeader" scope="instance">
        <parameters>
          <parameter name="colHeaderNode" type="Node" usage="required"/>
          <parameter name="colFocusIdx" type="Integer" usage="required"/>
          <parameter name="prevColFocusIdx" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance"/>
      <method name="_scrollInfo" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="domNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollHeader" scope="instance">
        <parameters>
          <parameter name="currentIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isHeaderHidden" scope="instance">
        <return-description>Boolean
	true if headers are hidden
	false if headers are not hidden</return-description>
      </method>
      <method name="colSizeAdjust" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="colIdx" type="Object" usage="required"/>
          <parameter name="delta" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="can't adjust single col. grid"/>
        </return-types>
      </method>
      <method name="styleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusIndex" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inCellIndex" type="int" usage="required">
            <description>grid cell index</description>
          </parameter>
        </parameters>
      </method>
      <method name="setFocusCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="object" usage="required">
            <description>grid cell object</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="next" scope="instance"/>
      <method name="previous" scope="instance"/>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="inRowDelta" type="int" usage="required">
            <description>vertical distance from current focus</description>
          </parameter>
          <parameter name="inColDelta" type="int" usage="required">
            <description>horizontal distance from current focus</description>
          </parameter>
        </parameters>
      </method>
      <method name="previousKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tabOut" scope="instance">
        <parameters>
          <parameter name="inFocusNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusGridView" scope="instance"/>
      <method name="focusGrid" scope="instance">
        <parameters>
          <parameter name="inSkipFocusCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findAndFocusGridCell" scope="instance">
        <return-description>Boolean
	true if focus was set to a cell
	false if no cell found to set focus onto</return-description>
      </method>
      <method name="focusHeader" scope="instance"/>
      <method name="blurHeader" scope="instance"/>
      <method name="doFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doLastNodeFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doLastNodeBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doColHeaderFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doColHeaderBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_colHeadNode" scope="instance" type="Object"/>
      <property name="_colHeadFocusIdx" scope="instance" type="Number"/>
      <property name="_contextMenuBindNode" scope="instance" type="Object"/>
      <property name="tabbingOut" scope="instance" type="bool"/>
      <property name="focusClass" scope="instance" type="String"/>
      <property name="focusView" scope="instance" type="Object"/>
      <property name="_headerConnects" scope="instance-prototype" type="Array"/>
      <property name="rowIndex" scope="instance-prototype" type="Number"/>
      <property name="_connects" scope="instance" type="Array"/>
      <property name="headerMenu" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._FocusManager.cell.view.scrollboxNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._FocusManager.grid">
    <properties>
      <property name="scroller" scope="instance" type="Object"/>
      <property name="viewsHeaderNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._FocusManager.cell">
    <properties>
      <property name="index" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid" superclass="dijit._Widget">
    <description>_Grid provides the full set of grid features without any
	direct connection to a data store.
	The grid exposes a get function for the grid, or optionally
	individual columns, to populate cell contents.
	The grid is rendered based on its structure, an object describing
	column and cell layout.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_setAutoHeightAttr" scope="instance">
        <parameters>
          <parameter name="ah" type="Object" usage="required"/>
          <parameter name="skipRender" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRowCountAttr" scope="instance"/>
      <method name="textSizeChanged" scope="instance"/>
      <method name="sizeChange" scope="instance"/>
      <method name="createManagers" scope="instance"/>
      <method name="createSelection" scope="instance"/>
      <method name="createScroller" scope="instance"/>
      <method name="createLayout" scope="instance"/>
      <method name="onMoveColumn" scope="instance"/>
      <method name="onResizeColumn" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="createViews" scope="instance"/>
      <method name="createView" scope="instance">
        <parameters>
          <parameter name="inClass" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildViews" scope="instance"/>
      <method name="_setStructureAttr" scope="instance">
        <parameters>
          <parameter name="structure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="dojox.grid.__ViewDef|Array&lt;dojox.grid.__ViewDef&gt;|Array&lt;dojox.grid.__CellDef&gt;|Array&lt;Array[dojox.grid.__CellDef&gt;]" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnTogglingItems" scope="instance"/>
      <method name="_setHeaderMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setHeaderMenu" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="required"/>
        </parameters>
      </method>
      <method name="setupHeaderMenu" scope="instance"/>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showMessage" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_structureChanged" scope="instance"/>
      <method name="hasLayout" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPadBorder" scope="instance"/>
      <method name="_getHeaderHeight" scope="instance"/>
      <method name="_resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adaptWidth" scope="instance"/>
      <method name="adaptHeight" scope="instance">
        <parameters>
          <parameter name="inHeaderHeight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="update" scope="instance"/>
      <method name="_render" scope="instance"/>
      <method name="prerender" scope="instance"/>
      <method name="postrender" scope="instance"/>
      <method name="postresize" scope="instance"/>
      <method name="renderRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="beginUpdate" scope="instance"/>
      <method name="endUpdate" scope="instance"/>
      <method name="defaultUpdate" scope="instance"/>
      <method name="updateRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>Index of the row to render</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateRows" scope="instance">
        <parameters>
          <parameter name="startIndex" type="Integer" usage="required">
            <description>Index of the starting row to render</description>
          </parameter>
          <parameter name="howMany" type="Integer" usage="required">
            <description>How many rows to update.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateRowCount" scope="instance">
        <parameters>
          <parameter name="inRowCount" type="int" usage="required">
            <description>Number of rows in the grid.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowHeightChanged" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>index of the row that has changed height</description>
          </parameter>
        </parameters>
      </method>
      <method name="scrollTo" scope="instance">
        <parameters>
          <parameter name="inTop" type="Integer" usage="required">
            <description>vertical position of the grid in pixels</description>
          </parameter>
        </parameters>
      </method>
      <method name="finishScrollJob" scope="instance"/>
      <method name="setScrollTop" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scrollToRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCell" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required">
            <description>Grid column index of cell to retrieve</description>
          </parameter>
        </parameters>
        <return-description>a grid cell</return-description>
      </method>
      <method name="setCellWidth" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inUnitWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellName" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="canSort" scope="instance">
        <parameters>
          <parameter name="inSortInfo" type="Integer" usage="required">
            <description>Sort information, 1-based index of column on which to sort, positive for an ascending sort
	and negative for a descending sort</description>
          </parameter>
        </parameters>
        <return-description>Boolean
	True if grid can be sorted on the given column in the given direction</return-description>
      </method>
      <method name="sort" scope="instance"/>
      <method name="getSortAsc" scope="instance">
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getSortIndex" scope="instance">
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="setSortIndex" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required">
            <description>Column index on which to sort.</description>
          </parameter>
          <parameter name="inAsc" type="Boolean" usage="required">
            <description>If true, sort the grid in ascending order, otherwise in descending order</description>
          </parameter>
        </parameters>
      </method>
      <method name="setSortInfo" scope="instance">
        <parameters>
          <parameter name="inSortInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dispatch" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchKeyEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchContentEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchHeaderEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dokeydown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dodblclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="docontextmenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheaderclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheaderdblclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doheadercontextmenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStartEdit" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inFieldIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doCancelEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRow" scope="instance"/>
      <method name="removeSelectedRows" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="ctor" type="Object" usage="required"/>
          <parameter name="cellFunc" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="for vendetta"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dojox.grid._Events.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dojox.grid._Events" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="instance" type="Object"/>
      <property name="classTag" scope="instance" type="String">
        <description>CSS class applied to the grid's domNode</description>
      </property>
      <property name="rowCount" scope="instance" type="Integer">
        <description>Number of rows to display.</description>
      </property>
      <property name="keepRows" scope="instance" type="Integer">
        <description>Number of rows to keep in the rendering cache.</description>
      </property>
      <property name="rowsPerPage" scope="instance" type="Integer">
        <description>Number of rows to render at a time.</description>
      </property>
      <property name="autoWidth" scope="instance" type="Boolean">
        <description>If autoWidth is true, grid width is automatically set to fit the data.</description>
      </property>
      <property name="initialWidth" scope="instance" type="String">
        <description>A css string to use to set our initial width (only used if autoWidth
	is true).  The first rendering of the grid will be this width, any
	resizing of columns, etc will result in the grid switching to
	autoWidth mode.  Note, this width will override any styling in a
	stylesheet or directly on the node.</description>
      </property>
      <property name="autoHeight" scope="instance" type="Boolean|Integer">
        <description>If autoHeight is true, grid height is automatically set to fit the data.
	If it is an integer, the height will be automatically set to fit the data
	if there are fewer than that many rows - and the height will be set to show
	that many rows if there are more</description>
      </property>
      <property name="rowHeight" scope="instance" type="Integer">
        <description>If rowHeight is set to a positive number, it will define the height of the rows
	in pixels. This can provide a significant performance advantage, since it
	eliminates the need to measure row sizes during rendering, which is one
	the primary bottlenecks in the DataGrid's performance.</description>
      </property>
      <property name="autoRender" scope="instance" type="Boolean">
        <description>If autoRender is true, grid will render itself after initialization.</description>
      </property>
      <property name="defaultHeight" scope="instance" type="String">
        <description>default height of the grid, measured in any valid css unit.</description>
      </property>
      <property name="height" scope="instance" type="String">
        <description>explicit height of the grid, measured in any valid css unit.  This will be populated (and overridden)
	if the height: css attribute exists on the source node.</description>
      </property>
      <property name="structure" scope="instance" type="dojox.grid.__ViewDef|Array&lt;dojox.grid.__ViewDef&gt;|Array&lt;dojox.grid.__CellDef&gt;|Array&lt;Array[dojox.grid.__CellDef&gt;]">
        <description>View layout defintion.</description>
      </property>
      <property name="elasticView" scope="instance" type="Integer">
        <description>Override defaults and make the indexed grid view elastic, thus filling available horizontal space.</description>
      </property>
      <property name="singleClickEdit" scope="instance" type="boolean">
        <description>Single-click starts editing. Default is double-click</description>
      </property>
      <property name="selectionMode" scope="instance" type="String">
        <description>Set the selection mode of grid's Selection.  Value must be 'single', 'multiple',
	or 'extended'.  Default is 'extended'.</description>
      </property>
      <property name="rowSelector" scope="instance" type="Boolean|String">
        <description>If set to true, will add a row selector view to this grid.  If set to a CSS width, will add
	a row selector of that width to this grid.</description>
      </property>
      <property name="columnReordering" scope="instance" type="Boolean">
        <description>If set to true, will add drag and drop reordering to views with one row of columns.</description>
      </property>
      <property name="headerMenu" scope="instance" type="dijit.Menu">
        <description>If set to a dijit.Menu, will use this as a context menu for the grid headers.</description>
      </property>
      <property name="placeholderLabel" scope="instance" type="String">
        <description>Label of placeholders to search for in the header menu to replace with column toggling
	menu items.</description>
      </property>
      <property name="selectable" scope="instance" type="Boolean">
        <description>Set to true if you want to be able to select the text within the grid.</description>
      </property>
      <property name="_click" scope="instance" type="Array"/>
      <property name="loadingMessage" scope="instance" type="String">
        <description>Message that shows while the grid is loading</description>
      </property>
      <property name="errorMessage" scope="instance" type="String">
        <description>Message that shows when the grid encounters an error loading</description>
      </property>
      <property name="noDataMessage" scope="instance" type="String">
        <description>Message that shows if the grid has no data - wrap it in a
	span with class 'dojoxGridNoData' if you want it to be
	styled similar to the loading and error messages</description>
      </property>
      <property name="escapeHTMLInData" scope="instance" type="Boolean">
        <description>This will escape HTML brackets from the data to prevent HTML from
	user-inputted data being rendered with may contain JavaScript and result in
	XSS attacks. This is true by default, and it is recommended that it remain
	true. Setting this to false will allow data to be displayed in the grid without
	filtering, and should be only used if it is known that the data won't contain
	malicious scripts. If HTML is needed in grid cells, it is recommended that
	you use the formatter function to generate the HTML (the output of
	formatter functions is not filtered, even with escapeHTMLInData set to true).</description>
      </property>
      <property name="formatterScope" scope="instance" type="Object">
        <description>An object to execute format functions within.  If not set, the
	format functions will execute within the scope of the cell that
	has a format function.</description>
      </property>
      <property name="editable" scope="instance" type="boolean">
        <description>indicates if the grid contains editable cells, default is false
	set to true if editable cell encountered during rendering</description>
      </property>
      <property name="sortInfo" scope="instance" type="Number"/>
      <property name="themeable" scope="instance" type="Object"/>
      <property name="_placeholders" scope="instance" type="Object"/>
      <property name="_layoutClass" scope="instance" type="Object">
        <description>The class to use for our layout - can be overridden by grid subclasses</description>
      </property>
      <property name="lastScrollTop" scope="instance" type="Number"/>
      <property name="scrollTop" scope="instance" type="Number"/>
      <property name="_autoHeight" scope="instance" type="bool"/>
      <property name="rows" scope="instance" type="Object"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="edit" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_pendingChangeSize" scope="instance" type="Object"/>
      <property name="_pendingResultSize" scope="instance" type="Object"/>
      <property name="_padBorder" scope="instance" type="Object"/>
      <property name="fitTo" scope="instance" type="String"/>
      <property name="_parentContentBoxHeight" scope="instance" type="Object"/>
      <property name="updating" scope="instance" type="bool"/>
      <property name="fastScroll" scope="instance" type="Boolean">
        <description>flag modifies vertical scrolling behavior. Defaults to true but set to false for slower
	scroll performance but more immediate scrolling feedback</description>
      </property>
      <property name="delayScroll" scope="instance" type="bool"/>
      <property name="scrollRedrawThreshold" scope="instance" type="int">
        <description>pixel distance a user must scroll vertically to trigger grid scrolling.</description>
      </property>
      <property name="_pendingScroll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.domNode">
    <properties>
      <property name="tabIndex" scope="instance" type="String"/>
      <property name="onReveal" scope="instance" type="Object"/>
      <property name="onSizeChange" scope="instance" type="Object"/>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.domNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.scroller">
    <properties>
      <property name="grid" scope="instance" type="Object"/>
      <property name="renderRow" scope="instance" type="Object"/>
      <property name="removeRow" scope="instance" type="Object"/>
      <property name="windowHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.views">
    <properties>
      <property name="createView" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.layout">
    <properties>
      <property name="structure" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.messagesNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.messagesNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.viewsHeaderNode"/>
  <class type="dojox.grid._Grid.viewsHeaderNode.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.viewsNode.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Grid.invalidated">
    <properties>
      <property name="all" scope="instance" type="Object"/>
      <property name="rowCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.__CellDef">
    <methods>
      <method name="get" scope="instance"/>
      <method name="formatter" scope="instance"/>
    </methods>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>The text to use in the header of the grid for this cell.</description>
      </property>
      <property name="value" scope="instance" type="String">
        <description>If &amp;quot;get&amp;quot; is not specified, this is used as the data for the cell.
	defaultValue: String?
	If &amp;quot;get&amp;quot; and &amp;quot;value&amp;quot; aren't specified or if &amp;quot;get&amp;quot; returns an undefined
	value, this is used as the data for the cell.  &amp;quot;formatter&amp;quot; is not run
	on this if &amp;quot;get&amp;quot; returns an undefined value.</description>
      </property>
      <property name="type" scope="instance" type="dojox.grid.cells._Base|Function">
        <description>TODO</description>
      </property>
      <property name="editable" scope="instance" type="Boolean">
        <description>Whether this cell should be editable or not.</description>
      </property>
      <property name="hidden" scope="instance" type="Boolean">
        <description>If true, the cell will not be displayed.
	noresize: Boolean?
	If true, the cell will not be able to be resized.</description>
      </property>
      <property name="width" scope="instance" type="Integer|String">
        <description>A CSS size.  If it's an Integer, the width will be in em's.</description>
      </property>
      <property name="colSpan" scope="instance" type="Integer">
        <description>How many columns to span this cell.  Will not work in the first
	sub-row of cells.</description>
      </property>
      <property name="rowSpan" scope="instance" type="Integer">
        <description>How many sub-rows to span this cell.</description>
      </property>
      <property name="styles" scope="instance" type="String">
        <description>A string of styles to apply to both the header cell and main
	grid cells.  Must end in a ';'.</description>
      </property>
      <property name="headerStyles" scope="instance" type="String">
        <description>A string of styles to apply to just the header cell.  Must end
	in a ';'</description>
      </property>
      <property name="cellStyles" scope="instance" type="String">
        <description>A string of styles to apply to just the main grid cells.  Must
	end in a ';'</description>
      </property>
      <property name="classes" scope="instance" type="String">
        <description>A space separated list of classes to apply to both the header
	cell and the main grid cells.</description>
      </property>
      <property name="headerClasses" scope="instance" type="String">
        <description>A space separated list of classes to apply to just the header
	cell.</description>
      </property>
      <property name="cellClasses" scope="instance" type="String">
        <description>A space separated list of classes to apply to just the main
	grid cells.</description>
      </property>
      <property name="attrs" scope="instance" type="String">
        <description>A space separated string of attribute='value' pairs to add to
	the header cell element and main grid cell elements.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.__ViewDef">
    <methods>
      <method name="onBeforeRow" scope="instance"/>
      <method name="onAfterRow" scope="instance"/>
    </methods>
    <properties>
      <property name="noscroll" scope="instance" type="Boolean">
        <description>If true, no scrollbars will be rendered without scrollbars.</description>
      </property>
      <property name="width" scope="instance" type="Integer|String">
        <description>A CSS size.  If it's an Integer, the width will be in em's. If
	&amp;quot;noscroll&amp;quot; is true, this value is ignored.</description>
      </property>
      <property name="cells" scope="instance" type="Array&lt;dojox.grid.__CellDef&gt;|Array&lt;Array[dojox.grid.__CellDef&gt;]">
        <description>The structure of the cells within this grid.</description>
      </property>
      <property name="type" scope="instance" type="String">
        <description>A string containing the constructor of a subclass of
	dojox.grid._View.  If this is not specified, dojox.grid._View
	is used.</description>
      </property>
      <property name="defaultCell" scope="instance" type="dojox.grid.__CellDef">
        <description>A cell definition with default values for all cells in this view.  If
	a property is defined in a cell definition in the &amp;quot;cells&amp;quot; array and
	this property, the cell definition's property will override this
	property's property.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid._Layout">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveColumn" scope="instance">
        <parameters>
          <parameter name="sourceViewIndex" type="Object" usage="required"/>
          <parameter name="destViewIndex" type="Object" usage="required"/>
          <parameter name="cellIndex" type="Object" usage="required"/>
          <parameter name="targetIndex" type="Object" usage="required"/>
          <parameter name="before" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColumnVisibility" scope="instance">
        <parameters>
          <parameter name="columnIndex" type="Object" usage="required"/>
          <parameter name="visible" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRowDef" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRowsDef" scope="instance">
        <parameters>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addViewDef" scope="instance">
        <parameters>
          <parameter name="inDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="cells" scope="instance" type="Array"/>
      <property name="structure" scope="instance" type="Array"/>
      <property name="defaultWidth" scope="instance" type="String"/>
      <property name="_defaultCellProps" scope="instance" type="Object"/>
      <property name="fieldIndex" scope="instance" type="Number"/>
      <property name="cellCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Layout.grid">
    <properties>
      <property name="sortInfo" scope="instance" type="Object"/>
      <property name="rowSelector" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._RadioSelector" superclass="dojox.grid._Selector">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="renderHeader" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._Selector" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputType" scope="instance" type="String"/>
      <property name="selectionMode" scope="instance" type="String"/>
      <property name="_contentBuilderClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._RowManager">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="prepareStylingRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyStyles" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOverRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isOver" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="linesToEms" scope="instance" type="Number"/>
      <property name="overRow" scope="instance" type="Number"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._RowSelector" superclass="dojox.grid._View">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="getWidth" scope="instance"/>
      <method name="buildRowContent" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderHeader" scope="instance"/>
      <method name="updateRow" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="adaptWidth" scope="instance"/>
      <method name="doStyleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseover" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseout" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._View" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultWidth" scope="instance" type="String"/>
      <property name="noscroll" scope="instance" type="Object"/>
      <property name="padBorderWidth" scope="instance" type="Number"/>
      <property name="contentWidth" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid._RowSelector.scrollboxNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._RowSelector.headerNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inContentNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="inRowCount" type="Object" usage="required"/>
          <parameter name="inKeepRows" type="Object" usage="required"/>
          <parameter name="inRowsPerPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPageCount" scope="instance">
        <parameters>
          <parameter name="rowCount" type="Object" usage="required"/>
          <parameter name="rowsPerPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="setKeepInfo" scope="instance">
        <parameters>
          <parameter name="inKeepRows" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setContentNodes" scope="instance">
        <parameters>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultNodes" scope="instance"/>
      <method name="invalidate" scope="instance"/>
      <method name="updateRowCount" scope="instance">
        <parameters>
          <parameter name="inRowCount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pageExists" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="measurePage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="positionPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="repositionPages" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="installPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="preparePage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inReuseNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removePage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pacify" scope="instance">
        <parameters>
          <parameter name="inShouldPacify" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setPacifying" scope="instance">
        <parameters>
          <parameter name="inPacifying" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startPacify" scope="instance"/>
      <method name="doPacify" scope="instance"/>
      <method name="endPacify" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="calcLastPageHeight" scope="instance"/>
      <method name="updateContentHeight" scope="instance">
        <parameters>
          <parameter name="inDh" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updatePageHeight" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="fromBuild" type="Object" usage="required"/>
          <parameter name="fromAsynRendering" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowHeightChanged" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="fromAsynRendering" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidateNodes" scope="instance"/>
      <method name="createPageNode" scope="instance"/>
      <method name="getPageHeight" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pushPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popPage" scope="instance"/>
      <method name="findPage" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inReuseNode" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="needPage" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onscroll" scope="instance"/>
      <method name="scroll" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getScrollBottom" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processNodeEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inPageNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultPageNode" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="positionPageNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPageNodePosition" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidatePageNode" scope="instance">
        <parameters>
          <parameter name="inPageIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPageRow" scope="instance">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastPageRow" scope="instance">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstVisibleRow" scope="instance">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
          <parameter name="inPageTop" type="Object" usage="required"/>
          <parameter name="inScrollTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getLastVisibleRow" scope="instance">
        <parameters>
          <parameter name="inPage" type="Object" usage="required"/>
          <parameter name="inBottom" type="Object" usage="required"/>
          <parameter name="inScrollBottom" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findTopRow" scope="instance">
        <parameters>
          <parameter name="inScrollTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findScrollTop" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="rowCount" scope="instance" type="Number"/>
      <property name="defaultRowHeight" scope="instance" type="Number"/>
      <property name="keepRows" scope="instance" type="Number"/>
      <property name="contentNode" scope="instance" type="Object"/>
      <property name="defaultPageHeight" scope="instance" type="Number"/>
      <property name="keepPages" scope="instance" type="Number"/>
      <property name="pageCount" scope="instance" type="Object"/>
      <property name="windowHeight" scope="instance" type="Number"/>
      <property name="firstVisibleRow" scope="instance" type="Object"/>
      <property name="lastVisibleRow" scope="instance" type="Object"/>
      <property name="averageRowHeight" scope="instance" type="Number"/>
      <property name="page" scope="instance" type="Number"/>
      <property name="pageTop" scope="instance" type="Number"/>
      <property name="rowsPerPage" scope="instance" type="Object"/>
      <property name="contentNodes" scope="instance" type="Object"/>
      <property name="colCount" scope="instance" type="Object"/>
      <property name="pageNodes" scope="instance-prototype" type="Array"/>
      <property name="_invalidating" scope="instance" type="bool"/>
      <property name="pageHeights" scope="instance-prototype" type="Array"/>
      <property name="height" scope="instance" type="Number"/>
      <property name="pacifying" scope="instance" type="bool"/>
      <property name="pacifyTicks" scope="instance" type="Number"/>
      <property name="startPacifyTicks" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Number"/>
      <property name="dummy" scope="instance" type="Number"/>
      <property name="stack" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller.scrollboxNode">
    <properties>
      <property name="scrollTop" scope="instance" type="Number"/>
      <property name="onscroll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller.grid.viewsNode"/>
  <class type="dojox.grid._Scroller.grid.viewsNode.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Scroller.grid">
    <properties>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder" superclass="dojox.grid._HeaderBuilder.prototype">
    <methods/>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder.generateHtml">
    <methods/>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder.generateHtml.view">
    <properties>
      <property name="contentWidth" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder.doclick">
    <methods/>
  </class>
  <class type="dojox.grid._InputSelectorHeaderBuilder.doclick.view">
    <properties>
      <property name="_selectionChanging" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid._SelectorContentBuilder" superclass="dojox.grid._ContentBuilder.prototype">
    <methods>
      <method name="getCellContent" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findTarget" scope="instance"/>
      <method name="domouseover" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseout" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid._SelectorContentBuilder.generateHtml">
    <methods/>
  </class>
  <class type="dojox.grid._SelectorContentBuilder.generateHtml.view">
    <properties>
      <property name="contentWidth" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid._SelectorContentBuilder.doclick">
    <methods/>
  </class>
  <class type="dojox.grid._SelectorContentBuilder.doclick.view.grid.selection">
    <properties>
      <property name="mode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._InputSelectorContentBuilder" superclass="dojox.grid._SelectorContentBuilder.prototype">
    <methods/>
  </class>
  <class type="dojox.grid._InputSelectorContentBuilder.getCellContent">
    <methods/>
    <properties>
      <property name="view" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Selector" superclass="dojox.grid._View">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="getWidth" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adaptWidth" scope="instance"/>
      <method name="doStyleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeselected" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._View" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputType" scope="instance" type="String"/>
      <property name="selectionMode" scope="instance" type="String"/>
      <property name="defaultWidth" scope="instance" type="String"/>
      <property name="noscroll" scope="instance" type="Object"/>
      <property name="padBorderWidth" scope="instance" type="Number"/>
      <property name="_contentBuilderClass" scope="instance" type="Object"/>
      <property name="contentWidth" scope="instance" type="Number"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="header" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Selector.grid.selection">
    <properties>
      <property name="mode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Selector.scrollboxNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._RadioSelector.headerNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._CheckBoxSelector.headerNode.style">
    <properties>
      <property name="visibility" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._CheckBoxSelector.grid">
    <properties>
      <property name="rowCount" scope="instance" type="Object"/>
      <property name="allItemsSelected" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid._Selector.headerNodeContainer.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._Expando" superclass="dijit._Widget">
    <methods>
      <method name="_toggleRows" scope="instance">
        <parameters>
          <parameter name="toggleClass" type="Object" usage="required"/>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setOpen" scope="instance">
        <parameters>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setOpen" scope="instance">
        <parameters>
          <parameter name="open" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onToggle" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRowNode" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
          <parameter name="rowNode" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="open" scope="instance" type="Object"/>
      <property name="toggleClass" scope="instance" type="String"/>
      <property name="itemId" scope="instance" type="String"/>
      <property name="cellIdx" scope="instance" type="Number"/>
      <property name="rowNode" scope="instance" type="Object"/>
      <property name="rowIdx" scope="instance" type="Number"/>
      <property name="expandoCell" scope="instance" type="Object"/>
      <property name="level" scope="instance" type="Number"/>
      <property name="templatePath" scope="instance" type="Object"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_tableRow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Expando.view"/>
  <class type="dojox.grid._Expando.view.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="treeModel" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._Expando.expandoInner">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeContentBuilder" superclass="dojox.grid._ContentBuilder">
    <methods>
      <method name="generateHtml" scope="instance">
        <parameters>
          <parameter name="inDataIndex" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="findTarget" scope="instance">
        <parameters>
          <parameter name="inSource" type="Object" usage="required"/>
          <parameter name="inTag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="instance">
        <parameters>
          <parameter name="inRowNode" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decorateEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._ContentBuilder" scope="instance"/>
    </mixins>
    <properties>
      <property name="view" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeContentBuilder.view.structure.cells">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeContentBuilder.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._TreeView" superclass="dojox.grid._View">
    <methods>
      <method name="_onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_cleanupExpandoCache" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="identity" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onBeforeRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._View" scope="instance"/>
    </mixins>
    <properties>
      <property name="_contentBuilderClass" scope="instance" type="Object"/>
      <property name="_expandos" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="setStructure" scope="instance">
        <parameters>
          <parameter name="inStructure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBeforeRow" scope="instance"/>
      <method name="_onAfterRow" scope="instance"/>
      <method name="_cleanupRowWidgets" scope="instance">
        <parameters>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="cells" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="testFlexCells" scope="instance"/>
      <method name="updateStructure" scope="instance"/>
      <method name="getScrollbarWidth" scope="instance">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getColumnsWidth" scope="instance">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="setColumnsWidth" scope="instance">
        <parameters>
          <parameter name="width" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getContentWidth" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="render" scope="instance"/>
      <method name="_hide" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDndDropBefore" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderHeader" scope="instance"/>
      <method name="_getHeaderContent" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="hasHScrollbar" scope="instance">
        <parameters>
          <parameter name="reset" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasVScrollbar" scope="instance">
        <parameters>
          <parameter name="reset" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="convertColPctToFixed" scope="instance"/>
      <method name="adaptHeight" scope="instance">
        <parameters>
          <parameter name="minusScroll" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adaptWidth" scope="instance"/>
      <method name="setSize" scope="instance">
        <parameters>
          <parameter name="w" type="Object" usage="required"/>
          <parameter name="h" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRowContent" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getHeaderCellNode" scope="instance">
        <parameters>
          <parameter name="inCellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doStyleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doscroll" scope="instance">
        <parameters>
          <parameter name="inEvent" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doContentEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doHeaderEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchContentEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchHeaderEvent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColWidth" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="update" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultWidth" scope="instance" type="String">
        <description>Default width of the view</description>
      </property>
      <property name="viewWidth" scope="instance" type="String">
        <description>Width for the view, in valid css unit</description>
      </property>
      <property name="templatePath" scope="instance" type="Object"/>
      <property name="themeable" scope="instance" type="bool"/>
      <property name="classTag" scope="instance" type="String"/>
      <property name="marginBottom" scope="instance" type="Number"/>
      <property name="rowPad" scope="instance" type="Number"/>
      <property name="_togglingColumn" scope="instance" type="int">
        <description>Width of the column being toggled (-1 for none)</description>
      </property>
      <property name="_headerBuilderClass" scope="instance" type="Object">
        <description>The class to use for our header builder</description>
      </property>
      <property name="_contentBuilderClass" scope="instance" type="Object">
        <description>The class to use for our content builder</description>
      </property>
      <property name="rowNodes" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="header" scope="instance" type="Object"/>
      <property name="structure" scope="instance" type="Object"/>
      <property name="noscroll" scope="instance" type="Object"/>
      <property name="simpleStructure" scope="instance" type="Object"/>
      <property name="flexCells" scope="instance" type="Object"/>
      <property name="bottomMarker" scope="instance" type="Object"/>
      <property name="topMarker" scope="instance" type="Object"/>
      <property name="arrowDim" scope="instance" type="Object"/>
      <property name="_source_conn" scope="instance" type="Object"/>
      <property name="_source_sub" scope="instance" type="Object"/>
      <property name="_removingColumn" scope="instance" type="bool"/>
      <property name="index" scope="instance" type="Object"/>
      <property name="contentWidth" scope="instance" type="Object"/>
      <property name="_hasHScroll" scope="instance" type="bool"/>
      <property name="_hasVScroll" scope="instance" type="bool"/>
      <property name="contentNode" scope="instance" type="Object"/>
      <property name="lastTop" scope="instance" type="Number"/>
      <property name="firstScroll" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerNodeContainer.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._View.scrollboxNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerContentNode.firstChild.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._View.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.source">
    <properties>
      <property name="_targetNode" scope="instance" type="Object"/>
      <property name="_beforeTarget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.grid.views">
    <properties>
      <property name="views" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.grid">
    <properties>
      <property name="initialWidth" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerContentNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.domNode">
    <properties>
      <property name="clientHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.contentNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.domNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.headerNode.style">
    <properties>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._View.scrollboxNode">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._GridAvatar" superclass="dojo.dnd.Avatar">
    <methods>
      <method name="construct" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Avatar" scope="instance"/>
    </mixins>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="oldOffsetY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._GridAvatar.manager">
    <properties>
      <property name="source" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._ViewManager">
    <description>Grid creates views automatically based on grid's layout structure.
	Users should typically not need to access individual views or the views collection directly.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="addView" scope="instance">
        <parameters>
          <parameter name="inView" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyViews" scope="instance"/>
      <method name="getContentNodes" scope="instance"/>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="inCallback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEach" scope="instance">
        <parameters>
          <parameter name="inMethod" type="Object" usage="required"/>
          <parameter name="inArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="normalizeHeaderNodeHeight" scope="instance"/>
      <method name="normalizeRowNodeHeights" scope="instance">
        <parameters>
          <parameter name="inRowNodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resetHeaderNodeHeight" scope="instance"/>
      <method name="renormalizeRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getViewWidth" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="measureHeader" scope="instance"/>
      <method name="measureContent" scope="instance"/>
      <method name="findClient" scope="instance">
        <parameters>
          <parameter name="inAutoWidth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="arrange" scope="instance">
        <parameters>
          <parameter name="l" type="Object" usage="required"/>
          <parameter name="w" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNodes" type="Object" usage="required"/>
          <parameter name="skipRenorm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="skipRenorm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="instance">
        <parameters>
          <parameter name="inTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstScrollingView" scope="instance"/>
    </methods>
    <properties>
      <property name="defaultWidth" scope="instance" type="Number"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._ViewManager.views">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid._DeferredTextWidget" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="deferred" scope="instance" type="Object"/>
      <property name="_destroyOnRemove" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells">
    <properties>
      <property name="_base" scope="instance" type="Object"/>
      <property name="dijit" scope="instance" type="Object"/>
      <property name="tree" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inProps" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_defaultFormat" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="callArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inItem" type="Object" usage="required"/>
        </parameters>
        <return-description>html for a given grid cell</return-description>
      </method>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="anything" usage="required">
            <description>cell data to edit</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>string of html to place in grid cell</return-description>
      </method>
      <method name="getNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>dom node for a given grid cell</return-description>
      </method>
      <method name="getHeaderNode" scope="instance"/>
      <method name="getEditNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="canResize" scope="instance"/>
      <method name="isFlex" scope="instance"/>
      <method name="applyEdit" scope="instance">
        <parameters>
          <parameter name="inValue" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelEdit" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onEditBlur" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerOnBlur" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="needFormatNode" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelFormatNode" scope="instance"/>
      <method name="_formatNode" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="dom" usage="required">
            <description>node
	dom node for the editor</description>
          </parameter>
          <parameter name="inDatum" type="anything" usage="required">
            <description>cell data to edit</description>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="dispatchEvent" scope="instance">
        <parameters>
          <parameter name="m" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
        <return-description>value of editor</return-description>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inValue" type="anything" usage="required">
            <description>value of editor</description>
          </parameter>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
          <parameter name="inNode" type="dom" usage="required">
            <description>node
	editor node</description>
          </parameter>
        </parameters>
      </method>
      <method name="save" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="restore" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="_finish" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="cancel" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <description>grid row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cellDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="styles" scope="instance" type="String"/>
      <property name="classes" scope="instance" type="String"/>
      <property name="editable" scope="instance" type="bool"/>
      <property name="alwaysEditing" scope="instance" type="bool"/>
      <property name="formatter" scope="instance" type="Object"/>
      <property name="defaultValue" scope="instance" type="String"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="hidden" scope="instance" type="bool"/>
      <property name="noresize" scope="instance" type="bool"/>
      <property name="draggable" scope="instance-prototype" type="Object"/>
      <property name="_valueProp" scope="instance" type="String"/>
      <property name="_formatPending" scope="instance" type="bool"/>
      <property name="unitWidth" scope="instance" type="Object"/>
      <property name="_props" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Base.grid">
    <properties>
      <property name="formatterScope" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Base.grid.edit">
    <properties>
      <property name="info" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.Cell" superclass="dojox.grid.cells._Base">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cellDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="keyFilter" scope="instance-prototype" type="RegExp">
        <description>optional regex for disallowing keypresses</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.cells.RowIndex" superclass="dojox.grid.cells.Cell">
    <methods>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cellDef" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells.Cell" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="editable" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.Select" superclass="dojox.grid.cells.Cell">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells.Cell" scope="instance"/>
    </mixins>
    <properties>
      <property name="options" scope="instance" type="Array">
        <description>text of each item</description>
      </property>
      <property name="values" scope="instance-prototype" type="Array">
        <description>value for each item</description>
      </property>
      <property name="returnIndex" scope="instance" type="Integer">
        <description>editor returns only the index of the selected option and not the value</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.cells.AlwaysEdit" superclass="dojox.grid.cells.Cell">
    <methods>
      <method name="_formatNode" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyStaticValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells.Cell" scope="instance"/>
    </mixins>
    <properties>
      <property name="alwaysEditing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.AlwaysEdit.grid">
    <properties>
      <property name="edit" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.Bool" superclass="dojox.grid.cells.AlwaysEdit">
    <methods>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells.AlwaysEdit" scope="instance"/>
    </mixins>
    <properties>
      <property name="_valueProp" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.cells._Widget" superclass="dojox.grid.cells._Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatEditing" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidgetProps" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="attachWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sizeWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="instance" type="Object"/>
      <property name="widget" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.ComboBox" superclass="dojox.grid.cells._Widget">
    <methods>
      <method name="getWidgetProps" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="instance" type="Object"/>
      <property name="widget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.DateTextBox" superclass="dojox.grid.cells._Widget">
    <methods>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWidgetProps" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.CheckBox" superclass="dojox.grid.cells._Widget">
    <methods>
      <method name="getValue" scope="instance"/>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sizeWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.Editor" superclass="dojox.grid.cells._Widget">
    <methods>
      <method name="getWidgetProps" scope="instance">
        <parameters>
          <parameter name="inDatum" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createWidget" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="instance">
        <parameters>
          <parameter name="inNode" type="Object" usage="required"/>
          <parameter name="inDatum" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="populateEditor" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
      <property name="widget" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatAggregate">
    <methods/>
    <properties>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.formatAggregate.grid.edit">
    <properties>
      <property name="info" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.getOpenState">
    <methods/>
    <properties>
      <property name="openStates" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.TreeCell.getOpenState.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._Events">
    <description>Methods are copied or replaced for overwriting, this might be refined once
	an overall plugin architecture is set up for DataGrid.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dokeyup" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Un-decorated event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domouseup" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="domousedown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCellMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object that contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCellDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectedRegionContextMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid and info of selected
	regions(selection type - row|column, selected index - [...])</description>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowSelectorMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowSelectorMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUpRow" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRowMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_events" scope="instance-prototype" type="Object">
        <description>Method map cached from dojox.grid._Events().</description>
      </property>
      <property name="headerCellActiveClass" scope="instance" type="String">
        <description>css class to apply to grid header cells when activated(mouse down)</description>
      </property>
      <property name="cellActiveClass" scope="instance" type="String">
        <description>css class to apply to grid content cells when activated(mouse down)</description>
      </property>
      <property name="rowActiveClass" scope="instance" type="String">
        <description>css class to apply to grid rows when activated(mouse down)
	TODO - make the following events more reasonalble - e.g. more accurate conditions
	events for row selectors</description>
      </property>
      <property name="focus" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._Events._click">
    <properties>
      <property name="0" scope="instance" type="Object"/>
      <property name="1" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusArea">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
          <parameter name="focusManager" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="rowStep" type="Object" usage="required"/>
          <parameter name="colStep" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="funcName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="keydown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="keyup" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="contentMouseEventPlanner" scope="instance"/>
      <method name="headerMouseEventPlanner" scope="instance"/>
    </methods>
    <properties>
      <property name="name" scope="instance" type="string">
        <description>Name of this area.</description>
      </property>
      <property name="onFocus" scope="instance" type="Function(event)">
        <description>step)
	Called when this area logically gets focus.
	event: Event object
	May be unavailable, should check before use.
	step: Integer
	The distance in the tab sequence from last focused area to this area.</description>
      </property>
      <property name="onBlur" scope="instance" type="Function(event)">
        <description>step)
	Called when this area logically loses focus.
	event: Event object
	May be unavailable, should check before use.
	step: Integer
	The distance in the tab sequence from this area to the area to focus.</description>
      </property>
      <property name="onMove" scope="instance" type="Function(rowStep)">
        <description>colStep, event)
	Called when focus is moving around within this area.
	rowStep: Integer
	colStep: Integer
	event: Event object
	May be unavailable, should check before use.</description>
      </property>
      <property name="onKey" scope="instance" type="Function(event)">
        <description>isBubble)
	Called when some key is pressed when focus is logically in this area.
	event: Event object
	isBubble: Boolean
	Whether is in bubble stage (true) or catch stage (false).</description>
      </property>
      <property name="getRegions" scope="instance" type="Function())">
        <description>Define the small regions (dom nodes) in this area.</description>
      </property>
      <property name="onRegionFocus" scope="instance" type="Function(event))">
        <description>Connected to the onfocus event of the defined regions (if any)</description>
      </property>
      <property name="onRegionBlur" scope="instance" type="Function(event))">
        <description>Connected to the onblur event of the defined regions (if any)</description>
      </property>
      <property name="_fm" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusArea._evtStack">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusManager" superclass="dojox.grid._FocusManager">
    <methods>
      <method name="_stopEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="addArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getArea" scope="instance">
        <parameters>
          <parameter name="areaName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_bindAreaEvents" scope="instance"/>
      <method name="removeArea" scope="instance">
        <parameters>
          <parameter name="areaName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="currentArea" scope="instance">
        <parameters>
          <parameter name="areaName" type="String" usage="required"/>
          <parameter name="toBlurOld" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="placeArea" scope="instance">
        <examples>
          <example>placeArea("myarea","before"|"after",...)
	placeArea("myarea","below"|"above",...)</example>
        </examples>
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="pos" type="Object" usage="required"/>
          <parameter name="otherAreaName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ignoreArea" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusArea" scope="instance">
        <parameters>
          <parameter name="areaId" type="int|string|areaObj" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tab" scope="instance">
        <parameters>
          <parameter name="step" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseEvent" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="contentMouseEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="headerMouseEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initFocusView" scope="instance"/>
      <method name="isNavHeader" scope="instance"/>
      <method name="previousKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusCell" scope="instance">
        <parameters>
          <parameter name="inCell" type="Object" usage="required"/>
          <parameter name="inRowIndex" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="doFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doBlur" scope="instance"/>
      <method name="doLastNodeFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_delayedHeaderFocus" scope="instance"/>
      <method name="_delayedCellFocus" scope="instance"/>
      <method name="_changeMenuBindNode" scope="instance">
        <parameters>
          <parameter name="oldBindNode" type="Object" usage="required"/>
          <parameter name="newBindNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="focusHeader" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurHeader" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_navHeader" scope="instance">
        <parameters>
          <parameter name="rowStep" type="Object" usage="required"/>
          <parameter name="colStep" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHeaderKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setActiveColHeader" scope="instance"/>
      <method name="findAndFocusGridCell" scope="instance"/>
      <method name="_focusContent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurContent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_navContent" scope="instance">
        <parameters>
          <parameter name="rowStep" type="Object" usage="required"/>
          <parameter name="colStep" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="move" scope="instance">
        <parameters>
          <parameter name="inRowDelta" type="Object" usage="required"/>
          <parameter name="inColDelta" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onContentKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_focusEditableCell" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_applyEditableCell" scope="instance"/>
      <method name="_blurEditableCell" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initNavigatableElems" scope="instance"/>
      <method name="_onEditableCellKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onEditableCellMouseEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid._FocusManager" scope="instance"/>
    </mixins>
    <properties>
      <property name="_areas" scope="instance-prototype" type="Object"/>
      <property name="_currentAreaIdx" scope="instance-prototype" type="Number"/>
      <property name="tabbingOut" scope="instance" type="bool"/>
      <property name="_areaQueue" scope="instance-prototype" type="Array"/>
      <property name="_gridBlured" scope="instance-prototype" type="Object"/>
      <property name="focusView" scope="instance" type="Object"/>
      <property name="cell" scope="instance" type="Object"/>
      <property name="rowIndex" scope="instance" type="Object"/>
      <property name="_contextMenuBindNode" scope="instance" type="Object"/>
      <property name="_colHeadNode" scope="instance" type="Object"/>
      <property name="_colHeadFocusIdx" scope="instance" type="Object"/>
      <property name="_blurFromEditableCell" scope="instance" type="Object"/>
      <property name="_isNavigating" scope="instance" type="Object"/>
      <property name="_contentMouseEventHandlers" scope="instance" type="Array"/>
      <property name="_headerMouseEventHandlers" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusManager.grid">
    <properties>
      <property name="headerMenu" scope="instance" type="Object"/>
      <property name="scroller" scope="instance" type="Object"/>
      <property name="edit" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusManager._navElems">
    <properties>
      <property name="lowest" scope="instance" type="Object"/>
      <property name="last" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._FocusManager.grid.layout">
    <properties>
      <property name="cellCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._Plugin">
    <description>Provides common plugin functionality and basic life cycle management.
	Each concrete plugin must have a name field and is responsible for registering itself to the global plugin registry
	e.g. for dnd plugin:
			dojox.grid.EnhancedGrid.registerPlugin("dnd" /*plugin name*/,
													dojox.grid.enhanced.plugins.DnD /*full class name of a plugin
													{"preInit": false, "dependency": ["nestedSorting"]} /*properties*/);
	[Keywords] of plugin properties(case sensitive)
	- "preInit": boolean, whether a plugin should be created before EnhancedGrid.postCreate(),
	false by default(plugins are created after EnhancedGrid.postCreate()).
	- "dependency": array or string, plugin(s) indicated by "dependency" will be created before the current one.
	Note: recursive cycle dependencies are not supported e.g. following dependency is invalid:
	pluginA -&gt; pluginB -&gt; pluginA</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
          <parameter name="option" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="instance"/>
      <method name="onPreInit" scope="instance"/>
      <method name="onPostInit" scope="instance"/>
      <method name="onStartUp" scope="instance"/>
      <method name="connect" scope="instance">
        <examples>
          <example>	var plugin = new dojox.grid.enhanced._Plugin(grid,"myPlugin",{...});
		// when foo.bar() is called, call the listener in the scope of plugin
		plugin.connect(foo, "bar", function(){
			console.debug(this.xxx());//"this" - plugin scope
		});</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <examples>
          <example>	var plugin = new dojox.grid.enhanced._Plugin(grid,"myPlugin",{...});
		// when /my/topic is published, call the subscriber in the scope of plugin
		// with passed parameter - "v"
		plugin.subscribe("/my/topic", function(v){
			console.debug(this.xxx(v));//"this" - plugin scope
		});</example>
        </examples>
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>Plugin name, e.g. 'nestedSorting', 'dnd'...</description>
      </property>
      <property name="grid" scope="instance-prototype" type="Object">
        <description>Grid that the plugin belongs to</description>
      </property>
      <property name="option" scope="instance-prototype" type="Object">
        <description>Plugin properties - leveraged with default and user specified properties.
	e.g. for dnd plugin, it may look like {&amp;quot;class&amp;quot;: dojox.grid.enhanced.plugins.DnD, &amp;quot;dependency&amp;quot;: [&amp;quot;nestedSorting&amp;quot;], ...}</description>
      </property>
      <property name="_connects" scope="instance-prototype" type="Array">
        <description>List of all connections.</description>
      </property>
      <property name="_subscribes" scope="instance-prototype" type="Array">
        <description>List of all subscribes.</description>
      </property>
      <property name="privates" scope="instance-prototype" type="Object">
        <description>Private properties/methods shouldn't be mixin-ed anytime.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._PluginManager">
    <description>Plugin manager is responsible for
	1. Loading required plugins
	2. Handling collaboration and dependencies among plugins
	Some plugin dependencies:
	- "columnReordering" attribute won't work when either DnD or Indirect Selections plugin is on.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="inGrid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="preInit" scope="instance"/>
      <method name="postInit" scope="instance"/>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="func" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parseProps" scope="instance">
        <parameters>
          <parameter name="plugins" type="Object" usage="required">
            <description>Plugin properties defined by user</description>
          </parameter>
        </parameters>
      </method>
      <method name="_normalize" scope="instance">
        <parameters>
          <parameter name="p" type="String" usage="required">
            <description>Plugin name</description>
          </parameter>
          <parameter name="plugins" type="Object" usage="required">
            <description>Plugin properties set by user</description>
          </parameter>
          <parameter name="registry" type="Object" usage="required">
            <description>The global plugin registry</description>
          </parameter>
          <parameter name="loading" type="Object" usage="required">
            <description>Map for checking process state</description>
          </parameter>
        </parameters>
      </method>
      <method name="_init" scope="instance">
        <parameters>
          <parameter name="pre" type="Boolean" usage="required">
            <description>True - preInit | False - postInit(by default)</description>
          </parameter>
        </parameters>
      </method>
      <method name="loadPlugin" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Plugin name
	return: Object
	The newly loaded plugin</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="return if no plugin option"/>
          <return-type type="return if plugin(&quot;name&quot;) already existed"/>
        </return-types>
      </method>
      <method name="_initView" scope="instance">
        <parameters>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pluginExisted" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Plugin name
	return: Boolean
	True - existed | False - not existed</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPlugin" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>Plugin name
	return: Object
	Plugin instance</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPluginClazz" scope="instance">
        <parameters>
          <parameter name="clazz" type="class" usage="required">
            <description>| String
	Plugin class</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="return if it's already a clazz"/>
        </return-types>
      </method>
      <method name="isFixedCell" scope="instance">
        <parameters>
          <parameter name="cell" type="Object" usage="required">
            <description>Target cell(column)
	return: Boolean
	True - fixed| False - not fixed</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="registerPlugin" scope="instance">
        <parameters>
          <parameter name="clazz" type="String" usage="required">
            <description>Full class name, e.g. &amp;quot;dojox.grid.enhanced.plugins.DnD&amp;quot;</description>
          </parameter>
          <parameter name="props" type="Object" usage="required">
            <description>- Optional
	Plugin properties e.g. {&amp;quot;dependency&amp;quot;: [&amp;quot;nestedSorting&amp;quot;], ...}</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_connects" scope="instance-prototype" type="Array">
        <description>Connection list</description>
      </property>
      <property name="_store" scope="instance" type="Object"/>
      <property name="registry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._PluginManager.grid">
    <properties>
      <property name="focus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._PluginManager.grid.edit">
    <methods>
      <method name="styleRow" scope="instance">
        <parameters>
          <parameter name="inRow" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced._PluginManager._options">
    <properties>
      <property name="columnReordering" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced._PluginManager._plugins">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins">
    <methods>
      <method name="wrap" scope="instance">
        <parameters>
          <parameter name="store" type="Read-store" usage="required">
            <description>The store to be wrapped.</description>
          </parameter>
          <parameter name="funcName" type="Object" usage="required"/>
          <parameter name="layer" type="_StoreLayer" usage="required">
            <description>The layer to be used
	returns
	The wrapped store, for nested use only.</description>
          </parameter>
          <parameter name="layerFuncName" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Read-store"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.AutoScroll" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initEvents" scope="instance"/>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_fireEvent" scope="instance">
        <parameters>
          <parameter name="eventName" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_manageAutoScroll" scope="instance">
        <parameters>
          <parameter name="toStop" type="Object" usage="required"/>
          <parameter name="isVertical" type="Object" usage="required"/>
          <parameter name="isForward" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScroll" scope="instance">
        <parameters>
          <parameter name="isVertical" type="Object" usage="required"/>
          <parameter name="isForward" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollColumn" scope="instance">
        <parameters>
          <parameter name="isForward" type="Object" usage="required"/>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>Plugin name</description>
      </property>
      <property name="autoScrollInterval" scope="instance-prototype" type="Integer">
        <description>The time interval (in miliseconds) between 2 scrolling.</description>
      </property>
      <property name="autoScrollMargin" scope="instance-prototype" type="Integer">
        <description>The width (in pixel) of the margin area where autoscroll can be triggered.</description>
      </property>
      <property name="_scrolling" scope="instance-prototype" type="bool"/>
      <property name="_handler" scope="instance" type="Object"/>
      <property name="readyForAutoScroll" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.AutoScroll.grid">
    <methods>
      <method name="onStartAutoScroll" scope="instance"/>
      <method name="onEndAutoScroll" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.CellMerge" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="mergeCells" scope="instance">
        <parameters>
          <parameter name="rowTester" type="Function(Integer))|Integer" usage="required">
            <description>If it's a function, it's a predicate to decide which rows are to be merged.
	It takes an integer (the row index), and should return true or false;</description>
          </parameter>
          <parameter name="startColumnIndex" type="Integer" usage="required">
            <description>The column index of the left most cell that shall be merged.</description>
          </parameter>
          <parameter name="endColumnIndex" type="Integer" usage="required">
            <description>The column index of the right most cell that shall be merged.</description>
          </parameter>
          <parameter name="majorColumnIndex" type="Integer" usage="optional">
            <description>The column index of the cell whose content should be used as the content of the merged cell.
	It must be larger than or equal to the startColumnIndex, and less than or equal to the endColumnIndex.
	If it is omitted, the content of the leading edge (left-most for ltr, right most for rtl) cell will be used.
	return: Object | null
	A handler for the merged cells created by a call of this function.
	This handler can be used later to unmerge cells using the function unmergeCells
	If the merge is not valid, returns null;</description>
          </parameter>
        </parameters>
      </method>
      <method name="unmergeCells" scope="instance">
        <parameters>
          <parameter name="mergeHandler" type="object" usage="required">
            <description>A handler for the merged cells created by a call of function mergeCells.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getMergedCells" scope="instance"/>
      <method name="getMergedCellsByRow" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setupConfig" scope="instance">
        <parameters>
          <parameter name="config" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initEvents" scope="instance"/>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_getWidth" scope="instance">
        <parameters>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onAfterRow" scope="instance">
        <parameters>
          <parameter name="viewIdx" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="subrows" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createRecord" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isValid" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateRows" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>Plugin name
	----------------Public----------------------------</description>
      </property>
      <property name="_merged" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.CellMerge.grid">
    <properties>
      <property name="mergeCells" scope="instance" type="Object"/>
      <property name="unmergeCells" scope="instance" type="Object"/>
      <property name="getMergedCells" scope="instance" type="Object"/>
      <property name="getMergedCellsByRow" scope="instance" type="Object"/>
      <property name="rowCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.CellMerge._records">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.CellMerge.grid.layout"/>
  <class type="dojox.grid.enhanced.plugins.CellMerge.grid.layout.cells">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Cookie" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_saveCookie" scope="instance"/>
      <method name="onPreInit" scope="instance"/>
      <method name="addCookieHandler" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>An object with the following structure:
		{
			name: &amp;quot;some-string&amp;quot;,
			onLoad: /* void */ function(/* object */partOfCookie, /* EDG */grid){...},
			onSave: /* object */ function(/* EDG */grid){...}
		}</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeCookie" scope="instance"/>
      <method name="setCookieEnabled" scope="instance">
        <parameters>
          <parameter name="cookieName" type="String" usage="optional">
            <description>Name of a cookie handler if provided, otherwise for all cookies.</description>
          </parameter>
          <parameter name="enabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getCookieEnabled" scope="instance">
        <parameters>
          <parameter name="cookieName" type="String" usage="optional">
            <description>Name of a cookie handler if provided, otherwise for all cookies.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>Plugin name</description>
      </property>
      <property name="_cookieEnabled" scope="instance" type="bool"/>
      <property name="_cookieHandlers" scope="instance-prototype" type="Array"/>
      <property name="_cookie" scope="instance" type="Object"/>
      <property name="_cookieStartedup" scope="instance" type="Object"/>
      <property name="cookieProps" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Cookie.grid">
    <properties>
      <property name="addCookieHandler" scope="instance" type="Object"/>
      <property name="removeCookie" scope="instance" type="Object"/>
      <property name="setCookieEnabled" scope="instance" type="Object"/>
      <property name="getCookieEnabled" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Dialog" superclass="dijit.Dialog">
    <methods>
      <method name="_position" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Dialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="refNode" scope="instance" type="Object"/>
      <property name="_relativePosition" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_mixinGrid" scope="instance"/>
      <method name="setupConfig" scope="instance">
        <examples>
          <example>The following code disables row DnD within grid,
	but still can drag rows out of grid or drag rows from other gird.
		setUpConfig({
			"row": {
				"within": false
			}
		});
	The opposite way is also okay:
		setUpConfig({
			"within": {
				"row": false
			}
		});
	And if you'd like to disable/enable a whole set, here's a shortcut:
		setUpConfig({
			"cell", true,
			"out": false
		});
	Because mode has higher priority than type, the following will disable row dnd within grid:
		setUpConfig({
			"within", {
				"row": false;
			},
			"row", {
				"within": true
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="config" type="Object" usage="required">
            <description>DnD configuration object.
	See the examples below.</description>
          </parameter>
        </parameters>
      </method>
      <method name="copyOnly" scope="instance">
        <parameters>
          <parameter name="isCopyOnly" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isOutOfGrid" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseMove" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseUp" scope="instance"/>
      <method name="_initEvents" scope="instance"/>
      <method name="_clear" scope="instance"/>
      <method name="_getDnDRegion" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_startDnd" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_endDnd" scope="instance">
        <parameters>
          <parameter name="destroySource" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createDnDUI" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="isMovingIn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyDnDUI" scope="instance">
        <parameters>
          <parameter name="isMovingOut" type="Object" usage="required"/>
          <parameter name="destroySource" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createSource" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_destroySource" scope="instance"/>
      <method name="_createMoveable" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyMoveable" scope="instance"/>
      <method name="_calcColTargetAnchorPos" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="containerPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcRowTargetAnchorPos" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="containerPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcCellTargetAnchorPos" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="containerPos" type="Object" usage="required"/>
          <parameter name="targetAnchor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_markTargetAnchor" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="instance"/>
      <method name="_getVisibleHeaders" scope="instance"/>
      <method name="_rearrange" scope="instance"/>
      <method name="onDraggingOver" scope="instance">
        <parameters>
          <parameter name="sourcePlugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mapRegion" scope="instance">
        <parameters>
          <parameter name="srcGrid" type="Object" usage="required"/>
          <parameter name="dndRegion" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDraggingOut" scope="instance">
        <parameters>
          <parameter name="sourcePlugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragIn" scope="instance">
        <parameters>
          <parameter name="sourcePlugin" type="Object" usage="required"/>
          <parameter name="isCopy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragOut" scope="instance">
        <parameters>
          <parameter name="isMove" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_canAccept" scope="instance">
        <parameters>
          <parameter name="sourcePlugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_allDnDItemsLoaded" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>plugin name;</description>
      </property>
      <property name="_targetAnchorBorderWidth" scope="instance" type="Number"/>
      <property name="_copyOnly" scope="instance-prototype" type="bool"/>
      <property name="_container" scope="instance-prototype" type="Object"/>
      <property name="rearranger" scope="instance-prototype" type="Object"/>
      <property name="_dnding" scope="instance" type="bool"/>
      <property name="_oldCursor" scope="instance" type="Object"/>
      <property name="_alreadyOut" scope="instance" type="bool"/>
      <property name="_moveEvent" scope="instance" type="Object"/>
      <property name="_target" scope="instance" type="Object"/>
      <property name="_targetAnchor" scope="instance" type="Object"/>
      <property name="_externalDnd" scope="instance" type="Object"/>
      <property name="_isSource" scope="instance" type="bool"/>
      <property name="_extDnding" scope="instance" type="bool"/>
      <property name="_markTagetAnchorHandler" scope="instance" type="Object"/>
      <property name="_elem" scope="instance" type="Object"/>
      <property name="_source" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._config"/>
  <class type="dojox.grid.enhanced.plugins.DnD._config.row">
    <properties>
      <property name="within" scope="instance" type="Object"/>
      <property name="in" scope="instance" type="Object"/>
      <property name="out" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._config.col">
    <properties>
      <property name="within" scope="instance" type="Object"/>
      <property name="in" scope="instance" type="Object"/>
      <property name="out" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._config.cell">
    <properties>
      <property name="within" scope="instance" type="Object"/>
      <property name="in" scope="instance" type="Object"/>
      <property name="out" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD.grid">
    <properties>
      <property name="setupDnDConfig" scope="instance" type="Object"/>
      <property name="dndCopyOnly" scope="instance" type="Object"/>
      <property name="rowCount" scope="instance" type="Object"/>
      <property name="_by_idx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD.selector">
    <properties>
      <property name="_selected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD.grid.layout"/>
  <class type="dojox.grid.enhanced.plugins.DnD.grid.layout.cells">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._dndRegion">
    <properties>
      <property name="handle" scope="instance" type="Object"/>
      <property name="type" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._dndRegion.selected">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD.grid.scroller">
    <properties>
      <property name="firstVisibleRow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._dndRegion.selected.0.min">
    <properties>
      <property name="row" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.DnD._dndRegion.selected.0.max">
    <properties>
      <property name="row" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDElement">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="dndPlugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="createDnDNodes" scope="instance">
        <parameters>
          <parameter name="dndRegion" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDnDNodes" scope="instance"/>
      <method name="destroyDnDNodes" scope="instance"/>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="nodeId" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="plugin" scope="instance-prototype" type="Object"/>
      <property name="node" scope="instance-prototype" type="Object"/>
      <property name="_items" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDSource" superclass="dojo.dnd.Source">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="param" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="nodeId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDraggingOver" scope="instance"/>
      <method name="onDraggingOut" scope="instance"/>
      <method name="onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
    <properties>
      <property name="accept" scope="instance" type="Array"/>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="dndElem" scope="instance-prototype" type="Object"/>
      <property name="dndPlugin" scope="instance-prototype" type="Object"/>
      <property name="sourcePlugin" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDAvatar" superclass="dojo.dnd.Avatar">
    <methods>
      <method name="construct" scope="instance"/>
      <method name="_getItemCount" scope="instance"/>
      <method name="_getGridDnDIconClass" scope="instance"/>
      <method name="_generateText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Avatar" scope="instance"/>
    </mixins>
    <properties>
      <property name="_itemType" scope="instance" type="Object"/>
      <property name="_itemCount" scope="instance" type="Object"/>
      <property name="isA11y" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDAvatar.manager">
    <properties>
      <property name="source" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridDnDAvatar.manager._dndPlugin.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Exporter" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="EnhancedGrid" usage="required">
            <description>The grid to plug in to.</description>
          </parameter>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixinGrid" scope="instance"/>
      <method name="setExportFormatter" scope="instance">
        <parameters>
          <parameter name="formatter" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="exportGrid" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required">
            <description>A registered export format name</description>
          </parameter>
          <parameter name="args" type="object" usage="optional">
            <description>includes:
	{
	fetchArgs: object?
	Any arguments for store.fetch
	writerArgs: object?
	Arguments for the given format writer
	}</description>
          </parameter>
          <parameter name="onExported" type="Function(string))" usage="required">
            <description>Call back function when export result is ready</description>
          </parameter>
        </parameters>
      </method>
      <method name="exportSelected" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required">
            <description>A registered export format name</description>
          </parameter>
          <parameter name="writerArgs" type="object" usage="optional">
            <description>Arguments for the given format writer</description>
          </parameter>
        </parameters>
        <return-description>string
	The exported string</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_buildRow" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
          <parameter name="writer" type="ExportWriter" usage="required"/>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="_goThroughGridData" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="writer" type="ExportWriter" usage="required"/>
        </parameters>
      </method>
      <method name="_isSpecialCol" scope="instance">
        <parameters>
          <parameter name="header_cell" type="dojox.grid.__CellDef" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getExportWriter" scope="instance">
        <parameters>
          <parameter name="fileType" type="string" usage="required"/>
          <parameter name="writerArgs" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="ExportWriter"/>
        </return-types>
      </method>
      <method name="registerWriter" scope="instance">
        <parameters>
          <parameter name="fileType" type="string" usage="required"/>
          <parameter name="writerClsName" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>Plugin name.</description>
      </property>
      <property name="formatter" scope="instance-prototype" type="Object"/>
      <property name="writerNames" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Exporter.grid">
    <properties>
      <property name="exportTo" scope="instance" type="Object"/>
      <property name="exportGrid" scope="instance" type="Object"/>
      <property name="exportSelected" scope="instance" type="Object"/>
      <property name="setExportFormatter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Filter" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_wrapStore" scope="instance"/>
      <method name="onSetStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clientFilterGetter" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="cell" type="cell" usage="required"/>
          <parameter name="rowIndex" type="int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>plugin name</description>
      </property>
      <property name="filterBar" scope="instance-prototype" type="Object"/>
      <property name="clearFilterDialog" scope="instance-prototype" type="Object"/>
      <property name="filterStatusTip" scope="instance-prototype" type="Object"/>
      <property name="filterDefDialog" scope="instance-prototype" type="Object"/>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="nls" scope="instance-prototype" type="Object"/>
      <property name="args" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridSource" superclass="dojo.dnd.Source">
    <methods>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDraggingOver" scope="instance"/>
      <method name="onDraggingOut" scope="instance"/>
      <method name="onDropExternal" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getCellContent" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="leftTopCell" type="Object" usage="required"/>
          <parameter name="rightBottomCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getRowContent" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="rowIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnContent" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="colIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDropGridCells" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="leftTopCell" type="Object" usage="required"/>
          <parameter name="rightBottomCell" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDropGridRows" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="rowIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDropGridColumns" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="colIndexes" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
    <properties>
      <property name="accept" scope="instance" type="Array"/>
      <property name="insertNodesForGrid" scope="instance" type="If">
        <description>you'd like to insert some sort of nodes into your dnd source, turn this on,
	and override getCellContent/getRowContent/getColumnContent
	to populate the dnd data in your desired format.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.GridSource.sourcePlugin">
    <properties>
      <property name="_isSource" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.IndirectSelection" superclass="dojox.grid.enhanced._Plugin">
    <description>For better rendering performance, div(images) are used to simulate radio button|check boxes</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="addRowSelectCell" scope="instance">
        <parameters>
          <parameter name="option" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>Plugin name</description>
      </property>
      <property name="cellCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.IndirectSelection.grid">
    <properties>
      <property name="layout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.RowSelector" superclass="dojox.grid.cells._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="formatter" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="inValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleRow" scope="instance">
        <parameters>
          <parameter name="index" type="Integer" usage="required">
            <description>Row index</description>
          </parameter>
          <parameter name="value" type="Boolean" usage="required">
            <description>True - checked | False - unchecked</description>
          </parameter>
        </parameters>
      </method>
      <method name="setDisabled" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="disabled" type="Boolean" usage="required">
            <description>True - disabled | False - enabled</description>
          </parameter>
        </parameters>
      </method>
      <method name="disabled" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dokeyup" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Key up event</description>
          </parameter>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Integer" usage="required">
            <description>Target row</description>
          </parameter>
        </parameters>
      </method>
      <method name="_focusEndingCell" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Integer" usage="required">
            <description>Row index</description>
          </parameter>
          <parameter name="cellIndex" type="Integer" usage="required">
            <description>Column index</description>
          </parameter>
        </parameters>
      </method>
      <method name="_nativeSelect" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSelected" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onDeselected" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUpdateRow" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toggleCheckedStyle" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_toggleDisabledStyle" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getSelector" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pageDestroyed" scope="instance">
        <parameters>
          <parameter name="pageIndex" type="Integer" usage="required">
            <description>Index of destroyed page</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputType" scope="instance" type="String">
        <description>Input type - Radio|CheckBox</description>
      </property>
      <property name="map" scope="instance-prototype" type="Object">
        <description>Cache div refs of radio|checkbox to avoid querying each time</description>
      </property>
      <property name="disabledMap" scope="instance-prototype" type="Object">
        <description>Cache index of disabled rows</description>
      </property>
      <property name="isRowSelector" scope="instance" type="Boolean">
        <description>Marker of indirectSelection cell(column)</description>
      </property>
      <property name="_connects" scope="instance-prototype" type="Array">
        <description>List of all connections.</description>
      </property>
      <property name="_subscribes" scope="instance-prototype" type="Array">
        <description>List of all subscribes.</description>
      </property>
      <property name="checkedText" scope="instance" type="String">
        <description>Checked character for high contrast mode</description>
      </property>
      <property name="unCheckedText" scope="instance" type="String">
        <description>Unchecked character for high contrast mode</description>
      </property>
      <property name="baseClass" scope="instance-prototype" type="String"/>
      <property name="disabledCount" scope="instance" type="Number"/>
      <property name="inA11YMode" scope="instance" type="Object"/>
      <property name="checkedClass" scope="instance" type="String"/>
      <property name="disabledClass" scope="instance" type="String"/>
      <property name="checkedDisabledClass" scope="instance" type="String"/>
      <property name="statusTextClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.RowSelector.grid.scroller">
    <properties>
      <property name="rowsPerPage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.SingleRowSelector" superclass="dojox.grid.cells.RowSelector">
    <methods>
      <method name="_selectRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event fired on the target row</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells.RowSelector" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.MultipleRowSelector" superclass="dojox.grid.cells.RowSelector">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="toggleAllSelection" scope="instance">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required">
            <description>True - select all, False - deselect all</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRowMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Decorated event object which contains reference to grid, cell, and rowIndex</description>
          </parameter>
        </parameters>
      </method>
      <method name="_domouseup" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Mouse up event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_dokeyup" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Key up event</description>
          </parameter>
        </parameters>
      </method>
      <method name="_startSelection" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Integer" usage="required">
            <description>Index of the start row</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateSelection" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event of the current row,</description>
          </parameter>
          <parameter name="delta" type="Integer" usage="required">
            <description>Row index delta, used for swipe selection via Shift + Arrow key
	0: not via key, -1 : Shift +  Up, 1 : Shift + Down</description>
          </parameter>
        </parameters>
      </method>
      <method name="_swipeByKey" scope="instance">
        <parameters>
          <parameter name="rowOffset" type="Integer" usage="required">
            <description>Row offset, used for swipe selection via Shift + Cursor
	-1 : Shift +  Up, 1 : Shift + Down</description>
          </parameter>
          <parameter name="colOffset" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required">
            <description>Event of the current row,</description>
          </parameter>
        </parameters>
      </method>
      <method name="_finishSelect" scope="instance"/>
      <method name="inSwipeSelection" scope="instance"/>
      <method name="_nativeSelect" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectRow" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Event fired on the target row</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addHeaderSelector" scope="instance"/>
      <method name="_toggletHeader" scope="instance"/>
      <method name="_onSelectionChanged" scope="instance"/>
      <method name="_toggleDisabledStyle" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="disabled" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.cells.RowSelector" scope="instance"/>
    </mixins>
    <properties>
      <property name="inputType" scope="instance" type="String"/>
      <property name="swipeStartRowIndex" scope="instance" type="Integer">
        <description>Start row index for swipe selection</description>
      </property>
      <property name="swipeMinRowIndex" scope="instance" type="Integer">
        <description>Max row index for swipe selection</description>
      </property>
      <property name="swipeMaxRowIndex" scope="instance" type="Number"/>
      <property name="toSelect" scope="instance" type="Boolean">
        <description>new state for selection</description>
      </property>
      <property name="lastClickRowIdx" scope="instance" type="Integer">
        <description>Row index for last click, used for range selection via Shift + click</description>
      </property>
      <property name="toggleAllTrigerred" scope="instance" type="Boolean">
        <description>Whether toggle all has been triggered or not</description>
      </property>
      <property name="unCheckedText" scope="instance" type="String"/>
      <property name="_headerSelectorConnectIdx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.cells.MultipleRowSelector.grid">
    <properties>
      <property name="selection" scope="instance" type="Object"/>
      <property name="_selectingRange" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Menu" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="onStartUp" scope="instance"/>
      <method name="_initMenu" scope="instance">
        <parameters>
          <parameter name="menuType" type="String" usage="required"/>
          <parameter name="menu" type="String" usage="required">
            <description>| Widget(dijit.Menu)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getMenuWidget" scope="instance">
        <parameters>
          <parameter name="menu" type="String|dijit.Menu" usage="required"/>
        </parameters>
      </method>
      <method name="_setRowMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="required"/>
        </parameters>
      </method>
      <method name="_setCellMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedRegionMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="required"/>
        </parameters>
      </method>
      <method name="_setMenuAttr" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="required"/>
          <parameter name="menuType" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="showMenu" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="Array">
        <description>menu types</description>
      </property>
      <property name="types" scope="instance" type="Array"/>
      <property name="option" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Menu.grid">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="showMenu" scope="instance" type="Object"/>
      <property name="_setRowMenuAttr" scope="instance" type="Object"/>
      <property name="_setCellMenuAttr" scope="instance" type="Object"/>
      <property name="_setSelectedRegionMenuAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.NestedSorting" superclass="dojox.grid.enhanced._Plugin">
    <description>A flexible way to control multiple column sorting, including
	1. Set default sorting order
	2. Disable sorting for certain columns
	3. Set sorting order dynamically with JS API</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="onStartUp" scope="instance"/>
      <method name="_setGridSortIndex" scope="instance">
        <parameters>
          <parameter name="inIndex" type="Object" usage="required"/>
          <parameter name="inAsc" type="Object" usage="required"/>
          <parameter name="noRefresh" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="header click from base DataGrid"/>
        </return-types>
      </method>
      <method name="getSortProps" scope="instance"/>
      <method name="_initSort" scope="instance">
        <parameters>
          <parameter name="postSort" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initHeaderNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHeaderCellClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHeaderCellMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHeaderCellMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSortBtnClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_doSort" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSortData" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
          <parameter name="attr" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeSortData" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_prepareSingleSort" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_prepareNestedSort" scope="instance">
        <parameters>
          <parameter name="cellIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSortDef" scope="instance"/>
      <method name="_updateHeaderNodeUI" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isAsc" scope="instance">
        <parameters>
          <parameter name="cellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDesc" scope="instance">
        <parameters>
          <parameter name="cellIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCellByNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearSort" scope="instance"/>
      <method name="initCookieHandler" scope="instance"/>
      <method name="_loadNestedSortingProps" scope="instance">
        <parameters>
          <parameter name="sortInfo" type="Object" usage="required"/>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_saveNestedSortingProps" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initFocus" scope="instance"/>
      <method name="_focusHeader" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurHeader" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMove" scope="instance">
        <parameters>
          <parameter name="rowStep" type="Object" usage="required"/>
          <parameter name="colStep" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRegionView" scope="instance">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRegions" scope="instance"/>
      <method name="_focusRegion" scope="instance">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurRegion" scope="instance">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCurrentRegion" scope="instance"/>
      <method name="_getRegionHeader" scope="instance">
        <parameters>
          <parameter name="region" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>Plugin name
	'none'|'asc'|'desc'</description>
      </property>
      <property name="_currMainSort" scope="instance" type="String"/>
      <property name="_currRegionIdx" scope="instance" type="Object"/>
      <property name="_excludedCoIdx" scope="instance" type="Array"/>
      <property name="_headerNodes" scope="instance-prototype" type="Object"/>
      <property name="_connects" scope="instance" type="Object"/>
      <property name="_sortData" scope="instance-prototype" type="Object"/>
      <property name="focus" scope="instance" type="Object"/>
      <property name="_focusRegions" scope="instance" type="Object"/>
      <property name="_headerArea" scope="instance" type="Object"/>
      <property name="_excludedColIdx" scope="instance" type="Array"/>
      <property name="nls" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.NestedSorting._a11yText">
    <properties>
      <property name="dojoxGridDescending" scope="instance" type="String"/>
      <property name="dojoxGridAscending" scope="instance" type="String"/>
      <property name="dojoxGridAscendingTip" scope="instance" type="String"/>
      <property name="dojoxGridDescendingTip" scope="instance" type="String"/>
      <property name="dojoxGridUnsortedTip" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.NestedSorting.grid">
    <methods>
      <method name="setSortInfo" scope="instance"/>
    </methods>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="setSortIndex" scope="instance" type="Object"/>
      <property name="getSortProps" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.NestedSorting._sortDef">
    <properties>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.NestedSorting.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Pagination" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="init" scope="instance"/>
      <method name="_createPaginators" scope="instance">
        <parameters>
          <parameter name="paginationArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_wrapStoreLayer" scope="instance"/>
      <method name="_stopEvent" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onNew" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeSelectedRows" scope="instance"/>
      <method name="_onDelete" scope="instance"/>
      <method name="_regApis" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="nextPage" scope="instance"/>
      <method name="prevPage" scope="instance"/>
      <method name="gotoPage" scope="instance">
        <parameters>
          <parameter name="page" type="The" usage="required">
            <description>page to go to, starting at 1.</description>
          </parameter>
        </parameters>
      </method>
      <method name="gotoFirstPage" scope="instance"/>
      <method name="gotoLastPage" scope="instance"/>
      <method name="changePageSize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showGotoPageButton" scope="instance">
        <parameters>
          <parameter name="flag" type="boolean" usage="required">
            <description>Show the go to page button when flag is true, otherwise hide it</description>
          </parameter>
        </parameters>
      </method>
      <method name="scrollToRow" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="integer" usage="required">
            <description>The row index</description>
          </parameter>
        </parameters>
      </method>
      <method name="getTotalRowCount" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String"/>
      <property name="pageSize" scope="instance" type="Number"/>
      <property name="defaultRows" scope="instance" type="Number"/>
      <property name="_currentPage" scope="instance" type="Number"/>
      <property name="_maxSize" scope="instance" type="Number"/>
      <property name="gh" scope="instance" type="Object"/>
      <property name="nls" scope="instance" type="Object"/>
      <property name="paginators" scope="instance" type="Object"/>
      <property name="_store" scope="instance" type="Object"/>
      <property name="query" scope="instance" type="Object"/>
      <property name="forcePageStoreLayer" scope="instance" type="Object"/>
      <property name="_multiRemoving" scope="instance" type="bool"/>
      <property name="originalScrollToRow" scope="instance" type="Object"/>
      <property name="_originalOnNew" scope="instance" type="Object"/>
      <property name="_originalRemove" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Pagination.grid">
    <properties>
      <property name="rowsPerPage" scope="instance" type="Object"/>
      <property name="usingPagination" scope="instance" type="Object"/>
      <property name="gotoPage" scope="instance" type="Object"/>
      <property name="nextPage" scope="instance" type="Object"/>
      <property name="prevPage" scope="instance" type="Object"/>
      <property name="gotoFirstPage" scope="instance" type="Object"/>
      <property name="gotoLastPage" scope="instance" type="Object"/>
      <property name="changePageSize" scope="instance" type="Object"/>
      <property name="showGotoPageButton" scope="instance" type="Object"/>
      <property name="getTotalRowCount" scope="instance" type="Object"/>
      <property name="scrollToRow" scope="instance" type="Object"/>
      <property name="removeSelectedRows" scope="instance" type="Object"/>
      <property name="_onNew" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._ForcedPageStoreLayer" superclass="dojox.grid.enhanced.plugins._StoreLayer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="plugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins._StoreLayer" scope="instance"/>
    </mixins>
    <properties>
      <property name="tags" scope="instance" type="Array"/>
      <property name="_plugin" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="update" scope="instance"/>
      <method name="_setWidthValue" scope="instance"/>
      <method name="_regFocusMgr" scope="instance">
        <parameters>
          <parameter name="position" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_placeSelf" scope="instance"/>
      <method name="_resetGridHeight" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_styleMsgNode" scope="instance">
        <parameters>
          <parameter name="top" type="Object" usage="required"/>
          <parameter name="width" type="Object" usage="required"/>
          <parameter name="height" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateDescription" scope="instance"/>
      <method name="_updateSizeSwitch" scope="instance"/>
      <method name="_createSizeSwitchNodes" scope="instance"/>
      <method name="_updateSwitchNodeClass" scope="instance"/>
      <method name="_updatePageStepper" scope="instance"/>
      <method name="_createPageStepNodes" scope="instance"/>
      <method name="_createWardBtns" scope="instance"/>
      <method name="_resetPageStepNodes" scope="instance"/>
      <method name="_updatePageStepNodeClass" scope="instance"/>
      <method name="_showGotoButton" scope="instance">
        <parameters>
          <parameter name="flag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateGotoButton" scope="instance"/>
      <method name="_createGotoNode" scope="instance"/>
      <method name="_openGotopageDialog" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusPaginator" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusPageSizeNode" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusPageStepNode" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusGotoPageNode" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlurPaginator" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="isBubble" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveFocus" scope="instance">
        <parameters>
          <parameter name="rowDelta" type="Object" usage="required"/>
          <parameter name="colDelta" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPageSizeActivableNodes" scope="instance"/>
      <method name="_getPageStepActivableNodes" scope="instance"/>
      <method name="_getAllPageSizeNodes" scope="instance"/>
      <method name="_getAllPageStepNodes" scope="instance"/>
      <method name="_moveToNextActivableNode" scope="instance">
        <parameters>
          <parameter name="nodeList" type="Object" usage="required"/>
          <parameter name="curNodeValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSwitchPageSize" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onPageStep" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_getCurrentPageNo" scope="instance"/>
      <method name="_getPageCount" scope="instance"/>
      <method name="_getStartPage" scope="instance"/>
      <method name="_getStepPageSize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templatePath" scope="instance" type="Object"/>
      <property name="position" scope="instance" type="String"/>
      <property name="_maxItemSize" scope="instance" type="Object"/>
      <property name="description" scope="instance" type="Object"/>
      <property name="pageStepper" scope="instance" type="Object"/>
      <property name="maxPageStep" scope="instance" type="Number"/>
      <property name="sizeSwitch" scope="instance" type="Object"/>
      <property name="pageSizes" scope="instance" type="Object"/>
      <property name="gotoButton" scope="instance" type="bool"/>
      <property name="_originalResize" scope="instance" type="Object"/>
      <property name="currentPageSize" scope="instance" type="Object"/>
      <property name="_resultSize" scope="instance" type="Object"/>
      <property name="pageSizeValue" scope="instance" type="Object"/>
      <property name="initializedSizeNode" scope="instance" type="Object"/>
      <property name="pageStepValue" scope="instance" type="Object"/>
      <property name="gotoPageTd" scope="instance" type="Object"/>
      <property name="gotoPageDiv" scope="instance" type="Object"/>
      <property name="_gotoPageDialog" scope="instance" type="Object"/>
      <property name="_currentFocusNode" scope="instance" type="Object"/>
      <property name="focusArea" scope="instance" type="String"/>
      <property name="itemTitle" scope="instance" type="Object"/>
      <property name="descTemplate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator.grid">
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_pendingChangeSize" scope="instance" type="Object"/>
      <property name="_pendingResultSize" scope="instance" type="Object"/>
      <property name="messagesNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator.plugin">
    <properties>
      <property name="gh" scope="instance" type="String"/>
      <property name="forcePageStoreLayer" scope="instance" type="Object"/>
      <property name="showAll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator.descriptionDiv">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator.pageStepperDiv"/>
  <class type="dojox.grid.enhanced.plugins._Paginator.pageStepperDiv.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._Paginator.plugin.grid">
    <properties>
      <property name="usingPagination" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.pagination"/>
  <class type="dojox.grid.enhanced.plugins.pagination._GotoPageDialog">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="plugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createDialogContent" scope="instance"/>
      <method name="_styleContent" scope="instance"/>
      <method name="updatePageCount" scope="instance"/>
      <method name="showDialog" scope="instance"/>
      <method name="_onConfirm" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onCancel" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyDown" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setConfirmBtnState" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="pageCount" scope="instance-prototype" type="Object"/>
      <property name="_specifyNode" scope="instance" type="Object"/>
      <property name="_pageInputDiv" scope="instance" type="Object"/>
      <property name="_pageLabel" scope="instance" type="Object"/>
      <property name="_buttonDiv" scope="instance" type="Object"/>
      <property name="_confirmBtn" scope="instance" type="Object"/>
      <property name="_cancelBtn" scope="instance" type="Object"/>
      <property name="plugin" scope="instance" type="Object"/>
      <property name="_dialogNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.pagination._GotoPageDialog._pageTextBox">
    <properties>
      <property name="constraints" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.pagination._GotoPageDialog._gotoPageDialog">
    <properties>
      <property name="onCancel" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Printer" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixinGrid" scope="instance"/>
      <method name="printGrid" scope="instance">
        <parameters>
          <parameter name="args" type="__printArgs" usage="optional">
            <description>Arguments for print.</description>
          </parameter>
        </parameters>
      </method>
      <method name="printSelected" scope="instance">
        <parameters>
          <parameter name="args" type="__printArgs" usage="optional">
            <description>Arguments for print.</description>
          </parameter>
        </parameters>
      </method>
      <method name="exportToHTML" scope="instance">
        <parameters>
          <parameter name="args" type="__printArgs" usage="optional">
            <description>Arguments for print.</description>
          </parameter>
          <parameter name="onExported" type="Function(string))" usage="required">
            <description>call back function</description>
          </parameter>
        </parameters>
      </method>
      <method name="exportSelectedToHTML" scope="instance">
        <parameters>
          <parameter name="args" type="__printArgs" usage="optional">
            <description>Arguments for print.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_print" scope="instance">
        <parameters>
          <parameter name="htmlStr" type="string" usage="required">
            <description>String The html content string to be printed.</description>
          </parameter>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="_wrapHTML" scope="instance">
        <parameters>
          <parameter name="title" type="string" usage="required">
            <description>String A title for the html page.</description>
          </parameter>
          <parameter name="cssFiles" type="Array" usage="required">
            <description>css file pathes.</description>
          </parameter>
          <parameter name="body_content" type="string" usage="required">
            <description>String Content to print, not including &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt; part and &amp;lt;html&amp;gt; tags</description>
          </parameter>
        </parameters>
        <return-description>the wrapped HTML string ready for print</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="normalizeRowHeight" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_formalizeArgs" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>Plugin name</description>
      </property>
      <property name="_printFrame" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Printer.grid">
    <properties>
      <property name="printGrid" scope="instance" type="Object"/>
      <property name="printSelected" scope="instance" type="Object"/>
      <property name="exportToHTML" scope="instance" type="Object"/>
      <property name="exportSelectedToHTML" scope="instance" type="Object"/>
      <property name="normalizePrintedGrid" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setArgs" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="onSetStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hasIdentity" scope="instance">
        <parameters>
          <parameter name="points" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveColumns" scope="instance">
        <parameters>
          <parameter name="colsToMove" type="Array&lt;Integer&gt;" usage="required">
            <description>Array of column indexes.</description>
          </parameter>
          <parameter name="targetPos" type="Integer" usage="required">
            <description>The target position</description>
          </parameter>
        </parameters>
      </method>
      <method name="moveRows" scope="instance">
        <parameters>
          <parameter name="rowsToMove" type="Array&lt;Integer&gt;" usage="required">
            <description>Array of row indexes.</description>
          </parameter>
          <parameter name="targetPos" type="Integer" usage="required">
            <description>The target position</description>
          </parameter>
        </parameters>
      </method>
      <method name="moveCells" scope="instance">
        <parameters>
          <parameter name="cellsToMove" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="copyCells" scope="instance">
        <parameters>
          <parameter name="cellsToMove" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changeCells" scope="instance">
        <parameters>
          <parameter name="sourceGrid" type="Object" usage="required"/>
          <parameter name="cellsToMove" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearCells" scope="instance">
        <parameters>
          <parameter name="cellsToClear" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="insertRows" scope="instance">
        <parameters>
          <parameter name="sourceGrid" type="Object" usage="required"/>
          <parameter name="rowsToMove" type="Object" usage="required"/>
          <parameter name="targetPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRows" scope="instance">
        <parameters>
          <parameter name="rowsToRemove" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPageInfo" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>plugin name</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.args">
    <methods>
      <method name="setIdentifierForNewItem" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="_notRefreshSelection" scope="instance" type="Object"/>
      <property name="_noInternalMapping" scope="instance" type="Object"/>
      <property name="rowCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid.selection">
    <properties>
      <property name="selected" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid.scroller">
    <properties>
      <property name="firstVisibleRow" scope="instance" type="Object"/>
      <property name="lastVisibleRow" scope="instance" type="Object"/>
      <property name="rowsPerPage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Rearrange.grid.scroller.pageNodes">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Search" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="searchRow" scope="instance">
        <parameters>
          <parameter name="searchArgs" type="Object|RegExp|String" usage="required"/>
          <parameter name="onSearched" type="Function(Integer)" usage="required">
            <description>item)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_search" scope="instance">
        <parameters>
          <parameter name="searchArgs" type="Object|RegExp" usage="required"/>
          <parameter name="start" type="Integer" usage="required"/>
          <parameter name="onSearched" type="Function(Integer)" usage="required">
            <description>item)</description>
          </parameter>
          <parameter name="isGlobal" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_checkRow" scope="instance">
        <parameters>
          <parameter name="item" type="store" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="searchArgs" type="Object|RegExp" usage="required"/>
          <parameter name="isGlobal" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>plugin name</description>
      </property>
      <property name="_cacheSize" scope="instance-prototype" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Search.grid">
    <properties>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="__SelectCellItem" superclass="__SelectItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="__SelectItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="row" scope="instance" type="Integer">
        <description>Row index of this cell</description>
      </property>
      <property name="col" scope="instance" type="Integer">
        <description>Column index of this cell</description>
      </property>
    </properties>
  </class>
  <class type="__SelectRowItem" superclass="__SelectItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="__SelectItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="row" scope="instance" type="Integer">
        <description>Row index of this row</description>
      </property>
      <property name="except" scope="instance" type="Array&lt;Integer&gt;">
        <description>An array of column indexes of all the unselected cells in this row.</description>
      </property>
    </properties>
  </class>
  <class type="__SelectColItem" superclass="__SelectItem">
    <methods/>
    <mixins scope="instance">
      <mixin type="__SelectItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="col" scope="instance" type="Integer">
        <description>Column index of this column</description>
      </property>
      <property name="except" scope="instance" type="Array&lt;Integer&gt;">
        <description>An array of row indexes of all the unselected cells in this column.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector" superclass="dojox.grid.enhanced._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="setupConfig" scope="instance">
        <parameters>
          <parameter name="config" type="Object" usage="required">
            <description>An object with the following structure (all properties are optional):
	{
	//Default is &amp;quot;multi&amp;quot;, all other values are same as &amp;quot;multi&amp;quot;.
	row: false|&amp;quot;disabled&amp;quot;|&amp;quot;single&amp;quot;,
	col: false|&amp;quot;disabled&amp;quot;|&amp;quot;single&amp;quot;,
	cell: false|&amp;quot;disabled&amp;quot;|&amp;quot;single&amp;quot;
	}</description>
          </parameter>
        </parameters>
      </method>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;</description>
          </parameter>
          <parameter name="rowIndex" type="Integer" usage="required">
            <description>If type is &amp;quot;row&amp;quot; or &amp;quot;cell&amp;quot;, this is the row index.
	If type if &amp;quot;col&amp;quot;, this is the column index.</description>
          </parameter>
          <parameter name="colIndex" type="Integer" usage="optional">
            <description>Only valid when type is &amp;quot;cell&amp;quot;
	return: Boolean
	true if selected, false if not. If cell is covered by a selected column, it's selected.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toggleSelect" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;</description>
          </parameter>
          <parameter name="rowIndex" type="Integer" usage="required">
            <description>If type is &amp;quot;row&amp;quot; or &amp;quot;cell&amp;quot;, this is the row index.
	If type if &amp;quot;col&amp;quot;, this is the column index.</description>
          </parameter>
          <parameter name="colIndex" type="Integer" usage="optional">
            <description>Only valid when type is &amp;quot;cell&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="colIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectRange" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;</description>
          </parameter>
          <parameter name="start" type="Integer" usage="required">
            <description>| Object
	If type is &amp;quot;row&amp;quot; or &amp;quot;col&amp;quot;, this is the index of the starting row or column.
	If type if &amp;quot;cell&amp;quot;, this is the left-top cell of the range.</description>
          </parameter>
          <parameter name="end" type="Integer" usage="required">
            <description>| Object
	If type is &amp;quot;row&amp;quot; or &amp;quot;col&amp;quot;, this is the index of the ending row or column.
	If type if &amp;quot;cell&amp;quot;, this is the right-bottom cell of the range.</description>
          </parameter>
          <parameter name="toSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="optional">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;. If omitted, clear all.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isSelecting" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;
	return: Boolean
	true if is selection, false otherwise.</description>
          </parameter>
        </parameters>
      </method>
      <method name="selectEnabled" scope="instance">
        <parameters>
          <parameter name="toEnable" type="Boolean" usage="optional">
            <description>To enable or not. Optional.
	return: Boolean | undefined
	Enabled or not.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getSelected" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;</description>
          </parameter>
          <parameter name="includeExceptions" type="Boolean" usage="required">
            <description>Only meaningful for rows/columns. If true, all selected rows/cols, even they are partly selected, are all returned.
	return: __SelectItem[]</description>
          </parameter>
        </parameters>
      </method>
      <method name="getSelectedCount" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot; or &amp;quot;col&amp;quot; or &amp;quot;cell&amp;quot;</description>
          </parameter>
          <parameter name="includeExceptions" type="Boolean" usage="required">
            <description>Only meaningful for rows/columns. If true, all selected rows/cols, even they are partly selected, are all returned.
	return: Integer
	The number of selected items.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getSelectedType" scope="instance"/>
      <method name="getLastSelectedRange" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hacks" scope="instance"/>
      <method name="_mixinGrid" scope="instance"/>
      <method name="_initEvents" scope="instance"/>
      <method name="_onSelectedById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="newIndex" type="Object" usage="required"/>
          <parameter name="isSelected" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetStore" scope="instance"/>
      <method name="_onInternalRearrange" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="mapping" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onExternalChange" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refresh" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_refreshSelected" scope="instance"/>
      <method name="_initAreas" scope="instance"/>
      <method name="_clearSelection" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot;, &amp;quot;col&amp;quot;, or &amp;quot;cell</description>
          </parameter>
          <parameter name="reservedItem" type="__SelectItem" usage="required">
            <description>The item to retain highlight.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_startSelect" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot;, &amp;quot;col&amp;quot;, or &amp;quot;cell&amp;quot;</description>
          </parameter>
          <parameter name="start" type="__SelectItem" usage="required">
            <description>The start point</description>
          </parameter>
          <parameter name="extending" type="Boolean" usage="required">
            <description>Whether this is a multi selection</description>
          </parameter>
          <parameter name="isRange" type="Boolean" usage="required">
            <description>Whether this is a range selection (i.e. select from the last end point to this point)</description>
          </parameter>
          <parameter name="mandatarySelect" type="Boolean" usage="required">
            <description>If true, toSelect will be same as the original selection status.</description>
          </parameter>
          <parameter name="toSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_endSelect" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>&amp;quot;row&amp;quot;, &amp;quot;col&amp;quot;, or &amp;quot;cell&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fireEvent" scope="instance">
        <parameters>
          <parameter name="evtName" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcToHighlight" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
          <parameter name="toSelect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightHeader" scope="instance">
        <parameters>
          <parameter name="colIdx" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightRowSelector" scope="instance">
        <parameters>
          <parameter name="rowIdx" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightSingle" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="toHighlight" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="toSelect" type="Object" usage="required"/>
          <parameter name="isRefresh" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_highlight" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="toSelect" type="Boolean" usage="required">
            <description>Whether we are selecting or deselecting.
	This function is time critical!!</description>
          </parameter>
        </parameters>
      </method>
      <method name="_focusPoint" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="point" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_blurPoint" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="point" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addToSelected" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_forEach" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
          <parameter name="func" type="Object" usage="required"/>
          <parameter name="halfClose" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeupForExceptions" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="newCellItems" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeupForCells" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="newItems" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addException" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addCellException" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_add" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isCellNotInExcept" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isSelected" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isInLastRange" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="isSelected" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isValid" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="allowNotSelectable" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>plugin name
	//	_config: null,
	//	_enabled: true,
	//	_selecting: {
	//		row: false,
	//		col: false,
	//		cell: false
	//	},
	//	_selected: {
	//		row: [],
	//		col: [],
	//		cell: []
	//	},
	//	_startPoint: {},
	//	_currentPoint: {},
	//	_lastAnchorPoint: {},
	//	_lastEndPoint: {},
	//	_lastSelectedAnchorPoint: {},
	//	_lastSelectedEndPoint: {},
	//	_keyboardSelect: {
	//		row: 0,
	//		col: 0,
	//		cell: 0
	//	},
	//	_curType: null,
	//	_lastType: null,
	//	_usingKeyboard: false,
	//	_toSelect: true,</description>
      </property>
      <property name="_enabled" scope="instance-prototype" type="Object"/>
      <property name="_selected" scope="instance-prototype" type="Object"/>
      <property name="_oldDeselectAll" scope="instance" type="Object"/>
      <property name="_lastFocusedRowBarIdx" scope="instance" type="Number"/>
      <property name="_isUsingRowSelector" scope="instance" type="Object"/>
      <property name="_toSelect" scope="instance" type="Object"/>
      <property name="_curType" scope="instance" type="Object"/>
      <property name="_isStartFocus" scope="instance" type="bool"/>
      <property name="_lastType" scope="instance-prototype" type="Object"/>
      <property name="_selectedRowModified" scope="instance-prototype" type="Object"/>
      <property name="_selecting" scope="instance" type="Object"/>
      <property name="_startPoint" scope="instance" type="Object"/>
      <property name="_currentPoint" scope="instance" type="Object"/>
      <property name="_lastAnchorPoint" scope="instance" type="Object"/>
      <property name="_lastEndPoint" scope="instance" type="Object"/>
      <property name="_lastSelectedAnchorPoint" scope="instance" type="Object"/>
      <property name="_lastSelectedEndPoint" scope="instance" type="Object"/>
      <property name="_keyboardSelect" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid">
    <methods>
      <method name="onStartSelect" scope="instance"/>
      <method name="onEndSelect" scope="instance"/>
      <method name="onStartDeselect" scope="instance"/>
      <method name="onEndDeselect" scope="instance"/>
      <method name="onSelectCleared" scope="instance"/>
    </methods>
    <properties>
      <property name="_selectingRange" scope="instance" type="bool"/>
      <property name="setupSelectorConfig" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.selection">
    <methods>
      <method name="clickSelect" scope="instance"/>
      <method name="selectRange" scope="instance">
        <parameters>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectRange" scope="instance">
        <parameters>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="instance"/>
    </methods>
    <properties>
      <property name="_selectedById" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.views.views"/>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.views.views.0">
    <methods>
      <method name="doStyleRowNode" scope="instance">
        <parameters>
          <parameter name="inRowIndex" type="Object" usage="required"/>
          <parameter name="inRowNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.layout">
    <properties>
      <property name="cells" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector.grid.focus">
    <properties>
      <property name="_colHeadFocusIdx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.Selector._config">
    <properties>
      <property name="row" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._RowMapLayer" superclass="dojox.grid.enhanced.plugins._StoreLayer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="instance"/>
      <method name="setMapping" scope="instance">
        <parameters>
          <parameter name="mapping" type="Object" usage="required">
            <description>keys are original rowIndexes, values are new rowIndexes.</description>
          </parameter>
        </parameters>
      </method>
      <method name="clearMapping" scope="instance"/>
      <method name="_onDelete" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="userRequest" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRowArrays" scope="instance">
        <parameters>
          <parameter name="rows" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_subFetch" scope="instance">
        <parameters>
          <parameter name="userRequest" type="Object" usage="required"/>
          <parameter name="rowArrays" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="result" type="Object" usage="required"/>
          <parameter name="map" type="Object" usage="required"/>
          <parameter name="oldOnComplete" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="count" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins._StoreLayer" scope="instance"/>
    </mixins>
    <properties>
      <property name="tags" scope="instance" type="Array"/>
      <property name="_map" scope="instance-prototype" type="Object"/>
      <property name="_revMap" scope="instance-prototype" type="Object"/>
      <property name="_oldOnDelete" scope="instance" type="Object"/>
      <property name="_oldSort" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._RowMapLayer.grid">
    <properties>
      <property name="_onDelete" scope="instance" type="Object"/>
      <property name="sort" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._SelectionPreserver">
    <description>When this feature turned on, Grid will try to preserve selections across various user actions, e.g. sorting, filtering etc.
	Precondition - Identifier(id) is required for store, as id is used for differentiating row items.
	Known issue - The preserved selections might be inaccurate if some unloaded rows are selected by range previously(e.g.SHIFT + click)</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="selection" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_reSelectById" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectById" scope="instance">
        <parameters>
          <parameter name="toSelect" type="Object" usage="required"/>
          <parameter name="inItemOrIndex" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectedById" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateMapping" scope="instance">
        <parameters>
          <parameter name="trustSelection" type="Object" usage="required"/>
          <parameter name="isSelect" type="Object" usage="required"/>
          <parameter name="isForAll" type="Object" usage="required"/>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_connects" scope="instance" type="Array">
        <description>List of all connections.</description>
      </property>
      <property name="_selectedById" scope="instance" type="Object"/>
      <property name="_trustSelection" scope="instance" type="Array"/>
      <property name="_defaultSelected" scope="instance" type="bool"/>
      <property name="selection" scope="instance-prototype" type="Object"/>
      <property name="grid" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._SelectionPreserver._idMap">
    <properties>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._StoreLayer">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="initialize" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="_wrap" scope="instance">
        <parameters>
          <parameter name="store" type="Read-store" usage="required">
            <description>The store to be wrapped.</description>
          </parameter>
          <parameter name="funcName" type="Object" usage="required"/>
          <parameter name="layerFuncName" type="Object" usage="required"/>
          <parameter name="nextLayer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_unwrap" scope="instance">
        <parameters>
          <parameter name="nextLayer" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enabled" scope="instance">
        <parameters>
          <parameter name="toEnable" type="bool" usage="optional">
            <description>Boolean If given, is a setter, otherwise, it's getter.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="name" scope="instance">
        <return-description>The name of this layer.</return-description>
      </method>
      <method name="originFetch" scope="instance"/>
    </methods>
    <properties>
      <property name="_store" scope="instance-prototype" type="Read-store">
        <description>The wrapped store.</description>
      </property>
      <property name="_originFetch" scope="instance-prototype" type="function">
        <description>The original fetch function of the store.</description>
      </property>
      <property name="__enabled" scope="instance-prototype" type="Boolean">
        <description>To control whether this layer is valid.</description>
      </property>
      <property name="tags" scope="instance" type="Array"/>
      <property name="layerFuncName" scope="instance" type="String"/>
      <property name="_funcName" scope="instance" type="Object"/>
      <property name="__name" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._ServerSideLayer" superclass="dojox.grid.enhanced.plugins._StoreLayer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enabled" scope="instance">
        <parameters>
          <parameter name="toEnable" type="bool" usage="optional"/>
        </parameters>
      </method>
      <method name="useCommands" scope="instance">
        <parameters>
          <parameter name="toUse" type="bool" usage="optional">
            <description>Boolean If provided, it's a setter, otherwise, it's a getter</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="userRequest" type="keywordArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.data.api.Request"/>
        </return-types>
      </method>
      <method name="command" scope="instance">
        <parameters>
          <parameter name="cmdName" type="string" usage="required">
            <description>The name of the command</description>
          </parameter>
          <parameter name="cmdContent" type="(string|number|bool|)" usage="optional">
            <description>anything The content of the command</description>
          </parameter>
        </parameters>
        <return-description>The content of the command if cmdContent is undefined</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="onCommandLoad" scope="instance">
        <parameters>
          <parameter name="response" type="string" usage="required">
            <description>server response</description>
          </parameter>
          <parameter name="userRequest" type="keywordArgs" usage="required">
            <description>in|out] dojo.data.api.Request
	The request object for *fetch*. You can modify this object according to the *response*
	so as to change the behavior of *fetch*</description>
          </parameter>
        </parameters>
      </method>
      <method name="onCommandError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="_onUserCommandLoad" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins._StoreLayer" scope="instance"/>
    </mixins>
    <properties>
      <property name="_url" scope="instance-prototype" type="string">
        <description>The url of the server
	__cmds [private] object
	The command object to be sent to server.</description>
      </property>
      <property name="_isStateful" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins._ServerSideLayer.__cmds">
    <properties>
      <property name="enable" scope="instance" type="Object"/>
      <property name="cmdlayer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.exporter"/>
  <class type="dojox.grid.enhanced.plugins.exporter.CSVWriter" superclass="dojox.grid.enhanced.plugins.exporter._ExportWriter">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="writerArgs" type="object" usage="optional">
            <description>{separator:'...'}</description>
          </parameter>
        </parameters>
      </method>
      <method name="_formatCSVCell" scope="instance">
        <parameters>
          <parameter name="cellValue" type="string" usage="required">
            <description>The value in a cell.</description>
          </parameter>
        </parameters>
        <return-description>The formatted content of a cell</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="beforeContentRow" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="handleCell" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.exporter._ExportWriter" scope="instance"/>
    </mixins>
    <properties>
      <property name="_separator" scope="instance-prototype" type="String"/>
      <property name="_newline" scope="instance-prototype" type="String"/>
      <property name="_headers" scope="instance" type="Array"/>
      <property name="_dataRows" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.exporter.TableWriter" superclass="dojox.grid.enhanced.plugins.exporter._ExportWriter">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="writerArgs" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_getTableAttrs" scope="instance">
        <parameters>
          <parameter name="tagName" type="string" usage="required">
            <description>An html tag name</description>
          </parameter>
        </parameters>
        <return-description>The well formatted attributes for the given html table.tag</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getRowClass" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getColumnClass" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="beforeView" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterView" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="beforeSubrow" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterSubrow" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="handleCell" scope="instance">
        <parameters>
          <parameter name="arg_obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="afterContent" scope="instance"/>
      <method name="toString" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.exporter._ExportWriter" scope="instance"/>
    </mixins>
    <properties>
      <property name="_viewTables" scope="instance" type="Array"/>
      <property name="_tableAttrs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.exporter._ExportWriter">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="writerArgs" type="object" usage="optional">
            <description>Any implementation of this class might accept a writerArgs object (optional),
	which contains some writer-specific arguments given by the user.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getExportDataForCell" scope="instance">
        <parameters>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="rowItem" type="Object" usage="required"/>
          <parameter name="cell" type="Object" usage="required"/>
          <parameter name="grid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="beforeHeader" scope="instance">
        <parameters>
          <parameter name="grid" type="EnhancedGrid" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterHeader" scope="instance">
        <return-description>undefined</return-description>
      </method>
      <method name="beforeContent" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required">
            <description>All the items fetched from the store
	return:
	true: go on handling the contents and then call afterContent.
	false: skip all the contents, won't call afterContent.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterContent" scope="instance">
        <return-description>undefined</return-description>
      </method>
      <method name="beforeContentRow" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	row,rowIdx,
	spCols
	}
	return:
	true: go on handling the current data row and then call afterContentRow.
	false: skip the current data row, won't call afterContentRow.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterContentRow" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	row,rowIdx,
	spCols
	}</description>
          </parameter>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="beforeView" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	view,viewIdx,
	spCols(if isHeader==false)
	}
	return:
	true: go on handling the current view and then call afterView.
	false: skip the current view, won't call afterView.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterView" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	view,viewIdx,
	spCols(if isHeader==false)
	}</description>
          </parameter>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="beforeSubrow" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	row,rowIdx,
	view,viewIdx,
	subrow,subrowIdx,
	spCols(if isHeader==false)
	}
	return:
	true: go on handling the current subrow and then call afterSubrow.
	false: skip the current subrow, won't call afterSubrow.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="afterSubrow" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	row,rowIdx,
	view,viewIdx,
	subrow,subrowIdx,
	spCols(if isHeader==false)
	}</description>
          </parameter>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="handleCell" scope="instance">
        <parameters>
          <parameter name="argObj" type="object" usage="required">
            <description>An object with at least the following context properties available:
	{
	grid,isHeader,
	row,rowIdx,
	view,viewIdx,
	subrow,subrowIdx,
	cell,cellIdx,
	spCols(if isHeader==false)
	}</description>
          </parameter>
        </parameters>
        <return-description>undefined</return-description>
      </method>
      <method name="toString" scope="instance">
        <return-description>The exported result string.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.exporter._ExportWriter.argObj">
    <properties>
      <property name="grid" scope="instance" type="EnhancedGrid">
        <description>The grid object we are now handling.</description>
      </property>
      <property name="isHeader" scope="instance" type="bool">
        <description>Indicating which context we're handling, header or content.</description>
      </property>
      <property name="view" scope="instance" type="_View">
        <description>Reference to the current _View object.</description>
      </property>
      <property name="viewIdx" scope="instance" type="int">
        <description>The index of the current _View object in the views array.
	If the grid does not have any rowselector view, it conforms to the index
	in the _ViewManager.views.</description>
      </property>
      <property name="subrow" scope="instance" type="_View.structure.cells[i]">
        <description>Reference to the current subrow.
	A subrow describe the innter structure of a row in a view, it's an array of cells</description>
      </property>
      <property name="subrowIdx" scope="instance" type="int">
        <description>The index of the current subrow in the subrow array: _View.structure.cells.</description>
      </property>
      <property name="cell" scope="instance" type="dojox.grid.__CellDef">
        <description>Reference to the current cell.</description>
      </property>
      <property name="cellIdx" scope="instance" type="int">
        <description>The index of the current cell in the current subrow.
	It's different from cell.index, which is the index in the whole line.</description>
      </property>
      <property name="row" scope="instance" type="item">
        <description>The current row of data (logically), a.k.a.: current item.</description>
      </property>
      <property name="rowIdx" scope="instance" type="int">
        <description>The index of the current row (item).</description>
      </property>
      <property name="spCols" scope="instance" type="Array&lt;int&gt;">
        <description>An array of special column indexes(flat,not regarding structure).
	Special columns are typically attached to grid as a kind of UI facility
	by the grid widget, instead of some real data.
	For example, indirect selectors and row indexers.
	Users can choose to export it or not.</description>
      </property>
      <property name="colOffset" scope="instance" type="int">
        <description>If the grid has a _RowSelector view or something else, this view will NOT be
	passed to the user in argObj. So the column index (cell.index) will appear shifted
	(start from 1 instead of 0). This colOffset is provided to remove this shift.
	usage:
	var correctColIndex = argObj.cell.index + argObj.colOffset;</description>
      </property>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter">
    <properties>
      <property name="FilterLayer" scope="instance" type="Object"/>
      <property name="_DataExprs" scope="instance" type="Object"/>
      <property name="_FilterExpr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ClearFilterConfirm" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="_onCancel" scope="instance"/>
      <method name="_onClear" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_clearBtnLabel" scope="instance" type="Object"/>
      <property name="_cancelBtnLabel" scope="instance" type="Object"/>
      <property name="_clearFilterMsg" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ClearFilterConfirm.plugin">
    <properties>
      <property name="nls" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="isFilterBarShown" scope="instance"/>
      <method name="showFilterBar" scope="instance">
        <parameters>
          <parameter name="toShow" type="Object" usage="required"/>
          <parameter name="useAnim" type="Object" usage="required"/>
          <parameter name="animArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleFilterBar" scope="instance">
        <parameters>
          <parameter name="useAnim" type="Object" usage="required"/>
          <parameter name="animArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnIdx" scope="instance">
        <parameters>
          <parameter name="coordX" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="toggleClearFilterBtn" scope="instance">
        <parameters>
          <parameter name="toHide" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_closeFilterBar" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showFilterDefDialog" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clearFilterDefDialog" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onEnterButton" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMoveButton" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLeaveButton" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onShowFilterDefDialog" scope="instance">
        <parameters>
          <parameter name="colIdx" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_onCloseFilterDefDialog" scope="instance"/>
      <method name="_onClickFilterBar" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseEnter" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseLeave" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateTipPosition" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocusFilterBar" scope="instance">
        <parameters>
          <parameter name="highlightOnly" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlurFilterBar" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFiltered" scope="instance">
        <parameters>
          <parameter name="filteredSize" type="int" usage="required"/>
          <parameter name="originSize" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_initAriaInfo" scope="instance"/>
      <method name="_isInColumn" scope="instance">
        <parameters>
          <parameter name="mousePos_x" type="int" usage="required"/>
          <parameter name="headerNode" type="domNode" usage="required"/>
          <parameter name="colIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_setStatusTipTimeout" scope="instance"/>
      <method name="_clearStatusTipTimeout" scope="instance"/>
      <method name="_showStatusTooltip" scope="instance"/>
      <method name="_highlightHeader" scope="instance">
        <parameters>
          <parameter name="colIdx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_clearHeaderHighlight" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_timeout_statusTooltip" scope="instance" type="Number"/>
      <property name="_handle_statusTooltip" scope="instance" type="Object"/>
      <property name="_curColIdx" scope="instance" type="Number"/>
      <property name="_filterBarDefBtnLabel" scope="instance" type="Object"/>
      <property name="_filterBarClearBtnLabel" scope="instance" type="Object"/>
      <property name="_closeFilterBarBtnLabel" scope="instance" type="Object"/>
      <property name="_noFilterMsg" scope="instance" type="Object"/>
      <property name="oldGetHeaderHeight" scope="instance" type="Object"/>
      <property name="_leavingBtn" scope="instance" type="bool"/>
      <property name="_defPaneIsShown" scope="instance" type="bool"/>
      <property name="_tippos" scope="instance" type="Object"/>
      <property name="_isFocused" scope="instance" type="bool"/>
      <property name="_focusPos" scope="instance" type="Number"/>
      <property name="_previousHeaderIdx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.plugin">
    <properties>
      <property name="nls" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.plugin.args">
    <properties>
      <property name="itemsName" scope="instance" type="Object"/>
      <property name="statusTipTimeout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.plugin.grid">
    <methods>
      <method name="_getHeaderHeight" scope="instance"/>
    </methods>
    <properties>
      <property name="showFilterBar" scope="instance" type="Object"/>
      <property name="toggleFilterBar" scope="instance" type="Object"/>
      <property name="isFilterBarShown" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.defineFilterButton.domNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.plugin.grid.views.views.0.domNode">
    <properties>
      <property name="offsetHeight" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBar.statusBarNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder">
    <methods>
      <method name="buildExpression" scope="instance">
        <parameters>
          <parameter name="def" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder.supportedOps">
    <methods>
      <method name="range" scope="instance">
        <parameters>
          <parameter name="operands" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="equalto" scope="instance" type="Object"/>
      <property name="lessthan" scope="instance" type="Object"/>
      <property name="lessthanorequalto" scope="instance" type="Object"/>
      <property name="largerthan" scope="instance" type="Object"/>
      <property name="largerthanorequalto" scope="instance" type="Object"/>
      <property name="contains" scope="instance" type="Object"/>
      <property name="startswith" scope="instance" type="Object"/>
      <property name="endswith" scope="instance" type="Object"/>
      <property name="notequalto" scope="instance" type="Object"/>
      <property name="notcontains" scope="instance" type="Object"/>
      <property name="notstartswith" scope="instance" type="Object"/>
      <property name="notendswith" scope="instance" type="Object"/>
      <property name="isempty" scope="instance" type="Object"/>
      <property name="logicany" scope="instance" type="Object"/>
      <property name="logicall" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder.supportedTypes">
    <properties>
      <property name="number" scope="instance" type="Object"/>
      <property name="string" scope="instance" type="Object"/>
      <property name="boolean" scope="instance" type="Object"/>
      <property name="date" scope="instance" type="Object"/>
      <property name="time" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder.defaultArgs"/>
  <class type="dojox.grid.enhanced.plugins.filter.FilterBuilder.defaultArgs.boolean">
    <methods>
      <method name="convert" scope="instance">
        <parameters>
          <parameter name="dataValue" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="falseValue" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveColumn" scope="instance">
        <parameters>
          <parameter name="sourceViewIndex" type="Object" usage="required"/>
          <parameter name="destViewIndex" type="Object" usage="required"/>
          <parameter name="cellIndex" type="Object" usage="required"/>
          <parameter name="targetIndex" type="Object" usage="required"/>
          <parameter name="before" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_setupData" scope="instance"/>
      <method name="setFilter" scope="instance">
        <parameters>
          <parameter name="rules" type="Object" usage="required"/>
          <parameter name="ruleRelation" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFilter" scope="instance"/>
      <method name="getColumnLabelByValue" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getConditionLabelByValue" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="c" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addCriteriaBoxes" scope="instance">
        <parameters>
          <parameter name="cnt" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="removeCriteriaBoxes" scope="instance">
        <parameters>
          <parameter name="cnt" type="int|CriteriaBox|Array&lt;int&gt;" usage="required"/>
          <parameter name="isIdx" type="bool" usage="optional"/>
        </parameters>
      </method>
      <method name="getCriteria" scope="instance">
        <parameters>
          <parameter name="idx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="getExprForCriteria" scope="instance">
        <parameters>
          <parameter name="rule" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getExprForColumn" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="colIdx" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnType" scope="instance">
        <parameters>
          <parameter name="colIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="clearFilter" scope="instance">
        <parameters>
          <parameter name="noRefresh" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="showDialog" scope="instance">
        <parameters>
          <parameter name="colIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="closeDialog" scope="instance"/>
      <method name="onFilter" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClearFilter" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRendered" scope="instance">
        <parameters>
          <parameter name="cbox" type="Current" usage="required">
            <description>visible criteria box</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onSetFilter" scope="instance">
        <parameters>
          <parameter name="filterDef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_prepareDialog" scope="instance">
        <parameters>
          <parameter name="colIndex" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_defineFilter" scope="instance"/>
      <method name="_updateCBoxTitles" scope="instance"/>
      <method name="_updatePane" scope="instance"/>
      <method name="canFilter" scope="instance"/>
      <method name="_closeDlgAndUpdateGrid" scope="instance"/>
    </methods>
    <properties>
      <property name="curColIdx" scope="instance" type="Number"/>
      <property name="_relOpCls" scope="instance" type="String"/>
      <property name="_savedCriterias" scope="instance" type="Object"/>
      <property name="_defPane" scope="instance-prototype" type="Object"/>
      <property name="builder" scope="instance-prototype" type="Object"/>
      <property name="_dataTypeMap" scope="instance" type="Object"/>
      <property name="_clearWithoutRefresh" scope="instance" type="Object"/>
      <property name="__alreadyResizedForIE6" scope="instance" type="Object"/>
      <property name="_criteriasChanged" scope="instance" type="bool"/>
      <property name="defaultType" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.plugin">
    <properties>
      <property name="nls" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.plugin.grid">
    <properties>
      <property name="setFilter" scope="instance" type="Object"/>
      <property name="getFilter" scope="instance" type="Object"/>
      <property name="getFilterRelation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.filterDefPane">
    <properties>
      <property name="cboxContainer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.plugin.args">
    <properties>
      <property name="ruleCount" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog._cboxes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefDialog.filterDefPane.criteriaPane">
    <properties>
      <property name="scrollTop" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefPane" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="_onRelSelectChange" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onAddCBox" scope="instance"/>
      <method name="_onCancel" scope="instance"/>
      <method name="_onClearFilter" scope="instance"/>
      <method name="_onFilter" scope="instance"/>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_addRuleBtnLabel" scope="instance" type="Object"/>
      <property name="_cancelBtnLabel" scope="instance" type="Object"/>
      <property name="_clearBtnLabel" scope="instance" type="Object"/>
      <property name="_filterBtnLabel" scope="instance" type="Object"/>
      <property name="_relAll" scope="instance" type="Object"/>
      <property name="_relAny" scope="instance" type="Object"/>
      <property name="_relMsgFront" scope="instance" type="Object"/>
      <property name="_relMsgTail" scope="instance" type="Object"/>
      <property name="cboxContainer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefPane.plugin">
    <properties>
      <property name="nls" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterDefPane.dlg">
    <properties>
      <property name="_relOpCls" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_getColumnOptions" scope="instance"/>
      <method name="onMoveColumn" scope="instance"/>
      <method name="_onChangeColumn" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRemove" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="_showSelectOrLabel" scope="instance">
        <parameters>
          <parameter name="sel" type="Object" usage="required"/>
          <parameter name="alt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onChangeCondition" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateValueBox" scope="instance">
        <parameters>
          <parameter name="cond" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_checkValidCriteria" scope="instance"/>
      <method name="_createValueBox" scope="instance">
        <parameters>
          <parameter name="cls" type="widget" usage="required">
            <description>constructor</description>
          </parameter>
          <parameter name="arg" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_createRangeBox" scope="instance">
        <parameters>
          <parameter name="cls" type="widget" usage="required">
            <description>constructor</description>
          </parameter>
          <parameter name="arg" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="changeCurrentColumn" scope="instance">
        <parameters>
          <parameter name="selectCurCol" type="bool" usage="required"/>
        </parameters>
      </method>
      <method name="curColumn" scope="instance"/>
      <method name="curCondition" scope="instance"/>
      <method name="curValue" scope="instance"/>
      <method name="save" scope="instance"/>
      <method name="load" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getExpr" scope="instance"/>
      <method name="isEmpty" scope="instance"/>
      <method name="updateRuleTitle" scope="instance">
        <parameters>
          <parameter name="isEmpty" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRuleIndex" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setAriaInfo" scope="instance">
        <parameters>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getUsableConditions" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setConditionsByType" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueBoxByType" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueBoxArgByType" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="formatValue" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="cond" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueBoxClsInfo" scope="instance">
        <parameters>
          <parameter name="colIndex" type="int|string" usage="required"/>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_curValueBox" scope="instance" type="Object"/>
      <property name="_colSelectLabel" scope="instance" type="Object"/>
      <property name="_condSelectLabel" scope="instance" type="Object"/>
      <property name="_valueBoxLabel" scope="instance" type="Object"/>
      <property name="_anyColumnOption" scope="instance" type="Object"/>
      <property name="_colOptions" scope="instance" type="Object"/>
      <property name="_isRange" scope="instance" type="Object"/>
      <property name="_ruleIndex" scope="instance" type="Object"/>
      <property name="_index" scope="instance" type="Object"/>
      <property name="_condSelect" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox.plugin">
    <properties>
      <property name="nls" scope="instance" type="Object"/>
      <property name="grid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox.dlg">
    <properties>
      <property name="curColIdx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox._pane._buttonWidget"/>
  <class type="dojox.grid.enhanced.plugins.filter.CriteriaBox._pane._buttonWidget.titleTextNode">
    <properties>
      <property name="title" scope="instance" type="Object"/>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.AccordionContainer" superclass="dijit.layout.AccordionContainer">
    <methods>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="fromTitle" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_modifyChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="isFirst" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hackHeight" scope="instance">
        <parameters>
          <parameter name="toGrow" type="bool" usage="required"/>
          <parameter name="heightDif" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_setupTitleDom" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.AccordionContainer" scope="instance"/>
    </mixins>
    <properties>
      <property name="nls" scope="instance" type="Object"/>
      <property name="_focusOnRemoveBtn" scope="instance" type="bool"/>
      <property name="_titleHeight" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.AccordionContainer.domNode.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.UniqueComboBox" superclass="dijit.form.ComboBox">
    <methods>
      <method name="_openResultList" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form.ComboBox" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="searchAttr" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.BooleanValueBox" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="onChange" scope="instance"/>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <parameters>
          <parameter name="prop" type="Object" usage="required"/>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="_baseId" scope="instance" type="Object"/>
      <property name="_lblTrue" scope="instance" type="String"/>
      <property name="_lblFalse" scope="instance" type="String"/>
      <property name="args" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._FilterLayerMixin">
    <methods>
      <method name="filterDef" scope="instance">
        <parameters>
          <parameter name="filter" type="_ConditionExpr|null)" usage="optional">
            <description>null: clear filter definition
	undefined: it's getter</description>
          </parameter>
        </parameters>
        <return-description>A filter definition if it's getter.</return-description>
      </method>
      <method name="name" scope="instance">
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="onFilterDefined" scope="instance">
        <parameters>
          <parameter name="filter" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFiltered" scope="instance">
        <parameters>
          <parameter name="filteredSize" type="Integer" usage="required">
            <description>The number of remaining fetched items after filtering.</description>
          </parameter>
          <parameter name="totalSize" type="Integer" usage="required">
            <description>The number of original fetched items.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_filter" scope="instance" type="_ConditionExpr">
        <description>The filter definition</description>
      </property>
      <property name="tags" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ServerSideFilterLayer" superclass="dojox.grid.enhanced.plugins._ServerSideLayer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filterDef" scope="instance">
        <parameters>
          <parameter name="filter" type="(_ConditionExpr|null)" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
      <method name="onCommandLoad" scope="instance">
        <parameters>
          <parameter name="responce" type="string" usage="required"/>
          <parameter name="userRequest" type="(in|out)keywordArgs" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._FilterLayerMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins._ServerSideLayer" scope="instance"/>
      <mixin type="dojox.grid.enhanced.plugins.filter._FilterLayerMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_filter" scope="instance" type="Object"/>
      <property name="_filteredSize" scope="instance" type="Object"/>
      <property name="_onUserCommandLoad" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ClientSideFilterLayer" superclass="dojox.grid.enhanced.plugins._StoreLayer">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_defaultGetter" scope="instance">
        <parameters>
          <parameter name="datarow" type="Object" usage="required"/>
          <parameter name="colName" type="Object" usage="required"/>
          <parameter name="rowIndex" type="Object" usage="required"/>
          <parameter name="store" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filterDef" scope="instance">
        <parameters>
          <parameter name="filter" type="(_ConditionExpr|null)" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
      <method name="setGetter" scope="instance">
        <parameters>
          <parameter name="getter" type="function" usage="required">
            <description>function(datarow, colArg, rowIndex, store);</description>
          </parameter>
        </parameters>
      </method>
      <method name="fetchAllOnFirstFilter" scope="instance">
        <parameters>
          <parameter name="toFetchAll" type="bool" usage="optional">
            <description>boolean If provided, it's a set function, otherwise it's a get function.</description>
          </parameter>
        </parameters>
        <return-description>Whether fetch all on first filter if this is a getter</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="invalidate" scope="instance"/>
      <method name="_fetch" scope="instance">
        <parameters>
          <parameter name="userRequest" type="Object" usage="required"/>
          <parameter name="filterRequest" type="dojo.data.api.Request" usage="required">
            <description>The actual request used in store.fetch.
	This function is called recursively to fill the result store items
	until the user specified item count is reached. Only in recursive calls,
	this parameter is valid.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_hasReachedStoreEnd" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_applyFilter" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="rowIndex" type="Integer" usage="required"/>
        </parameters>
        <return-description>whether this row survived the filter.</return-description>
      </method>
      <method name="_doFilter" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="startIdx" type="Integer" usage="required"/>
          <parameter name="userRequest" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchBegin" scope="instance">
        <parameters>
          <parameter name="size" type="Integer" usage="required"/>
          <parameter name="req" type="request" usage="required">
            <description>object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_completeQuery" scope="instance">
        <parameters>
          <parameter name="userRequest" type="request" usage="required">
            <description>object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addCachedItems" scope="instance">
        <parameters>
          <parameter name="items" type="Array" usage="required">
            <description>Data items to add.</description>
          </parameter>
          <parameter name="filterStartIdx" type="Integer" usage="required">
            <description>The start point to insert in the cache.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMappingChange" scope="instance">
        <parameters>
          <parameter name="mapping" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._FilterLayerMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins._StoreLayer" scope="instance"/>
      <mixin type="dojox.grid.enhanced.plugins.filter._FilterLayerMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_result" scope="instance" type="Array">
        <description>Current fetch result</description>
      </property>
      <property name="_resultStartIdx" scope="instance" type="Integer">
        <description>The index in cache of the first result item</description>
      </property>
      <property name="_indexMap" scope="instance" type="Array">
        <description>A map from the row index of this._items to the row index of the original store.</description>
      </property>
      <property name="_getter" scope="instance-prototype" type="Function(datarow)">
        <description>colArg, rowIndex, store);
	A user defined way to get data from store</description>
      </property>
      <property name="_nextUnfetchedIdx" scope="instance" type="Integer">
        <description>The index of the next item in the store that is never fetched.</description>
      </property>
      <property name="_storeSize" scope="instance" type="Integer">
        <description>The actual size of the original store</description>
      </property>
      <property name="_fetchAll" scope="instance" type="bool"/>
      <property name="_filter" scope="instance" type="Object"/>
      <property name="_lastSortInfo" scope="instance" type="Object"/>
      <property name="_store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.ClientSideFilterLayer._items">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="showDialog" scope="instance">
        <parameters>
          <parameter name="pos_x" type="int" usage="required"/>
          <parameter name="pos_y" type="int" usage="required"/>
          <parameter name="columnIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="closeDialog" scope="instance"/>
      <method name="_updateStatus" scope="instance">
        <parameters>
          <parameter name="columnIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createStatusDetail" scope="instance"/>
      <method name="_addButtonForRules" scope="instance"/>
      <method name="_getCriteriaStr" scope="instance">
        <parameters>
          <parameter name="c" type="object" usage="required"/>
          <parameter name="rowIdx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_modifyFilter" scope="instance"/>
    </methods>
    <properties>
      <property name="_pos" scope="instance" type="Object"/>
      <property name="_removedCriterias" scope="instance-prototype" type="Array"/>
      <property name="_rules" scope="instance-prototype" type="Array"/>
      <property name="statusPane" scope="instance-prototype" type="Object"/>
      <property name="_statusHeader" scope="instance" type="Object"/>
      <property name="_dlg" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.plugin">
    <properties>
      <property name="nls" scope="instance" type="Object"/>
      <property name="filterDefDialog" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusTitle">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusRel">
    <properties>
      <property name="innerHTML" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusRelPre">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusRelPost">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusTip.statusPane.statusDetailNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.FilterStatusPane" superclass="dijit._Widget">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._ConditionExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>object A data item of a store.</description>
          </parameter>
          <parameter name="getter" type="Function(row,colArg))" usage="required">
            <description>function(datarow, colArg)
	A user defined function that extract cell data from *datarow*.
	*colArg* is an argument that provides a kind of column information.
	It is defined by user in the constructor of a _DataExpr object.</description>
          </parameter>
        </parameters>
        <return-description>MUST return a _ConditionExpr object</return-description>
      </method>
      <method name="toObject" scope="instance">
        <return-description>An object for serialization.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getName" scope="instance">
        <return-description>the name of this kind of expression</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._DataExpr" superclass="dojox.grid.enhanced.plugins.filter._ConditionExpr">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required">
            <description>If *isColumn* is a boolean true, then it should be a kind of column information, like field name
	or column index. Otherwise, it is regarded as a pure value, and the getValue method will simply
	return it.</description>
          </parameter>
          <parameter name="isColumn" type="bool" usage="optional">
            <description>boolean Optional. To specify whether this _DataExpr represents a column or a pure value.</description>
          </parameter>
          <parameter name="convertArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <return-description>the value of this data expression.</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
      <method name="toObject" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._ConditionExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
      <property name="_convertData" scope="instance-prototype" type="Object"/>
      <property name="_convertArgs" scope="instance" type="Object"/>
      <property name="_colArg" scope="instance" type="Object"/>
      <property name="_value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._OperatorExpr" superclass="dojox.grid.enhanced.plugins.filter._ConditionExpr">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="toObject" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._ConditionExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
      <property name="_operands" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._UniOpExpr" superclass="dojox.grid.enhanced.plugins.filter._OperatorExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colArg))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>object</description>
          </parameter>
          <parameter name="getter" type="Function(row,colArg))" usage="required"/>
        </parameters>
        <return-description>MUST return a _ConditionExpr object.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._OperatorExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter._BiOpExpr" superclass="dojox.grid.enhanced.plugins.filter._OperatorExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colArg))" usage="required"/>
        </parameters>
      </method>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>object</description>
          </parameter>
          <parameter name="getter" type="Function(row,colArg))" usage="required"/>
        </parameters>
        <return-description>MUST return a _ConditionExpr object.</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._OperatorExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.BooleanExpr" superclass="dojox.grid.enhanced.plugins.filter._DataExpr">
    <methods>
      <method name="_convertData" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._DataExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.StringExpr" superclass="dojox.grid.enhanced.plugins.filter._DataExpr">
    <methods>
      <method name="_convertData" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._DataExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.NumberExpr" superclass="dojox.grid.enhanced.plugins.filter._DataExpr">
    <methods>
      <method name="_convertDataToExpr" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._DataExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.DateExpr" superclass="dojox.grid.enhanced.plugins.filter._DataExpr">
    <methods>
      <method name="_convertData" scope="instance">
        <parameters>
          <parameter name="dataValue" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="toObject" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._DataExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
      <property name="_value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.TimeExpr" superclass="dojox.grid.enhanced.plugins.filter.DateExpr">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter.DateExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicAND" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicOR" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicXOR" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicNOT" superclass="dojox.grid.enhanced.plugins.filter._UniOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._UniOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicALL" superclass="dojox.grid.enhanced.plugins.filter._OperatorExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._OperatorExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LogicANY" superclass="dojox.grid.enhanced.plugins.filter._OperatorExpr">
    <methods>
      <method name="applyRow" scope="instance">
        <parameters>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._OperatorExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.EqualTo" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LessThan" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LessThanOrEqualTo" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LargerThan" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.LargerThanOrEqualTo" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.Contains" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.StartsWith" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.EndsWith" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.Matches" superclass="dojox.grid.enhanced.plugins.filter._BiOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="left_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="right_operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_ConditionExpr"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._BiOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.grid.enhanced.plugins.filter.IsEmpty" superclass="dojox.grid.enhanced.plugins.filter._UniOpExpr">
    <methods>
      <method name="_calculate" scope="instance">
        <parameters>
          <parameter name="operand" type="_ConditionExpr" usage="required"/>
          <parameter name="datarow" type="data" usage="required">
            <description>item</description>
          </parameter>
          <parameter name="getter" type="Function(row,colIdx))" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.grid.enhanced.plugins.filter._UniOpExpr" scope="instance"/>
    </mixins>
    <properties>
      <property name="_name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.help">
    <methods>
      <method name="locate" scope="instance">
        <description>Search for locally available data; variable names and any cached
	documentation results for matches containing our search parameter
	searchFor
	The string to search for.</description>
        <parameters>
          <parameter name="searchFor" type="String" usage="required"/>
          <parameter name="searchIn" type="String|Object|Array&lt;String&gt;|Array&lt;Object&gt;" usage="required">
            <description>The namespaces to search in. Defaults to dojox.help._namespaces</description>
          </parameter>
          <parameter name="maxResults" type="Number" usage="required">
            <description>The maximum number of results.</description>
          </parameter>
        </parameters>
      </method>
      <method name="refresh" scope="instance">
        <parameters>
          <parameter name="namespace" type="String" usage="optional">
            <description>The string-representation of a namespace.</description>
          </parameter>
          <parameter name="recursive" type="Boolean" usage="optional">
            <description>Whether to recurse through the namespace.</description>
          </parameter>
        </parameters>
      </method>
      <method name="noConflict" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="optional">
            <description>If you pass an item, only that item will be cleaned</description>
          </parameter>
        </parameters>
      </method>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="namespaces" type="Array&lt;String&gt;" usage="required">
            <description>Any namespaces to add to the default (dojox.help._namespaces)</description>
          </parameter>
          <parameter name="noConflict" type="Boolen" usage="optional">
            <description>Whether to start in noConflict mode</description>
          </parameter>
        </parameters>
      </method>
      <method name="_noConflict" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_clean" scope="instance">
        <parameters>
          <parameter name="self" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_displayLocated" scope="instance">
        <parameters>
          <parameter name="located" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_displayHelp" scope="instance">
        <parameters>
          <parameter name="loading" type="Object" usage="required"/>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_addVersion" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stripPrototype" scope="instance">
        <parameters>
          <parameter name="original" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="__toString" scope="instance"/>
      <method name="_recurse" scope="instance">
        <parameters>
          <parameter name="namespace" type="String" usage="optional"/>
          <parameter name="recursive" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="__recurse" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
          <parameter name="root" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
          <parameter name="recursive" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_plainText" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_namespaces" scope="instance" type="Array"/>
      <property name="_rpc" scope="instance" type="Object"/>
      <property name="_attributes" scope="instance" type="Array"/>
      <property name="_toStrings" scope="instance" type="Object"/>
      <property name="_overrides" scope="instance" type="Array"/>
      <property name="_recursions" scope="instance" type="Array"/>
      <property name="_names" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="console" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.help._help">
    <methods/>
    <properties>
      <property name="__name__" scope="instance" type="Object"/>
      <property name="__searched__" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.help._parse">
    <methods/>
    <properties>
      <property name="__parameters__" scope="instance" type="Object"/>
      <property name="__source__" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.help._toString">
    <methods/>
    <properties>
      <property name="__parameters__" scope="instance" type="Array"/>
      <property name="__searching__" scope="instance" type="Object"/>
      <property name="__output__" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight">
    <description>This project parses pre &gt; code nodes, and applies syntax highlighting for
	a wide variety of languages. Simply dojo.require() in all the
	dojox.highlight.languages you wish to include in your highlighingting,
	and customize colors in the highlight.css.
	It is provided as a dojo package, contributed under CLA
	by Ivan Sagalaev and is available originally from:
	http://softwaremaniacs.org/soft/highlight/en/</description>
    <methods>
      <method name="processString" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="lang" type="String" usage="optional"/>
        </parameters>
        <return-description>Object containing:
	result - string of html with spans to apply formatting
	partialResult - if the formating failed: string of html
	up to the point of the failure, otherwise: undefined
	langName - the language used to do the formatting</return-description>
      </method>
      <method name="init" scope="instance">
        <description>Syntax highlight a passed DomNode or String ID of a DomNode</description>
        <examples>
          <example>	dojox.highlight.init("someId");</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="stop iterations"/>
          <return-type type="continue iterations"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants">
    <properties>
      <property name="IDENT_RE" scope="instance" type="String"/>
      <property name="UNDERSCORE_IDENT_RE" scope="instance" type="String"/>
      <property name="NUMBER_RE" scope="instance" type="String"/>
      <property name="C_NUMBER_RE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.APOS_STRING_MODE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
      <property name="relevance" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.QUOTE_STRING_MODE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
      <property name="relevance" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.BACKSLASH_ESCAPE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
      <property name="relevance" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.C_LINE_COMMENT_MODE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
      <property name="relevance" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.C_BLOCK_COMMENT_MODE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.HASH_COMMENT_MODE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="String"/>
      <property name="end" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.highlight.constants.C_NUMBER_MODE">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="begin" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="String"/>
      <property name="relevance" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.Code">
    <methods/>
    <properties>
      <property name="node" scope="instance" type="String|DomNode">
        <description>A String ID or DomNode reference to use as the root node of this instance.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.highlight.languages">
    <properties>
      <property name="_all" scope="instance" type="Object"/>
      <property name="_dynamic" scope="instance" type="Object"/>
      <property name="_static" scope="instance" type="Object"/>
      <property name="_www" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.cpp">
    <properties>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.cpp.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.cpp.defaultMode.keywords">
    <properties>
      <property name="false" scope="instance" type="Number"/>
      <property name="int" scope="instance" type="Number"/>
      <property name="float" scope="instance" type="Number"/>
      <property name="while" scope="instance" type="Number"/>
      <property name="private" scope="instance" type="Number"/>
      <property name="char" scope="instance" type="Number"/>
      <property name="catch" scope="instance" type="Number"/>
      <property name="export" scope="instance" type="Number"/>
      <property name="virtual" scope="instance" type="Number"/>
      <property name="operator" scope="instance" type="Number"/>
      <property name="sizeof" scope="instance" type="Number"/>
      <property name="dynamic_cast" scope="instance" type="Number"/>
      <property name="typedef" scope="instance" type="Number"/>
      <property name="const_cast" scope="instance" type="Number"/>
      <property name="const" scope="instance" type="Number"/>
      <property name="struct" scope="instance" type="Number"/>
      <property name="for" scope="instance" type="Number"/>
      <property name="static_cast" scope="instance" type="Number"/>
      <property name="union" scope="instance" type="Number"/>
      <property name="namespace" scope="instance" type="Number"/>
      <property name="unsigned" scope="instance" type="Number"/>
      <property name="long" scope="instance" type="Number"/>
      <property name="throw" scope="instance" type="Number"/>
      <property name="volatile" scope="instance" type="Number"/>
      <property name="static" scope="instance" type="Number"/>
      <property name="protected" scope="instance" type="Number"/>
      <property name="bool" scope="instance" type="Number"/>
      <property name="template" scope="instance" type="Number"/>
      <property name="mutable" scope="instance" type="Number"/>
      <property name="if" scope="instance" type="Number"/>
      <property name="public" scope="instance" type="Number"/>
      <property name="friend" scope="instance" type="Number"/>
      <property name="do" scope="instance" type="Number"/>
      <property name="return" scope="instance" type="Number"/>
      <property name="goto" scope="instance" type="Number"/>
      <property name="auto" scope="instance" type="Number"/>
      <property name="void" scope="instance" type="Number"/>
      <property name="enum" scope="instance" type="Number"/>
      <property name="else" scope="instance" type="Number"/>
      <property name="break" scope="instance" type="Number"/>
      <property name="new" scope="instance" type="Number"/>
      <property name="extern" scope="instance" type="Number"/>
      <property name="using" scope="instance" type="Number"/>
      <property name="true" scope="instance" type="Number"/>
      <property name="class" scope="instance" type="Number"/>
      <property name="asm" scope="instance" type="Number"/>
      <property name="case" scope="instance" type="Number"/>
      <property name="typeid" scope="instance" type="Number"/>
      <property name="short" scope="instance" type="Number"/>
      <property name="reinterpret_cast" scope="instance" type="Number"/>
      <property name="default" scope="instance" type="Number"/>
      <property name="double" scope="instance" type="Number"/>
      <property name="register" scope="instance" type="Number"/>
      <property name="explicit" scope="instance" type="Number"/>
      <property name="signed" scope="instance" type="Number"/>
      <property name="typename" scope="instance" type="Number"/>
      <property name="try" scope="instance" type="Number"/>
      <property name="this" scope="instance" type="Number"/>
      <property name="switch" scope="instance" type="Number"/>
      <property name="continue" scope="instance" type="Number"/>
      <property name="wchar_t" scope="instance" type="Number"/>
      <property name="inline" scope="instance" type="Number"/>
      <property name="delete" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.css">
    <properties>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.css.defaultMode">
    <properties>
      <property name="contains" scope="instance" type="Array"/>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="illegal" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.delphi">
    <properties>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.delphi.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.django">
    <properties>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.django.defaultMode">
    <properties>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.groovy">
    <properties>
      <property name="modes" scope="instance" type="Array"/>
      <property name="GROOVY_KEYWORDS" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.groovy.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.html">
    <properties>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="modes" scope="instance" type="Array"/>
      <property name="HTML_TAGS" scope="instance" type="Object"/>
      <property name="HTML_DOCTYPE" scope="instance" type="Object"/>
      <property name="HTML_ATTR" scope="instance" type="Object"/>
      <property name="HTML_VALUE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.html.defaultMode">
    <properties>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.java">
    <properties>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.java.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript">
    <properties>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords"/>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.keyword">
    <properties>
      <property name="in" scope="instance" type="Number"/>
      <property name="if" scope="instance" type="Number"/>
      <property name="for" scope="instance" type="Number"/>
      <property name="while" scope="instance" type="Number"/>
      <property name="finally" scope="instance" type="Number"/>
      <property name="var" scope="instance" type="Number"/>
      <property name="new" scope="instance" type="Number"/>
      <property name="function" scope="instance" type="Number"/>
      <property name="do" scope="instance" type="Number"/>
      <property name="return" scope="instance" type="Number"/>
      <property name="void" scope="instance" type="Number"/>
      <property name="else" scope="instance" type="Number"/>
      <property name="break" scope="instance" type="Number"/>
      <property name="catch" scope="instance" type="Number"/>
      <property name="instanceof" scope="instance" type="Number"/>
      <property name="with" scope="instance" type="Number"/>
      <property name="throw" scope="instance" type="Number"/>
      <property name="case" scope="instance" type="Number"/>
      <property name="default" scope="instance" type="Number"/>
      <property name="try" scope="instance" type="Number"/>
      <property name="this" scope="instance" type="Number"/>
      <property name="switch" scope="instance" type="Number"/>
      <property name="continue" scope="instance" type="Number"/>
      <property name="typeof" scope="instance" type="Number"/>
      <property name="delete" scope="instance" type="Number"/>
      <property name="const" scope="instance" type="Number"/>
      <property name="label" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.literal">
    <properties>
      <property name="true" scope="instance" type="Number"/>
      <property name="false" scope="instance" type="Number"/>
      <property name="null" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.pygments._html"/>
  <class type="dojox.highlight.languages.pygments._html.tags">
    <properties>
      <property name="code" scope="instance" type="Number"/>
      <property name="kbd" scope="instance" type="Number"/>
      <property name="font" scope="instance" type="Number"/>
      <property name="noscript" scope="instance" type="Number"/>
      <property name="style" scope="instance" type="Number"/>
      <property name="img" scope="instance" type="Number"/>
      <property name="title" scope="instance" type="Number"/>
      <property name="menu" scope="instance" type="Number"/>
      <property name="tt" scope="instance" type="Number"/>
      <property name="tr" scope="instance" type="Number"/>
      <property name="param" scope="instance" type="Number"/>
      <property name="li" scope="instance" type="Number"/>
      <property name="tfoot" scope="instance" type="Number"/>
      <property name="th" scope="instance" type="Number"/>
      <property name="input" scope="instance" type="Number"/>
      <property name="td" scope="instance" type="Number"/>
      <property name="dl" scope="instance" type="Number"/>
      <property name="blockquote" scope="instance" type="Number"/>
      <property name="fieldset" scope="instance" type="Number"/>
      <property name="big" scope="instance" type="Number"/>
      <property name="dd" scope="instance" type="Number"/>
      <property name="abbr" scope="instance" type="Number"/>
      <property name="optgroup" scope="instance" type="Number"/>
      <property name="dt" scope="instance" type="Number"/>
      <property name="button" scope="instance" type="Number"/>
      <property name="isindex" scope="instance" type="Number"/>
      <property name="p" scope="instance" type="Number"/>
      <property name="small" scope="instance" type="Number"/>
      <property name="div" scope="instance" type="Number"/>
      <property name="dir" scope="instance" type="Number"/>
      <property name="em" scope="instance" type="Number"/>
      <property name="frame" scope="instance" type="Number"/>
      <property name="meta" scope="instance" type="Number"/>
      <property name="sub" scope="instance" type="Number"/>
      <property name="bdo" scope="instance" type="Number"/>
      <property name="label" scope="instance" type="Number"/>
      <property name="acronym" scope="instance" type="Number"/>
      <property name="sup" scope="instance" type="Number"/>
      <property name="body" scope="instance" type="Number"/>
      <property name="xml" scope="instance" type="Number"/>
      <property name="basefont" scope="instance" type="Number"/>
      <property name="base" scope="instance" type="Number"/>
      <property name="br" scope="instance" type="Number"/>
      <property name="address" scope="instance" type="Number"/>
      <property name="strong" scope="instance" type="Number"/>
      <property name="legend" scope="instance" type="Number"/>
      <property name="ol" scope="instance" type="Number"/>
      <property name="script" scope="instance" type="Number"/>
      <property name="caption" scope="instance" type="Number"/>
      <property name="s" scope="instance" type="Number"/>
      <property name="col" scope="instance" type="Number"/>
      <property name="h2" scope="instance" type="Number"/>
      <property name="h3" scope="instance" type="Number"/>
      <property name="h1" scope="instance" type="Number"/>
      <property name="h6" scope="instance" type="Number"/>
      <property name="h4" scope="instance" type="Number"/>
      <property name="h5" scope="instance" type="Number"/>
      <property name="table" scope="instance" type="Number"/>
      <property name="select" scope="instance" type="Number"/>
      <property name="noframes" scope="instance" type="Number"/>
      <property name="span" scope="instance" type="Number"/>
      <property name="area" scope="instance" type="Number"/>
      <property name="dfn" scope="instance" type="Number"/>
      <property name="strike" scope="instance" type="Number"/>
      <property name="cite" scope="instance" type="Number"/>
      <property name="thead" scope="instance" type="Number"/>
      <property name="head" scope="instance" type="Number"/>
      <property name="option" scope="instance" type="Number"/>
      <property name="form" scope="instance" type="Number"/>
      <property name="hr" scope="instance" type="Number"/>
      <property name="var" scope="instance" type="Number"/>
      <property name="link" scope="instance" type="Number"/>
      <property name="b" scope="instance" type="Number"/>
      <property name="colgroup" scope="instance" type="Number"/>
      <property name="ul" scope="instance" type="Number"/>
      <property name="applet" scope="instance" type="Number"/>
      <property name="del" scope="instance" type="Number"/>
      <property name="iframe" scope="instance" type="Number"/>
      <property name="pre" scope="instance" type="Number"/>
      <property name="frameset" scope="instance" type="Number"/>
      <property name="ins" scope="instance" type="Number"/>
      <property name="tbody" scope="instance" type="Number"/>
      <property name="html" scope="instance" type="Number"/>
      <property name="samp" scope="instance" type="Number"/>
      <property name="map" scope="instance" type="Number"/>
      <property name="object" scope="instance" type="Number"/>
      <property name="a" scope="instance" type="Number"/>
      <property name="xmlns" scope="instance" type="Number"/>
      <property name="center" scope="instance" type="Number"/>
      <property name="textarea" scope="instance" type="Number"/>
      <property name="i" scope="instance" type="Number"/>
      <property name="q" scope="instance" type="Number"/>
      <property name="u" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.pygments">
    <properties>
      <property name="_www" scope="instance" type="Object"/>
      <property name="css" scope="instance" type="Object"/>
      <property name="html" scope="instance" type="Object"/>
      <property name="javascript" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.css.defaultMode.keywords">
    <properties>
      <property name="name tag" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.css.defaultMode.keywords.keyword">
    <properties>
      <property name="@media" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.keyword constant">
    <properties>
      <property name="true" scope="instance" type="Number"/>
      <property name="false" scope="instance" type="Number"/>
      <property name="null" scope="instance" type="Number"/>
      <property name="NaN" scope="instance" type="Number"/>
      <property name="Infinity" scope="instance" type="Number"/>
      <property name="undefined" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.name builtin">
    <properties>
      <property name="Array" scope="instance" type="Number"/>
      <property name="Boolean" scope="instance" type="Number"/>
      <property name="Date" scope="instance" type="Number"/>
      <property name="Error" scope="instance" type="Number"/>
      <property name="Function" scope="instance" type="Number"/>
      <property name="Math" scope="instance" type="Number"/>
      <property name="netscape" scope="instance" type="Number"/>
      <property name="Number" scope="instance" type="Number"/>
      <property name="Object" scope="instance" type="Number"/>
      <property name="Packages" scope="instance" type="Number"/>
      <property name="RegExp" scope="instance" type="Number"/>
      <property name="String" scope="instance" type="Number"/>
      <property name="sun" scope="instance" type="Number"/>
      <property name="decodeURI" scope="instance" type="Number"/>
      <property name="decodeURIComponent" scope="instance" type="Number"/>
      <property name="encodeURI" scope="instance" type="Number"/>
      <property name="encodeURIComponent" scope="instance" type="Number"/>
      <property name="eval" scope="instance" type="Number"/>
      <property name="isFinite" scope="instance" type="Number"/>
      <property name="isNaN" scope="instance" type="Number"/>
      <property name="parseFloat" scope="instance" type="Number"/>
      <property name="parseInt" scope="instance" type="Number"/>
      <property name="document" scope="instance" type="Number"/>
      <property name="window" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.javascript.defaultMode.keywords.name builtin pseudo">
    <properties>
      <property name="this" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.pygments.xml">
    <properties>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xml">
    <properties>
      <property name="modes" scope="instance" type="Array"/>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="XML_COMMENT" scope="instance" type="Object"/>
      <property name="XML_ATTR" scope="instance" type="Object"/>
      <property name="XML_VALUE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xml.defaultMode">
    <properties>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.python">
    <properties>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.python.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="illegal" scope="instance" type="String"/>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.python.defaultMode.keywords">
    <properties>
      <property name="and" scope="instance" type="Number"/>
      <property name="elif" scope="instance" type="Number"/>
      <property name="is" scope="instance" type="Number"/>
      <property name="global" scope="instance" type="Number"/>
      <property name="as" scope="instance" type="Number"/>
      <property name="in" scope="instance" type="Number"/>
      <property name="if" scope="instance" type="Number"/>
      <property name="from" scope="instance" type="Number"/>
      <property name="raise" scope="instance" type="Number"/>
      <property name="for" scope="instance" type="Number"/>
      <property name="except" scope="instance" type="Number"/>
      <property name="finally" scope="instance" type="Number"/>
      <property name="print" scope="instance" type="Number"/>
      <property name="import" scope="instance" type="Number"/>
      <property name="pass" scope="instance" type="Number"/>
      <property name="None" scope="instance" type="Number"/>
      <property name="return" scope="instance" type="Number"/>
      <property name="exec" scope="instance" type="Number"/>
      <property name="else" scope="instance" type="Number"/>
      <property name="break" scope="instance" type="Number"/>
      <property name="not" scope="instance" type="Number"/>
      <property name="with" scope="instance" type="Number"/>
      <property name="class" scope="instance" type="Number"/>
      <property name="assert" scope="instance" type="Number"/>
      <property name="yield" scope="instance" type="Number"/>
      <property name="try" scope="instance" type="Number"/>
      <property name="while" scope="instance" type="Number"/>
      <property name="continue" scope="instance" type="Number"/>
      <property name="del" scope="instance" type="Number"/>
      <property name="or" scope="instance" type="Number"/>
      <property name="def" scope="instance" type="Number"/>
      <property name="lambda" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.sql">
    <properties>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="modes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.sql.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.sql.defaultMode.keywords">
    <properties>
      <property name="keyword" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.sql.defaultMode.keywords.aggregate">
    <properties>
      <property name="count" scope="instance" type="Number"/>
      <property name="sum" scope="instance" type="Number"/>
      <property name="min" scope="instance" type="Number"/>
      <property name="max" scope="instance" type="Number"/>
      <property name="avg" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xquery">
    <properties>
      <property name="case_insensitive" scope="instance" type="Object"/>
      <property name="modes" scope="instance" type="Array"/>
      <property name="XQUERY_COMMENT" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xquery.defaultMode">
    <properties>
      <property name="lexems" scope="instance" type="Array"/>
      <property name="contains" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.highlight.languages.xquery.defaultMode.keywords">
    <properties>
      <property name="keyword" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="highlight"/>
  <class type="highlight.Code" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_populate" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRange" scope="instance">
        <parameters>
          <parameter name="range" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_updateView" scope="instance"/>
      <method name="_loadError" scope="instance">
        <parameters>
          <parameter name="error" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance" type="String"/>
      <property name="range" scope="instance" type="Object"/>
      <property name="style" scope="instance" type="String"/>
      <property name="listType" scope="instance" type="String"/>
      <property name="lang" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_lines" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="highlight.Code.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.highlight.widget">
    <properties>
      <property name="Code" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html">
    <methods>
      <method name="_adjustCssPaths" scope="instance">
        <description>Say we fetch a HTML page from level1/page.html
	It has some inline CSS:
	@import "css/page.css" tv, screen;
	...
	background-image: url(images/aplhaimage.png);
	as we fetched this HTML and therefore this CSS
	from level1/page.html, these paths needs to be adjusted to:
	@import 'level1/css/page.css' tv, screen;
	...
	background-image: url(level1/images/alphaimage.png);
	In IE it will also adjust relative paths in AlphaImageLoader()
	filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='images/alphaimage.png');
	will be adjusted to:
	filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='level1/images/alphaimage.png');
	Please note that any relative paths in AlphaImageLoader in external css files wont work, as
	the paths in AlphaImageLoader is MUST be declared relative to the HTML page,
	not relative to the CSS file that declares it</description>
        <parameters>
          <parameter name="cssUrl" type="Object" usage="required"/>
          <parameter name="cssText" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustHtmlPaths" scope="instance">
        <parameters>
          <parameter name="htmlUrl" type="Object" usage="required"/>
          <parameter name="cont" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_snarfStyles" scope="instance">
        <parameters>
          <parameter name="cssUrl" type="String" usage="required"/>
          <parameter name="cont" type="String" usage="required"/>
          <parameter name="styles" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_snarfScripts" scope="instance">
        <parameters>
          <parameter name="cont" type="Object" usage="required"/>
          <parameter name="byRef" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="evalInGlobal" scope="instance">
        <parameters>
          <parameter name="code" type="Object" usage="required"/>
          <parameter name="appendNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="instance">
        <examples>
          <example>A safe string/node/nodelist content replacement/injection with hooks for extension
	Example Usage:
	dojo.html.set(node, "some string");
	dojo.html.set(node, contentNode, {options});
	dojo.html.set(node, myNode.childNodes, {options});</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>the parent element that will receive the content</description>
          </parameter>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required">
            <description>the content to be set on the parent element.
	This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes</description>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <description>Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter</description>
          </parameter>
        </parameters>
      </method>
      <method name="insertCssRule" scope="instance">
        <parameters>
          <parameter name="selector" type="String" usage="required">
            <description>A fully qualified class name, as it would appear in
	a CSS dojo.doc. Start classes with periods, target
	nodes with '#'. Large selectors can also be created
	like:
	 &amp;quot;#myDiv.myClass span input&amp;quot;</description>
          </parameter>
          <parameter name="declaration" type="String" usage="required">
            <description>A single string that would make up a style block, not
	including the curly braces. Include semi-colons between
	statements. Do not use JavaScript style declarations
	in camel case, use as you would in a CSS dojo.doc:
	 &amp;quot;color:#ffoooo;font-size:12px;margin-left:5px;&amp;quot;</description>
          </parameter>
          <parameter name="styleSheetName" type="String" usage="required">
            <description>optional )
	Name of the dynamic style sheet this rule should be
	inserted into. If is not found by that name, it is
	created. If no name is passed, the name &amp;quot;default&amp;quot; is
	used.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="removeCssRule" scope="instance">
        <description>Only removes DYNAMICALLY created cssRules. If you
	created it with dojox.html.insertCssRule, it can be removed.</description>
        <parameters>
          <parameter name="selector" type="String" usage="required"/>
          <parameter name="declaration" type="String" usage="required"/>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getStyleSheet" scope="instance">
        <parameters>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="StyleSheet"/>
        </return-types>
      </method>
      <method name="getDynamicStyleSheet" scope="instance">
        <parameters>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="StyleSheet"/>
        </return-types>
      </method>
      <method name="enableStyleSheet" scope="instance">
        <parameters>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="disableStyleSheet" scope="instance">
        <parameters>
          <parameter name="styleSheetName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="activeStyleSheet" scope="instance">
        <description>If passed a title, enables a that style sheet. All other
	toggle-able style sheets are disabled.
	If no argument is passed, returns currently enabled
	style sheet.</description>
        <parameters>
          <parameter name="title" type="?String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="StyleSheet"/>
        </return-types>
      </method>
      <method name="getPreferredStyleSheet" scope="instance"/>
      <method name="getToggledStyleSheets" scope="instance">
        <return-description>An array of all toggle-able style sheets
	TODO: 	Sets of style sheets could be grouped according to
	an ID and used in sets, much like different
	groups of radio buttons. It would not however be
	according to W3C spec</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getStyleSheets" scope="instance">
        <return-description>An hash map of all the style sheets.
	TODO: 	Does not recursively search for @imports, so it will
	only go one level deep.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
      <property name="ellipsis" scope="instance" type="Object"/>
      <property name="styles" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html._ContentSetter" superclass="dojo.html._ContentSetter">
    <methods>
      <method name="_renderStyles" scope="instance">
        <parameters>
          <parameter name="styles" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="empty" scope="instance"/>
      <method name="onBegin" scope="instance"/>
      <method name="onEnd" scope="instance"/>
      <method name="tearDown" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.html._ContentSetter" scope="instance"/>
    </mixins>
    <properties>
      <property name="adjustPaths" scope="instance" type="Boolean">
        <description>Adjust relative paths in html string content to point to this page
	Only useful if you grab content from a another folder than the current one</description>
      </property>
      <property name="referencePath" scope="instance" type="String"/>
      <property name="renderStyles" scope="instance" type="bool"/>
      <property name="executeScripts" scope="instance" type="bool"/>
      <property name="scriptHasHooks" scope="instance" type="bool"/>
      <property name="scriptHookReplacement" scope="instance" type="Object"/>
      <property name="_styleNodes" scope="instance" type="Array"/>
      <property name="_styles" scope="instance" type="Array"/>
      <property name="_code" scope="instance" type="Object"/>
      <property name="content" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html._ContentSetter.node">
    <properties>
      <property name="ownerDocument" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html.entities">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="required">
            <description>The string to process for possible entity encoding.</description>
          </parameter>
          <parameter name="m" type="array" usage="optional">
            <description>An optional list of character to entity name mappings (array of
	arrays).  If not provided, it uses the and Latin entities as the
	set to map and escape.</description>
          </parameter>
        </parameters>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="required">
            <description>The string to process for possible entity encoding to decode.</description>
          </parameter>
          <parameter name="m" type="array" usage="optional">
            <description>An optional list of character to entity name mappings (array of
	arrays).  If not provided, it uses the HTML and Latin entities as the
	set to map and decode.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="html" scope="instance" type="Array"/>
      <property name="latin" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.html.ext-dojo.style">
    <methods>
      <method name="_notSupported" scope="instance"/>
      <method name="_setTransformOriginFilter" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="transformOrigin" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getTransformOriginFilter" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getTransformFilter" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="setTransform" scope="instance"/>
      <method name="setTransformOrigin" scope="instance"/>
    </methods>
    <properties>
      <property name="supportsTransform" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html.ext-dojo.style._toPx">
    <methods/>
    <properties>
      <property name="_conversion" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html.ext-dojo.style.init">
    <methods>
      <method name="setTransform" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="transform" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getTransform" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="setTransformOrigin" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="transformOrigin" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getTransformOrigin" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tPropertyName" scope="instance" type="String"/>
      <property name="toPropertyName" scope="instance" type="String"/>
      <property name="supportsTransform" scope="instance" type="bool"/>
      <property name="_conversion" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html.ext-dojo.style._setTransformFilter">
    <methods/>
    <properties>
      <property name="_toPx" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.html.ext-dojo"/>
  <class type="dojox.html.format">
    <methods>
      <method name="prettyPrint" scope="instance">
        <parameters>
          <parameter name="html" type="String" usage="required">
            <description>The string of HTML to try and generate a 'pretty' formatting.</description>
          </parameter>
          <parameter name="indentBy" type="Integer" usage="optional">
            <description>Optional input for the number of spaces to use when indenting.
	If not defined, zero, negative, or greater than 10, will just use tab
	as the indent.</description>
          </parameter>
          <parameter name="maxLineLength" type="Integer" usage="optional">
            <description>Optional input for the number of characters a text line should use in
	the document, including the indent if possible.</description>
          </parameter>
          <parameter name="map" type="Array" usage="optional">
            <description>Optional array of entity mapping characters to use when processing the
	HTML Text content.  By default it uses the default set used by the
	dojox.html.entities.encode function.</description>
          </parameter>
          <parameter name="xhtml" type="boolean" usage="required">
            <description>Optional parameter that declares that the returned HTML should try to be 'xhtml' compatible.
	This means normally unclosed tags are terminated with /&amp;gt; instead of &amp;gt;.  Example: &amp;lt;hr&amp;gt; -&amp;gt; &amp;lt;hr /&amp;gt;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.html.metrics">
    <methods>
      <method name="getFontMeasurements" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getCachedFontMeasurements" scope="instance">
        <parameters>
          <parameter name="recalculate" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextBox" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
          <parameter name="className" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getScrollbar" scope="instance"/>
      <method name="initOnFontResize" scope="instance">
        <parameters>
          <parameter name="interval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFontResize" scope="instance"/>
      <method name="_fontresize" scope="instance"/>
    </methods>
    <properties>
      <property name="_fontResizeNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image">
    <methods>
      <method name="preload" scope="instance">
        <examples>
          <example>Load two images into cache:
		dojox.image.preload(["foo.png", "bar.gif"]);</example>
          <example>Using djConfig:
		var djConfig = {
			preloadImages:["bar.png", "baz.png", "http://example.com/icon.gif"]
		};</example>
        </examples>
        <parameters>
          <parameter name="urls" type="Array" usage="required">
            <description>The list of urls to load. Can be any valid .src attribute.</description>
          </parameter>
        </parameters>
        <return-description>Array
	An Array of DomNodes that have been cached.</return-description>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.Badge" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_init" scope="instance"/>
      <method name="_getCell" scope="instance">
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getImage" scope="instance"/>
      <method name="_enbiggen" scope="instance">
        <parameters>
          <parameter name="e" type="Event|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_loadUnder" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_disenbiggen" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cycle" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="children" scope="instance" type="String">
        <description>A CSS3 Selector that determines the node to become a child</description>
      </property>
      <property name="rows" scope="instance" type="Integer">
        <description>Number of Rows to display</description>
      </property>
      <property name="cols" scope="instance" type="Integer">
        <description>Number of Columns to display</description>
      </property>
      <property name="cellSize" scope="instance" type="Integer">
        <description>Size in PX of each thumbnail</description>
      </property>
      <property name="cellMargin" scope="instance" type="Integer">
        <description>Size in PX to adjust for cell margins</description>
      </property>
      <property name="delay" scope="instance" type="Integer">
        <description>Time (in ms) to show the image before sizing down again</description>
      </property>
      <property name="threads" scope="instance" type="Integer">
        <description>how many cycles will be going &amp;quot;simultaneously&amp;quot; (&amp;gt;2 not reccommended)</description>
      </property>
      <property name="easing" scope="instance" type="Function|String">
        <description>An easing function to use when showing the node (does not apply to shrinking)</description>
      </property>
    </properties>
  </class>
  <class type="dojox.image.Badge._nl">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.FlickrBadge" superclass="dojox.image.Badge">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.image.Badge" scope="instance"/>
    </mixins>
    <properties>
      <property name="children" scope="instance" type="String"/>
      <property name="userid" scope="instance" type="String">
        <description>If you know your Flickr userid, you can set it to prevent a call to fetch the id</description>
      </property>
      <property name="username" scope="instance" type="String">
        <description>Your Flickr username</description>
      </property>
      <property name="setid" scope="instance" type="String">
        <description>The id of the set to display</description>
      </property>
      <property name="tags" scope="instance" type="String"/>
      <property name="searchText" scope="instance" type="String">
        <description>Free text search.  Photos who's title, description, or tags contain the text will be displayed</description>
      </property>
      <property name="target" scope="instance" type="String">
        <description>Where to display the pictures when clicked on.  Valid values are the same as the target attribute
	of the A tag.</description>
      </property>
      <property name="apikey" scope="instance" type="String"/>
      <property name="_store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.Gallery" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setDataStore" scope="instance">
        <parameters>
          <parameter name="dataStore" type="An" usage="required">
            <description>implementation of the dojo.data.api.Read API. This accesses the image
	data.</description>
          </parameter>
          <parameter name="request" type="An" usage="required">
            <description>implementation of the dojo.data.api.Request API. This specifies the
	query and paging information to be used by the data store</description>
          </parameter>
          <parameter name="paramNames" type="optional" usage="required">
            <description>An object defining the names of the item attributes to fetch from the
	data store.  The four attributes allowed are 'linkAttr', 'imageLargeAttr',
	'imageThumbAttr' and 'titleAttr'</description>
          </parameter>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="showNextImage" scope="instance">
        <parameters>
          <parameter name="inTimer" type="Boolean" usage="required">
            <description>If true, a slideshow is active, otherwise the slideshow is inactive.</description>
          </parameter>
        </parameters>
      </method>
      <method name="toggleSlideshow" scope="instance"/>
      <method name="toggleSlideShow" scope="instance"/>
      <method name="showImage" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="callback" type="optional" usage="required">
            <description>Function Optional callback function to call when the image has finished displaying.</description>
          </parameter>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_centerChildren" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="imageHeight" scope="instance" type="Number">
        <description>Maximum height of an image in the SlideShow widget</description>
      </property>
      <property name="imageWidth" scope="instance" type="Number">
        <description>Maximum width of an image in the SlideShow widget</description>
      </property>
      <property name="pageSize" scope="instance" type="Number">
        <description>The number of records to retrieve from the data store per request.</description>
      </property>
      <property name="autoLoad" scope="instance" type="Boolean">
        <description>If true, images are loaded before the user views them. If false, an
	image is loaded when the user displays it.</description>
      </property>
      <property name="linkAttr" scope="instance" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	URL to link to from an image, if any.</description>
      </property>
      <property name="imageThumbAttr" scope="instance" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	URL to the thumbnail image.</description>
      </property>
      <property name="imageLargeAttr" scope="instance" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	URL to the image.</description>
      </property>
      <property name="titleAttr" scope="instance" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	title of the picture, if any.</description>
      </property>
      <property name="slideshowInterval" scope="instance" type="Integer">
        <description>Time, in seconds, between image changes in the slide show.</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetid" scope="instance" type="Object"/>
      <property name="thumbPicker" scope="instance" type="Object"/>
      <property name="slideShow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.Lightbox" superclass="dijit._Widget">
    <description>An Elegant, keyboard accessible, markup and store capable Lightbox widget to show images
	in a modal dialog-esque format. Can show individual images as Modal dialog, or can group
	images with multiple entry points, all using a single "master" Dialog for visualization
	key controls:
	ESC - close
	Down Arrow / Rt Arrow / N - Next Image
	Up Arrow / Lf Arrow / P - Previous Image</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_addSelf" scope="instance"/>
      <method name="_handleClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="disable" scope="instance"/>
      <method name="enable" scope="instance"/>
      <method name="onClick" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="group" scope="instance" type="String">
        <description>Grouping images in a page with similar tags will provide a 'slideshow' like grouping of images</description>
      </property>
      <property name="title" scope="instance" type="String">
        <description>A string of text to be shown in the Lightbox beneath the image (empty if using a store)</description>
      </property>
      <property name="href" scope="instance" type="String"/>
      <property name="duration" scope="instance" type="Integer">
        <description>Generic time in MS to adjust the feel of widget. could possibly add various
	durations for the various actions (dialog fadein, sizeing, img fadein ...)</description>
      </property>
      <property name="modal" scope="instance" type="Boolean">
        <description>If true, this Dialog instance will be truly modal and prevent closing until
	explicitly told to by calling hide() or clicking the (x) - Defaults to false
	to preserve previous behaviors. (aka: enable click-to-click on the underlay)</description>
      </property>
      <property name="_allowPassthru" scope="instance" type="Boolean">
        <description>Privately set this to disable/enable natural link of anchor tags</description>
      </property>
      <property name="_attachedDialog" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.LightboxDialog" superclass="dijit.Dialog">
    <description>A widget that intercepts anchor links (typically around images)
	and displays a modal Dialog. this is the actual Dialog, which you can
	create and populate manually, though should use simple Lightbox's
	unless you need the direct access.
	There should only be one of these on a page, so all dojox.image.Lightbox's will us it
	(the first instance of a Lightbox to be show()'n will create me If i do not exist)</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <return-description>dijit._Widget
	Perhaps the only `dijit._Widget` that returns itself to allow
	'chaining' or var referencing with .startup()</return-description>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="groupData" type="Object" usage="required">
            <description>needs href and title attributes. the values for this image.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_ready" scope="instance">
        <parameters>
          <parameter name="src" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_nextImage" scope="instance"/>
      <method name="_prevImage" scope="instance"/>
      <method name="_loadImage" scope="instance"/>
      <method name="_prepNodes" scope="instance"/>
      <method name="_calcTitleSize" scope="instance"/>
      <method name="resizeTo" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="forceTitle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_scaleToFit" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required">
            <description>The 'size' object passed around for this image</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_setImageSize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_size" scope="instance"/>
      <method name="_position" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_showImage" scope="instance"/>
      <method name="_showNav" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="addImage" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required">
            <description>The image information to add.
	href: String - link to image (required)
	title: String - title to display</description>
          </parameter>
          <parameter name="group" type="String" usage="optional">
            <description>attach to group of similar tag or null for individual image instance</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeImage" scope="instance">
        <parameters>
          <parameter name="child" type="Widget" usage="required">
            <description>Object A reference to the Lightbox child that was added (or an object literal)
	only the .href member is compared for uniqueness. The object may contain
	a .group member as well.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeGroup" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_makeAnims" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="groupData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onImageClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Dialog" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String">
        <description>The current title, read from object passed to show()</description>
      </property>
      <property name="inGroup" scope="instance" type="Array">
        <description>Array of objects. this is populated by from the JSON object _groups, and
	should not be populate manually. it is a placeholder for the currently
	showing group of images in this master dialog</description>
      </property>
      <property name="imgUrl" scope="instance" type="String">
        <description>The src=&amp;quot;&amp;quot; attribute of our imageNode (can be null at statup)</description>
      </property>
      <property name="errorMessage" scope="instance" type="String">
        <description>The text to display when an unreachable image is linked</description>
      </property>
      <property name="adjust" scope="instance" type="Boolean">
        <description>If true, ensure the image always stays within the viewport
	more difficult than necessary to disable, but enabled by default
	seems sane in most use cases.</description>
      </property>
      <property name="modal" scope="instance" type="Boolean">
        <description>If true, this Dialog instance will be truly modal and prevent closing until
	explicitly told to by calling hide() or clicking the (x) - Defaults to false
	to preserve previous behaviors. (aka: enable click-to-click on the underlay)</description>
      </property>
      <property name="errorImg" scope="instance" type="Url">
        <description>Path to the image used when a 404 is encountered</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_animConnects" scope="instance" type="Array"/>
      <property name="_vp" scope="instance" type="Object"/>
      <property name="_lastGroup" scope="instance" type="Object"/>
      <property name="_index" scope="instance" type="Object"/>
      <property name="_imageReady" scope="instance" type="bool"/>
      <property name="_lastTitleSize" scope="instance" type="Object"/>
      <property name="_lastSize" scope="instance" type="Object"/>
      <property name="_currentSize" scope="instance" type="Object"/>
      <property name="_wasStyled" scope="instance" type="Object"/>
      <property name="_showImageAnim" scope="instance" type="Object"/>
      <property name="_loadingAnim" scope="instance" type="Object"/>
      <property name="_showNavAnim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.LightboxDialog._groups">
    <properties>
      <property name="XnoGroupX" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.image.LightboxDialog.imgNode">
    <properties>
      <property name="height" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.LightboxNano">
    <description>Very lightweight lightbox which only displays a larger image.  There is
	no support for a caption or description.  The lightbox can be closed by
	clicking any where or pressing any key.  This widget is intended to be
	used on &lt;a&gt; and &lt;img&gt; tags.  Upon creation, if the domNode is &lt;img&gt; tag,
	then it is wrapped in an &lt;a&gt; tag, then a &lt;div class="enlarge"&gt; is placed
	inside the &lt;a&gt; and can be styled to display an icon that the original
	can be enlarged.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="optional"/>
          <parameter name="n" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_createDiv" scope="instance">
        <parameters>
          <parameter name="cssClass" type="String" usage="required"/>
          <parameter name="refNode" type="DomNode" usage="required"/>
          <parameter name="display" type="boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="_load" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_hideLoading" scope="instance"/>
      <method name="_show" scope="instance"/>
      <method name="_sizeBg" scope="instance"/>
      <method name="_key" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_coords" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_hide" scope="instance"/>
      <method name="_reset" scope="instance"/>
      <method name="_anim" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="onEnd" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <description>An object with optional members of &lt;code&gt;href&lt;/code&gt; and &lt;code&gt;origin&lt;/code&gt;.
	&lt;code&gt;origin&lt;/code&gt; can be be a String|Id of a DomNode to use when
	animating the openeing of the image (the 'box' effect starts
	from this origin point. eg: { origin: e.target })
	If there's no origin, it will use the center of the viewport.
	The &lt;code&gt;href&lt;/code&gt; member is a string URL for the image to be
	displayed. Omiting either of these members will revert to
	the default href (which could be absent in some cases) and
	the original srcNodeRef for the widget.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="href" scope="instance" type="string">
        <description>URL to the large image to show in the lightbox.</description>
      </property>
      <property name="duration" scope="instance" type="int">
        <description>The delay in milliseconds of the LightboxNano open and close animation.</description>
      </property>
      <property name="preloadDelay" scope="instance" type="int">
        <description>The delay in milliseconds after the LightboxNano is created before preloading the larger image.</description>
      </property>
      <property name="_connects" scope="instance" type="Array"/>
      <property name="_loadingNode" scope="instance" type="bool"/>
      <property name="_img" scope="instance" type="Object"/>
      <property name="_bg" scope="instance" type="Object"/>
      <property name="_node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.Magnifier" superclass="dojox.image.MagnifierLite">
    <description>An unobtrusive way to add an unstyled overlay
	above the srcNode image element. The overlay/glass is a
	scaled version of the src image (so larger images sized down
	are clearer).
	over-ride the _createGlass method to create your custom surface,
	being sure to create an img node on that surface.</description>
    <methods>
      <method name="_createGlass" scope="instance"/>
      <method name="_placeGlass" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setImage" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.image.MagnifierLite" scope="instance"/>
    </mixins>
    <properties>
      <property name="glassNode" scope="instance" type="Object"/>
      <property name="surfaceNode" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="img" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.MagnifierLite" superclass="dijit._Widget">
    <description>An unobtrusive way to add an unstyled overlay
	above the srcNode image element. The overlay/glass is a
	scaled version of the src image (so larger images sized down
	are clearer).
	The logic behind requiring the src image to be large is
	"it's going to be downloaded, anyway" so this method avoids
	having to make thumbnails and 2 http requests among other things.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_createGlass" scope="instance"/>
      <method name="_adjustScale" scope="instance"/>
      <method name="_showGlass" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideGlass" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_placeGlass" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setImage" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="finalize" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="glassSize" scope="instance" type="Int">
        <description>the width and height of the bounding box</description>
      </property>
      <property name="scale" scope="instance" type="Decimal">
        <description>the multiplier of the Mangification.</description>
      </property>
      <property name="glassNode" scope="instance" type="Object"/>
      <property name="surfaceNode" scope="instance" type="Object"/>
      <property name="img" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Object"/>
      <property name="_imageSize" scope="instance" type="Object"/>
      <property name="_zoomSize" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setDataStore" scope="instance">
        <parameters>
          <parameter name="dataStore" type="An" usage="required">
            <description>implementation of the dojo.data.api.Read API. This accesses the image
	data.</description>
          </parameter>
          <parameter name="request" type="An" usage="required">
            <description>implementation of the dojo.data.api.Request API. This specifies the
	query and paging information to be used by the data store</description>
          </parameter>
          <parameter name="paramNames" type="optional" usage="required">
            <description>An object defining the names of the item attributes to fetch from the
	data store.  The three attributes allowed are 'linkAttr', 'imageLargeAttr' and 'titleAttr'</description>
          </parameter>
        </parameters>
      </method>
      <method name="reset" scope="instance">
        <description>Removes all previously loaded images, and clears all caches.</description>
      </method>
      <method name="isImageLoaded" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>number index in the data store to check if it is loaded.</description>
          </parameter>
        </parameters>
      </method>
      <method name="moveImageLoadingPointer" scope="instance">
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>number index in the data store to start loading images from.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="showNextImage" scope="instance">
        <parameters>
          <parameter name="inTimer" type="Boolean" usage="required">
            <description>If true, a slideshow is active, otherwise the slideshow is inactive.</description>
          </parameter>
          <parameter name="forceLoop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleSlideShow" scope="instance"/>
      <method name="getShowTopicName" scope="instance">
        <description>The information published is: index, title and url</description>
      </method>
      <method name="getLoadTopicName" scope="instance">
        <description>The information published is the index position of the image loaded.</description>
      </method>
      <method name="showImage" scope="instance">
        <parameters>
          <parameter name="index" type="Number" usage="required">
            <description>The position of the image in the data store to display</description>
          </parameter>
          <parameter name="callback" type="Function" usage="optional">
            <description>Optional callback function to call when the image has finished displaying.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fitSize" scope="instance">
        <parameters>
          <parameter name="force" type="Boolean" usage="required">
            <description>If true, the widget is always resized, regardless of the value of 'fixedHeight'</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getTopPadding" scope="instance"/>
      <method name="_loadNextImage" scope="instance"/>
      <method name="_loadImage" scope="instance">
        <description>This function loads the image at position 'index' into the
	internal cache of images.  This does not cause the image to be displayed.</description>
        <parameters>
          <parameter name="index" type="The" usage="required">
            <description>position in the data store to load an image from.</description>
          </parameter>
          <parameter name="callbackFn" type="An" usage="required">
            <description>optional function to execute when the image has finished loading.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_stop" scope="instance"/>
      <method name="_prev" scope="instance"/>
      <method name="_next" scope="instance"/>
      <method name="_startTimer" scope="instance"/>
      <method name="_calcNavDimensions" scope="instance"/>
      <method name="_setTitle" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required">
            <description>The String title of the image</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fitImage" scope="instance">
        <parameters>
          <parameter name="img" type="Node" usage="required">
            <description>The image DOM node to optionally resize</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>An Event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_showNav" scope="instance">
        <parameters>
          <parameter name="force" type="Boolean" usage="required">
            <description>If true, the navigation controls are repositioned even if they are
	currently visible.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_hideNav" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>The DOM Event that triggered this function</description>
          </parameter>
        </parameters>
      </method>
      <method name="_overElement" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="imageHeight" scope="instance" type="Number">
        <description>The maximum height of an image</description>
      </property>
      <property name="imageWidth" scope="instance" type="Number">
        <description>The maximum width of an image.</description>
      </property>
      <property name="title" scope="instance" type="String">
        <description>The initial title of the SlideShow</description>
      </property>
      <property name="titleTemplate" scope="instance" type="String">
        <description>a way to customize the wording in the title. supported parameters to be populated are:
	${title} = the passed title of the image
	${current} = the current index of the image
	${total} = the total number of images in the SlideShow
	should add more?</description>
      </property>
      <property name="noLink" scope="instance" type="Boolean">
        <description>Prevents the slideshow from putting an anchor link around the displayed image
	enables if true, though still will not link in absence of a url to link to</description>
      </property>
      <property name="loop" scope="instance" type="Boolean">
        <description>true/false - make the slideshow loop</description>
      </property>
      <property name="hasNav" scope="instance" type="Boolean">
        <description>toggle to enable/disable the visual navigation controls</description>
      </property>
      <property name="images" scope="instance" type="Array">
        <description>Contains the DOM nodes that individual images are stored in when loaded or loading.</description>
      </property>
      <property name="pageSize" scope="instance" type="Number">
        <description>The number of images to request each time.</description>
      </property>
      <property name="autoLoad" scope="instance" type="Boolean">
        <description>If true, then images are preloaded, before the user navigates to view them.
	If false, an image is not loaded until the user views it.</description>
      </property>
      <property name="autoStart" scope="instance" type="Boolean">
        <description>If true, the SlideShow begins playing immediately</description>
      </property>
      <property name="fixedHeight" scope="instance" type="Boolean">
        <description>If true, the widget does not resize itself to fix the displayed image.</description>
      </property>
      <property name="imageStore" scope="instance" type="Object">
        <description>Implementation of the dojo.data.api.Read API, which provides data on the images
	to be displayed.</description>
      </property>
      <property name="linkAttr" scope="instance" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	URL to link to from an image, if any.</description>
      </property>
      <property name="imageLargeAttr" scope="instance" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	URL to the image.</description>
      </property>
      <property name="titleAttr" scope="instance" type="String">
        <description>Defines the name of the attribute to request from the store to retrieve the
	title of the picture, if any.</description>
      </property>
      <property name="slideshowInterval" scope="instance" type="Number">
        <description>Time, in seconds, between image transitions during a slideshow.</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_imageCounter" scope="instance" type="Number">
        <description>A counter to keep track of which index image is to be loaded next</description>
      </property>
      <property name="_tmpImage" scope="instance" type="DomNode">
        <description>The temporary image to show when a picture is loading.</description>
      </property>
      <property name="_currentImage" scope="instance" type="Object"/>
      <property name="isInitialized" scope="instance" type="bool"/>
      <property name="imageIndex" scope="instance" type="Number"/>
      <property name="_timerCancelled" scope="instance" type="Object"/>
      <property name="_slideId" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="_navAnim" scope="instance" type="Object"/>
      <property name="_navShowing" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.outerNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow._request">
    <methods>
      <method name="onComplete" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="start" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.navPlay">
    <properties>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.navPrev">
    <properties>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.navNext">
    <properties>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.SlideShow.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.ThumbnailPicker" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="init" scope="instance"/>
      <method name="getClickTopicName" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getShowTopicName" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="setDataStore" scope="instance">
        <parameters>
          <parameter name="dataStore" type="An" usage="required">
            <description>implementation of the dojo.data.api.Read API. This accesses the image
	data.</description>
          </parameter>
          <parameter name="request" type="An" usage="required">
            <description>implementation of the dojo.data.api.Request API. This specifies the
	query and paging information to be used by the data store</description>
          </parameter>
          <parameter name="paramNames" type="optional" usage="required">
            <description>An object defining the names of the item attributes to fetch from the
	data store.  The four attributes allowed are 'linkAttr', 'imageLargeAttr',
	'imageThumbAttr' and 'titleAttr'</description>
          </parameter>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="isVisible" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_next" scope="instance"/>
      <method name="_prev" scope="instance"/>
      <method name="_checkLoad" scope="instance">
        <parameters>
          <parameter name="img" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showThumbs" scope="instance">
        <parameters>
          <parameter name="index" type="Number" usage="required">
            <description>The index of the first thumbnail</description>
          </parameter>
        </parameters>
      </method>
      <method name="markImageLoaded" scope="instance">
        <description>If 'useLoadNotifier' is set to true, then a visual cue is
	given to state whether the image is loaded or not.	Calling this function
	marks an image as loaded.</description>
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setThumbClass" scope="instance">
        <parameters>
          <parameter name="thumb" type="DomNode" usage="required">
            <description>The thumbnail DOM node to set the class on</description>
          </parameter>
          <parameter name="className" type="String" usage="required">
            <description>The CSS class to add to the DOM node.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_loadNextPage" scope="instance"/>
      <method name="_loadImage" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateNavControls" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="imageStore" scope="instance" type="Object">
        <description>A data store that implements the dojo.data Read API.</description>
      </property>
      <property name="size" scope="instance" type="Number">
        <description>Width or height in pixels, depending if horizontal or vertical.
	FIXME: use CSS?</description>
      </property>
      <property name="thumbHeight" scope="instance" type="Number">
        <description>Default height of a thumbnail image
	FIXME: use CSS?</description>
      </property>
      <property name="thumbWidth" scope="instance" type="Number">
        <description>Default width of an image
	FIXME: use CSS?</description>
      </property>
      <property name="useLoadNotifier" scope="instance" type="Boolean">
        <description>Setting useLoadNotifier to true makes a colored DIV appear under each
	thumbnail image, which is used to display the loading status of each
	image in the data store.</description>
      </property>
      <property name="useHyperlink" scope="instance" type="boolean">
        <description>Setting useHyperlink to true causes a click on a thumbnail to open a link.</description>
      </property>
      <property name="hyperlinkTarget" scope="instance" type="String">
        <description>If hyperlinkTarget is set to &amp;quot;new&amp;quot;, clicking on a thumb will open a new window
	If it is set to anything else, clicking a thumbnail will open the url in the
	current window.</description>
      </property>
      <property name="isClickable" scope="instance" type="Boolean">
        <description>When set to true, the cursor over a thumbnail changes.</description>
      </property>
      <property name="isScrollable" scope="instance" type="Boolean">
        <description>When true, uses smoothScroll to move between pages</description>
      </property>
      <property name="isHorizontal" scope="instance" type="Boolean">
        <description>If true, the thumbnails are displayed horizontally. Otherwise they are displayed
	vertically</description>
      </property>
      <property name="autoLoad" scope="instance" type="Boolean"/>
      <property name="linkAttr" scope="instance" type="String">
        <description>The attribute name for accessing the url from the data store</description>
      </property>
      <property name="imageThumbAttr" scope="instance" type="String">
        <description>The attribute name for accessing the thumbnail image url from the data store</description>
      </property>
      <property name="imageLargeAttr" scope="instance" type="String">
        <description>The attribute name for accessing the large image url from the data store</description>
      </property>
      <property name="pageSize" scope="instance" type="Number">
        <description>The number of images to request each time.</description>
      </property>
      <property name="titleAttr" scope="instance" type="String">
        <description>The attribute name for accessing the title from the data store</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_thumbs" scope="instance" type="Array"/>
      <property name="_thumbIndex" scope="instance" type="Number">
        <description>The index of the first thumbnail shown</description>
      </property>
      <property name="_maxPhotos" scope="instance" type="Number">
        <description>The total number of photos in the image store</description>
      </property>
      <property name="_loadedImages" scope="instance" type="Object">
        <description>Stores the indices of images that have been marked as loaded using the
	markImageLoaded function.</description>
      </property>
      <property name="widgetid" scope="instance" type="Object"/>
      <property name="_scrollerSize" scope="instance" type="Number"/>
      <property name="_sizeProperty" scope="instance" type="Object"/>
      <property name="_totalSize" scope="instance" type="Number"/>
      <property name="isInitialized" scope="instance" type="bool"/>
      <property name="_offsetAttr" scope="instance" type="String"/>
      <property name="_sizeAttr" scope="instance" type="String"/>
      <property name="_scrollAttr" scope="instance" type="String"/>
      <property name="_loadInProgress" scope="instance" type="Object"/>
      <property name="_noImages" scope="instance" type="bool"/>
      <property name="_loadingImages" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.ThumbnailPicker.request">
    <properties>
      <property name="start" scope="instance" type="Number"/>
      <property name="count" scope="instance" type="Object"/>
      <property name="onComplete" scope="instance" type="Object"/>
      <property name="onError" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.image.ThumbnailPicker.thumbScroller">
    <properties>
      <property name="scrollLeft" scope="instance" type="Object"/>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io">
    <methods>
      <method name="httpParse" scope="instance">
        <parameters>
          <parameter name="httpStream" type="String" usage="required">
            <description>HTTP stream to parse</description>
          </parameter>
          <parameter name="topHeaders" type="String" usage="optional">
            <description>Extra header information to add to each HTTP request (kind of HTTP inheritance)</description>
          </parameter>
          <parameter name="partial" type="Boolean" usage="optional">
            <description>A true value indicates that the stream may not be finished, it may end arbitrarily in mid stream.
	The last XHR object will have a special property _lastIndex that indicates the how far along
	the httpStream could be successfully parsed into HTTP messages.
	return:
	Returns an array of XHR-like object for reading the headers for each message</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="the content is not finished"/>
        </return-types>
      </method>
      <method name="xhrMultiPart" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.io.__xhrMultiArgs" usage="required"/>
        </parameters>
      </method>
      <method name="xhrScriptPlugin" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>Url prefix of the site which can handle JSONP requests.</description>
          </parameter>
          <parameter name="callbackParamName" type="String" usage="required"/>
          <parameter name="httpAdapter" type="Function" usage="optional">
            <description>This allows for adapting HTTP requests that could not otherwise be
	sent with JSONP, so you can use a convention for headers and PUT/DELETE methods.</description>
          </parameter>
        </parameters>
      </method>
      <method name="xhrWindowNamePlugin" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required">
            <description>Url prefix of the site which can handle windowName requests.</description>
          </parameter>
          <parameter name="httpAdapter" type="Function" usage="optional">
            <description>This allows for adapting HTTP requests that could not otherwise be
	sent with window.name, so you can use a convention for headers and PUT/DELETE methods.</description>
          </parameter>
          <parameter name="trusted" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.io.OAuth"/>
  <class type="dojox.io.OAuth.__AccessorArgs">
    <methods/>
    <properties>
      <property name="key" scope="instance" type="String">
        <description>The key or token issued to either the consumer or by the OAuth service.</description>
      </property>
      <property name="secret" scope="instance" type="String">
        <description>The secret (shared secret for consumers, issued secret by OAuth service).</description>
      </property>
    </properties>
  </class>
  <class type="dojox.io.OAuth.__OAuthArgs">
    <methods/>
    <properties>
      <property name="consumer" scope="instance" type="dojox.io.OAuth.__AccessorArgs">
        <description>The consumer information issued to your OpenAuth application.
	sig_method: String
	The method used to create the signature.  Should be PLAINTEXT or HMAC-SHA1.</description>
      </property>
      <property name="token" scope="instance" type="dojox.io.OAuth.__AccessorArgs">
        <description>The request token and secret issued by the OAuth service.  If not
	issued yet, this should be null.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip">
    <description>Do not use this object directly. See the Dojo Book page
	on XMLHttpRequest IFrame Proxying:
	http://dojotoolkit.org/book/dojo-book-0-4/part-5-connecting-pieces/i-o/cross-domain-xmlhttprequest-using-iframe-proxy
	Usage of XHR IFrame Proxying does not work from local disk in Safari.</description>
    <methods>
      <method name="_realSend" scope="instance">
        <parameters>
          <parameter name="facade" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="receive" scope="instance">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
          <parameter name="urlEncodedData" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="frameLoaded" scope="instance">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="destroyState" scope="instance">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="createFacade" scope="instance"/>
      <method name="sendRequest" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
          <parameter name="encodedData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendRequestStart" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendRequestPart" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setServerUrl" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeServerUrl" scope="instance">
        <parameters>
          <parameter name="stateId" type="Object" usage="required"/>
          <parameter name="cmd" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fragmentReceivedEvent" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fragmentReceived" scope="instance">
        <parameters>
          <parameter name="frag" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unpackMessage" scope="instance">
        <parameters>
          <parameter name="encodedMessage" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="xipClientUrl" scope="instance" type="Object"/>
      <property name="urlLimit" scope="instance" type="Number"/>
      <property name="_callbackName" scope="instance" type="String"/>
      <property name="_state" scope="instance" type="Object"/>
      <property name="_stateIdCounter" scope="instance" type="Number"/>
      <property name="_isWebKit" scope="instance" type="bool"/>
      <property name="_xhrObjOld" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade">
    <description>Do not use this object directly. See the Dojo Book page
	on XMLHttpRequest IFrame Proxying:
	http://dojotoolkit.org/book/dojo-book-0-4/part-5-connecting-pieces/i-o/cross-domain-xmlhttprequest-using-iframe-proxy</description>
    <methods>
      <method name="setRequestHeader" scope="instance">
        <parameters>
          <parameter name="header" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="abort" scope="instance"/>
      <method name="getAllResponseHeaders" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getResponseHeader" scope="instance">
        <parameters>
          <parameter name="header" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_requestHeaders" scope="instance" type="Object"/>
      <property name="_allResponseHeaders" scope="instance" type="Object"/>
      <property name="_responseHeaders" scope="instance" type="Object"/>
      <property name="_method" scope="instance" type="Object"/>
      <property name="_uri" scope="instance" type="Object"/>
      <property name="_bodyData" scope="instance" type="Object"/>
      <property name="responseText" scope="instance" type="Object"/>
      <property name="responseXML" scope="instance" type="Object"/>
      <property name="status" scope="instance" type="Object"/>
      <property name="statusText" scope="instance" type="Object"/>
      <property name="readyState" scope="instance" type="Number"/>
      <property name="_ifpServerUrl" scope="instance" type="Object"/>
      <property name="_stateId" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade.open">
    <methods/>
    <properties>
      <property name="_method" scope="instance" type="Object"/>
      <property name="_uri" scope="instance" type="Object"/>
      <property name="readyState" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade.send">
    <methods/>
    <properties>
      <property name="_bodyData" scope="instance" type="Object"/>
      <property name="_stateId" scope="instance" type="Object"/>
      <property name="readyState" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.io.proxy.xip.XhrIframeFacade._setResponseHeaders">
    <methods/>
    <properties>
      <property name="_allResponseHeaders" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.proxy"/>
  <class type="dojox.io.proxy.xip.send">
    <methods/>
    <properties>
      <property name="fullXipClientUrl" scope="instance" type="Object"/>
      <property name="send" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="window.location">
    <properties>
      <property name="href" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.scriptFrame">
    <methods>
      <method name="_getWaiters" scope="instance">
        <parameters>
          <parameter name="frameId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_fixAttachUrl" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_loaded" scope="instance">
        <parameters>
          <parameter name="frameId" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_waiters" scope="instance" type="Object"/>
      <property name="_loadedIds" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.io.windowName">
    <methods>
      <method name="send" scope="instance">
        <description>In order to provide a windowname transport accessible resources/web services, a server
	should check for the presence of a parameter window.name=true and if a request includes
	such a parameter, it should respond to the request with an HTML
	document that sets it's window.name to the string that is to be
	delivered to the client. For example, if a client makes a window.name request like:
		http://othersite.com/greeting?windowname=true
	And server wants to respond to the client with "Hello", it should return an html page:
		&lt;html&gt;&lt;script type="text/javascript"&gt;
		window.name="Hello";
		&lt;/script&gt;&lt;/html&gt;
	One can provide XML or JSON data by simply quoting the data as a string, and parsing the data
	on the client.
	If you use the authorization window.name protocol, the requester should include an
	authElement element in the args, and a request will be created like:
		http://othersite.com/greeting?windowname=auth
	And the server can respond like this:
		&lt;html&gt;&lt;script type="text/javascript"&gt;
		var loc = window.name;
		authorizationButton.onclick = function(){
			window.name="Hello";
			location = loc;
		};
		&lt;/script&gt;&lt;/html&gt;
	When using windowName from a XD Dojo build, make sure to set the
	dojo.dojoBlankHtmlUrl property to a local URL.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>The method to use to send the request, GET or POST</description>
          </parameter>
          <parameter name="args" type="dojo.__IoArgs" usage="required">
            <description>See dojo.xhr
	args.authElement: DOMNode?
	By providing an authElement, this indicates that windowName should use the
	authorized window.name protocol, relying on
	the loaded XD resource to return to the provided return URL on completion
	of authorization/authentication. The provided authElement will be used to place
	the iframe in, so the user can interact with the server resource for authentication
	and/or authorization to access the resource.
	args.onAuthLoad: Function?
	When using authorized access to resources, this function will be called when the
	authorization page has been loaded. (When authorization is actually completed,
	the deferred callback function is called with the result). The primary use for this
	is to make the authElement visible to the user once the resource has loaded
	(this can be preferable to showing the iframe while the resource is loading
	since it may not require authorization, it may simply return the resource).</description>
          </parameter>
        </parameters>
      </method>
      <method name="_send" scope="instance">
        <parameters>
          <parameter name="dfd" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="authTarget" type="Object" usage="required"/>
          <parameter name="onAuthLoad" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_frameNum" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.io.__xhrContentArgs">
    <methods/>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>Name of the form value.</description>
      </property>
      <property name="content" scope="instance" type="String">
        <description>The contents of the value.</description>
      </property>
      <property name="filename" scope="instance" type="String">
        <description>An optional filename to pass to the server, as defined by the boundary.</description>
      </property>
      <property name="contentType" scope="instance" type="String">
        <description>An optional content-type (MIME) to pass to the server, if value is being
	treated as a file.</description>
      </property>
      <property name="charset" scope="instance" type="String">
        <description>Optional charset to pass, for the server to interpret the file correctly.</description>
      </property>
      <property name="contentTransferEncoding" scope="instance" type="String">
        <description>Optional transfer encoding header value.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.io.__xhrMultiArgs">
    <methods>
      <method name="load" scope="instance"/>
      <method name="error" scope="instance"/>
      <method name="handle" scope="instance"/>
    </methods>
    <properties>
      <property name="url" scope="instance" type="String">
        <description>URL to server endpoint.</description>
      </property>
      <property name="content" scope="instance" type="Object">
        <description>Contains properties with string values. These
	properties will be serialized using multi-part
	boundaries.</description>
      </property>
      <property name="file" scope="instance" type="Object">
        <description>Alias for &amp;quot;content&amp;quot;.  Provided for backwards compatibility.</description>
      </property>
      <property name="timeout" scope="instance" type="Integer">
        <description>Milliseconds to wait for the response. If this time
	passes, the then error callbacks are called.</description>
      </property>
      <property name="form" scope="instance" type="DOMNode">
        <description>DOM node for a form. Used to extract the form values
	and send to the server; each form value will be serialized
	using multi-part boundaries.</description>
      </property>
      <property name="preventCache" scope="instance" type="Boolean">
        <description>Default is false. If true, then a
	&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
	with a value that changes with each request
	(timestamp). Useful only with GET-type requests.</description>
      </property>
      <property name="handleAs" scope="instance" type="String">
        <description>Acceptable values depend on the type of IO
	transport (see specific IO calls for more information).</description>
      </property>
    </properties>
  </class>
  <class type="dojox.io.xhrPlugins">
    <methods>
      <method name="register" scope="instance">
        <return-types>
          <return-type type="or check to see if we have the same path"/>
        </return-types>
      </method>
      <method name="addProxy" scope="instance">
        <examples>
          <example>Define a proxy:
		dojox.io.xhrPlugins.addProxy("/proxy?url=");
	And then when you call:
		dojo.xhr("GET",{url:"http://othersite.com/file"});
	It would result in the request (to your origin server):
		GET /proxy?url=http%3A%2F%2Fothersite.com%2Ffile HTTP/1.1</example>
        </examples>
        <parameters>
          <parameter name="proxyUrl" type="This" usage="required">
            <description>is URL to send the requests to.</description>
          </parameter>
        </parameters>
      </method>
      <method name="addCrossSiteXhr" scope="instance">
        <description>This can be used for servers that support W3C cross-site XHR. In order for
	a server to allow a client to make cross-site XHR requests,
	it should respond with the header like:
		Access-Control: allow &lt;*&gt;
	see: http://www.w3.org/TR/access-control/</description>
        <parameters>
          <parameter name="url" type="Requests" usage="required">
            <description>that start with this URL will be considered for using
	cross-site XHR.</description>
          </parameter>
          <parameter name="httpAdapter" type="This" usage="required">
            <description>allows for adapting HTTP requests that could not otherwise be
	sent with XDR, so you can use a convention for headers and PUT/DELETE methods.</description>
          </parameter>
        </parameters>
      </method>
      <method name="fullHttpAdapter" scope="instance">
        <description>The following convention is used:
	method name -&gt; ?http-method=PUT
	Header -&gt; http-Header-Name=header-value
	X-Header -&gt; header_name=header-value</description>
        <examples>
          <example>dojox.io.xhrPlugins.addXdr("http://somesite.com", dojox.io.xhrPlugins.fullHttpAdapter);</example>
        </examples>
        <parameters>
          <parameter name="plainXhr" type="Object" usage="required"/>
          <parameter name="noRawBody" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojo.query.pseudos">
    <methods>
      <method name="has" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="visible" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hidden" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selected" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checked" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disabled" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="enabled" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="input" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="button" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="header" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="inputPseudos" scope="instance"/>
    </mixins>
  </class>
  <class type="dojo.query"/>
  <class type="dojox.json">
    <methods>
      <method name="_slice" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_find" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_distinctFilter" scope="instance">
        <parameters>
          <parameter name="array" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <description>JSONQuery provides a comprehensive set of data querying tools including filtering,
	recursive search, sorting, mapping, range selection, and powerful expressions with
	wildcard string comparisons and various operators. JSONQuery generally supersets
	JSONPath and provides syntax that matches and behaves like JavaScript where
	possible.
	JSONQuery evaluations begin with the provided object, which can referenced with
	$. From
	the starting object, various operators can be successively applied, each operating
	on the result of the last operation.
	Supported Operators:
	--------------------
	* .property - This will return the provided property of the object, behaving exactly
	like JavaScript.
	* [expression] - This returns the property name/index defined by the evaluation of
	the provided expression, behaving exactly like JavaScript.
	* [?expression] - This will perform a filter operation on an array, returning all the
	items in an array that match the provided expression. This operator does not
	need to be in brackets, you can simply use ?expression, but since it does not
	have any containment, no operators can be used afterwards when used
	without brackets.
	* [^?expression] - This will perform a distinct filter operation on an array. This behaves
	as [?expression] except that it will remove any duplicate values/objects from the
	result set.
	* [/expression], [\expression], [/expression, /expression] - This performs a sort
	operation on an array, with sort based on the provide expression. Multiple comma delimited sort
	expressions can be provided for multiple sort orders (first being highest priority). /
	indicates ascending order and \ indicates descending order
	* [=expression] - This performs a map operation on an array, creating a new array
	with each item being the evaluation of the expression for each item in the source array.
	* [start:end:step] - This performs an array slice/range operation, returning the elements
	from the optional start index to the optional end index, stepping by the optional step number.
	* [expr,expr] - This a union operator, returning an array of all the property/index values from
	the evaluation of the comma delimited expressions.
	* .* or [*] - This returns the values of all the properties of the current object.
	* $ - This is the root object, If a JSONQuery expression does not being with a $,
	it will be auto-inserted at the beginning.
	* @ - This is the current object in filter, sort, and map expressions. This is generally
	not necessary, names are auto-converted to property references of the current object
	in expressions.
	*	..property - Performs a recursive search for the given property name, returning
	an array of all values with such a property name in the current object and any subobjects
	* expr = expr - Performs a comparison (like JS's ==). When comparing to
	a string, the comparison string may contain wildcards * (matches any number of
	characters) and ? (matches any single character).
	* expr ~ expr - Performs a string comparison with case insensitivity.
	* ..[?expression] - This will perform a deep search filter operation on all the objects and
	subobjects of the current data. Rather than only searching an array, this will search
	property values, arrays, and their children.
	* $1,$2,$3, etc. - These are references to extra parameters passed to the query
	function or the evaluator function.
	* +, -, /, *, &amp;, |, %, (, ), &lt;, &gt;, &lt;=, &gt;=, != - These operators behave just as they do
	in JavaScript.
		dojox.json.query(queryString,object)
	and
		dojox.json.query(queryString)(object)
	always return identical results. The first one immediately evaluates, the second one returns a
	function that then evaluates the object.</description>
        <examples>
          <example>	dojox.json.query("foo",{foo:"bar"})
	This will return "bar".</example>
          <example>	evaluator = dojox.json.query("?foo='bar'&amp;rating&gt;3");
	This creates a function that finds all the objects in an array with a property
	foo that is equals to "bar" and with a rating property with a value greater
	than 3.
		evaluator([{foo:"bar",rating:4},{foo:"baz",rating:2}])
	This returns:
		{foo:"bar",rating:4}</example>
          <example>	evaluator = dojox.json.query("$[?price&lt;15.00][\rating][0:10]");
	This finds objects in array with a price less than 15.00 and sorts then
	by rating, highest rated first, and returns the first ten items in from this
	filtered and sorted list.</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required">
            <description>Query string</description>
          </parameter>
          <parameter name="obj" type="Object" usage="optional">
            <description>Target of the JSONQuery</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="we mark all the inner brackets as skippable"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.json.ref.resolveJson">
    <description>A JSON Schema object that can be used to advise the handling of the JSON (defining ids, date properties, urls, etc)</description>
    <methods/>
    <properties>
      <property name="refAttribute" scope="instance" type="Object"/>
      <property name="_addProp" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.json.ref.toJson">
    <methods/>
    <properties>
      <property name="_useRefs" scope="instance" type="Object"/>
      <property name="_addProp" scope="instance" type="Object"/>
      <property name="refAttribute" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.json.schema">
    <methods>
      <method name="validate" scope="instance">
        <description>The validate method will return an object with two properties:
	valid: A boolean indicating if the instance is valid by the schema
	errors: An array of validation errors. If there are no errors, then an
	empty list will be returned. A validation error will have two properties:
	property: which indicates which property had the error
	message: which indicates what the error was</description>
        <parameters>
          <parameter name="instance" type="Any" usage="required">
            <description>The instance value/object to validate</description>
          </parameter>
          <parameter name="schema" type="Object" usage="required">
            <description>The schema to use to validate</description>
          </parameter>
        </parameters>
      </method>
      <method name="checkPropertyChange" scope="instance">
        <parameters>
          <parameter name="value" type="Any" usage="required">
            <description>The new instance value/object to check</description>
          </parameter>
          <parameter name="schema" type="Object" usage="required">
            <description>The schema to use to validate
	return:
	see dojox.validate.jsonSchema.validate</description>
          </parameter>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="mustBeValid" scope="instance">
        <parameters>
          <parameter name="result" type="the" usage="required">
            <description>result returned from checkPropertyChange or validate</description>
          </parameter>
        </parameters>
      </method>
      <method name="_validate" scope="instance">
        <parameters>
          <parameter name="instance" type="Any" usage="required"/>
          <parameter name="schema" type="Object" usage="required"/>
          <parameter name="_changing" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.jsonPath">
    <methods>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="expr" type="String" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_regularExpressions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.aspect">
    <methods>
      <method name="cflow" scope="instance">
        <parameters>
          <parameter name="instance" type="Object" usage="required">
            <description>An instance to be matched. If null, any context will be examined.
	Otherwise the context should belong to this instance.</description>
          </parameter>
          <parameter name="method" type="String|RegExp|Array" usage="optional">
            <description>An optional pattern to be matched against a method name. Can be a string,
	a RegExp object or an array of strings and RegExp objects.
	If it is omitted, any name will satisfy the criteria.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="counter" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="memoizer" scope="instance">
        <parameters>
          <parameter name="keyMaker" type="Function" usage="optional">
            <description>the function, which takes method's arguments and returns a key,
	which can be used to index the result.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="memoizerGuard" scope="instance">
        <parameters>
          <parameter name="method" type="String|Array" usage="optional">
            <description>Optional method's name to be guarded: only cache for
	this method will be invalidated on call. Can be a string
	or an array of method names. If omitted the whole cache
	will be invalidated.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="profiler" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="optional">
            <description>The optional name of the profile section.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="timer" scope="instance">
        <parameters>
          <parameter name="name" type="String" usage="optional">
            <description>The optional unique name of the timer.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="tracer" scope="instance">
        <parameters>
          <parameter name="grouping" type="Boolean" usage="required">
            <description>The flag to group output. If true, indents embedded console messages.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="advise" scope="instance">
        <description>Attaches AOP-style advices to a method. Can attach several
	advices at once and operate on several methods of an object.
	The latter is achieved when a RegExp is specified as
	a method name, or an array of strings and regular expressions
	is used. In this case all functional methods that
	satisfy the RegExp condition are processed. This function
	returns a handle, which can be used to unadvise, or null,
	if advising has failed.
	This function is a convenience wrapper for
	dojox.lang.aspect.adviseRaw().</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <description>A source object for the advised function. Cannot be a DOM node.
	If this object is a constructor, its prototype is advised.</description>
          </parameter>
          <parameter name="method" type="String|RegExp|Array" usage="required">
            <description>A string name of the function in obj. In case of RegExp all
	methods of obj matching the regular expression are advised.</description>
          </parameter>
          <parameter name="advice" type="Object|Function|Array" usage="required">
            <description>An object, which defines advises, or a function, which
	returns such object, or an array of previous items.
	The advice object can define following member functions:
	before, around, afterReturning, afterThrowing, after.
	If the function is supplied, it is called with a context
	object once per call to create a temporary advice object, which
	is destroyed after the processing. The temporary advice object
	can implement a destroy() method, if it wants to be called when
	not needed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="adviseRaw" scope="instance">
        <description>Attaches AOP-style advices to object's methods. Can attach several
	advices at once and operate on several methods of the object.
	The latter is achieved when a RegExp is specified as
	a method name. In this case all functional methods that
	satisfy the RegExp condition are processed. This function
	returns a handle, which can be used to unadvise, or null,
	if advising has failed.</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <description>A source object for the advised function.
	Cannot be a DOM node.</description>
          </parameter>
          <parameter name="methods" type="Array" usage="required">
            <description>An array of method names (strings) to be advised.</description>
          </parameter>
          <parameter name="advices" type="Array" usage="required">
            <description>An array of advices represented by objects or functions that
	return such objects on demand during the event processing.
	The advice object can define following member functions:
	before, around, afterReturning, afterThrowing, after.
	If the function is supplied, it is called with a context
	object once per call to create a temporary advice object, which
	is destroyed after the processing. The temporary advice object
	can implement a destroy() method, if it wants to be called when
	not needed.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="unadvise" scope="instance">
        <parameters>
          <parameter name="handle" type="Object" usage="required">
            <description>The object returned by dojox.lang.aspect.advise().</description>
          </parameter>
        </parameters>
      </method>
      <method name="getContext" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getContextStack" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="proceed" scope="instance">
        <description>Calls the original function (or the next level around advice).
	Accepts and passes on any number of arguments, and returns a value.
	This function is valid only in the content of around calls.</description>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.async">
    <methods>
      <method name="seq" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="par" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="any" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="cond" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="ifThen" scope="instance">
        <parameters>
          <parameter name="cond" type="Object" usage="required"/>
          <parameter name="ifTrue" type="Object" usage="required"/>
          <parameter name="ifFalse" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loop" scope="instance">
        <parameters>
          <parameter name="cond" type="Object" usage="required"/>
          <parameter name="body" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.async.event">
    <methods>
      <method name="from" scope="instance">
        <parameters>
          <parameter name="src" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="failOn" scope="instance">
        <parameters>
          <parameter name="src" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.async.timeout">
    <methods>
      <method name="from" scope="instance">
        <parameters>
          <parameter name="ms" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="failOn" scope="instance">
        <parameters>
          <parameter name="ms" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.async.topic">
    <methods>
      <method name="from" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="failOn" scope="instance">
        <parameters>
          <parameter name="topic" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.docs">
    <methods>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="async" type="Boolean" usage="required">
            <description>If true, the documentation will be loaded asynchronously</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_loadedDocs" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.functional">
    <methods>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="every" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="inlineLambda" scope="instance">
        <parameters>
          <parameter name="lambda" type="String" usage="required">
            <description>The String variable representing the lambda function.</description>
          </parameter>
          <parameter name="init" type="String|Array" usage="required">
            <description>Conveys how to initialize parameters. If it is a String, then the apply() method
	would be emulated treating &amp;quot;init&amp;quot; as a list of input parameters.
	It it is an Array, then the call() method is emulated treating array members
	as input parameters.</description>
          </parameter>
          <parameter name="add2dict" type="Function" usage="optional">
            <description>The optional function, which is used to record names of lambda parameters.
	If supplied, this function is called with a name of every parameter.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="binrec" scope="instance">
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is used to detect the termination of recursion.
	It accepts the same parameter as the generated recursive function itself.
	This function should return &amp;quot;true&amp;quot;, if the recursion should be stopped,
	and the &amp;quot;then&amp;quot; part should be executed. Otherwise the recursion will proceed.</description>
          </parameter>
          <parameter name="then" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called upon termination of the recursion.
	It accepts the same parameters as the generated recursive function itself.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="before" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called before the recursive step.
	It accepts the same parameter as the generated recursive function itself.
	The returned value should be an array of two variable, which are used to call
	the generated function recursively twice in row starting from the first item.
	above:
	The lambda expression, which is called after the recursive step.
	It accepts three parameters: two returned values from recursive steps, and
	the original array of parameters used with all other functions.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="curry" scope="instance">
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="arity" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="partial" scope="instance">
        <description>This method is used to produce partially bound
	functions. If you want to change the order of arguments, use
	dojox.lang.functional.mixer() or dojox.lang.functional.flip().</description>
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="mixer" scope="instance">
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="mix" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="flip" scope="instance">
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="foldl" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldl1" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldr" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldr1" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="reduce" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="reduceRight" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="unfold" scope="instance">
        <parameters>
          <parameter name="pr" type="Function|String|Array" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="g" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="rawLambda" scope="instance">
        <description>This method is to normalize a functional representation (a
	text snippet) to an object that contains an array of
	arguments, and a body , which is used to calculate the
	returning value.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="buildLambda" scope="instance">
        <description>This method returns a textual representation of a function
	built from the snippet. It is meant to be evaled in the
	proper context, so local variables can be pulled from the
	environment.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="lambda" scope="instance">
        <description>This method is used to normalize a functional
	representation (a text snippet, an array, or a function) to
	a function object.</description>
        <parameters>
          <parameter name="s" type="Function|String|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="clearLambdaCache" scope="instance"/>
      <method name="linrec" scope="instance">
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is used to detect the termination of recursion.
	It accepts the same parameter as the generated recursive function itself.
	This function should return &amp;quot;true&amp;quot;, if the recursion should be stopped,
	and the &amp;quot;then&amp;quot; part should be executed. Otherwise the recursion will proceed.</description>
          </parameter>
          <parameter name="then" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called upon termination of the recursion.
	It accepts the same parameters as the generated recursive function itself.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="before" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called before the recursive step.
	It accepts the same parameter as the generated recursive function itself.
	The returned value should be an array, which is used to call
	the generated function recursively.
	above:
	The lambda expression, which is called after the recursive step.
	It accepts two parameters: the returned value from the recursive step, and
	the original array of parameters used with all other functions.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="buildListcomp" scope="instance">
        <description>This method returns a textual representation of a function
	built from the list comprehension text snippet (conformant to JS 1.7).
	It is meant to be evaled in the proper context, so local variable can be
	pulled from the environment.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="compileListcomp" scope="instance">
        <description>This method returns a function built from the list
	comprehension text snippet (conformant to JS 1.7). It is meant to be
	reused several times.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="listcomp" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="multirec" scope="instance">
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is used to detect the termination of recursion.
	It accepts the same parameter as the generated recursive function itself.
	This function should return &amp;quot;true&amp;quot;, if the recursion should be stopped,
	and the &amp;quot;then&amp;quot; part should be executed. Otherwise the recursion will proceed.</description>
          </parameter>
          <parameter name="then" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called upon termination of the recursion.
	It accepts the same parameters as the generated recursive function itself.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="before" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called before the recursive step.
	It accepts the same parameter as the generated recursive function itself.
	The returned value should be an array, which is used to call
	the generated function recursively. Each member of the array should be
	an array of parameters. The length of it defines how many times
	the generated function is called recursively.
	above:
	The lambda expression, which is called after the recursive step.
	It accepts two parameters: the array of returned values from recursive steps,
	and the original array of parameters used with all other functions.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="numrec" scope="instance">
        <description>This is a simplification of the linear recursion combinator:
	- the generated function takes one numeric parameter "x",
	- the "cond" is fixed and checks for 0.
	- the "before" is fixed and the generated function is called with "x - 1".
	- the "above is called with two parameters: the return from the generated
	function, and with "x".
	- as you can see the recursion is done by decreasing the parameter,
	and calling itself until it reaches 0.</description>
        <parameters>
          <parameter name="then" type="Object" usage="required">
            <description>The value, which is used upon termination of the recursion.
	It will be returned as the value of the generated function.
	above:
	The lambda expression, which is called after the recursive step.
	It accepts two parameters: the returned value from the recursive step, and
	the original parameter. The returned value will be returned as the value of
	the generated function.</description>
          </parameter>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="keys" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="values" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="filterIn" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="forIn" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="mapIn" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="filterRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="forEachRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="mapRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="everyRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="someRev" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="scanl" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scanl1" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scanr" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scanr1" scope="instance">
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="repeat" scope="instance">
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="until" scope="instance">
        <parameters>
          <parameter name="pr" type="Function|String|Array" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="tailrec" scope="instance">
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is used to detect the termination of recursion.
	It accepts the same parameter as the generated recursive function itself.
	This function should return &amp;quot;true&amp;quot;, if the recursion should be stopped,
	and the &amp;quot;then&amp;quot; part should be executed. Otherwise the recursion will proceed.</description>
          </parameter>
          <parameter name="then" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called upon termination of the recursion.
	It accepts the same parameters as the generated recursive function itself.
	The returned value will be returned as the value of the generated function.</description>
          </parameter>
          <parameter name="before" type="Function|String|Array" usage="required">
            <description>The lambda expression, which is called before the recursive step.
	It accepts the same parameter as the generated recursive function itself,
	and returns an array of arguments for the next recursive call of
	the generated function.</description>
          </parameter>
        </parameters>
      </method>
      <method name="zip" scope="instance">
        <description>This is the venerable zip combiner (for example,
	see Python documentation for general details). The returned
	array is truncated to match the length of the shortest input
	array.</description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="unzip" scope="instance">
        <description>This function is similar to dojox.lang.functional.zip()
	and can be used to unzip objects packed by
	dojox.lang.functional.zip(). It is here mostly to provide
	a short-cut for the different method signature.</description>
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="array" scope="instance" type="Object"/>
      <property name="arg" scope="instance" type="Object"/>
      <property name="fold" scope="instance" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
      <property name="reversed" scope="instance" type="Object"/>
      <property name="scan" scope="instance" type="Object"/>
      <property name="sequence" scope="instance" type="Object"/>
      <property name="util" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="frame.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="frame.contentWindow">
    <properties>
      <property name="document" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.oo">
    <methods>
      <method name="makeDecorator" scope="instance">
        <parameters>
          <parameter name="decorator" type="Function|Object" usage="required">
            <description>a function to handle the custom assignment,
	or an object with exec() method</description>
          </parameter>
        </parameters>
        <return-description>Function:
	new decorator constructor</return-description>
      </method>
      <method name="filter" scope="instance">
        <parameters>
          <parameter name="bag" type="Object" usage="required">
            <description>object to be filtered</description>
          </parameter>
          <parameter name="map" type="Object" usage="required">
            <description>the dictionary for renaming/removing while copying</description>
          </parameter>
        </parameters>
        <return-description>new dojox.lang.oo.Filter object</return-description>
      </method>
      <method name="applyDecorator" scope="instance">
        <parameters>
          <parameter name="decorator" type="Function" usage="required">
            <description>top-level decorator to apply</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>name of the property</description>
          </parameter>
          <parameter name="newValue" type="Object" usage="required">
            <description>new value of the property</description>
          </parameter>
          <parameter name="oldValue" type="Object" usage="required">
            <description>old value of the property</description>
          </parameter>
        </parameters>
        <return-description>Object:
	returns the final value of the property</return-description>
      </method>
      <method name="__mixin" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <description>target to receive new/updated properties</description>
          </parameter>
          <parameter name="source" type="Object" usage="required">
            <description>source of properties
	defaults: dojox.lang.oo.__MixinDefaults?:
	default functions for various aspects of mixing</description>
          </parameter>
          <parameter name="decorator" type="Object" usage="required"/>
          <parameter name="filter" type="Object" usage="required"/>
          <parameter name="mixer" type="Object" usage="required"/>
        </parameters>
        <return-description>Object:
	target</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="mixin" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <description>target to receive new/updated properties</description>
          </parameter>
          <parameter name="source" type="Object" usage="one-or-more">
            <description>source of properties, more than one source is allowed</description>
          </parameter>
        </parameters>
        <return-description>Object:
	target</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="rearrange" scope="instance">
        <description>Properties of an object are to be renamed or removed specified
	by "map" argument. Only own properties of "map" are processed.</description>
        <examples>
          <example>	oo.rearrange(bag, {
			abc: "def",	// rename "abc" attribute to "def"
			ghi: null	// remove/hide "ghi" attribute
		});</example>
        </examples>
        <parameters>
          <parameter name="bag" type="Object" usage="required">
            <description>the object to be processed</description>
          </parameter>
          <parameter name="map" type="Object" usage="required">
            <description>the dictionary for renaming (false value indicates removal of the named property)</description>
          </parameter>
        </parameters>
        <return-description>Object:
	the original object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.lang.oo.Decorator">
    <description>This object holds an original function or another decorator
	object, and implements a special mixin algorithm to be used
	by dojox.lang.oo.mixin.</description>
    <methods/>
    <properties>
      <property name="value" scope="instance" type="Object">
        <description>a payload to be processed by the decorator.</description>
      </property>
      <property name="decorator" scope="instance" type="Function|Object">
        <description>a function to handle the custom assignment, or an object with exec()
	method. The signature is:
	decorator(/*String*/ name, /*Function*/ newValue, /*Function*/ oldValue).</description>
      </property>
    </properties>
  </class>
  <class type="dojox.lang.oo.Filter">
    <description>This object is used as a holder of an original object
	(whose properites are to be copied), and a filter
	function used while copying by dojox.lang.oo.mixin.</description>
    <methods/>
    <properties>
      <property name="bag" scope="instance" type="Object">
        <description>object to be filtered</description>
      </property>
      <property name="filter" scope="instance" type="Function|Object">
        <description>a function to handle the name filtering,
	or an object with exec() method</description>
      </property>
    </properties>
  </class>
  <class type="dojox.lang.oo.aop">
    <properties>
      <property name="before" scope="instance" type="Object"/>
      <property name="around" scope="instance" type="Object"/>
      <property name="afterReturning" scope="instance" type="Object"/>
      <property name="afterThrowing" scope="instance" type="Object"/>
      <property name="after" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.oo.general">
    <properties>
      <property name="augment" scope="instance" type="Object"/>
      <property name="override" scope="instance" type="Object"/>
      <property name="shuffle" scope="instance" type="Object"/>
      <property name="wrap" scope="instance" type="Object"/>
      <property name="tap" scope="instance" type="Object"/>
      <property name="before" scope="instance" type="Object"/>
      <property name="after" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.lang.oo.__MixinDefaults">
    <methods/>
    <properties>
      <property name="decorator" scope="instance" type="Function">
        <description>a decorator function to be used in absence of other decorators</description>
      </property>
      <property name="filter" scope="instance" type="Function">
        <description>a filter function to be used in absence of other filters</description>
      </property>
      <property name="mixer" scope="instance" type="Function">
        <description>a mixer function to be used to mix in new properties</description>
      </property>
    </properties>
  </class>
  <class type="JSONSchema">
    <properties>
      <property name="__defineGetter__" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout">
    <properties>
      <property name="BorderContainer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ContentPane" superclass="dijit.layout.ContentPane">
    <description>useful if you send ContentPane a complete page, instead of a html fragment
	scans for
	* title Node, remove
	* DOCTYPE tag, remove</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="onExecError" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="cont" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
    </mixins>
    <properties>
      <property name="adjustPaths" scope="instance" type="Boolean">
        <description>Adjust relative paths in html string content to point to this page.
	Only useful if you grab content from a another folder then the current one</description>
      </property>
      <property name="cleanContent" scope="instance" type="Boolean"/>
      <property name="renderStyles" scope="instance" type="Boolean">
        <description>trigger/load styles in the content</description>
      </property>
      <property name="executeScripts" scope="instance" type="Boolean">
        <description>Execute (eval) scripts that is found in the content</description>
      </property>
      <property name="scriptHasHooks" scope="instance" type="Boolean">
        <description>replace keyword '_container_' in scripts with 'dijit.byId(this.id)'
	NOTE this name might change in the near future</description>
      </property>
      <property name="ioMethod" scope="instance" type="dojo.xhrGet|dojo.xhrPost">
        <description>reference to the method that should grab the content</description>
      </property>
      <property name="ioArgs" scope="instance-prototype" type="Object">
        <description>makes it possible to add custom args to xhrGet, like ioArgs.headers['X-myHeader'] = 'true'
	could put back _renderStyles by wrapping/aliasing dojox.html._ContentSetter.prototype._renderStyles</description>
      </property>
      <property name="_contentSetter" scope="instance" type="Object"/>
      <property name="_contentSetterParams" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.DragPane" superclass="dijit._Widget">
    <description>A small widget which takes a node with overflow:auto and
	allows dragging to position the content. Useful with images,
	or for just adding "something" to a overflow-able div.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_down" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_up" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_move" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="invert" scope="instance" type="Boolean">
        <description>Naturally, the behavior is to invert the axis of the drag.
	Setting invert:false will make the pane drag in the same
	direction as the mouse.</description>
      </property>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_x" scope="instance" type="Object"/>
      <property name="_y" scope="instance" type="Object"/>
      <property name="_mover" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ExpandoPane" superclass="dijit.layout.ContentPane">
    <description>Works just like a ContentPane inside of a borderContainer. Will expand/collapse on
	command, and supports having Layout Children as direct descendants</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_startupSizes" scope="instance"/>
      <method name="_afterResize" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setupAnims" scope="instance"/>
      <method name="preview" scope="instance"/>
      <method name="toggle" scope="instance"/>
      <method name="_hideWrapper" scope="instance"/>
      <method name="_showEnd" scope="instance"/>
      <method name="_hideEnd" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="newSize" type="Object" usage="optional">
            <description>The size object to resize to</description>
          </parameter>
        </parameters>
      </method>
      <method name="_trap" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="easeOut" scope="instance" type="String|Function">
        <description>easing function used to hide pane</description>
      </property>
      <property name="easeIn" scope="instance" type="String|Function">
        <description>easing function use to show pane</description>
      </property>
      <property name="duration" scope="instance" type="Integer">
        <description>duration to run show/hide animations</description>
      </property>
      <property name="startExpanded" scope="instance" type="Boolean">
        <description>Does this widget start in an open (true) or closed (false) state</description>
      </property>
      <property name="previewOpacity" scope="instance" type="Float">
        <description>A value from 0 .. 1 indicating the opacity to use on the container
	when only showing a preview</description>
      </property>
      <property name="previewOnDblClick" scope="instance" type="Boolean">
        <description>If true, will override the default behavior of a double-click calling a full toggle.
	If false, a double-click will cause the preview to popup</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_animConnects" scope="instance" type="Array"/>
      <property name="_isHorizontal" scope="instance" type="Object"/>
      <property name="_container" scope="instance" type="Object"/>
      <property name="_closedSize" scope="instance" type="Object"/>
      <property name="_titleHeight" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="_currentSize" scope="instance" type="Object"/>
      <property name="_showSize" scope="instance" type="Object"/>
      <property name="_showing" scope="instance" type="bool"/>
      <property name="_hasSizes" scope="instance" type="Object"/>
      <property name="_showAnim" scope="instance" type="Object"/>
      <property name="_hideAnim" scope="instance" type="Object"/>
      <property name="_isonlypreview" scope="instance" type="bool"/>
      <property name="_previewShowing" scope="instance" type="bool"/>
      <property name="_contentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane" superclass="dojox.layout.ContentPane">
    <description>Makes a `dojox.layout.ContentPane` float and draggable by it's title [similar to TitlePane]
	and over-rides onClick to onDblClick for wipeIn/Out of containerNode
	provides minimize(dock) / show() and hide() methods, and resize [almost]</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="setTitle" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance"/>
      <method name="hide" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="callback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="minimize" scope="instance"/>
      <method name="maximize" scope="instance"/>
      <method name="_restore" scope="instance"/>
      <method name="_dock" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bringToTop" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="closable" scope="instance" type="Boolean">
        <description>Allow closure of this Node</description>
      </property>
      <property name="dockable" scope="instance" type="Boolean">
        <description>Allow minimizing of pane if true</description>
      </property>
      <property name="resizable" scope="instance" type="Boolean">
        <description>Allow resizing of pane true if true</description>
      </property>
      <property name="maxable" scope="instance" type="Boolean">
        <description>Horrible param name for &amp;quot;Can you maximize this floating pane?&amp;quot;</description>
      </property>
      <property name="resizeAxis" scope="instance" type="String">
        <description>One of: x | xy | y to limit pane's sizing direction</description>
      </property>
      <property name="title" scope="instance" type="String">
        <description>Title to use in the header</description>
      </property>
      <property name="dockTo" scope="instance" type="DomNode">
        <description>if empty, will create private layout.Dock that scrolls with viewport
	on bottom span of viewport.</description>
      </property>
      <property name="duration" scope="instance" type="Integer">
        <description>Time is MS to spend toggling in/out node</description>
      </property>
      <property name="iconSrc" scope="instance" type="String">
        <description>[not implemented yet] will be either icon in titlepane to left
	of Title, and/or icon show when docked in a fisheye-like dock
	or maybe dockIcon would be better?</description>
      </property>
      <property name="contentClass" scope="instance" type="String">
        <description>The className to give to the inner node which has the content</description>
      </property>
      <property name="_showAnim" scope="instance" type="Object"/>
      <property name="_hideAnim" scope="instance" type="Object"/>
      <property name="_dockNode" scope="instance" type="Object"/>
      <property name="_restoreState" scope="instance" type="Object"/>
      <property name="_allFPs" scope="instance" type="Array"/>
      <property name="_startZ" scope="instance" type="Number"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="bgIframe" scope="instance" type="Object"/>
      <property name="_naturalState" scope="instance" type="Object"/>
      <property name="_resizeHandle" scope="instance" type="Object"/>
      <property name="_started" scope="instance" type="Object"/>
      <property name="_maximized" scope="instance" type="bool"/>
      <property name="_isDocked" scope="instance" type="Object"/>
      <property name="_currentState" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.dockNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.closeNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.maxNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.restoreNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.resizeHandle.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.domNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="position" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.canvas.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.containerNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.FloatingPane.domNode"/>
  <class type="dojox.layout.Dock" superclass="dijit._Widget">
    <methods>
      <method name="addNode" scope="instance">
        <parameters>
          <parameter name="refNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="_positionDock" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_docked" scope="instance" type="Array"/>
      <property name="_inPositioning" scope="instance" type="bool"/>
      <property name="autoPosition" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.layout._DockNode" superclass="dijit._Widget">
    <methods>
      <method name="restore" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String">
        <description>Shown in dock icon. should read parent iconSrc?</description>
      </property>
      <property name="paneRef" scope="instance" type="Widget">
        <description>reference to the FloatingPane we reprasent in any given dock</description>
      </property>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer" superclass="dojox.layout.GridContainerLite">
    <description>This component inherits of all features of gridContainerLite plus :
	- Resize colums
	- Add / remove columns
	- Fix columns at left or at right.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="resizeChildAfterDrop" scope="instance">
        <description>Allow to resize and put grips</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>domNode of dropped widget.</description>
          </parameter>
          <parameter name="targetArea" type="Object" usage="required">
            <description>AreaManager Object containing information of targetArea</description>
          </parameter>
          <parameter name="indexChild" type="Integer" usage="required">
            <description>Index where the dropped widget has been placed</description>
          </parameter>
        </parameters>
      </method>
      <method name="onShow" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="_createGrip" scope="instance">
        <parameters>
          <parameter name="index" type="Integer" usage="required">
            <description>index where the grip has to be created.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_placeGrips" scope="instance"/>
      <method name="_onGripDbClick" scope="instance"/>
      <method name="_resizeColumnOn" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onGripMouseUp" scope="instance"/>
      <method name="_resizeColumnMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_resizeColumnOff" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setColumns" scope="instance">
        <parameters>
          <parameter name="nbColumns" type="Integer" usage="required">
            <description>Number of columns</description>
          </parameter>
        </parameters>
      </method>
      <method name="_addColumn" scope="instance">
        <parameters>
          <parameter name="nbColumns" type="Integer" usage="required">
            <description>Number of column to added</description>
          </parameter>
        </parameters>
      </method>
      <method name="_deleteColumn" scope="instance">
        <parameters>
          <parameter name="indices" type="Array" usage="required">
            <description>Column index array</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateColumnsWidth" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required">
            <description>dojox.mdnd.AreaManager singleton</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.layout.GridContainerLite" scope="instance"/>
    </mixins>
    <properties>
      <property name="hasResizableColumns" scope="instance" type="Boolean">
        <description>Allow or not resizing of columns by a grip handle.</description>
      </property>
      <property name="liveResizeColumns" scope="instance" type="Boolean">
        <description>Specifies whether columns resize as you drag (true) or only upon mouseup (false)</description>
      </property>
      <property name="minColWidth" scope="instance" type="Integer">
        <description>Minimum column width in percentage.</description>
      </property>
      <property name="minChildWidth" scope="instance" type="Integer">
        <description>Minimum children width in pixel (only used for IE6 which doesn't handle min-width css property)</description>
      </property>
      <property name="mode" scope="instance" type="String">
        <description>Location to add/remove columns, must be set to 'left' or 'right' (default).</description>
      </property>
      <property name="isRightFixed" scope="instance" type="Boolean">
        <description>Define if the last right column is fixed.
	Used when you add or remove columns by calling setColumns method.</description>
      </property>
      <property name="isLeftFixed" scope="instance" type="Boolean">
        <description>Define if the last left column is fixed.
	Used when you add or remove columns by calling setColumns method.</description>
      </property>
      <property name="_activeGrip" scope="instance" type="Object"/>
      <property name="_initX" scope="instance" type="Object"/>
      <property name="_isResized" scope="instance" type="bool"/>
      <property name="_oldTabSize" scope="instance" type="Object"/>
      <property name="_currentColumn" scope="instance" type="Object"/>
      <property name="_currentColumnWidth" scope="instance" type="Object"/>
      <property name="_nextColumn" scope="instance" type="Object"/>
      <property name="_nextColumnWidth" scope="instance" type="Object"/>
      <property name="_currentMinCol" scope="instance" type="Object"/>
      <property name="_nextMinCol" scope="instance" type="Object"/>
      <property name="_connectResizeColumnMove" scope="instance" type="Object"/>
      <property name="_connectOnGripMouseUp" scope="instance" type="Object"/>
      <property name="_connectResizeColumnOff" scope="instance" type="Object"/>
      <property name="_dragManager" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer.domNode.style">
    <properties>
      <property name="overflowY" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer._activeGrip.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer._currentColumn.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer._nextColumn.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer.gridContainerTable">
    <properties>
      <property name="clientWidth" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainer._grid">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainerLite" superclass="dijit.layout._LayoutWidget">
    <description>GridContainerLite displays the child elements by column
	(ie: the children widths are fixed by the column width of the grid but
	the children heights are free).
	Each child is movable by drag and drop inside the GridContainer.
	The position of other children is automatically calculated when a child is moved.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resizeChildAfterDrop" scope="instance">
        <description>These components are resized only if the targetArea.node is a
	child of this instance of gridContainerLite.
	To be resized, the dropped node must have also a method resize.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>domNode of dropped widget.</description>
          </parameter>
          <parameter name="targetArea" type="Object" usage="required">
            <description>AreaManager Object containing information of targetArea</description>
          </parameter>
          <parameter name="indexChild" type="Integer" usage="required">
            <description>Index where the dropped widget has been placed</description>
          </parameter>
        </parameters>
        <return-description>True if resized.</return-description>
      </method>
      <method name="resizeChildAfterDragStart" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>domNode of dragged widget.</description>
          </parameter>
          <parameter name="sourceArea" type="Object" usage="required">
            <description>AreaManager Object containing information of sourceArea</description>
          </parameter>
          <parameter name="indexChild" type="Integer" usage="required">
            <description>Index where the dragged widget has been placed</description>
          </parameter>
        </parameters>
      </method>
      <method name="getChildren" scope="instance">
        <return-description>An array containing all children (widgets).</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_isShown" scope="instance">
        <return-description>true if the content is currently shown</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="layout" scope="instance"/>
      <method name="onShow" scope="instance"/>
      <method name="onHide" scope="instance"/>
      <method name="_createCells" scope="instance"/>
      <method name="_getZonesAttr" scope="instance"/>
      <method name="enableDnd" scope="instance"/>
      <method name="disableDnd" scope="instance"/>
      <method name="_organizeChildren" scope="instance"/>
      <method name="_organizeChildrenManually" scope="instance"/>
      <method name="_insertChild" scope="instance">
        <parameters>
          <parameter name="child" type="Widget" usage="required"/>
          <parameter name="column" type="Integer" usage="required">
            <description>Column number</description>
          </parameter>
          <parameter name="p" type="Integer" usage="optional">
            <description>Place in the zone (0 - first)</description>
          </parameter>
        </parameters>
        <return-description>The widget inserted</return-description>
        <return-types>
          <return-type type="Widget"/>
        </return-types>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="addService" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
          <parameter name="column" type="Integer" usage="optional"/>
          <parameter name="p" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required">
            <description>widget to insert</description>
          </parameter>
          <parameter name="column" type="Integer" usage="optional">
            <description>column number</description>
          </parameter>
          <parameter name="p" type="Integer" usage="optional">
            <description>place in the zone (first = 0)</description>
          </parameter>
        </parameters>
        <return-description>The widget inserted</return-description>
        <return-types>
          <return-type type="Widget"/>
        </return-types>
      </method>
      <method name="_setColWidthsAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateColumnsWidth" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required">
            <description>dojox.mdnd.AreaManager singleton</description>
          </parameter>
        </parameters>
      </method>
      <method name="_selectFocus" scope="instance">
        <description>Possibility to move focus into the GridContainer (TAB, LEFT ARROW, RIGHT ARROW, UP ARROW, DOWN ARROW).
	Possibility to move GridContainer's children (Drag and Drop) with keyboard. (SHIFT +  ARROW).
	If the type of widget is not draggable, a popup is displayed.</description>
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="autoRefresh" scope="instance" type="Boolean">
        <description>Enable the refresh of registered areas on drag start.</description>
      </property>
      <property name="templateString" scope="instance" type="String">
        <description>template of gridContainer.</description>
      </property>
      <property name="dragHandleClass" scope="instance" type="Array">
        <description>:
	CSS class enabling a drag handle on a child.</description>
      </property>
      <property name="nbZones" scope="instance" type="Integer">
        <description>The number of dropped zones, by default 1.</description>
      </property>
      <property name="doLayout" scope="instance" type="Boolean">
        <description>If true, change the size of my currently displayed child to match my size.</description>
      </property>
      <property name="isAutoOrganized" scope="instance" type="Boolean">
        <description>If true, widgets are organized automatically,
	else the attribute colum of child will define the right column.</description>
      </property>
      <property name="acceptTypes" scope="instance-prototype" type="Array">
        <description>The GridContainer will only accept the children that fit to the types.</description>
      </property>
      <property name="colWidths" scope="instance" type="String">
        <description>A comma separated list of column widths. If the column widths do not add up
	to 100, the remaining columns split the rest of the width evenly
	between them.</description>
      </property>
      <property name="_border" scope="instance" type="Object"/>
      <property name="_draggedNode" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_disabled" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainerLite._dragManager">
    <properties>
      <property name="autoRefresh" scope="instance" type="Object"/>
      <property name="dragHandleClass" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainerLite._contentBox">
    <properties>
      <property name="h" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainerLite._grid">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.GridContainerLite.gridNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RadioGroup" superclass="dijit.layout.StackContainer">
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_setupChild" scope="instance">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="instance">
        <parameters>
          <parameter name="newWidget" type="dijit._Widget" usage="required"/>
          <parameter name="oldWidget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="duration" scope="instance" type="Integer">
        <description>used for Fade and Slide RadioGroup's, the duration to run the transition animation. does not affect anything
	in default RadioGroup</description>
      </property>
      <property name="hasButtons" scope="instance" type="Boolean">
        <description>toggles internal button making on or off</description>
      </property>
      <property name="buttonClass" scope="instance" type="String">
        <description>The full declared className of the Button widget to use for hasButtons</description>
      </property>
      <property name="templateString" scope="instance" type="String">
        <description>the template for our container</description>
      </property>
      <property name="_children" scope="instance" type="Object"/>
      <property name="_buttons" scope="instance" type="Object"/>
      <property name="_size" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RadioGroupFade" superclass="dojox.layout.RadioGroup">
    <methods>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.layout.RadioGroup" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.RadioGroupSlide" superclass="dojox.layout.RadioGroup">
    <description>An extension on a stock RadioGroup widget, sliding the pane
	into view from being hidden. The entry direction is randomized
	on each view</description>
    <methods>
      <method name="easing" scope="instance-prototype"/>
      <method name="constructor" scope="instance"/>
      <method name="_positionChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="FIXME: is there a real &quot;size&quot; floating around always?"/>
        </return-types>
      </method>
      <method name="_showChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.layout.RadioGroup" scope="instance"/>
    </mixins>
    <properties>
      <property name="zTop" scope="instance" type="Integer">
        <description>A z-index to apply to the incoming pane</description>
      </property>
      <property name="_anim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout._RadioButton" superclass="dijit._Widget">
    <description>A private widget used to manipulate the StackContainer (RadioGroup*). Don't create directly.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_onMouse" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_clearSelected" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="String">
        <description>the Text Label of the button</description>
      </property>
      <property name="page" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.ResizeHandle" superclass="dijit._Widget">
    <description>The handle on the bottom-right corner of FloatingPane or other widgets that allows
	the widget to be resized.
	Typically not used directly.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_beginSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewCoords" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_checkConstraints" scope="instance">
        <parameters>
          <parameter name="newW" type="Object" usage="required"/>
          <parameter name="newH" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_changeSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_endSizing" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="targetId" scope="instance" type="String">
        <description>id of the Widget OR DomNode that I will size</description>
      </property>
      <property name="targetContainer" scope="instance" type="DomNode">
        <description>over-ride targetId and attch this handle directly to a reference of a DomNode</description>
      </property>
      <property name="resizeAxis" scope="instance" type="String">
        <description>one of: x|y|xy limit resizing to a single axis, default to xy ...</description>
      </property>
      <property name="activeResize" scope="instance" type="Boolean">
        <description>if true, node will size realtime with mouse movement,
	if false, node will create virtual node, and only resize target on mouseUp</description>
      </property>
      <property name="activeResizeClass" scope="instance" type="String">
        <description>css class applied to virtual resize node.</description>
      </property>
      <property name="animateSizing" scope="instance" type="Boolean">
        <description>only applicable if activeResize = false. onMouseup, animate the node to the
	new size</description>
      </property>
      <property name="animateMethod" scope="instance" type="String">
        <description>one of &amp;quot;chain&amp;quot; or &amp;quot;combine&amp;quot; ... visual effect only. combine will &amp;quot;scale&amp;quot;
	node to size, &amp;quot;chain&amp;quot; will alter width, then height</description>
      </property>
      <property name="animateDuration" scope="instance" type="Integer">
        <description>time in MS to run sizing animation. if animateMethod=&amp;quot;chain&amp;quot;, total animation
	playtime is 2*animateDuration</description>
      </property>
      <property name="minHeight" scope="instance" type="Integer">
        <description>smallest height in px resized node can be</description>
      </property>
      <property name="minWidth" scope="instance" type="Integer">
        <description>smallest width in px resize node can be</description>
      </property>
      <property name="constrainMax" scope="instance" type="Boolean">
        <description>Toggle if this widget cares about the maxHeight and maxWidth
	parameters.</description>
      </property>
      <property name="maxHeight" scope="instance" type="Integer">
        <description>Largest height size in px the resize node can become.</description>
      </property>
      <property name="maxWidth" scope="instance" type="Integer">
        <description>Largest width size in px the reize node can become.</description>
      </property>
      <property name="fixedAspect" scope="instance" type="Boolean">
        <description>Toggle to enable this widget to maintain the aspect
	ratio of the attached node.</description>
      </property>
      <property name="intermediateChanges" scope="instance" type="Boolean">
        <description>Toggle to enable/disable this widget from firing onResize
	events at every step of a resize. If &lt;code&gt;activeResize&lt;/code&gt; is true,
	and this is false, onResize only fires _after_ the drop
	operation. Animated resizing is not affected by this setting.</description>
      </property>
      <property name="startTopic" scope="instance" type="String">
        <description>The name of the topic this resizehandle publishes when resize is starting</description>
      </property>
      <property name="endTopic" scope="instance" type="String">
        <description>The name of the topic this resizehandle publishes when resize is complete</description>
      </property>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_resizeHelper" scope="instance" type="Object"/>
      <property name="minSize" scope="instance" type="Object"/>
      <property name="maxSize" scope="instance" type="Object"/>
      <property name="_resizeX" scope="instance" type="Object"/>
      <property name="_resizeY" scope="instance" type="Object"/>
      <property name="targetWidget" scope="instance" type="Object"/>
      <property name="targetDomNode" scope="instance" type="Object"/>
      <property name="_isSizing" scope="instance" type="bool"/>
      <property name="startPoint" scope="instance" type="Object"/>
      <property name="startSize" scope="instance" type="Object"/>
      <property name="_aspect" scope="instance" type="Object"/>
      <property name="_pconnects" scope="instance" type="Array"/>
      <property name="_activeResizeLastEvent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout._ResizeHelper" superclass="dijit._Widget">
    <methods>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.layout.RotatorContainer" superclass="dijit.layout.StackContainer">
    <description>The RotatorContainer cycles through the children with a transition.
	published topics:
	[widgetId]-update - Notifies pager(s) that a child has changed.
	Parameters:
	/*boolean*/ playing - true if playing, false if paused
	/*int*/ current     - current selected child
	/*int*/ total       - total number of children</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_setShowTabsAttr" scope="instance">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_updatePager" scope="instance"/>
      <method name="_onMouseOver" scope="instance"/>
      <method name="_onMouseOut" scope="instance"/>
      <method name="_resetTimer" scope="instance"/>
      <method name="_cycle" scope="instance">
        <parameters>
          <parameter name="next" type="boolean" usage="required">
            <description>or int</description>
          </parameter>
        </parameters>
      </method>
      <method name="_manualChange" scope="instance"/>
      <method name="_play" scope="instance">
        <parameters>
          <parameter name="skip" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pause" scope="instance"/>
      <method name="_state" scope="instance">
        <parameters>
          <parameter name="playing" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="instance">
        <parameters>
          <parameter name="next" type="dijit._Widget" usage="required"/>
          <parameter name="prev" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_transitionEnd" scope="instance"/>
      <method name="_fade" scope="instance">
        <parameters>
          <parameter name="next" type="dijit._Widget" usage="required"/>
          <parameter name="prev" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_styleNode" scope="instance">
        <parameters>
          <parameter name="node" type="DOMnode" usage="required"/>
          <parameter name="opacity" type="number" usage="required"/>
          <parameter name="zIndex" type="int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="showTabs" scope="instance" type="Boolean">
        <description>Sets the display of the tabs.  The tabs are actually a StackController.
	The child's title is used for the tab's label.</description>
      </property>
      <property name="transitionDelay" scope="instance" type="int">
        <description>The delay in milliseconds before transitioning to the next child.</description>
      </property>
      <property name="transition" scope="instance" type="String">
        <description>The type of transition to perform when switching children.
	A null transition will transition instantly.</description>
      </property>
      <property name="transitionDuration" scope="instance" type="int">
        <description>The duration of the transition in milliseconds.</description>
      </property>
      <property name="autoStart" scope="instance" type="Boolean">
        <description>Starts the timer to transition children upon creation.</description>
      </property>
      <property name="suspendOnHover" scope="instance" type="Boolean">
        <description>Pause the rotator when the mouse hovers over it.</description>
      </property>
      <property name="pauseOnManualChange" scope="instance" type="Boolean">
        <description>Pause the rotator when the tab is changed or the pager's next/previous
	buttons are clicked.</description>
      </property>
      <property name="reverse" scope="instance" type="Boolean">
        <description>Causes the rotator to rotate in reverse order.</description>
      </property>
      <property name="pagerId" scope="instance" type="String">
        <description>ID the pager widget.</description>
      </property>
      <property name="cycles" scope="instance" type="int">
        <description>Number of cycles before pausing.</description>
      </property>
      <property name="pagerClass" scope="instance" type="String">
        <description>The declared Class of the Pager used for this Widget</description>
      </property>
      <property name="id" scope="instance" type="String"/>
      <property name="tabNode" scope="instance" type="Object"/>
      <property name="_stackController" scope="instance" type="Object"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
      <property name="_over" scope="instance" type="bool"/>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="_playing" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.layout.RotatorPager" superclass="dijit._Widget">
    <description>A pager can be defined one of two ways:
	* Externally of the RotatorContainer's template and tell the
	RotatorPager the rotatorId of the RotatorContainer
	* As a direct descendant of the RotatorContainer (i.e. inside the
	RotatorContainer's template)
	The pager can contain the following components:
	* Previous button
	- Must be a dijit.form.Button
	- dojoAttachPoint must be named "previous"
	* Next button
	- Must be a dijit.form.Button
	- dojoAttachPoint must be named "next"
	* Play/Pause toggle button
	- Must be a dijit.form.ToggleButton
	- dojoAttachPoint must be named "playPause"
	- Use iconClass to specify toggled state
	* Current child #
	- dojoAttachPoint must be named "current"
	* Total # of children
	- dojoAttachPoint must be named "total"
	You can choose to exclude specific controls as well as add elements
	for styling.
	Should you need a pager, but don't want to use Dijit buttons, you can
	write your own pager widget and just wire it into the topics.  The
	topic names are prefixed with the widget ID of the RotatorContainer.
	Notifications are received from and sent to the RotatorContainer as
	well as other RotatorPagers.
	published topics:
	[widgetId]-cycle - Notify that the next or previous button was pressed.
	Parameters:
	/*boolean*/ next - true if next, false if previous
	[widgetId]-state - Notify that the play/pause button was toggled.
	Parameters:
	/*boolean*/ playing - true if playing, false if paused</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_state" scope="instance">
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="instance">
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
          <parameter name="current" type="int" usage="required"/>
          <parameter name="total" type="int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="rotatorId" scope="instance" type="int">
        <description>The ID of the rotator this pager is tied to.
	Only required if defined outside of the RotatorContainer's container.</description>
      </property>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.layout.RotatorPager.current">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.RotatorPager.total">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ScrollPane" superclass="dijit.layout.ContentPane">
    <description>A sizable container that takes it's content's natural size and creates
	a scroll effect based on the relative mouse position. It is an interesting
	way to display lists of data, or blocks of content, within a confined
	space.
	Horizontal scrolling is supported. Combination scrolling is not.
	FIXME: need to adust the _line somehow, it stops scrolling</description>
    <methods>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="n" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="_calc" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_enter" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_leave" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="_line" scope="instance" type="dojo._Line">
        <description>storage for our top and bottom most scrollpoints</description>
      </property>
      <property name="_lo" scope="instance" type="the">
        <description>height of the visible pane</description>
      </property>
      <property name="_offset" scope="instance" type="Number"/>
      <property name="orientation" scope="instance" type="String">
        <description>either &amp;quot;horizontal&amp;quot; or &amp;quot;vertical&amp;quot; for scroll orientation.</description>
      </property>
      <property name="autoHide" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_dir" scope="instance" type="String"/>
      <property name="_vertical" scope="instance" type="bool"/>
      <property name="_size" scope="instance" type="Object"/>
      <property name="_helpLine" scope="instance" type="Object"/>
      <property name="_showAnim" scope="instance" type="Object"/>
      <property name="_hideAnim" scope="instance" type="Object"/>
      <property name="_edge" scope="instance" type="String"/>
      <property name="_scroll" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.ScrollPane.helper.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.TableContainer" superclass="dijit.layout._LayoutWidget">
    <description>The TableContainer lays out child widgets in a Table layout.
	Each widget can specify a "label" or a "title" parameter.
	This label is displayed either above or to the left of
	a widget depending on whether the "orientation" attribute
	is "horiz" or "vert", for horizontal and vertical respectively.
	The number of columns is configured using the "cols" attribute.
	The width of labels can be configured using the "labelWidth" parameter.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="layout" scope="instance"/>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setSpacingAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="cols" scope="instance" type="Number"/>
      <property name="labelWidth" scope="instance" type="Number|String">
        <description>Defines the width of a label.  If the value is a number, it is
	treated as a pixel value.  The other valid value is a percentage,
	e.g. &amp;quot;50%&amp;quot;</description>
      </property>
      <property name="showLabels" scope="instance" type="Boolean">
        <description>True if labels should be displayed, false otherwise.</description>
      </property>
      <property name="orientation" scope="instance" type="String">
        <description>Either &amp;quot;horiz&amp;quot; or &amp;quot;vert&amp;quot; for label orientation.</description>
      </property>
      <property name="spacing" scope="instance" type="Number">
        <description>The cell spacing to apply to the table.</description>
      </property>
      <property name="customClass" scope="instance" type="String">
        <description>A CSS class that will be applied to child elements.  For example, if
	the class is &amp;quot;myClass&amp;quot;, the table will have &amp;quot;myClass-table&amp;quot; applied to it,
	each label TD will have &amp;quot;myClass-labelCell&amp;quot; applied, and each
	widget TD will have &amp;quot;myClass-valueCell&amp;quot; applied.</description>
      </property>
      <property name="_children" scope="instance" type="Array"/>
      <property name="_initialized" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.TableContainer.table">
    <properties>
      <property name="cellspacing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ToggleSplitter" superclass="dijit.layout._Splitter">
    <description>Extends the dijit.layout._Splitter to add a toggling behavior
	on double-click</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_onMouseUp" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onPrelimMouseMove" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="instance"/>
      <method name="_getStyleProps" scope="instance">
        <parameters>
          <parameter name="paneNode" type="Object" usage="required"/>
          <parameter name="open" type="Object" usage="required"/>
          <parameter name="paneStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setStateClass" scope="instance"/>
      <method name="_setOpenAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="_toggleMe" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout._Splitter" scope="instance"/>
    </mixins>
    <properties>
      <property name="container" scope="instance" type="Object"/>
      <property name="region" scope="instance" type="Object"/>
      <property name="open" scope="instance" type="Boolean">
        <description>the initial and current state of the splitter (and its attached pane)</description>
      </property>
      <property name="closedThreshold" scope="instance" type="Integer">
        <description>how small the attached pane can be before its considered closed</description>
      </property>
      <property name="openSize" scope="instance" type="String">
        <description>the css height/width value to apply by default when the attached pane is open</description>
      </property>
      <property name="_closedSize" scope="instance" type="String">
        <description>the css height/width value to apply by default when the attached pane is closed</description>
      </property>
      <property name="templateString" scope="instance" type="String"/>
      <property name="_started" scope="instance" type="Object"/>
      <property name="_openStyleProps" scope="instance" type="Object"/>
      <property name="_startPosn" scope="instance" type="Number"/>
      <property name="_onUpHandle" scope="instance" type="Object"/>
      <property name="_onMoveHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ToggleSplitter.child">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd">
    <methods>
      <method name="_setGcDndHandle" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="withHandles" type="Object" usage="required"/>
          <parameter name="handleClasses" type="Object" usage="required"/>
          <parameter name="first" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="handdleIE" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.Avatar" superclass="dojo.dnd.Avatar">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="manager" type="Object" usage="required"/>
          <parameter name="opacity" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="construct" scope="instance"/>
      <method name="update" scope="instance"/>
      <method name="_generateText" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Avatar" scope="instance"/>
    </mixins>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="opacity" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.Avatar.manager">
    <properties>
      <property name="source" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd" superclass="dojo.dnd.Source">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calculateCoords" scope="instance">
        <parameters>
          <parameter name="height" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setDndItemSelectable" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="isSelectable" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getDraggedWidget" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="isAccepted" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="onDndStart" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="onDndDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Object" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_markTargetAnchor" scope="instance">
        <parameters>
          <parameter name="before" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="instance"/>
      <method name="setIndicatorPosition" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="deleteDashedZone" scope="instance"/>
      <method name="insertDashedZone" scope="instance">
        <parameters>
          <parameter name="before" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="insertNodes" scope="instance">
        <parameters>
          <parameter name="addSelected" type="Boolean" usage="required"/>
          <parameter name="data" type="Array" usage="required"/>
          <parameter name="before" type="Boolean" usage="required"/>
          <parameter name="anchor" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_checkAutoScroll" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollUp" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollDown" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stopAutoScroll" scope="instance"/>
      <method name="_sumAncestorProperties" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="prop" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="integer"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Source" scope="instance"/>
    </mixins>
    <properties>
      <property name="GC_OFFSET_X" scope="instance" type="Object"/>
      <property name="GC_OFFSET_Y" scope="instance" type="Object"/>
      <property name="firstIndicator" scope="instance" type="bool"/>
      <property name="dndNodes" scope="instance" type="Object"/>
      <property name="selection" scope="instance" type="Object"/>
      <property name="anchor" scope="instance" type="Object"/>
      <property name="containerSource" scope="instance" type="bool"/>
      <property name="targetAnchor" scope="instance" type="Object"/>
      <property name="targetBox" scope="instance" type="Object"/>
      <property name="before" scope="instance" type="Object"/>
      <property name="_over" scope="instance-prototype" type="bool"/>
      <property name="dropObject" scope="instance" type="Object"/>
      <property name="dom" scope="instance-prototype" type="Object"/>
      <property name="autoScrollActive" scope="instance" type="bool"/>
      <property name="_timer" scope="instance-prototype" type="Object"/>
      <property name="childBoxes" scope="instance" type="Object"/>
      <property name="dropIndicator" scope="instance" type="Object"/>
      <property name="withHandles" scope="instance" type="Object"/>
      <property name="handleClasses" scope="instance" type="Object"/>
      <property name="opacity" scope="instance" type="Object"/>
      <property name="allowAutoScroll" scope="instance" type="Object"/>
      <property name="singular" scope="instance" type="Object"/>
      <property name="skipForm" scope="instance" type="Object"/>
      <property name="defaultHandleClass" scope="instance" type="String"/>
      <property name="isDropped" scope="instance" type="bool"/>
      <property name="isOffset" scope="instance" type="Object"/>
      <property name="hideSource" scope="instance" type="Object"/>
      <property name="_drop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd._drop.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd.current">
    <properties>
      <property name="coords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.PlottedDnd.offsetDrag">
    <properties>
      <property name="x" scope="instance" type="Number"/>
      <property name="y" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.layout.dnd.DropIndicator">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="cn" type="String" usage="required"/>
          <parameter name="tag" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="isInserted" scope="instance"/>
      <method name="create" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="tag" scope="instance" type="String"/>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="document.body">
    <methods>
      <method name="onselectstart" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.layout.ext-dijit.layout">
    <properties>
      <property name="StackContainer-touch" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.layout.ext-dijit"/>
  <class type="dojox.math.BigInteger.prototype">
    <properties>
      <property name="_chunkSize" scope="instance" type="Object"/>
      <property name="_toRadix" scope="instance" type="Object"/>
      <property name="_fromRadix" scope="instance" type="Object"/>
      <property name="_fromNumber" scope="instance" type="Object"/>
      <property name="_bitwiseTo" scope="instance" type="Object"/>
      <property name="_changeBit" scope="instance" type="Object"/>
      <property name="_addTo" scope="instance" type="Object"/>
      <property name="_dMultiply" scope="instance" type="Object"/>
      <property name="_dAddOffset" scope="instance" type="Object"/>
      <property name="_multiplyLowerTo" scope="instance" type="Object"/>
      <property name="_multiplyUpperTo" scope="instance" type="Object"/>
      <property name="_modInt" scope="instance" type="Object"/>
      <property name="_millerRabin" scope="instance" type="Object"/>
      <property name="clone" scope="instance" type="Object"/>
      <property name="intValue" scope="instance" type="Object"/>
      <property name="byteValue" scope="instance" type="Object"/>
      <property name="shortValue" scope="instance" type="Object"/>
      <property name="signum" scope="instance" type="Object"/>
      <property name="toByteArray" scope="instance" type="Object"/>
      <property name="equals" scope="instance" type="Object"/>
      <property name="min" scope="instance" type="Object"/>
      <property name="max" scope="instance" type="Object"/>
      <property name="and" scope="instance" type="Object"/>
      <property name="or" scope="instance" type="Object"/>
      <property name="xor" scope="instance" type="Object"/>
      <property name="andNot" scope="instance" type="Object"/>
      <property name="not" scope="instance" type="Object"/>
      <property name="shiftLeft" scope="instance" type="Object"/>
      <property name="shiftRight" scope="instance" type="Object"/>
      <property name="getLowestSetBit" scope="instance" type="Object"/>
      <property name="bitCount" scope="instance" type="Object"/>
      <property name="testBit" scope="instance" type="Object"/>
      <property name="setBit" scope="instance" type="Object"/>
      <property name="clearBit" scope="instance" type="Object"/>
      <property name="flipBit" scope="instance" type="Object"/>
      <property name="add" scope="instance" type="Object"/>
      <property name="subtract" scope="instance" type="Object"/>
      <property name="multiply" scope="instance" type="Object"/>
      <property name="divide" scope="instance" type="Object"/>
      <property name="remainder" scope="instance" type="Object"/>
      <property name="divideAndRemainder" scope="instance" type="Object"/>
      <property name="modPow" scope="instance" type="Object"/>
      <property name="modInverse" scope="instance" type="Object"/>
      <property name="pow" scope="instance" type="Object"/>
      <property name="gcd" scope="instance" type="Object"/>
      <property name="isProbablePrime" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="NullExp">
    <properties>
      <property name="convert" scope="instance" type="Object"/>
      <property name="revert" scope="instance" type="Object"/>
      <property name="mulTo" scope="instance" type="Object"/>
      <property name="sqrTo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="Barrett">
    <properties>
      <property name="convert" scope="instance" type="Object"/>
      <property name="revert" scope="instance" type="Object"/>
      <property name="reduce" scope="instance" type="Object"/>
      <property name="mulTo" scope="instance" type="Object"/>
      <property name="sqrTo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="Classic.prototype">
    <properties>
      <property name="convert" scope="instance" type="Object"/>
      <property name="revert" scope="instance" type="Object"/>
      <property name="reduce" scope="instance" type="Object"/>
      <property name="mulTo" scope="instance" type="Object"/>
      <property name="sqrTo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="Montgomery.prototype">
    <properties>
      <property name="convert" scope="instance" type="Object"/>
      <property name="revert" scope="instance" type="Object"/>
      <property name="reduce" scope="instance" type="Object"/>
      <property name="mulTo" scope="instance" type="Object"/>
      <property name="sqrTo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="BigInteger.prototype">
    <properties>
      <property name="_DB" scope="instance" type="Object"/>
      <property name="_copyTo" scope="instance" type="Object"/>
      <property name="_fromInt" scope="instance" type="Object"/>
      <property name="_fromString" scope="instance" type="Object"/>
      <property name="_clamp" scope="instance" type="Object"/>
      <property name="_dlShiftTo" scope="instance" type="Object"/>
      <property name="_drShiftTo" scope="instance" type="Object"/>
      <property name="_lShiftTo" scope="instance" type="Object"/>
      <property name="_rShiftTo" scope="instance" type="Object"/>
      <property name="_subTo" scope="instance" type="Object"/>
      <property name="_multiplyTo" scope="instance" type="Object"/>
      <property name="_squareTo" scope="instance" type="Object"/>
      <property name="_divRemTo" scope="instance" type="Object"/>
      <property name="_invDigit" scope="instance" type="Object"/>
      <property name="_isEven" scope="instance" type="Object"/>
      <property name="_exp" scope="instance" type="Object"/>
      <property name="toString" scope="instance" type="Object"/>
      <property name="negate" scope="instance" type="Object"/>
      <property name="abs" scope="instance" type="Object"/>
      <property name="compareTo" scope="instance" type="Object"/>
      <property name="bitLength" scope="instance" type="Object"/>
      <property name="mod" scope="instance" type="Object"/>
      <property name="modPowInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="BigInteger">
    <methods/>
    <properties>
      <property name="_DM" scope="instance" type="Number"/>
      <property name="_DV" scope="instance" type="bool"/>
      <property name="_FV" scope="instance" type="Object"/>
      <property name="_F1" scope="instance" type="Number"/>
      <property name="_F2" scope="instance" type="Number"/>
      <property name="am" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.curves">
    <methods>
      <method name="Arc" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
          <parameter name="ccw" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="Circle" scope="instance">
        <parameters>
          <parameter name="center" type="Object" usage="required"/>
          <parameter name="radius" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math.curves.Line">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="dimensions" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.curves.Bezier">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="p" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.curves.CatmullRom">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="step" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="c" scope="instance" type="Number"/>
      <property name="p" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.curves.CenteredArc">
    <methods>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="center" scope="instance" type="Object"/>
      <property name="radius" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Number"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.math.curves.Path">
    <methods>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="curve" type="Object" usage="required"/>
          <parameter name="weight" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="curve" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeAll" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.math.matrix">
    <methods>
      <method name="multiply" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="product" scope="instance">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="sum" scope="instance">
        <return-types>
          <return-type type="Number"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="inverse" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="determinant" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="create" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
          <parameter name="value" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="ones" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="zeros" scope="instance">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="identity" scope="instance">
        <parameters>
          <parameter name="size" type="Number" usage="required"/>
          <parameter name="scale" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="adjoint" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="transpose" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="points" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="copy" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scale" scope="instance">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="factor" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="iDF" scope="instance" type="Number"/>
      <property name="ALMOST_ZERO" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.math.matrix.upperTriangle">
    <methods/>
    <properties>
      <property name="iDF" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.math.random.Secure">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="prng" type="Function" usage="required">
            <description>function that returns an instance of PRNG (pseudorandom number generator)
	with two methods: init(array) and next(). It should have a property &amp;quot;size&amp;quot;
	to indicate the required pool size.</description>
          </parameter>
          <parameter name="noEvents" type="Boolean" usage="optional">
            <description>if false or absent, onclick and onkeypress event will be used to add
	&amp;quot;randomness&amp;quot;, otherwise events will not be used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="nextBytes" scope="instance">
        <parameters>
          <parameter name="byteArray" type="Array" usage="required">
            <description>Array: array to be filled in with random numbers, only existing
	elements will be filled.</description>
          </parameter>
        </parameters>
      </method>
      <method name="seedTime" scope="instance"/>
      <method name="_seed_int" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="state" scope="instance" type="Object"/>
      <property name="pool" scope="instance-prototype" type="Object"/>
      <property name="pptr" scope="instance-prototype" type="Number"/>
      <property name="prng" scope="instance" type="Function">
        <description>function that returns an instance of PRNG (pseudorandom number generator)
	with two methods: init(array) and next(). It should have a property &amp;quot;size&amp;quot;
	to indicate the required pool size.
	noEvents: Boolean?:
	if false or absent, onclick and onkeypress event will be used to add
	&amp;quot;randomness&amp;quot;, otherwise events will not be used.</description>
      </property>
      <property name="h" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="Arcfour">
    <methods/>
  </class>
  <class type="Arcfour.init">
    <methods/>
    <properties>
      <property name="S" scope="instance" type="Object"/>
      <property name="i" scope="instance" type="Number"/>
      <property name="j" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="Arcfour.next">
    <methods/>
    <properties>
      <property name="S" scope="instance" type="Object"/>
      <property name="i" scope="instance" type="bool"/>
      <property name="j" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.math.stats">
    <methods>
      <method name="sd" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="variance" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="bestFit" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Object&gt;" usage="required">
            <description>|| Number[]</description>
          </parameter>
          <parameter name="xProp" type="String" usage="optional"/>
          <parameter name="yProp" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="forecast" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Object&gt;" usage="required">
            <description>|| Number[]</description>
          </parameter>
          <parameter name="x" type="Number" usage="required"/>
          <parameter name="xProp" type="String" usage="optional"/>
          <parameter name="yProp" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="mean" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="min" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="max" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="median" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="mode" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="sum" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="approxLin" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required">
            <description>a sorted numeric array to be used for the approximation.</description>
          </parameter>
          <parameter name="pos" type="Number" usage="required">
            <description>a position number from 0 to 1. If outside of this range it
	will be clamped.</description>
          </parameter>
        </parameters>
        <return-description>Number</return-description>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="summary" scope="instance">
        <parameters>
          <parameter name="a" type="Array&lt;Number&gt;" usage="required">
            <description>a numeric array to be appraised.</description>
          </parameter>
          <parameter name="alreadySorted" type="Boolean" usage="optional">
            <description>a Boolean flag to indicated that the array is already sorted.
	This is an optional flag purely to improve the performance.
	If skipped, the array will be assumed unsorted.</description>
          </parameter>
        </parameters>
        <return-description>Object</return-description>
        <return-types>
          <return-type type="sort it properly"/>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.mdnd">
    <methods>
      <method name="areaManager" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_areaManager" scope="instance" type="Object"/>
      <property name="autoScroll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.AreaManager">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="init" scope="instance"/>
      <method name="registerByNode" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>a DOM node corresponding to the Dnd Area</description>
          </parameter>
          <parameter name="notInitAreas" type="Boolean" usage="required">
            <description>if false or undefined, init the areas.</description>
          </parameter>
        </parameters>
      </method>
      <method name="registerByClass" scope="instance"/>
      <method name="unregister" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>A node corresponding to the D&amp;amp;D Area.</description>
          </parameter>
        </parameters>
        <return-description>True if the area is found and unregistered.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_addMoveableItem" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>A child of the D&amp;amp;D Area.</description>
          </parameter>
        </parameters>
        <return-description>The draggable item.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_deleteMoveableItem" scope="instance">
        <parameters>
          <parameter name="objItem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getIndexArea" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>A moveable Object.</description>
          </parameter>
        </parameters>
        <return-description>area index or -1</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_searchDragHandle" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>A child of the D&amp;amp;D Area.</description>
          </parameter>
        </parameters>
        <return-description>The drag handle node.</return-description>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="addDragItem" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>a node corresponding to the D&amp;amp;D Area</description>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <description>the node which has to be treated.</description>
          </parameter>
          <parameter name="index" type="Integer" usage="required">
            <description>the place in the area
	noCheckParent:
	if true, doesn't check if node has a parent.</description>
          </parameter>
          <parameter name="notCheckParent" type="Boolean" usage="required"/>
        </parameters>
        <return-description>True if the node has been inserted else false.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="removeDragItem" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>A node corresponding to the DndArea.</description>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node which has to be treated.</description>
          </parameter>
        </parameters>
        <return-description>the removed node</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_getChildren" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>A DnD area.</description>
          </parameter>
        </parameters>
        <return-description>The children of a DnD area</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setMarginArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>The object of a D&amp;amp;D Area.</description>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node which contains margins</description>
          </parameter>
        </parameters>
      </method>
      <method name="findCurrentIndexArea" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating the area size</description>
          </parameter>
        </parameters>
        <return-description>an index of area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_isAccepted" scope="instance">
        <parameters>
          <parameter name="type" type="Array" usage="required">
            <description>containing item type</description>
          </parameter>
          <parameter name="accept" type="Array" usage="required">
            <description>containing types</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragStart" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node which is about to be dragged</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragEnter" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates of the dragged Node.</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>size of the dragged Node.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragExit" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates of the dragged Node.</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>size of the dragged Node.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDrag" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node which is dragged</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
          <parameter name="mousePosition" type="Object" usage="required">
            <description>coordinates of mouse</description>
          </parameter>
        </parameters>
      </method>
      <method name="placeDropIndicator" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
        </parameters>
        <return-description>the current drop index</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_placeDropIndicator" scope="instance">
        <parameters>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDropCancel" scope="instance"/>
      <method name="onDrop" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The node which is about to be dropped</description>
          </parameter>
        </parameters>
      </method>
      <method name="_resetAfterDrop" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="autoRefresh" scope="instance" type="Boolean">
        <description>Enable the refresh of registered areas on drag start.</description>
      </property>
      <property name="areaClass" scope="instance" type="String">
        <description>CSS class enabled an area if areaClass is defined</description>
      </property>
      <property name="dragHandleClass" scope="instance" type="String">
        <description>CSS class enabled a drag handle.</description>
      </property>
      <property name="_areaList" scope="instance-prototype" type="Array"/>
      <property name="_oldIndexArea" scope="instance-prototype" type="Number"/>
      <property name="_currentIndexArea" scope="instance-prototype" type="Number"/>
      <property name="_accept" scope="instance" type="bool"/>
      <property name="_cover" scope="instance" type="Object"/>
      <property name="_cover2" scope="instance" type="Object"/>
      <property name="_dragStartHandler" scope="instance" type="Object"/>
      <property name="_sourceIndexArea" scope="instance-prototype" type="Number"/>
      <property name="_lastValidIndexArea" scope="instance" type="Object"/>
      <property name="_dragItem" scope="instance" type="Object"/>
      <property name="_currentDropIndex" scope="instance-prototype" type="Number"/>
      <property name="_sourceDropIndex" scope="instance-prototype" type="Number"/>
      <property name="_eventsIE7" scope="instance" type="Array"/>
      <property name="_oldDropIndex" scope="instance-prototype" type="Number"/>
      <property name="resizeHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.AreaManager._cover.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.AreaManager._cover2.style">
    <properties>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.AutoScroll">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="init" scope="instance"/>
      <method name="getViewport" scope="instance"/>
      <method name="setAutoScrollNode" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>node to scroll</description>
          </parameter>
        </parameters>
      </method>
      <method name="setAutoScrollMaxPage" scope="instance"/>
      <method name="checkAutoScroll" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollDown" scope="instance"/>
      <method name="_autoScrollUp" scope="instance"/>
      <method name="_autoScrollRight" scope="instance"/>
      <method name="_autoScrollLeft" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="stopAutoScroll" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="interval" scope="instance" type="Integer">
        <description>default mouse move offset</description>
      </property>
      <property name="recursiveTimer" scope="instance" type="Integer"/>
      <property name="marginMouse" scope="instance" type="Integer">
        <description>Default mouse margin</description>
      </property>
      <property name="_html" scope="instance" type="Object"/>
      <property name="_v" scope="instance" type="Object"/>
      <property name="_node" scope="instance" type="Object"/>
      <property name="_yMax" scope="instance" type="Object"/>
      <property name="_xMax" scope="instance" type="Object"/>
      <property name="_y" scope="instance" type="Object"/>
      <property name="_x" scope="instance" type="Object"/>
      <property name="_autoScrollActive" scope="instance" type="bool"/>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="resizeHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.AutoScroll._node.style">
    <properties>
      <property name="top" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.DropIndicator">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="area" type="Node" usage="required">
            <description>the dnd targer area node</description>
          </parameter>
          <parameter name="nodeRef" type="Node" usage="required">
            <description>node where the dropIndicator have to be placed into the area
	dragNode:
	the node which is dragged</description>
          </parameter>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
        <return-description>the node inserted or null if it crashes</return-description>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="remove" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="node" scope="instance-prototype" type="DOMNode">
        <description>the drop indicator node</description>
      </property>
    </properties>
  </class>
  <class type="dojox.mdnd.DropIndicator.node.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.LazyManager">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="getItem" scope="instance">
        <parameters>
          <parameter name="draggedNode" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="startDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="draggedNode" type="DOMNode" usage="optional"/>
        </parameters>
      </method>
      <method name="cancelDrag" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="_registry" scope="instance" type="Object"/>
      <property name="_fakeSource" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.LazyManager.manager">
    <properties>
      <property name="target" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.Moveable">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required">
            <description>Hash of parameters</description>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <description>The draggable node</description>
          </parameter>
        </parameters>
      </method>
      <method name="isFormElement" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>a DOM event</description>
          </parameter>
        </parameters>
        <return-description>if true, the target is one of those specific nodes.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>a DOM event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onFirstMove" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>A DOM event</description>
          </parameter>
        </parameters>
      </method>
      <method name="initOffsetDrag" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>A DOM event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMove" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>a DOM event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>a DOM event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragStart" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>a DOM node</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>absolute position of the main node</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width an height values</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragEnd" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>a DOM node</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDrag" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <description>a DOM node</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>position of the main node (equals to css left/top properties)</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
          <parameter name="mousePosition" type="Object" usage="required">
            <description>coordiantes of mouse</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="handle" scope="instance-prototype" type="DOMNode">
        <description>The node on which the user clicks to drag the main node.</description>
      </property>
      <property name="skip" scope="instance-prototype" type="Boolean">
        <description>A flag to control a drag action if a form element has been focused.
	If true, the drag action is not executed.</description>
      </property>
      <property name="dragDistance" scope="instance" type="Integer">
        <description>The user clicks on the handle, but the drag action will really begin
	if he tracks the main node to more than 3 pixels.</description>
      </property>
      <property name="_selectStart" scope="instance" type="Object"/>
      <property name="_firstX" scope="instance" type="Object"/>
      <property name="_firstY" scope="instance" type="Object"/>
      <property name="_isDragging" scope="instance" type="bool"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="date" scope="instance" type="Object"/>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="d" scope="instance" type="Object"/>
      <property name="autoScroll" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.Moveable.node"/>
  <class type="dojox.mdnd.Moveable.offsetDrag">
    <properties>
      <property name="l" scope="instance" type="Number"/>
      <property name="t" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.mdnd.Moveable.node.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.PureSource" superclass="dojo.dnd.Selector">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <description>Node or node's id to build the source on.</description>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SourceArgs" usage="optional">
            <description>Any property of this class may be configured via the params
	object which is mixed-in to the 'dojo.dnd.Source' instance.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDndCancel" scope="instance"/>
      <method name="copyState" scope="instance">
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required">
            <description>The &amp;quot;copy&amp;quot; was pressed.</description>
          </parameter>
        </parameters>
        <return-description>True, if we need to copy items, false to move.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="markupFactory" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required">
            <description>???</description>
          </parameter>
          <parameter name="node" type="DomNode" usage="required">
            <description>???</description>
          </parameter>
        </parameters>
        <return-description>New dojox.mdnd.PureSource instance.</return-description>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Mouse event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Mouse event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Mouse event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onOverEvent" scope="instance"/>
      <method name="onOutEvent" scope="instance"/>
      <method name="_markDndStatus" scope="instance">
        <parameters>
          <parameter name="copy" type="Boolean" usage="required">
            <description>Copy status.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <description>Mouse event.</description>
          </parameter>
        </parameters>
        <return-description>True if user clicked on "approved" items.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.dnd.Selector" scope="instance"/>
    </mixins>
    <properties>
      <property name="horizontal" scope="instance" type="bool"/>
      <property name="copyOnly" scope="instance" type="Object"/>
      <property name="skipForm" scope="instance" type="bool"/>
      <property name="withHandles" scope="instance" type="bool"/>
      <property name="isSource" scope="instance" type="Object"/>
      <property name="targetState" scope="instance" type="String"/>
      <property name="generateText" scope="instance" type="Object"/>
      <property name="isDragging" scope="instance-prototype" type="bool"/>
      <property name="mouseDown" scope="instance-prototype" type="bool"/>
      <property name="targetAnchor" scope="instance" type="Object"/>
      <property name="mouseButton" scope="instance" type="Object"/>
      <property name="accept" scope="instance" type="Object"/>
      <property name="sourceState" scope="instance" type="String"/>
      <property name="topics" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter">
    <methods>
      <method name="dndToDojo" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_dndFromDojo" scope="instance" type="Object"/>
      <property name="_dndToDojo" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="subscribeDnd" scope="instance"/>
      <method name="unsubscribeDnd" scope="instance"/>
      <method name="_getHoverArea" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>containing the coordinates x and y (mouse position)</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragStart" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>the DOM event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragEnter" scope="instance"/>
      <method name="onDragExit" scope="instance"/>
      <method name="isAccepted" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The dragged node.</description>
          </parameter>
          <parameter name="accept" type="Object" usage="required">
            <description>containing the type accepted for a target dojo.</description>
          </parameter>
        </parameters>
        <return-description>true if the dragged node is accepted in the target dojo.</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="onDndSource" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the dojo source/target</description>
          </parameter>
        </parameters>
      </method>
      <method name="_resetAvatar" scope="instance"/>
      <method name="onDropCancel" scope="instance"/>
      <method name="onDrop" scope="instance">
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <description>the source which provides items</description>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <description>the list of transferred items</description>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <description>copy items, if true, move items otherwise</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_dojoManager" scope="instance-prototype" type="Object"/>
      <property name="_currentArea" scope="instance-prototype" type="Object">
        <description>The current Area on mouse over</description>
      </property>
      <property name="_oldArea" scope="instance" type="Object">
        <description>The old area the mouse has passed over</description>
      </property>
      <property name="_moveHandler" scope="instance-prototype" type="Object">
        <description>The handler of mouse connection</description>
      </property>
      <property name="_subscribeHandler" scope="instance" type="Array">
        <description>The list of dojo dnd topics</description>
      </property>
      <property name="_dragNode" scope="instance" type="Object"/>
      <property name="_copy" scope="instance" type="Object"/>
      <property name="_source" scope="instance" type="Object"/>
      <property name="_outSourceHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo.dropIndicatorSize">
    <properties>
      <property name="w" scope="instance" type="Number"/>
      <property name="h" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo._areaManager">
    <properties>
      <property name="_areaList" scope="instance" type="Object"/>
      <property name="_oldIndexArea" scope="instance" type="Object"/>
      <property name="_currentIndexArea" scope="instance" type="Object"/>
      <property name="_accept" scope="instance" type="bool"/>
      <property name="_currentDropIndex" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo._areaManager._dropIndicator.node.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndFromDojo._areaManager._dropIndicator">
    <properties>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="_getIndexDojoArea" scope="instance">
        <parameters>
          <parameter name="area" type="node" usage="required">
            <description>DOMNode A node corresponding to the target dojo.</description>
          </parameter>
        </parameters>
        <return-description>The index of area if it's registered else -1.</return-description>
      </method>
      <method name="_initCoordinates" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>A registered DOM node.</description>
          </parameter>
        </parameters>
        <return-description>An object which contains coordinates : *{x:0,y:,x1:0,y1:0}*</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>The DOM node which has to be registered.</description>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <description>A String to identify the node.
	dojoTarger:
	True if the dojo D&amp;amp;D have to be enable when mouse is hover the registered target dojo.</description>
          </parameter>
          <parameter name="dojoTarget" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="unregisterByNode" scope="instance">
        <parameters>
          <parameter name="area" type="DOMNode" usage="required">
            <description>The DOM node of target dojo.</description>
          </parameter>
        </parameters>
      </method>
      <method name="unregisterByType" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>A String to identify dojo targets.</description>
          </parameter>
        </parameters>
      </method>
      <method name="unregister" scope="instance"/>
      <method name="refresh" scope="instance"/>
      <method name="refreshByType" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>A String to identify dojo targets.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getHoverDojoArea" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>Coordinates of the mouse.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>Event object.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isAccepted" scope="instance">
        <parameters>
          <parameter name="draggedNode" type="DOMNode" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDragEnter" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>The current Javascript Event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDragExit" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>current javscript event</description>
          </parameter>
        </parameters>
      </method>
      <method name="onDrop" scope="instance">
        <parameters>
          <parameter name="e" type="DOMEvent" usage="required">
            <description>Event object.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_currentDojoArea" scope="instance-prototype" type="DOMNode">
        <description>Representing the current dojo area</description>
      </property>
      <property name="_dojoxManager" scope="instance-prototype" type="dojox.mdnd.AreaManager">
        <description>The reference to the dojox AreaManager</description>
      </property>
      <property name="_dragStartHandler" scope="instance-prototype" type="Object">
        <description>Handle to keep start subscribe</description>
      </property>
      <property name="_dropHandler" scope="instance-prototype" type="Object">
        <description>Handle to keep drop subscribe</description>
      </property>
      <property name="_moveHandler" scope="instance" type="Object">
        <description>Handle to keep move subscribe</description>
      </property>
      <property name="_moveUpHandler" scope="instance" type="Object">
        <description>Handle to kee move up subscribe</description>
      </property>
      <property name="_lazyManager" scope="instance" type="Object"/>
      <property name="_oldDojoArea" scope="instance" type="Object"/>
      <property name="cancelHandler" scope="instance" type="Object"/>
      <property name="dropHandler" scope="instance" type="Object"/>
      <property name="accept" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoList">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dragItem.item"/>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dropIndicator.node.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dragItem"/>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dragItem.item.node"/>
  <class type="dojox.mdnd.adapter.DndToDojo._dojoxManager._dragItem.item.node.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.adapter.DndToDojo._draggedNode"/>
  <class type="dojox.mdnd.adapter.DndToDojo._draggedNode.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mdnd.dropMode"/>
  <class type="dojox.mdnd.dropMode.DefaultDropMode">
    <methods>
      <method name="addArea" scope="instance">
        <parameters>
          <parameter name="areas" type="Array" usage="required">
            <description>array of areas</description>
          </parameter>
          <parameter name="object" type="Object" usage="required">
            <description>data type of a DndArea</description>
          </parameter>
        </parameters>
        <return-description>a sorted area</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="updateAreas" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>array of areas</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>the DnD area</description>
          </parameter>
        </parameters>
      </method>
      <method name="initItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>the DnD area</description>
          </parameter>
        </parameters>
      </method>
      <method name="refreshItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>a DnD area object</description>
          </parameter>
          <parameter name="indexItem" type="Integer" usage="required">
            <description>index of a draggable item</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>dropIndicator size</description>
          </parameter>
          <parameter name="added" type="Boolean" usage="required">
            <description>boolean to know if a dropIndicator has been added or deleted</description>
          </parameter>
        </parameters>
      </method>
      <method name="getDragPoint" scope="instance">
        <description>return for:
	- X point : the middle
	- Y point : search if the user goes up or goes down with his mouse.
	- Up : top of the draggable item
	- Down : bottom of the draggable item</description>
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
          <parameter name="mousePosition" type="Object" usage="required">
            <description>coordinates of mouse</description>
          </parameter>
        </parameters>
        <return-description>an object of coordinates
	example : {'x':10,'y':10}</return-description>
      </method>
      <method name="getTargetArea" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>a list of DnD areas objects</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates [x,y] of the dragItem</description>
          </parameter>
          <parameter name="currentIndexArea" type="integer" usage="required">
            <description>an index representing the active DnD area</description>
          </parameter>
        </parameters>
        <return-description>the index of the DnD area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_checkInterval" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>a list of DnD areas objects</description>
          </parameter>
          <parameter name="index" type="Integer" usage="required">
            <description>index of a DnD area (to get the interval)</description>
          </parameter>
          <parameter name="x" type="Coord" usage="required">
            <description>coordinate x, of the dragNode</description>
          </parameter>
        </parameters>
        <return-description>true if the dragNode is in intervall</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getDropIndex" scope="instance">
        <parameters>
          <parameter name="targetArea" type="Object" usage="required">
            <description>a DnD area object</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates [x,y] of the draggable item</description>
          </parameter>
        </parameters>
        <return-description>a number
	or -1 if the area has no children or the drop index represents the last position in to the area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="_oldXPoint" scope="instance" type="Integer">
        <description>used to save a X position</description>
      </property>
      <property name="_oldYPoint" scope="instance" type="Integer">
        <description>used to save a Y position</description>
      </property>
      <property name="_oldBehaviour" scope="instance" type="String">
        <description>see &amp;lt;getDragPoint&amp;gt;</description>
      </property>
    </properties>
  </class>
  <class type="dojox.mdnd.dropMode.OverDropMode">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="addArea" scope="instance">
        <parameters>
          <parameter name="areas" type="Array" usage="required">
            <description>array of areas</description>
          </parameter>
          <parameter name="object" type="Object" usage="required">
            <description>data type of a DndArea</description>
          </parameter>
        </parameters>
        <return-description>a sorted area</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="updateAreas" scope="instance">
        <description>the area position (and size) is equal to the postion of the domNode associated.</description>
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>array of areas</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>the D&amp;amp;D area.</description>
          </parameter>
        </parameters>
      </method>
      <method name="initItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>the D&amp;amp;D area.</description>
          </parameter>
        </parameters>
      </method>
      <method name="refreshItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>a D&amp;amp;D area object</description>
          </parameter>
          <parameter name="indexItem" type="Integer" usage="required">
            <description>index of a draggable item</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>dropIndicator size</description>
          </parameter>
          <parameter name="added" type="Boolean" usage="required">
            <description>boolean to know if a dropIndicator has been added or deleted</description>
          </parameter>
        </parameters>
      </method>
      <method name="getDragPoint" scope="instance">
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
          <parameter name="mousePosition" type="Object" usage="required">
            <description>coordinates of mouse</description>
          </parameter>
        </parameters>
        <return-description>an object of coordinates
	examples:{'x':10,'y':10}</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTargetArea" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>a list of D&amp;amp;D areas objects</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates [x,y] of the dragItem (see getDragPoint())</description>
          </parameter>
          <parameter name="currentIndexArea" type="integer" usage="required">
            <description>an index representing the active D&amp;amp;D area</description>
          </parameter>
        </parameters>
        <return-description>the index of the D&amp;D area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_checkInterval" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>a list of D&amp;amp;D areas objects</description>
          </parameter>
          <parameter name="index" type="Integer" usage="required">
            <description>index of a D&amp;amp;D area (to get the interval)</description>
          </parameter>
          <parameter name="x" type="Coord" usage="required">
            <description>coordinate x, of the dragNode (see getDragPoint())</description>
          </parameter>
          <parameter name="y" type="Coord" usage="required"/>
        </parameters>
        <return-description>true if the dragNode is in intervall</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getDropIndex" scope="instance">
        <parameters>
          <parameter name="targetArea" type="Object" usage="required">
            <description>a D&amp;amp;D area object.</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates [x,y] of the draggable item.</description>
          </parameter>
        </parameters>
        <return-description>a number or -1 if the area has no children or the drop index represents the last position in to the area</return-description>
        <return-types>
          <return-type type="integer"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="_oldXPoint" scope="instance" type="Integer">
        <description>used to save a X position</description>
      </property>
      <property name="_oldYPoint" scope="instance" type="Integer">
        <description>used to save a Y position</description>
      </property>
      <property name="_oldBehaviour" scope="instance" type="Integer">
        <description>see getDragpoint()</description>
      </property>
      <property name="_dragHandler" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.mdnd.dropMode.VerticalDropMode">
    <methods>
      <method name="addArea" scope="instance">
        <parameters>
          <parameter name="areas" type="Array" usage="required">
            <description>array of areas</description>
          </parameter>
          <parameter name="object" type="Object" usage="required">
            <description>data type of a DndArea</description>
          </parameter>
        </parameters>
        <return-description>a sorted area</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="updateAreas" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>array of areas</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateArea" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>the DnD area</description>
          </parameter>
        </parameters>
      </method>
      <method name="initItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>the DnD area</description>
          </parameter>
        </parameters>
      </method>
      <method name="refreshItems" scope="instance">
        <parameters>
          <parameter name="area" type="Object" usage="required">
            <description>a DnD area object</description>
          </parameter>
          <parameter name="indexItem" type="Integer" usage="required">
            <description>index of a draggable item</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>dropIndicator size</description>
          </parameter>
          <parameter name="added" type="Boolean" usage="required">
            <description>boolean to know if a dropIndicator has been added or deleted</description>
          </parameter>
        </parameters>
      </method>
      <method name="getDragPoint" scope="instance">
        <description>return for:
	- X point : the middle
	- Y point : search if the user goes up or goes down with his mouse.
	- Up : top of the draggable item
	- Down : bottom of the draggable item</description>
        <parameters>
          <parameter name="coords" type="Object" usage="required">
            <description>an object encapsulating X and Y position</description>
          </parameter>
          <parameter name="size" type="Object" usage="required">
            <description>an object encapsulating width and height values</description>
          </parameter>
          <parameter name="mousePosition" type="Object" usage="required">
            <description>coordinates of mouse</description>
          </parameter>
        </parameters>
        <return-description>an object of coordinates
	example : {'x':10,'y':10}</return-description>
      </method>
      <method name="getTargetArea" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>a list of DnD areas objects</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates [x,y] of the dragItem</description>
          </parameter>
          <parameter name="currentIndexArea" type="integer" usage="required">
            <description>an index representing the active DnD area</description>
          </parameter>
        </parameters>
        <return-description>the index of the DnD area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_checkInterval" scope="instance">
        <parameters>
          <parameter name="areaList" type="Array" usage="required">
            <description>a list of DnD areas objects</description>
          </parameter>
          <parameter name="index" type="Integer" usage="required">
            <description>index of a DnD area (to get the interval)</description>
          </parameter>
          <parameter name="x" type="Coord" usage="required">
            <description>coordinate x, of the dragNode</description>
          </parameter>
        </parameters>
        <return-description>true if the dragNode is in intervall</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getDropIndex" scope="instance">
        <parameters>
          <parameter name="targetArea" type="Object" usage="required">
            <description>a DnD area object</description>
          </parameter>
          <parameter name="coords" type="Object" usage="required">
            <description>coordinates [x,y] of the draggable item</description>
          </parameter>
        </parameters>
        <return-description>a number
	or -1 if the area has no children or the drop index represents the last position in to the area</return-description>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="_oldXPoint" scope="instance" type="Integer">
        <description>used to save a X position</description>
      </property>
      <property name="_oldYPoint" scope="instance" type="Integer">
        <description>used to save a Y position</description>
      </property>
      <property name="_oldBehaviour" scope="instance" type="String">
        <description>see &amp;lt;getDragPoint&amp;gt;</description>
      </property>
    </properties>
  </class>
  <class type="dojox.mobile">
    <methods>
      <method name="addClass" scope="instance">
        <description>Finds the currently applied theme name, such as 'iphone' or 'android'
	from link elements, and adds it as a class name for the body element.</description>
      </method>
      <method name="setupIcon" scope="instance">
        <parameters>
          <parameter name="iconNode" type="DomNode" usage="required"/>
          <parameter name="iconPos" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="hideAddressBar" scope="instance"/>
      <method name="openWindow" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="target" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRoundRect" scope="instance">
        <parameters>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="isList" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyPngFilter" scope="instance">
        <parameters>
          <parameter name="root" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadCss" scope="instance">
        <parameters>
          <parameter name="files" type="String|Array" usage="required">
            <description>The CSS files to load and register with the page.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getCssPaths" scope="instance"/>
      <method name="loadCompatCssFiles" scope="instance"/>
    </methods>
    <properties>
      <property name="theme" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="loadCompatPattern" scope="instance" type="RegExp"/>
      <property name="compat" scope="instance" type="Object"/>
      <property name="parser" scope="instance" type="Object"/>
      <property name="scrollable" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.FixedSplitter" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="changeSize" type="Object" usage="required"/>
          <parameter name="resultSize" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="orientation" scope="instance" type="String"/>
      <property name="isContainer" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_started" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.FixedSplitterPane" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.FlippableView" superclass="dojox.mobile.View">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="onTouchStart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_nextView" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_previousView" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="scrollTo" scope="instance">
        <parameters>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideTo" scope="instance">
        <parameters>
          <parameter name="to" type="Object" usage="required"/>
          <parameter name="duration" type="Number" usage="required"/>
          <parameter name="easing" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onFlickAnimationEnd" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile._ScrollableMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.View" scope="instance"/>
      <mixin type="dojox.mobile._ScrollableMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="scrollDir" scope="instance" type="String"/>
      <property name="weight" scope="instance" type="Number"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.FlippableView.containerNode.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.FlippableView.domNode">
    <properties>
      <property name="offsetWidth" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.FlippableView.domNode.parentNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconContainer" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="_setupSubNodes" scope="instance">
        <parameters>
          <parameter name="ul" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="closeAll" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="defaultIcon" scope="instance" type="String"/>
      <property name="transition" scope="instance" type="String"/>
      <property name="pressedIconOpacity" scope="instance" type="Number"/>
      <property name="iconBase" scope="instance" type="String"/>
      <property name="iconPos" scope="instance" type="String"/>
      <property name="back" scope="instance" type="String"/>
      <property name="label" scope="instance" type="String"/>
      <property name="single" scope="instance" type="bool"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_terminator" scope="instance" type="Object"/>
      <property name="_addChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconContainer.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconContainer.domNode.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem" superclass="dojox.mobile.AbstractItem">
    <description>Dynamic creation is not supported.</description>
    <methods>
      <method name="createTemplate" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="setIcon" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="highlight" scope="instance"/>
      <method name="unhighlight" scope="instance"/>
      <method name="setOpacity" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="instantiateWidget" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isOpen" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDownIcon" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iconClicked" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="closeIconClicked" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="instance"/>
      <method name="_open_1" scope="instance"/>
      <method name="close" scope="instance"/>
      <method name="onOpen" scope="instance"/>
      <method name="onClose" scope="instance"/>
      <method name="onError" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.AbstractItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="lazy" scope="instance" type="bool"/>
      <property name="requires" scope="instance" type="String"/>
      <property name="timeout" scope="instance" type="Number"/>
      <property name="templateString" scope="instance" type="String"/>
      <property name="templateStringSub" scope="instance" type="String"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem.subNode">
    <properties>
      <property name="_parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem.srcNodeRef.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem.iconNode">
    <properties>
      <property name="src" scope="instance" type="Object"/>
      <property name="offsetLeft" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem.contentNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.IconItem.containerNode.parentNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.ScrollableView" superclass="dojox.mobile.View">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reparent" scope="instance"/>
      <method name="findAppBars" scope="instance"/>
      <method name="_checkFixedBar" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterTransitionIn" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile._ScrollableMixin.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.mobile.View" scope="instance"/>
      <mixin type="dojox.mobile._ScrollableMixin" scope="instance"/>
    </mixins>
    <properties>
      <property name="flippable" scope="instance" type="bool"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="fixedHeaderHeight" scope="instance" type="Object"/>
      <property name="fixedFooterHeight" scope="instance" type="Object"/>
      <property name="isLocalFooter" scope="instance" type="Object"/>
      <property name="fixedHeader" scope="instance" type="Object"/>
      <property name="fixedFooter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ScrollableView.domNode.style">
    <properties>
      <property name="overflow" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.ScrollableView.containerNode.style">
    <properties>
      <property name="position" scope="instance" type="String"/>
      <property name="width" scope="instance" type="String"/>
      <property name="paddingTop" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.ScrollableView.domNode.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ScrollableView.domNode.parentNode.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBar" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="onResize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconBase" scope="instance" type="String"/>
      <property name="iconPos" scope="instance" type="String"/>
      <property name="barType" scope="instance" type="String"/>
      <property name="inHeading" scope="instance" type="Object"/>
      <property name="_fixedButtonWidth" scope="instance" type="Number"/>
      <property name="_fixedButtonMargin" scope="instance" type="Number"/>
      <property name="_largeScreenWidth" scope="instance" type="Number"/>
      <property name="_clsName" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBar.domNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBar.containerNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBar.containerNode.style">
    <properties>
      <property name="padding" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton" superclass="dojox.mobile.AbstractItem">
    <methods>
      <method name="inheritParams" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="deselect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.AbstractItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="icon1" scope="instance" type="String"/>
      <property name="icon2" scope="instance" type="Object"/>
      <property name="iconPos1" scope="instance" type="String"/>
      <property name="iconPos2" scope="instance" type="Object"/>
      <property name="selected" scope="instance" type="Object"/>
      <property name="transition" scope="instance" type="String"/>
      <property name="tag" scope="instance" type="String"/>
      <property name="selectOne" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
      <property name="anchorNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.img1.style">
    <properties>
      <property name="visibility" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.img1">
    <methods>
      <method name="onload" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.mobile.TabBarButton.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.img2.style">
    <properties>
      <property name="visibility" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.img2">
    <methods>
      <method name="onload" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.mobile.TabBarButton.srcNodeRef.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.box">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabBarButton.domNode.parentNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabContainer" superclass="dijit._WidgetBase">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="createTabButtons" scope="instance"/>
      <method name="selectTab" scope="instance">
        <parameters>
          <parameter name="tab" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="onTabClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconBase" scope="instance" type="String"/>
      <property name="iconPos" scope="instance" type="String"/>
      <property name="fixedHeader" scope="instance" type="bool"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="tabHeaderNode" scope="instance" type="Object"/>
      <property name="_selectedPane" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabContainer.containerNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabContainer._selectedPane.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabPane" superclass="dijit._WidgetBase">
    <methods>
      <method name="inheritParams" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="getParentWidget" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="String"/>
      <property name="icon" scope="instance" type="String"/>
      <property name="iconPos" scope="instance" type="String"/>
      <property name="selected" scope="instance" type="bool"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.TabPane.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile._ScrollableMixin._meta">
    <properties>
      <property name="hidden" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile._ScrollableMixin" superclass="new">
    <methods>
      <method name="destroy" scope="instance"/>
      <method name="startup" scope="instance"/>
    </methods>
    <properties>
      <property name="fixedHeader" scope="instance" type="String"/>
      <property name="fixedFooter" scope="instance" type="String"/>
      <property name="isLocalFooter" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.View" superclass="dijit._WidgetBase">
    <description>View acts as a container for any HTML and/or widgets. An entire HTML page
	can have multiple View widgets and the user can navigate through
	the views back and forth without page transitions.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="onStartView" scope="instance"/>
      <method name="onBeforeTransitionIn" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterTransitionIn" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeTransitionOut" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterTransitionOut" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_saveState" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="performTransition" scope="instance">
        <examples>
          <example>Transitions to the blank view, and then opens another page.
		performTransition(null, 1, "slide", null, function(){location.href = href;});</example>
        </examples>
        <parameters>
          <parameter name="moveTo" type="String" usage="required">
            <description>The destination view id to transition the current view to.
	If null, transitions to a blank view.</description>
          </parameter>
          <parameter name="dir" type="Number" usage="required">
            <description>The transition direction. If 1, transition forward. If -1, transition backward.
	For example, the slide transition slides the view from right to left when dir == 1,
	and from left to right when dir == -1.
	transision: String
	The type of transition to perform. &amp;quot;slide&amp;quot;, &amp;quot;fade&amp;quot;, or &amp;quot;flip&amp;quot;</description>
          </parameter>
          <parameter name="transition" type="String" usage="required"/>
          <parameter name="context" type="Object|null" usage="required">
            <description>Object The object that the callback function will receive as &amp;quot;this&amp;quot;.</description>
          </parameter>
          <parameter name="method" type="String|Function" usage="required">
            <description>A callback function that is called when the transition has been finished.
	A function reference, or name of a function in context.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_doTransition" scope="instance">
        <parameters>
          <parameter name="fromNode" type="Object" usage="required"/>
          <parameter name="toNode" type="Object" usage="required"/>
          <parameter name="transition" type="Object" usage="required"/>
          <parameter name="dir" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAnimationStart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onAnimationEnd" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invokeCallback" scope="instance"/>
      <method name="getShowingView" scope="instance">
        <description>Note that dojox.mobile.currentView is the last shown view.
	If the page consists of a splitter, there are multiple showing views.</description>
      </method>
      <method name="show" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wakeUp" scope="instance">
        <parameters>
          <parameter name="node" type="The" usage="required">
            <description>node to forcibly redraw.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="selected" scope="instance" type="Boolean">
        <description>If true, the view is displayed at startup time.</description>
      </property>
      <property name="keepScrollPos" scope="instance" type="Boolean">
        <description>If true, the scroll position is kept between views.</description>
      </property>
      <property name="_started" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_visible" scope="instance" type="bool"/>
      <property name="_context" scope="instance" type="Object"/>
      <property name="_method" scope="instance" type="Object"/>
      <property name="_moveTo" scope="instance" type="Object"/>
      <property name="_dir" scope="instance" type="Object"/>
      <property name="_transition" scope="instance" type="Object"/>
      <property name="_arguments" scope="instance" type="Array"/>
      <property name="_args" scope="instance" type="Array"/>
      <property name="_dummyNode" scope="instance" type="Object"/>
      <property name="toNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.View.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.View.domNode.style">
    <properties>
      <property name="top" scope="instance" type="String"/>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.View.domNode.parentNode">
    <properties>
      <property name="childNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Heading" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="instance">
        <parameters>
          <parameter name="label" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="goTo" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="back" scope="instance" type="String"/>
      <property name="href" scope="instance" type="String"/>
      <property name="moveTo" scope="instance" type="String"/>
      <property name="transition" scope="instance" type="String"/>
      <property name="label" scope="instance" type="Object"/>
      <property name="iconBase" scope="instance" type="String"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_view" scope="instance" type="Object"/>
      <property name="_body" scope="instance" type="Object"/>
      <property name="_head" scope="instance" type="Object"/>
      <property name="_btn" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Heading.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Heading._btn.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Heading.domNode.firstChild">
    <properties>
      <property name="nodeValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRect" superclass="dijit._WidgetBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="shadow" scope="instance" type="bool"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRect.buildRendering">
    <methods/>
  </class>
  <class type="dojox.mobile.RoundRect.domNode">
    <properties>
      <property name="className" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRectCategory" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="label" scope="instance" type="String"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRectCategory.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeCategory" superclass="dojox.mobile.RoundRectCategory">
    <methods>
      <method name="buildRendering" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.RoundRectCategory" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.EdgeToEdgeCategory.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRectList" superclass="dijit._WidgetBase">
    <methods>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="redrawBorders" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="transition" scope="instance" type="String"/>
      <property name="iconBase" scope="instance" type="String"/>
      <property name="iconPos" scope="instance" type="String"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_addChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRectList.buildRendering">
    <methods/>
  </class>
  <class type="dojox.mobile.RoundRectList.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeList" superclass="dojox.mobile.RoundRectList">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.mobile.RoundRectList" scope="instance"/>
    </mixins>
    <properties>
      <property name="stateful" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeList.buildRendering">
    <methods/>
    <properties>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeList.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.AbstractItem" superclass="dijit._WidgetBase">
    <methods>
      <method name="inheritParams" scope="instance"/>
      <method name="findCurrentView" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="transitionTo" scope="instance">
        <parameters>
          <parameter name="moveTo" type="Object" usage="required"/>
          <parameter name="href" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="scene" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="instance">
        <parameters>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_instantiate" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="parent" type="Widget" usage="required"/>
        </parameters>
      </method>
      <method name="createDomButton" scope="instance">
        <parameters>
          <parameter name="refNode" type="DomNode" usage="required"/>
          <parameter name="toNode" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="deselect" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="defaultClickAction" scope="instance"/>
      <method name="getParentWidget" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="icon" scope="instance" type="String"/>
      <property name="iconPos" scope="instance" type="String"/>
      <property name="href" scope="instance" type="String"/>
      <property name="hrefTarget" scope="instance" type="String"/>
      <property name="moveTo" scope="instance" type="String"/>
      <property name="scene" scope="instance" type="String"/>
      <property name="clickable" scope="instance" type="bool"/>
      <property name="url" scope="instance" type="String"/>
      <property name="transition" scope="instance" type="String"/>
      <property name="transitionDir" scope="instance" type="Number"/>
      <property name="callback" scope="instance" type="Object"/>
      <property name="sync" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="String"/>
      <property name="toggle" scope="instance" type="bool"/>
      <property name="_duration" scope="instance" type="Number"/>
      <property name="_text" scope="instance" type="Object"/>
      <property name="_ws" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ListItem" superclass="dojox.mobile.AbstractItem">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="setIcon" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already selected"/>
        </return-types>
      </method>
      <method name="onAnchorLabelClicked" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setRightTextAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.AbstractItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="rightText" scope="instance" type="String"/>
      <property name="btnClass" scope="instance" type="String"/>
      <property name="anchorLabel" scope="instance" type="bool"/>
      <property name="noArrow" scope="instance" type="bool"/>
      <property name="selected" scope="instance" type="bool"/>
      <property name="anchorNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="btnNode" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="iconNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ListItem.srcNodeRef.childNodes">
    <properties>
      <property name="length" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ListItem._rightTextNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch" superclass="dijit._WidgetBase">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_changeState" scope="instance">
        <parameters>
          <parameter name="state" type="String" usage="required">
            <description>Thhe state to toggle, switch 'on' or 'off'</description>
          </parameter>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchStart" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTouchEnd" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStateChanged" scope="instance">
        <parameters>
          <parameter name="newState" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="value" scope="instance" type="String"/>
      <property name="leftLabel" scope="instance" type="String"/>
      <property name="rightLabel" scope="instance" type="String"/>
      <property name="_width" scope="instance" type="Number"/>
      <property name="inner" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="right" scope="instance" type="Object"/>
      <property name="knob" scope="instance" type="Object"/>
      <property name="_moved" scope="instance" type="Object"/>
      <property name="innerStartX" scope="instance" type="Object"/>
      <property name="touchStartX" scope="instance" type="Object"/>
      <property name="_conn1" scope="instance" type="Object"/>
      <property name="_conn2" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.buildRendering">
    <methods/>
    <properties>
      <property name="inner" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="right" scope="instance" type="Object"/>
      <property name="knob" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.inner.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.left.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.right.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Button" superclass="dijit._WidgetBase">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="btnClass" scope="instance" type="String"/>
      <property name="duration" scope="instance" type="Number"/>
      <property name="label" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.Button.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ToolBarButton" superclass="dojox.mobile.AbstractItem">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="deselect" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.AbstractItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="selected" scope="instance" type="bool"/>
      <property name="_defaultColor" scope="instance" type="String"/>
      <property name="_selColor" scope="instance" type="String"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
      <property name="iconNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ToolBarButton.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ProgressIndicator">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="start" scope="instance"/>
      <method name="stop" scope="instance"/>
      <method name="getInstance" scope="instance"/>
    </methods>
    <properties>
      <property name="interval" scope="instance" type="Number"/>
      <property name="colors" scope="instance" type="Array"/>
      <property name="_bars" scope="instance" type="Array"/>
      <property name="timer" scope="instance" type="Object"/>
      <property name="_instance" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.ProgressIndicator.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.app">
    <methods>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getActiveSceneController" scope="instance"/>
      <method name="getStageController" scope="instance"/>
      <method name="loadResources" scope="instance">
        <parameters>
          <parameter name="resources" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="loadResourcesForScene" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resolveTemplate" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resolveAssistant" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connectFlick" scope="instance">
        <parameters>
          <parameter name="target" type="Node" usage="required">
            <description>The DOM node to connect to</description>
          </parameter>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_base" scope="instance" type="Object"/>
      <property name="isIPhone" scope="instance" type="Object"/>
      <property name="isWebOS" scope="instance" type="bool"/>
      <property name="isAndroid" scope="instance" type="bool"/>
      <property name="_event" scope="instance" type="Object"/>
      <property name="compat" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.AlertDialog" superclass="dijit._WidgetBase">
    <methods>
      <method name="onChoose" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="_doTransition" scope="instance">
        <parameters>
          <parameter name="dir" type="An" usage="required">
            <description>integer.  If positive, the dialog is shown. If negative,
	the dialog is hidden.</description>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String">
        <description>The title of the AlertDialog</description>
      </property>
      <property name="text" scope="instance" type="String">
        <description>The text message displayed in the AlertDialog</description>
      </property>
      <property name="controller" scope="instance" type="Object">
        <description>The SceneController for the currently active scene</description>
      </property>
      <property name="buttons" scope="instance" type="Array"/>
      <property name="defaultButtonLabel" scope="instance" type="String"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="mask" scope="instance" type="Object"/>
      <property name="_handleSelect" scope="instance-prototype" type="Object">
        <description>Handle the selection of a value</description>
      </property>
      <property name="onClick" scope="instance-prototype" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageThumbView" superclass="dijit._WidgetBase">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="addThumb" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleImgLoad" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hideCached" scope="instance"/>
      <method name="onSelect" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setAnimationEnabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setItemsAttr" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemNode" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemNodeFromEvent" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="setContainerHeight" scope="instance">
        <parameters>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="calcPadding" scope="instance"/>
      <method name="place" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="items" scope="instance" type="Array">
        <description>The data items from which the image urls are retrieved.
	If an item is a string, it is expected to be a URL. Otherwise
	by default it is expected to have a 'url' member.  This can
	be configured using the 'urlParam' attribute on this widget.</description>
      </property>
      <property name="urlParam" scope="instance" type="String">
        <description>The paramter name used to retrieve an image url from a JSON object</description>
      </property>
      <property name="labelParam" scope="instance" type="Object"/>
      <property name="itemTemplate" scope="instance" type="String"/>
      <property name="minPadding" scope="instance" type="Number"/>
      <property name="maxPerRow" scope="instance" type="Object"/>
      <property name="maxRows" scope="instance" type="Number"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="thumbSize" scope="instance" type="String"/>
      <property name="animationEnabled" scope="instance" type="Object"/>
      <property name="selectedIndex" scope="instance" type="Number"/>
      <property name="cache" scope="instance" type="Array"/>
      <property name="cacheMustMatch" scope="instance" type="bool"/>
      <property name="clickEvent" scope="instance" type="String"/>
      <property name="cacheBust" scope="instance" type="bool"/>
      <property name="disableHide" scope="instance" type="bool"/>
      <property name="_onLoadImages" scope="instance" type="Object"/>
      <property name="visibleImages" scope="instance" type="Object"/>
      <property name="_cacheCounter" scope="instance" type="Number"/>
      <property name="thumbNodes" scope="instance" type="Object"/>
      <property name="_numRows" scope="instance" type="Object"/>
      <property name="padding" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageThumbView._thumbSize">
    <properties>
      <property name="h" scope="instance" type="Number"/>
      <property name="w" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageThumbView._size">
    <properties>
      <property name="w" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView" superclass="dojox.mobile.app._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="isAnimating" scope="instance"/>
      <method name="handleDragEnd" scope="instance"/>
      <method name="handleFlick" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveTo" scope="instance">
        <parameters>
          <parameter name="direction" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_switchImage" scope="instance">
        <parameters>
          <parameter name="toImg" type="Object" usage="required"/>
          <parameter name="fromImg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_animPanTo" scope="instance">
        <parameters>
          <parameter name="to" type="Object" usage="required"/>
          <parameter name="easing" type="Object" usage="required"/>
          <parameter name="duration" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="direction" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zoomTo" scope="instance">
        <parameters>
          <parameter name="centerX" type="Object" usage="required"/>
          <parameter name="centerY" type="Object" usage="required"/>
          <parameter name="zoom" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="_renderImg" scope="instance">
        <parameters>
          <parameter name="smallImg" type="Object" usage="required"/>
          <parameter name="largeImg" type="Object" usage="required"/>
          <parameter name="panDir" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setZoomAttr" scope="instance">
        <parameters>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setZoomCenterXAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setZoomCenterYAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setZoomCenterAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setAnimatedZoomAttr" scope="instance">
        <parameters>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setCenterUrlAttr" scope="instance">
        <parameters>
          <parameter name="urlOrObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setLeftUrlAttr" scope="instance">
        <parameters>
          <parameter name="urlOrObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setRightUrlAttr" scope="instance">
        <parameters>
          <parameter name="urlOrObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setImage" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="urlOrObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance">
        <parameters>
          <parameter name="type" type="String" usage="required">
            <description>The position of the image that has loaded, either
	&amp;quot;center&amp;quot;, &amp;quot;left&amp;quot; or &amp;quot;right&amp;quot;</description>
          </parameter>
          <parameter name="url" type="String" usage="required">
            <description>The src of the image</description>
          </parameter>
          <parameter name="isSmall" type="Boolean" usage="required">
            <description>True if it is a small version of the image that has loaded,
	false otherwise.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.app._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="zoom" scope="instance" type="Number">
        <description>The current level of zoom.  This should not be set manually.</description>
      </property>
      <property name="zoomCenterX" scope="instance" type="Number">
        <description>The X coordinate in the image where the zoom is focused</description>
      </property>
      <property name="zoomCenterY" scope="instance" type="Number">
        <description>The Y coordinate in the image where the zoom is focused</description>
      </property>
      <property name="maxZoom" scope="instance" type="Number">
        <description>The highest degree to which an image can be zoomed.  For example,
	a maxZoom of 5 means that the image will be 5 times larger than normal</description>
      </property>
      <property name="autoZoomLevel" scope="instance" type="Number">
        <description>The degree to which the image is zoomed when auto zoom is invoked.
	The higher the number, the more the image is zoomed in.</description>
      </property>
      <property name="disableAutoZoom" scope="instance" type="Boolean">
        <description>Disables auto zoom</description>
      </property>
      <property name="disableSwipe" scope="instance" type="Boolean">
        <description>Disables the users ability to swipe from one image to the next.</description>
      </property>
      <property name="autoZoomEvent" scope="instance" type="String">
        <description>Overrides the default event listened to which invokes auto zoom</description>
      </property>
      <property name="_leftImg" scope="instance" type="Node">
        <description>The small sized image to the left</description>
      </property>
      <property name="_rightImg" scope="instance" type="Node">
        <description>The small sized image to the right</description>
      </property>
      <property name="_leftSmallImg" scope="instance" type="Object"/>
      <property name="_rightSmallImg" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="downX" scope="instance" type="Object"/>
      <property name="downY" scope="instance" type="Object"/>
      <property name="panX" scope="instance-prototype" type="Number"/>
      <property name="panY" scope="instance-prototype" type="Number"/>
      <property name="_moveDir" scope="instance" type="Object"/>
      <property name="_animCallback" scope="instance" type="Object"/>
      <property name="_anim" scope="instance" type="Object"/>
      <property name="_updateAnimatedPan" scope="instance-prototype" type="Object"/>
      <property name="_onAnimPanEnd" scope="instance-prototype" type="Object"/>
      <property name="dispWidth" scope="instance" type="Number"/>
      <property name="dispHeight" scope="instance" type="Number"/>
      <property name="_updateAnimatedZoom" scope="instance-prototype" type="Object"/>
      <property name="handleLoad" scope="instance-prototype" type="Object">
        <description>Handles the loading of an image, both the large and small
	versions.  A render is triggered as a result of each image load.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView.buildRendering">
    <methods/>
    <properties>
      <property name="canvas" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView.canvas">
    <properties>
      <property name="height" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView._centerImg">
    <properties>
      <property name="_type" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView._centerSmallImg">
    <properties>
      <property name="_type" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.List" superclass="dijit._WidgetBase">
    <methods>
      <method name="dividerFunction" scope="instance"/>
      <method name="constructor" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="handleDrag" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="handleDragCancel" scope="instance"/>
      <method name="preDelete" scope="instance">
        <parameters>
          <parameter name="currentLeftPos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createDeleteButtons" scope="instance">
        <parameters>
          <parameter name="aroundNode" type="The" usage="required">
            <description>DOM node of the row about to be deleted.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_handleButtonClick" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="instance">
        <parameters>
          <parameter name="data" type="The" usage="required">
            <description>data related to the row being deleted</description>
          </parameter>
          <parameter name="index" type="The" usage="required">
            <description>index of the data in the total array</description>
          </parameter>
          <parameter name="array" type="The" usage="required">
            <description>array of data used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="cancelDelete" scope="instance"/>
      <method name="applyClass" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
          <parameter name="array" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setDataInfo" scope="instance">
        <parameters>
          <parameter name="rowNode" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSelect" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="index" type="Object" usage="required"/>
          <parameter name="rowNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_selectRow" scope="instance">
        <parameters>
          <parameter name="row" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_deselectRow" scope="instance"/>
      <method name="_getRowNode" scope="instance">
        <parameters>
          <parameter name="fromNode" type="Object" usage="required"/>
          <parameter name="ignoreNoClick" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="applyTemplate" scope="instance">
        <parameters>
          <parameter name="template" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="instance"/>
      <method name="_renderRange" scope="instance">
        <parameters>
          <parameter name="startIdx" type="Object" usage="required"/>
          <parameter name="endIdx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loadTemplate" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
          <parameter name="thisAttr" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setFormattersAttr" scope="instance">
        <parameters>
          <parameter name="formatters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setItemsAttr" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="items" scope="instance" type="Array">
        <description>The array of data items that will be rendered.</description>
      </property>
      <property name="itemTemplate" scope="instance" type="String">
        <description>The URL to the HTML file containing the markup for each individual
	data item.</description>
      </property>
      <property name="emptyTemplate" scope="instance" type="String">
        <description>The URL to the HTML file containing the HTML to display if there
	are no data items. This is optional.</description>
      </property>
      <property name="dividerTemplate" scope="instance" type="String">
        <description>The URL to the HTML file containing the markup for the dividers
	between groups of list items</description>
      </property>
      <property name="labelDelete" scope="instance" type="String">
        <description>The label to display for the Delete button</description>
      </property>
      <property name="labelCancel" scope="instance" type="String">
        <description>The label to display for the Cancel button</description>
      </property>
      <property name="controller" scope="instance" type="Object"/>
      <property name="autoDelete" scope="instance" type="Boolean"/>
      <property name="enableDelete" scope="instance" type="Boolean"/>
      <property name="enableHold" scope="instance" type="Boolean"/>
      <property name="formatters" scope="instance" type="Object">
        <description>A name/value map of functions used to format data for display</description>
      </property>
      <property name="_templateLoadCount" scope="instance" type="Number">
        <description>The number of templates remaining to load before the list renders.</description>
      </property>
      <property name="_mouseDownPos" scope="instance" type="Object">
        <description>The coordinates of where a mouseDown event was detected</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="_dragThreshold" scope="instance" type="Object"/>
      <property name="_deleting" scope="instance" type="bool"/>
      <property name="_deleteAnimConn" scope="instance" type="Object"/>
      <property name="_postDeleteAnim" scope="instance-prototype" type="Object">
        <description>Completes the deletion of a row.</description>
      </property>
      <property name="_deleteBtns" scope="instance" type="Object"/>
      <property name="buttons" scope="instance" type="Object"/>
      <property name="_replaceToken" scope="instance-prototype" type="Object"/>
      <property name="_checkLoadComplete" scope="instance-prototype" type="Object">
        <description>Checks if all templates have loaded</description>
      </property>
    </properties>
  </class>
  <class type="dojox.mobile.app.List._selectedRow.style">
    <properties>
      <property name="left" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.List.deleteRow">
    <methods/>
    <properties>
      <property name="_selectedRow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.List._selectedRow">
    <properties>
      <property name="previousSibling" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ListSelector" superclass="dojox.mobile.app._Widget">
    <methods>
      <method name="onChoose" scope="instance"/>
      <method name="_setDataAttr" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="show" scope="instance">
        <parameters>
          <parameter name="fromNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hide" scope="instance"/>
      <method name="render" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.app._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="data" scope="instance" type="Array">
        <description>The array of items to display.  Each element in the array
	should have both a label and value attribute, e.g.
	[{label: &amp;quot;Open&amp;quot;, value: 1} , {label: &amp;quot;Delete&amp;quot;, value: 2}]</description>
      </property>
      <property name="controller" scope="instance" type="Object">
        <description>The current SceneController widget.</description>
      </property>
      <property name="destroyOnHide" scope="instance" type="bool"/>
      <property name="mask" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.SceneAssistant">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="setup" scope="instance"/>
      <method name="activate" scope="instance">
        <parameters>
          <parameter name="params" type="Optional" usage="required">
            <description>paramters, only passed when a subsequent scene pops itself
	off the stack and passes back data.</description>
          </parameter>
        </parameters>
      </method>
      <method name="deactivate" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
    </methods>
    <properties>
      <property name="_connects" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.SceneController" superclass="dojox.mobile.View">
    <methods>
      <method name="init" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setContents" scope="instance">
        <parameters>
          <parameter name="templateHtml" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initAssistant" scope="instance"/>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="selector" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getWindowSize" scope="instance"/>
      <method name="showAlertDialog" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popupSubMenu" scope="instance">
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.View" scope="instance"/>
    </mixins>
    <properties>
      <property name="stageController" scope="instance" type="Object"/>
      <property name="keepScrollPos" scope="instance" type="bool"/>
      <property name="sceneName" scope="instance" type="Object"/>
      <property name="params" scope="instance" type="Object"/>
      <property name="_deferredInit" scope="instance" type="Object"/>
      <property name="sceneAssistantName" scope="instance" type="Object"/>
      <property name="_widgets" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.SceneController.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.SceneController.assistant">
    <properties>
      <property name="controller" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.StageController">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getActiveSceneController" scope="instance"/>
      <method name="pushScene" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setZIndex" scope="instance">
        <parameters>
          <parameter name="controller" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popScene" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="popScenesTo" scope="instance">
        <parameters>
          <parameter name="sceneName" type="Object" usage="required"/>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyScene" scope="instance">
        <parameters>
          <parameter name="scene" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="scenes" scope="instance-prototype" type="Array">
        <description>The list of scenes currently in existance in the app.</description>
      </property>
      <property name="effect" scope="instance-prototype" type="String"/>
      <property name="_opInProgress" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.TextBox" superclass="dojox.mobile.app._FormValueWidget">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="_setPlaceHolderAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance">
        <description>For `dijit.form.TextBox` this basically returns the value of the &lt;input&gt;.
	For `dijit.form.MappedTextBox` subclasses, which have both
	a "displayed value" and a separate "submit value",
	This treats the "displayed value" as the master value, computing the
	submit value from it via this.parse().</description>
      </method>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget to "value" which can be of
	any type as determined by the widget.</description>
        <parameters>
          <parameter name="value" type="The" usage="required">
            <description>visual element value is also set to a corresponding,
	but not necessarily the same, value.</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="optional">
            <description>If true, an onChange event is fired immediately instead of
	waiting for the next blur event.</description>
          </parameter>
          <parameter name="formattedValue" type="String" usage="optional">
            <description>If specified, used to set the visual element value,
	otherwise a computed visual value is used.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getDisplayedValueAttr" scope="instance">
        <description>Returns the displayed value (what the user sees on the screen),
	after filtering (ie, trimming spaces etc.).
	For some subclasses of TextBox (like ComboBox), the displayed value
	is different from the serialized value that's actually
	sent to the server (see dijit.form.ValidationTextBox.serialize)</description>
      </method>
      <method name="_setDisplayedValueAttr" scope="instance">
        <description>Sets the value of the visual element to the string "value".
	The widget value is also set to a corresponding,
	but not necessarily the same, value.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_refreshState" scope="instance"/>
      <method name="_onInput" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="filter" scope="instance">
        <description>For MappedTextBox subclasses, this is called twice
	- once with the display value
	- once the value as set/returned by attr('value', ...)
	and attr('value'), ex: a Number for NumberTextBox.
	In the latter case it does corrections like converting null to NaN.  In
	the former case the NumberTextBox.filter() method calls this.inherited()
	to execute standard trimming code in TextBox.filter().
	TODO: break this into two methods in 2.0</description>
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="instance"/>
      <method name="_onBlur" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="by" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.app._FormValueWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="trim" scope="instance" type="Boolean">
        <description>Removes leading and trailing whitespace if true.  Default is false.</description>
      </property>
      <property name="uppercase" scope="instance" type="Boolean">
        <description>Converts all characters to uppercase if true.  Default is false.</description>
      </property>
      <property name="lowercase" scope="instance" type="Boolean">
        <description>Converts all characters to lowercase if true.  Default is false.</description>
      </property>
      <property name="propercase" scope="instance" type="Boolean">
        <description>Converts the first character of each word to uppercase if true.</description>
      </property>
      <property name="maxLength" scope="instance" type="String">
        <description>HTML INPUT tag maxLength declaration.</description>
      </property>
      <property name="selectOnClick" scope="instance" type="Boolean">
        <description>If true, all text will be selected when focused with mouse</description>
      </property>
      <property name="placeHolder" scope="instance" type="String">
        <description>Defines a hint to help users fill out the input field (as defined in HTML 5).
	This should only contain plain text (no html markup).</description>
      </property>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="focusNode" scope="instance" type="Object"/>
      <property name="displayedValue" scope="instance" type="String">
        <description>For subclasses like ComboBox where the displayed value
	(ex: Kentucky) and the serialized value (ex: KY) are different,
	this represents the displayed value.
	Setting 'displayedValue' through attr('displayedValue', ...)
	updates 'value', and vice-versa.  Otherwise 'value' is updated
	from 'displayedValue' periodically, like onBlur etc.
	TODO: move declaration to MappedTextBox?
	Problem is that ComboBox references displayedValue,
	for benefit of FilteringSelect.
	if the textbox is blank, what value should be reported</description>
      </property>
      <property name="_blankValue" scope="instance" type="String"/>
      <property name="_selectOnClickHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.TextBox.textbox">
    <properties>
      <property name="value" scope="instance" type="String"/>
      <property name="selectionStart" scope="instance" type="Object"/>
      <property name="selectionEnd" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app._FormWidget" superclass="dijit._WidgetBase">
    <description>Represents a single HTML element.
	All these widgets should have these attributes just like native HTML input elements.
	You can set them during widget construction or afterwards, via `dijit._WidgetBase.attr`.
	They also share some common methods.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_setDisabledAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isFocusable" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="compare" scope="instance">
        <parameters>
          <parameter name="val1" type="anything" usage="required"/>
          <parameter name="val2" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="instance">
        <parameters>
          <parameter name="newValue" type="anything" usage="required">
            <description>the new value</description>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="optional">
            <description>For a slider, for example, dragging the slider is priorityChange==false,
	but on mouse up, it's priorityChange==true.  If intermediateChanges==true,
	onChange is only called form priorityChange=true events.</description>
          </parameter>
        </parameters>
      </method>
      <method name="create" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="_onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectInputText" scope="instance">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="start" type="Number" usage="optional"/>
          <parameter name="stop" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="String">
        <description>Name used when submitting form; same as &amp;quot;name&amp;quot; attribute or plain HTML elements</description>
      </property>
      <property name="alt" scope="instance" type="String">
        <description>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.</description>
      </property>
      <property name="value" scope="instance" type="String">
        <description>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.</description>
      </property>
      <property name="type" scope="instance" type="String">
        <description>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.</description>
      </property>
      <property name="disabled" scope="instance" type="Boolean">
        <description>Should this widget respond to user input?
	In markup, this is specified as &amp;quot;disabled='disabled'&amp;quot;, or just &amp;quot;disabled&amp;quot;.</description>
      </property>
      <property name="intermediateChanges" scope="instance" type="Boolean">
        <description>Fires onChange for each value change or only on demand</description>
      </property>
      <property name="scrollOnFocus" scope="instance" type="Boolean">
        <description>On focus, should this widget scroll into view?</description>
      </property>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="nameAttrSetting" scope="instance" type="Object"/>
      <property name="_onChangeActive" scope="instance" type="Boolean">
        <description>Indicates that changes to the value should call onChange() callback.
	This is false during widget initialization, to avoid calling onChange()
	when the initial value is set.</description>
      </property>
      <property name="_lastValue" scope="instance" type="Object"/>
      <property name="_resetValue" scope="instance" type="Object"/>
      <property name="_lastValueReported" scope="instance" type="Object"/>
      <property name="_onChangeHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app._FormValueWidget" superclass="dojox.mobile.app._FormWidget">
    <description>Each _FormValueWidget represents a single input value, and has a (possibly hidden) &lt;input&gt; element,
	to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	works as expected.</description>
    <methods>
      <method name="_setReadOnlyAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <description>Sets the value of the widget.
	If the value has changed, then fire onChange event, unless priorityChange
	is specified as null (or false?)</description>
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="required">
            <description>optional</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="instance"/>
      <method name="undo" scope="instance"/>
      <method name="reset" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.mobile.app._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="readOnly" scope="instance" type="Boolean">
        <description>Should this widget respond to user input?
	In markup, this is specified as &amp;quot;readOnly&amp;quot;.
	Similar to disabled except readOnly form values are submitted.</description>
      </property>
      <property name="attributeMap" scope="instance" type="Object"/>
      <property name="_resetValue" scope="instance" type="Object"/>
      <property name="value" scope="instance" type="Object"/>
      <property name="_hasBeenBlurred" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.mobile.app._Widget" superclass="dijit._WidgetBase">
    <methods>
      <method name="getScroll" scope="instance"/>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._WidgetBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.mobile.app.eventMap">
    <properties>
      <property name="onmousedown" scope="instance" type="String"/>
      <property name="mousedown" scope="instance" type="String"/>
      <property name="onmouseup" scope="instance" type="String"/>
      <property name="mouseup" scope="instance" type="String"/>
      <property name="onmousemove" scope="instance" type="String"/>
      <property name="mousemove" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="Mojo.Event">
    <properties>
      <property name="flick" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.mobile.app.ImageView.buildRendering.domNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.Switch.buildRendering.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRect.buildRendering.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.RoundRectList.buildRendering.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.mobile.EdgeToEdgeList.buildRendering.domNode">
    <properties>
      <property name="className" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.rails">
    <methods>
      <method name="live" scope="instance">
        <parameters>
          <parameter name="selector" type="Object" usage="required"/>
          <parameter name="evtName" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.validate">
    <methods>
      <method name="isText" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>length: Number, minlength: Number, maxlength: Number}
	flags.length  If set, checks if there are exactly flags.length number of characters.
	flags.minlength  If set, checks if there are at least flags.minlength number of characters.
	flags.maxlength  If set, checks if there are at most flags.maxlength number of characters.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isInRange" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>max:Number, min:Number, decimal:String}
	flags.max  A number, which the value must be less than or equal to for the validation to be true.
	flags.min  A number, which the value must be greater than or equal to for the validation to be true.
	flags.decimal  The character used for the decimal point.  Default is &amp;quot;.&amp;quot;.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isNumberFormat" scope="instance">
        <description>Validates any sort of number based format. Use it for phone numbers,
	social security numbers, zip-codes, etc. The value can be validated
	against one format or one of multiple formats.
	Format Definition
		 #        Stands for a digit, 0-9.
		 ?        Stands for an optional digit, 0-9 or nothing.
	All other characters must appear literally in the expression.</description>
        <examples>
          <example>  "(###) ###-####"       -&gt;   (510) 542-9742
		"(###) ###-#### x#???" -&gt;   (510) 542-9742 x153
		"###-##-####"          -&gt;   506-82-1089       i.e. social security number
		"#####-####"           -&gt;   98225-1649        i.e. zip code</example>
          <example> // returns true:
	 dojox.validate.isNumberFormat("123-45", { format:"###-##" });</example>
          <example>Check Multiple formats:
		dojox.validate.isNumberFormat("123-45", {
			format:["### ##","###-##","## ###"]
		});</example>
        </examples>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>FIXME: make pseudo-object for this
	format: String
	flags.format  A string or an Array of strings for multiple formats.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidLuhn" scope="instance">
        <description>Validate a String value against the Luhn algorithm to verify
	its integrity.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="check" scope="instance">
        <description>returns an object that contains several methods summarizing the results of the validation</description>
        <parameters>
          <parameter name="form" type="HTMLFormElement" usage="required">
            <description>form to be validated</description>
          </parameter>
          <parameter name="profile" type="Object" usage="required">
            <description>specifies how the form fields are to be validated
	{trim:Array, uppercase:Array, lowercase:Array, ucfirst:Array, digit:Array,
	required:Array, dependencies:Object, constraints:Object, confirm:Object}</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="evaluateConstraint" scope="instance">
        <description>The arrays are expected to be in the format of:
	constraints:{</description>
        <parameters>
          <parameter name="profile" type="The" usage="required">
            <description>dojo.validate.check() profile that this evaluation is against.</description>
          </parameter>
          <parameter name="constraint" type="Array" usage="required">
            <description>The single [] array of function and arguments for the function.</description>
          </parameter>
          <parameter name="fieldName" type="The" usage="required">
            <description>form dom name of the field being validated.</description>
          </parameter>
          <parameter name="elem" type="The" usage="required">
            <description>form element field.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidCreditCard" scope="instance">
        <description>Checks if a credit card type matches the # scheme in a passed value, and if
	the Luhn checksum is accurate (unless its an Enroute card, in which case
	the checkSum is skipped), returning a Boolean to check against.</description>
        <examples>
          <example>	if(dojox.validate.isValidCreditCard("12345", "mc")){
			console.log('inconceivable');
		}</example>
        </examples>
        <parameters>
          <parameter name="value" type="String|Int" usage="required">
            <description>A Value (credit card number) to validate</description>
          </parameter>
          <parameter name="ccType" type="String" usage="required">
            <description>A credit-card abbreviation.</description>
          </parameter>
        </parameters>
      </method>
      <method name="isValidCreditCardNumber" scope="instance">
        <parameters>
          <parameter name="value" type="String|Int" usage="required">
            <description>CC #, white spaces and dashes are ignored</description>
          </parameter>
          <parameter name="ccType" type="String" usage="optional">
            <description>One of the abbreviation values in &lt;code&gt;dojox.validate._cardInfo&lt;/code&gt; --
	if Omitted, function returns a &lt;code&gt;|&lt;/code&gt; delimited string of matching card types,
	or false if no matches found.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="isValidCvv" scope="instance">
        <parameters>
          <parameter name="value" type="String|Int" usage="required"/>
          <parameter name="ccType" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidIsbn" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>An ISBN to validate</description>
          </parameter>
        </parameters>
        <return-description>Boolean</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isIpAddress" scope="instance">
        <description>Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
	Supports 2 formats for Ipv6.
	value  A string.
	flags  An object.  All flags are boolean with default = true.
	flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
	flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
	flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
	flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
	flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
	Case insensitive.  Zero padding allowed.
	flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
	flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
	followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isUrl" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.scheme  Can be true, false, or [true, false].
	This means: required, not allowed, or either.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.
	flags in regexp.tld can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isEmailAddress" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.allowCruft  Allow address like &amp;lt;mailto:foo@yahoo.com&amp;gt;.  Default is false.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.
	flags in regexp.tld can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getEmailAddressList" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object (same as dojo.validate.isEmailAddressList)</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="creditCard" scope="instance" type="Object">
        <description>Module provides validation functions for Credit Cards, using account number
	rules in conjunction with the Luhn algorigthm, with a plugable card info database.</description>
      </property>
      <property name="_isInRangeCache" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
      <property name="isbn" scope="instance" type="Object"/>
      <property name="isEmailAddressList" scope="instance" type="Object"/>
      <property name="web" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.robot">
    <properties>
      <property name="recorder" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.rpc.Client">
    <properties>
      <property name="clientId" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.rpc.JsonRest">
    <methods>
      <method name="commit" scope="instance">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getDirtyObjects" scope="instance"/>
      <method name="revert" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="changing" scope="instance">
        <parameters>
          <parameter name="object" type="Object" usage="required"/>
          <parameter name="_deleting" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deleteObject" scope="instance">
        <parameters>
          <parameter name="object" type="object" usage="required">
            <description>to delete</description>
          </parameter>
        </parameters>
      </method>
      <method name="getConstructor" scope="instance">
        <parameters>
          <parameter name="service" type="Function|String" usage="required"/>
          <parameter name="schema" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="absoluteId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdAttribute" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getServiceAndId" scope="instance">
        <parameters>
          <parameter name="absoluteId" type="String" usage="required">
            <description>This is the absolute id of the object</description>
          </parameter>
        </parameters>
      </method>
      <method name="registerService" scope="instance">
        <parameters>
          <parameter name="service" type="Function" usage="required">
            <description>This is the service to register</description>
          </parameter>
          <parameter name="servicePath" type="String" usage="required">
            <description>This is the path that is used for all the ids for the objects returned by service</description>
          </parameter>
          <parameter name="schema" type="Object" usage="optional">
            <description>This is a JSON Schema object to associate with objects returned by this service</description>
          </parameter>
        </parameters>
      </method>
      <method name="byId" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="query" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_loader" scope="instance">
        <parameters>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="serviceClass" scope="instance" type="Object"/>
      <property name="conflictDateHeader" scope="instance" type="String"/>
      <property name="services" scope="instance" type="Object"/>
      <property name="schemas" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.rpc.JsonRest.sendToServer">
    <methods/>
    <properties>
      <property name="conflictDateHeader" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.manager">
    <description>Initializes the storage systems and figures out the best available
	storage options on this platform.</description>
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="name" type="string" usage="required">
            <description>The full class name of this provider, such as
	&amp;quot;dojox.storage.FlashStorageProvider&amp;quot;.</description>
          </parameter>
          <parameter name="instance" type="Object" usage="required">
            <description>An instance of this provider, which we will use to call
	isAvailable() on.</description>
          </parameter>
        </parameters>
      </method>
      <method name="setProvider" scope="instance">
        <description>Example-
	dojox.storage.setProvider(
	dojox.storage.IEStorageProvider)</description>
        <parameters>
          <parameter name="storageClass" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="autodetect" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="addOnLoad" scope="instance">
        <description>Adds a listener to know when Dojo Offline can be used. This
	ensures that the Dojo Offline framework is loaded and that the
	local dojox.storage system is ready to be used. This method is
	useful if you don't want to have a dependency on Dojo Events
	when using dojox.storage.</description>
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <description>A function to call when Dojo Offline is ready to go</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeOnLoad" scope="instance">
        <parameters>
          <parameter name="func" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isInitialized" scope="instance"/>
      <method name="supportsProvider" scope="instance">
        <description>Example-
	dojox.storage.manager.supportsProvider(
	"dojox.storage.InternetExplorerStorageProvider");</description>
        <parameters>
          <parameter name="storageClass" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getProvider" scope="instance"/>
      <method name="loaded" scope="instance">
        <description>Example 1-
	if(dojox.storage.manager.isInitialized() == false){
	dojo.connect(dojox.storage.manager, "loaded", TestStorage, "initialize");
	}else{
	dojo.connect(dojo, "loaded", TestStorage, "initialize");
	}
	Example 2-
	dojox.storage.manager.addOnLoad(someFunction);</description>
      </method>
      <method name="_fireLoaded" scope="instance"/>
      <method name="getResourceList" scope="instance">
        <description>This will return all files needed by all storage providers for
	this particular environment type. For example, if we are in the
	browser environment, then this will return the hidden SWF files
	needed by the FlashStorageProvider, even if we don't need them
	for the particular browser we are working within. This is meant
	to faciliate Dojo Offline, which must retrieve all resources we
	need offline into the offline cache -- we retrieve everything
	needed, in case another browser that requires different storage
	mechanisms hits the local offline cache. For example, if we
	were to sync against Dojo Offline on Firefox 2, then we would
	not grab the FlashStorageProvider resources needed for Safari.</description>
      </method>
    </methods>
    <properties>
      <property name="available" scope="instance" type="Object"/>
      <property name="currentProvider" scope="instance" type="Object">
        <description>The storage provider that was automagically chosen to do storage
	on this platform, such as dojox.storage.FlashStorageProvider.</description>
      </property>
      <property name="providers" scope="instance" type="Array"/>
      <property name="_initialized" scope="instance" type="Object"/>
      <property name="_onLoadListeners" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.rpc.OfflineRest">
    <methods>
      <method name="turnOffAutoSync" scope="instance"/>
      <method name="downloadChanges" scope="instance"/>
      <method name="addStore" scope="instance">
        <parameters>
          <parameter name="store" type="data-store" usage="required">
            <description>Store to add</description>
          </parameter>
          <parameter name="baseQuery" type="query" usage="optional">
            <description>This is the base query to should be used to load the items for
	the store. Generally you want to load all the items that should be
	available when offline.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="sync" scope="instance" type="Object"/>
      <property name="sendChanges" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="OfflineRest">
    <properties>
      <property name="stores" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="drr">
    <methods>
      <method name="_change" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="content" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_index" scope="instance" type="Object"/>
      <property name="_timeStamps" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.rpc.Service">
    <description>dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
	dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
	a "No match found" error.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
	dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
	a "No match found" error.</description>
        <parameters>
          <parameter name="smd" type="object" usage="required">
            <description>Takes a number of properties as kwArgs for defining the service.  It also
	accepts a string.  When passed a string, it is treated as a url from
	which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
	object.  It accepts serviceUrl, to manually define a url for the rpc service
	allowing the rpc system to be used without an smd definition. strictArgChecks
	forces the system to verify that the # of arguments provided in a call
	matches those defined in the smd.  smdString allows a developer to pass
	a jsonString directly, which will be converted into an object or alternatively
	smdObject is accepts an smdObject directly.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_generateService" scope="instance">
        <parameters>
          <parameter name="serviceName" type="Object" usage="required"/>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getRequest" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_executeMethod" scope="instance">
        <parameters>
          <parameter name="method" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_smd" scope="instance" type="Object"/>
      <property name="_options" scope="instance" type="Object"/>
      <property name="_requestId" scope="instance" type="Number"/>
      <property name="_nextId" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.secure">
    <methods>
      <method name="DOM" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unwrap" scope="instance">
        <parameters>
          <parameter name="result" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sandbox" scope="instance">
        <description>This function will create and return a sandbox object (see dojox.secure.__Sandbox)
	for the provided element.</description>
        <parameters>
          <parameter name="element" type="The" usage="required">
            <description>DOM element to use as the container for the sandbox</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.secure.__Sandbox"/>
        </return-types>
      </method>
      <method name="_safeDojoFunctions" scope="instance">
        <parameters>
          <parameter name="element" type="Object" usage="required"/>
          <parameter name="wrap" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="wrap the NodeList"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="badProps" scope="instance" type="RegExp"/>
      <property name="fromJson" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="wrap">
    <properties>
      <property name="safeHTML" scope="instance" type="Object"/>
      <property name="safeCSS" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.secure.capability">
    <properties>
      <property name="keywords" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.secure.capability.validate">
    <methods/>
    <properties>
      <property name="keywords" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch">
    <methods>
      <method name="registerTool" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="makeToolbar" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="figure" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="tools" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Anchor">
    <methods>
      <method name="type" scope="instance"/>
      <method name="beginEdit" scope="instance"/>
      <method name="endEdit" scope="instance"/>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setBinding" scope="instance">
        <parameters>
          <parameter name="pt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setUndo" scope="instance"/>
      <method name="enable" scope="instance"/>
      <method name="disable" scope="instance"/>
    </methods>
    <properties>
      <property name="annotation" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="_key" scope="instance" type="String"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="isControl" scope="instance" type="Object"/>
      <property name="count" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.sketch.AnnotationTool" superclass="dojox.sketch._Plugin">
    <methods>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
          <parameter name="rect" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_create" scope="instance">
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.sketch._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="_omd" scope="instance" type="bool"/>
      <property name="_cshape" scope="instance" type="Object"/>
      <property name="figure" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="onRemove" scope="instance">
        <parameters>
          <parameter name="noundo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="property" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPropertyChange" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="oldvalue" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCreate" scope="instance"/>
      <method name="onDblClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initialize" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="draw" scope="instance"/>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="setBinding" scope="instance">
        <parameters>
          <parameter name="pt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getTextBox" scope="instance">
        <parameters>
          <parameter name="zoomfactor" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="writeCommonAttrs" scope="instance"/>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="toolclass" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="id" scope="instance" type="Object"/>
      <property name="_key" scope="instance" type="Object"/>
      <property name="figure" scope="instance" type="Object"/>
      <property name="mode" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="boundingBox" scope="instance" type="Object"/>
      <property name="hasAnchors" scope="instance" type="Object"/>
      <property name="anchors" scope="instance" type="Object"/>
      <property name="_properties" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.beginEdit">
    <methods/>
    <properties>
      <property name="_type" scope="instance" type="Object"/>
      <property name="_prevState" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.endEdit">
    <methods/>
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_prevState" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.calculate">
    <methods>
      <method name="slope" scope="instance">
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dx" scope="instance">
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
          <parameter name="dy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dy" scope="instance">
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
          <parameter name="dx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sketch.Annotation.drawBBox">
    <methods/>
    <properties>
      <property name="boundingBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.setMode">
    <methods/>
    <properties>
      <property name="mode" scope="instance" type="Object"/>
      <property name="boundingBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.readCommonAttrs">
    <methods/>
    <properties>
      <property name="_properties" scope="instance" type="Object"/>
      <property name="data" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.readCommonAttrs.transform">
    <properties>
      <property name="dx" scope="instance" type="Object"/>
      <property name="dy" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Annotation.Modes">
    <properties>
      <property name="View" scope="instance" type="Number"/>
      <property name="Edit" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Number"/>
      <property name="textYOffset" scope="instance" type="Number"/>
      <property name="textAlign" scope="instance" type="String"/>
      <property name="startRotation" scope="instance" type="Number"/>
      <property name="endRotation" scope="instance" type="Number"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="startArrow" scope="instance" type="Object"/>
      <property name="startArrowGroup" scope="instance" type="Object"/>
      <property name="endArrow" scope="instance" type="Object"/>
      <property name="endArrowGroup" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation._rot">
    <methods/>
    <properties>
      <property name="startRotation" scope="instance" type="Object"/>
      <property name="endRotation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation._pos">
    <methods/>
    <properties>
      <property name="textOffset" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.apply">
    <methods/>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.apply.start">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.apply.control">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.apply.end">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.initialize">
    <methods/>
    <properties>
      <property name="endRotation" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="startArrowGroup" scope="instance" type="Object"/>
      <property name="startArrow" scope="instance" type="Object"/>
      <property name="endArrowGroup" scope="instance" type="Object"/>
      <property name="endArrow" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.destroy">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="startArrowGroup" scope="instance" type="Object"/>
      <property name="startArrow" scope="instance" type="Object"/>
      <property name="endArrowGroup" scope="instance" type="Object"/>
      <property name="endArrow" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.draw">
    <methods/>
    <properties>
      <property name="endRotation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.zoom">
    <methods/>
  </class>
  <class type="dojox.sketch.DoubleArrowAnnotation.zoom.figure">
    <properties>
      <property name="zoomFactor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure">
    <methods>
      <method name="hasSelections" scope="instance"/>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clearSelections" scope="instance"/>
      <method name="replaceSelection" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_dblclick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_keydown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_md" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mm" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mu" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calCol" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_delete" scope="instance">
        <parameters>
          <parameter name="arr" type="Object" usage="required"/>
          <parameter name="noundo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDblClickShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCreateShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeCreateShape" scope="instance">
        <parameters>
          <parameter name="shape" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="instance"/>
      <method name="draw" scope="instance"/>
      <method name="getFit" scope="instance"/>
      <method name="_add" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_keyFromEvt" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fromEvt" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="annotation" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="annotation" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAnnotator" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="convert" scope="instance">
        <parameters>
          <parameter name="ann" type="Object" usage="required"/>
          <parameter name="t" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="instance"/>
      <method name="onClick" scope="instance"/>
      <method name="_loadAnnotation" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onUndo" scope="instance"/>
      <method name="onBeforeUndo" scope="instance"/>
      <method name="onRedo" scope="instance"/>
      <method name="onBeforeRedo" scope="instance"/>
      <method name="undo" scope="instance"/>
      <method name="redo" scope="instance"/>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="annCounter" scope="instance" type="Number"/>
      <property name="shapes" scope="instance" type="Array"/>
      <property name="image" scope="instance" type="Object"/>
      <property name="imageSrc" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Object"/>
      <property name="zoomFactor" scope="instance" type="Number"/>
      <property name="tools" scope="instance" type="Object"/>
      <property name="obj" scope="instance" type="Object"/>
      <property name="selected" scope="instance" type="Array"/>
      <property name="_c" scope="instance" type="Object"/>
      <property name="_ctr" scope="instance" type="Object"/>
      <property name="_lp" scope="instance" type="Object"/>
      <property name="_action" scope="instance" type="Object"/>
      <property name="_prevState" scope="instance" type="Object"/>
      <property name="_startPoint" scope="instance" type="Object"/>
      <property name="_ctool" scope="instance" type="Object"/>
      <property name="_start" scope="instance" type="Object"/>
      <property name="_end" scope="instance" type="Object"/>
      <property name="_absEnd" scope="instance" type="Object"/>
      <property name="_cshape" scope="instance" type="Object"/>
      <property name="gridSize" scope="instance" type="Number"/>
      <property name="getValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.initUndoStack">
    <methods/>
    <properties>
      <property name="history" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.setTool">
    <methods/>
    <properties>
      <property name="_ctool" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.initialize">
    <methods/>
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="_cons" scope="instance" type="Array"/>
      <property name="image" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.destroy">
    <methods/>
    <properties>
      <property name="_cons" scope="instance" type="Array"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="obj" scope="instance" type="Object"/>
      <property name="shapes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.zoom">
    <methods/>
    <properties>
      <property name="zoomFactor" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.unzoom">
    <methods/>
    <properties>
      <property name="zoomFactor" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.setValue">
    <methods/>
    <properties>
      <property name="node" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Figure.load">
    <methods/>
    <properties>
      <property name="size" scope="instance" type="Object"/>
      <property name="imageSize" scope="instance" type="Object"/>
      <property name="imageSrc" scope="instance" type="Object"/>
      <property name="_loadDeferred" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Number"/>
      <property name="textYOffset" scope="instance" type="Number"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation._pos">
    <methods/>
    <properties>
      <property name="textOffset" scope="instance" type="Object"/>
      <property name="textAlign" scope="instance" type="String"/>
      <property name="textPosition" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.apply">
    <methods/>
  </class>
  <class type="dojox.sketch.LeadAnnotation.apply.start">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.apply.control">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.apply.end">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.initialize">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.LeadAnnotation.destroy">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="radius" scope="instance" type="Number"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Number"/>
      <property name="textAlign" scope="instance" type="String"/>
      <property name="rectShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation._pos">
    <methods/>
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.apply">
    <methods/>
    <properties>
      <property name="radius" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.apply.start">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.apply.end">
    <properties>
      <property name="x" scope="instance" type="String"/>
      <property name="y" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.initialize">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rectShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.PreexistingAnnotation.destroy">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rectShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="getBBox" scope="instance"/>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Number"/>
      <property name="textYOffset" scope="instance" type="Number"/>
      <property name="rotation" scope="instance" type="Number"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="arrowhead" scope="instance" type="Object"/>
      <property name="arrowheadGroup" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.anchors">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation._rot">
    <methods/>
    <properties>
      <property name="rotation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation._pos">
    <methods/>
    <properties>
      <property name="textOffset" scope="instance" type="Object"/>
      <property name="textAlign" scope="instance" type="String"/>
      <property name="textPosition" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.apply">
    <methods/>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.apply.start">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.apply.control">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.apply.end">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.initialize">
    <methods/>
    <properties>
      <property name="rotation" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="arrowheadGroup" scope="instance" type="Object"/>
      <property name="arrowhead" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.destroy">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="arrowheadGroup" scope="instance" type="Object"/>
      <property name="arrowhead" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.draw">
    <methods/>
    <properties>
      <property name="rotation" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.zoom">
    <methods/>
    <properties>
      <property name="_curPct" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.SingleArrowAnnotation.zoom.figure">
    <properties>
      <property name="zoomFactor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Slider" superclass="dojox.sketch._Plugin">
    <methods>
      <method name="_initButton" scope="instance"/>
      <method name="_zoomToFit" scope="instance"/>
      <method name="_setZoom" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="t" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.sketch._Plugin" scope="instance"/>
    </mixins>
    <properties>
      <property name="slider" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Slider.slider._movable.node">
    <properties>
      <property name="title" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.sketch.ButtonGroup">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="plugin" type="_Plugin" usage="required"/>
        </parameters>
      </method>
      <method name="_resetGroup" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_children" scope="instance-prototype" type="Array"/>
      <property name="_childMaps" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.Toolbar" superclass="dijit.Toolbar">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="setFigure" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="addGroupItem" scope="instance">
        <parameters>
          <parameter name="item" type="_Plugin" usage="required"/>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
      <method name="_setShape" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Toolbar" scope="instance"/>
    </mixins>
    <properties>
      <property name="figure" scope="instance" type="Object"/>
      <property name="plugins" scope="instance" type="Array"/>
      <property name="shapeGroup" scope="instance" type="Object"/>
      <property name="_plugins" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotationTool" superclass="dojox.sketch.AnnotationTool">
    <methods>
      <method name="onMouseDown" scope="instance"/>
      <method name="onMouseUp" scope="instance"/>
      <method name="onMouseMove" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.sketch.AnnotationTool" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.sketch.UnderlineAnnotationTool.figure">
    <properties>
      <property name="_end" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation">
    <methods>
      <method name="type" scope="instance"/>
      <method name="getType" scope="instance"/>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="instance"/>
    </methods>
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="lineShape" scope="instance" type="Object"/>
      <property name="constructor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.initialize">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="lineShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.destroy">
    <methods/>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="lineShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.getBBox">
    <methods/>
  </class>
  <class type="dojox.sketch.UnderlineAnnotation.getBBox.figure">
    <properties>
      <property name="zoomFactor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sketch.UndoStack">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="figure" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="apply" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
          <parameter name="from" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="cmd" type="String" usage="required"/>
          <parameter name="ann" type="ta.Annotation" usage="optional"/>
          <parameter name="before" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="undo" scope="instance"/>
      <method name="redo" scope="instance"/>
    </methods>
    <properties>
      <property name="_undoedSteps" scope="instance-prototype" type="Array"/>
      <property name="figure" scope="instance" type="Object"/>
      <property name="_steps" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.sketch.CommandTypes">
    <properties>
      <property name="Create" scope="instance" type="String"/>
      <property name="Move" scope="instance" type="String"/>
      <property name="Modify" scope="instance" type="String"/>
      <property name="Delete" scope="instance" type="String"/>
      <property name="Convert" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.sketch._Plugin">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_initButton" scope="instance"/>
      <method name="attr" scope="instance">
        <parameters>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onActivate" scope="instance"/>
      <method name="activate" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance">
        <parameters>
          <parameter name="f" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="instance">
        <parameters>
          <parameter name="o" type="Object" usage="required"/>
          <parameter name="f" type="Object" usage="required"/>
          <parameter name="tf" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setFigure" scope="instance">
        <parameters>
          <parameter name="figure" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="setToolbar" scope="instance">
        <parameters>
          <parameter name="toolbar" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="figure" scope="instance" type="Object"/>
      <property name="iconClassPrefix" scope="instance" type="String"/>
      <property name="itemGroup" scope="instance" type="String"/>
      <property name="button" scope="instance" type="Object"/>
      <property name="queryCommand" scope="instance" type="Object"/>
      <property name="shape" scope="instance" type="String"/>
      <property name="useDefaultCommand" scope="instance" type="Object"/>
      <property name="buttonClass" scope="instance" type="Object"/>
      <property name="_connects" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.socket">
    <methods>
      <method name="Reconnect" scope="instance">
        <examples>
          <example>You can use the Reconnect module:
	 dojo.require("dojox.socket");
	 dojo.require("dojox.socket.Reconnect");
	 var socket = dojox.socket({url:"/comet"});
	 // add auto-reconnect support
	 socket = dojox.socket.Reconnect(socket);</example>
        </examples>
        <parameters>
          <parameter name="socket" type="Socket" usage="required">
            <description>to add reconnection support to.</description>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
        <return-description>An object that implements the WebSocket API</return-description>
      </method>
    </methods>
  </class>
  <class type="Socket">
    <methods>
      <method name="WebSocket" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="socket" type="Object" usage="required"/>
          <parameter name="newSocket" type="Object" usage="required"/>
          <parameter name="listenForOpen" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="LongPoll" scope="instance">
        <examples>
          <example> dojo.require("dojox.socket.LongPoll");
	 var socket = dojox.socket.LongPoll({url:"/comet"});
	or:
	 dojo.require("dojox.socket.LongPoll");
	 dojox.socket.LongPoll.add();
	 var socket = dojox.socket({url:"/comet"});</example>
        </examples>
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required">
            <description>This uses the same arguments as the other I/O functions in Dojo, with this addition:
	args.interval:
	Indicates the amount of time (in milliseconds) after a response was received
	before another request is made. By default, a request is made immediately
	after getting a response. The interval can be increased to reduce load on the
	server or to do simple time-based polling where the server always responds
	immediately.
	args.transport:
	Provide an alternate transport like dojo.io.script.get</description>
          </parameter>
        </parameters>
        <return-description>An object that implements the WebSocket API</return-description>
      </method>
    </methods>
  </class>
  <class type="dojox.sql">
    <description>There are four ways to call this:
	1) Straight SQL: dojox.sql("SELECT * FROM FOOBAR");
	2) SQL with parameters: dojox.sql("INSERT INTO FOOBAR VALUES (?)", someParam)
	3) Encrypting particular values:
	dojox.sql("INSERT INTO FOOBAR VALUES (ENCRYPT(?))", someParam, "somePassword", callback)
	4) Decrypting particular values:
	dojox.sql("SELECT DECRYPT(SOMECOL1), DECRYPT(SOMECOL2) FROM
	FOOBAR WHERE SOMECOL3 = ?", someParam,
	"somePassword", callback)
	For encryption and decryption the last two values should be the the password for
	encryption/decryption, and the callback function that gets the result set.
	Note: We only support ENCRYPT(?) statements, and
	and DECRYPT(*) statements for now -- you can not have a literal string
	inside of these, such as ENCRYPT('foobar')
	Note: If you have multiple columns to encrypt and decrypt, you can use the following
	convenience form to not have to type ENCRYPT(?)/DECRYPT(*) many times:
	dojox.sql("INSERT INTO FOOBAR VALUES (ENCRYPT(?, ?, ?))",
	someParam1, someParam2, someParam3,
	"somePassword", callback)
	dojox.sql("SELECT DECRYPT(SOMECOL1, SOMECOL2) FROM
	FOOBAR WHERE SOMECOL3 = ?", someParam,
	"somePassword", callback)</description>
    <methods>
      <method name="_printDebugSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeResults" scope="instance">
        <parameters>
          <parameter name="rs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needsEncrypt" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_needsDecrypt" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.sql" scope="instance"/>
    </mixins>
    <properties>
      <property name="dbName" scope="instance" type="Object"/>
      <property name="debug" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql.open">
    <methods/>
    <properties>
      <property name="dbName" scope="instance" type="Object"/>
      <property name="_dbOpen" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql.close">
    <methods/>
    <properties>
      <property name="dbName" scope="instance" type="Object"/>
      <property name="_dbOpen" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.sql._exec">
    <methods/>
    <properties>
      <property name="_autoClose" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql._initDb">
    <methods/>
    <properties>
      <property name="db" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql._SQLCrypto">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="action" type="Object" usage="required"/>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_execEncryptSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_execDecryptSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_encrypt" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="encryptColumns" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decrypt" scope="instance">
        <parameters>
          <parameter name="resultSet" type="Object" usage="required"/>
          <parameter name="needsDecrypt" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_stripCryptoSQL" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_flagEncryptedArgs" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_determineDecryptedColumns" scope="instance">
        <parameters>
          <parameter name="sql" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_decryptSingleColumn" scope="instance">
        <parameters>
          <parameter name="columnName" type="Object" usage="required"/>
          <parameter name="columnValue" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="currentRowIndex" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_totalCrypto" scope="instance" type="Number"/>
      <property name="_finishedCrypto" scope="instance" type="Number"/>
      <property name="_finishedSpawningCrypto" scope="instance" type="Object"/>
      <property name="_finalArgs" scope="instance" type="Object"/>
      <property name="_finalResultSet" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.sql._crypto">
    <description>Taken from http://www.movable-type.co.uk/scripts/aes.html by
	Chris Veness (CLA signed); adapted for Dojo and Google Gears Worker Pool
	by Brad Neuberg, bkn3@columbia.edu</description>
    <methods>
      <method name="encrypt" scope="instance">
        <parameters>
          <parameter name="plaintext" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decrypt" scope="instance">
        <parameters>
          <parameter name="ciphertext" type="Object" usage="required"/>
          <parameter name="password" type="Object" usage="required"/>
          <parameter name="callback" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_workerHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_POOL_SIZE" scope="instance" type="Size">
        <description>of worker pool to create to help with crypto</description>
      </property>
    </properties>
  </class>
  <class type="dojox.sql._crypto._initWorkerPool">
    <methods/>
    <properties>
      <property name="_unemployed" scope="instance" type="Array"/>
      <property name="_employed" scope="instance" type="Object"/>
      <property name="_handleMessage" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.sql._crypto._initWorkerPool._manager">
    <methods>
      <method name="onmessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="sender" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.sql._crypto._assignWork">
    <methods/>
    <properties>
      <property name="_handleMessage" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage">
    <properties>
      <property name="_common" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.AirDBStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="_sql" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_beginTransaction" scope="instance"/>
      <method name="_commitTransaction" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="DATABASE_FILE" scope="instance" type="String"/>
      <property name="TABLE_NAME" scope="instance" type="String"/>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="_db" scope="instance" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.AirEncryptedLocalStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="_getItem" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setItem" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeItem" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.AirFileStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="_storagePath" scope="instance" type="String"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.BehaviorStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="_createStore" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="value" type="object" usage="required"/>
          <parameter name="resultsHandler" type="function" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="isValidKey" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isValidNamespace" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getFullKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_beginsWith" scope="instance">
        <parameters>
          <parameter name="haystack" type="string" usage="required"/>
          <parameter name="needle" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidNamespace" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidKey" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_addKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="storeName" scope="instance" type="String"/>
      <property name="keys" scope="instance" type="Object"/>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.CookieStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="value" type="object" usage="required"/>
          <parameter name="resultsHandler" type="function" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="isValidKey" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isValidNamespace" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getFullKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_save" scope="instance"/>
      <method name="_beginsWith" scope="instance">
        <parameters>
          <parameter name="haystack" type="string" usage="required"/>
          <parameter name="needle" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidNamespace" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidKey" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="cookieName" scope="instance" type="String"/>
      <property name="storageLife" scope="instance" type="Number"/>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.FlashStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="setFlushDelay" scope="instance">
        <parameters>
          <parameter name="newDelay" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getFlushDelay" scope="instance"/>
      <method name="flush" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="_destringify" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="getResourceList" scope="instance"/>
      <method name="_loaded" scope="instance"/>
      <method name="_onStatus" scope="instance">
        <parameters>
          <parameter name="statusResult" type="Object" usage="required"/>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="_available" scope="instance" type="bool"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
      <property name="_flashReady" scope="instance" type="bool"/>
      <property name="_pageReady" scope="instance" type="bool"/>
      <property name="_allNamespaces" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.GearsStorageProvider" superclass="dojox.storage.Provider">
    <description>You can disable this storage provider with the following djConfig
	variable:
	var djConfig = { disableGearsStorage: true };
	Authors of this storage provider-
	Brad Neuberg, bkn3@columbia.edu
	instance methods and properties</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="values" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="_initStorage" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="TABLE_NAME" scope="instance" type="String"/>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="_available" scope="instance" type="Object"/>
      <property name="_storageReady" scope="instance" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.LocalStorageProvider" superclass="dojox.storage.Provider">
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="value" type="object" usage="required"/>
          <parameter name="resultsHandler" type="function" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="isValidKey" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="isValidNamespace" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getFullKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_beginsWith" scope="instance">
        <parameters>
          <parameter name="haystack" type="string" usage="required"/>
          <parameter name="needle" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidNamespace" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsValidKey" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="store" scope="instance" type="Object"/>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.storage.Provider">
    <description>dojox.storage exposes the current available storage provider on this
	platform. It gives you methods such as dojox.storage.put(),
	dojox.storage.get(), etc.
	For more details on dojox.storage, see the primary documentation
	page at
	http://manual.dojotoolkit.org/storage.html
	Note for storage provider developers who are creating subclasses-
	This is the base class for all storage providers Specific kinds of
	Storage Providers should subclass this and implement these methods.
	You should avoid initialization in storage provider subclass's
	constructor; instead, perform initialization in your initialize()
	method.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="onHideSettingsUI" scope="instance"/>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <description>Example-
	var resultsHandler = function(status, key, message, namespace){
	alert("status="+status+", key="+key+", message="+message);
	};
	dojox.storage.put("test", "hello world", resultsHandler);
	Arguments:
	status - The status of the put operation, given by
	dojox.storage.FAILED, dojox.storage.SUCCEEDED, or
	dojox.storage.PENDING
	key - The key that was used for the put
	message - An optional message if there was an error or things failed.
	namespace - The namespace of the key. This comes at the end since
	it was added later.
	Important note: if you are using Dojo Storage in conjunction with
	Dojo Offline, then you don't need to provide
	a resultsHandler; this is because for Dojo Offline we
	use Google Gears to persist data, which has unlimited data
	once the user has given permission. If you are using Dojo
	Storage apart from Dojo Offline, then under the covers hidden
	Flash might be used, which is both asychronous and which might
	get denied; in this case you must provide a resultsHandler.</description>
        <parameters>
          <parameter name="key" type="string" usage="required">
            <description>A string key to use when retrieving this value in the future.</description>
          </parameter>
          <parameter name="value" type="object" usage="required">
            <description>A value to store; this can be any JavaScript type.</description>
          </parameter>
          <parameter name="resultsHandler" type="function" usage="required">
            <description>A callback function that will receive three arguments. The
	first argument is one of three values: dojox.storage.SUCCESS,
	dojox.storage.FAILED, or dojox.storage.PENDING; these values
	determine how the put request went. In some storage systems
	users can deny a storage request, resulting in a
	dojox.storage.FAILED, while in other storage systems a storage
	request must wait for user approval, resulting in a
	dojox.storage.PENDING status until the request is either
	approved or denied, resulting in another call back with
	dojox.storage.SUCCESS.
	The second argument in the call back is the key name that was being stored.
	The third argument in the call back is an optional message that
	details possible error messages that might have occurred during
	the storage process.</description>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <description>Optional string namespace that this value will be placed into;
	if left off, the value will be placed into dojox.storage.DEFAULT_NAMESPACE</description>
          </parameter>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required">
            <description>A string key to get the value of.</description>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <description>Optional string namespace that this value will be retrieved from;
	if left off, the value will be retrieved from dojox.storage.DEFAULT_NAMESPACE
	return: Returns any JavaScript object type; null if the key is not present</description>
          </parameter>
        </parameters>
      </method>
      <method name="hasKey" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance">
        <return-description>Returns the maximum storage size
	supported by this provider, in
	thousands of bytes (i.e., if it
	returns 60 then this means that 60K
	of storage is supported).
	If this provider can not determine
	it's maximum size, then
	dojox.storage.SIZE_NOT_AVAILABLE is
	returned; if there is no theoretical
	limit on the amount of storage
	this provider can return, then
	dojox.storage.SIZE_NO_LIMIT is
	returned</return-description>
      </method>
      <method name="putMultiple" scope="instance">
        <description>Example-
	var resultsHandler = function(status, key, message){
	alert("status="+status+", key="+key+", message="+message);
	};
	dojox.storage.put(["test"], ["hello world"], resultsHandler);
	Important note: if you are using Dojo Storage in conjunction with
	Dojo Offline, then you don't need to provide
	a resultsHandler; this is because for Dojo Offline we
	use Google Gears to persist data, which has unlimited data
	once the user has given permission. If you are using Dojo
	Storage apart from Dojo Offline, then under the covers hidden
	Flash might be used, which is both asychronous and which might
	get denied; in this case you must provide a resultsHandler.</description>
        <parameters>
          <parameter name="keys" type="array" usage="required">
            <description>An array of string keys to use when retrieving this value in the future,
	one per value to be stored</description>
          </parameter>
          <parameter name="values" type="array" usage="required">
            <description>An array of values to store; this can be any JavaScript type, though the
	performance of plain strings is considerably better</description>
          </parameter>
          <parameter name="resultsHandler" type="function" usage="required">
            <description>A callback function that will receive three arguments. The
	first argument is one of three values: dojox.storage.SUCCESS,
	dojox.storage.FAILED, or dojox.storage.PENDING; these values
	determine how the put request went. In some storage systems
	users can deny a storage request, resulting in a
	dojox.storage.FAILED, while in other storage systems a storage
	request must wait for user approval, resulting in a
	dojox.storage.PENDING status until the request is either
	approved or denied, resulting in another call back with
	dojox.storage.SUCCESS.
	The second argument in the call back is the key name that was being stored.
	The third argument in the call back is an optional message that
	details possible error messages that might have occurred during
	the storage process.</description>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <description>Optional string namespace that this value will be placed into;
	if left off, the value will be placed into dojox.storage.DEFAULT_NAMESPACE</description>
          </parameter>
        </parameters>
      </method>
      <method name="getMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="array" usage="required">
            <description>An array of string keys to get the value of.</description>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <description>Optional string namespace that this value will be retrieved from;
	if left off, the value will be retrieved from dojox.storage.DEFAULT_NAMESPACE
	return: Returns any JavaScript object type; null if the key is not present</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeMultiple" scope="instance">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="isValidKeyArray" scope="instance">
        <parameters>
          <parameter name="keys" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="isValidKey" scope="instance">
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getResourceList" scope="instance">
        <description>This method returns a list of URLs that this
	storage provider depends on to do its work.
	This list is used by the Dojo Offline Toolkit
	to cache these resources to ensure the machinery
	used by this storage provider is available offline.
	What is returned is an array of URLs.
	Note that Dojo Offline uses Gears as its native
	storage provider, and does not support using other
	kinds of storage providers while offline anymore.</description>
      </method>
    </methods>
    <properties>
      <property name="SUCCESS" scope="instance" type="String">
        <description>Flag that indicates a put() call to a
	storage provider was succesful.</description>
      </property>
      <property name="FAILED" scope="instance" type="String">
        <description>Flag that indicates a put() call to
	a storage provider failed.</description>
      </property>
      <property name="PENDING" scope="instance" type="String">
        <description>Flag that indicates a put() call to a
	storage provider is pending user approval.</description>
      </property>
      <property name="SIZE_NOT_AVAILABLE" scope="instance" type="String">
        <description>Returned by getMaximumSize() if this storage provider can not determine
	the maximum amount of data it can support.</description>
      </property>
      <property name="SIZE_NO_LIMIT" scope="instance" type="String">
        <description>Returned by getMaximumSize() if this storage provider has no theoretical
	limit on the amount of data it can store.</description>
      </property>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="String">
        <description>The namespace for all storage operations. This is useful if several
	applications want access to the storage system from the same domain but
	want different storage silos.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.storage.WhatWGStorageProvider" superclass="dojox.storage.Provider">
    <description>The WHAT WG storage API is documented at
	http://www.whatwg.org/specs/web-apps/current-work/#scs-client-side
	You can disable this storage provider with the following djConfig
	variable:
	var djConfig = { disableWhatWGStorage: true };
	Authors of this storage provider-
	JB Boisseau, jb.boisseau@eutech-ssii.com
	Brad Neuberg, bkn3@columbia.edu</description>
    <methods>
      <method name="initialize" scope="instance"/>
      <method name="isAvailable" scope="instance"/>
      <method name="put" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="resultsHandler" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="instance"/>
      <method name="getKeys" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance">
        <parameters>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="instance"/>
      <method name="getMaximumSize" scope="instance"/>
      <method name="hasSettingsUI" scope="instance"/>
      <method name="showSettingsUI" scope="instance"/>
      <method name="hideSettingsUI" scope="instance"/>
      <method name="getFullKey" scope="instance">
        <parameters>
          <parameter name="key" type="Object" usage="required"/>
          <parameter name="namespace" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.storage.Provider" scope="instance"/>
    </mixins>
    <properties>
      <property name="initialized" scope="instance" type="Object"/>
      <property name="_domain" scope="instance" type="Object"/>
      <property name="_available" scope="instance" type="Object"/>
      <property name="_statusHandler" scope="instance" type="Object"/>
      <property name="_allNamespaces" scope="instance" type="Object"/>
      <property name="_storageEventListener" scope="instance" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.BidiComplex">
    <methods>
      <method name="attachInput" scope="instance">
        <parameters>
          <parameter name="field" type="DOMNode" usage="required">
            <description>INPUT DOM node</description>
          </parameter>
          <parameter name="pattern" type="String" usage="required">
            <description>Complex Expression Pattern type. One of &amp;quot;FILE_PATH&amp;quot;, &amp;quot;URL&amp;quot;, &amp;quot;EMAIL&amp;quot;, &amp;quot;XPATH&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="createDisplayString" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="pattern" type="String" usage="required">
            <description>Complex Expression Pattern type. One of &amp;quot;FILE_PATH&amp;quot;, &amp;quot;URL&amp;quot;, &amp;quot;EMAIL&amp;quot;, &amp;quot;XPATH&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="stripSpecialCharacters" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_ceKeyDown" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ceKeyUp" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_processCopy" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
          <parameter name="isReverse" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ceCopyText" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_ceCutText" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getCaretPos" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedRange" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="selectionStart" type="Object" usage="required"/>
          <parameter name="selectionEnd" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="pattern" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.string">
    <methods>
      <method name="tokenize" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="re" type="RegExp" usage="required"/>
          <parameter name="parseDelim" type="Function" usage="optional">
            <description>Each group (excluding the 0 group) is passed as a parameter. If the function returns
	a value, it's added to the list of tokens.</description>
          </parameter>
          <parameter name="instance" type="Object" usage="optional">
            <description>Used as the &amp;quot;this&amp;quot; instance when calling parseDelim</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.string.Builder">
    <methods>
      <method name="append" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="concat" scope="instance">
        <parameters>
          <parameter name="s" type="String" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="appendArray" scope="instance">
        <parameters>
          <parameter name="strings" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="clear" scope="instance">
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="oldStr" type="String" usage="required"/>
          <parameter name="newStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="start" type="Number" usage="required"/>
          <parameter name="len" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="insert" scope="instance">
        <parameters>
          <parameter name="index" type="Number" usage="required"/>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="length" scope="instance" type="Number">
        <description>The current length of the internal string.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.string.sprintf"/>
  <class type="dojox.string.sprintf.Formatter">
    <methods>
      <method name="format" scope="instance">
        <parameters>
          <parameter name="filler" type="mixed" usage="one-or-more"/>
        </parameters>
      </method>
      <method name="formatInt" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="formatDouble" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="zeroPad" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
          <parameter name="length" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="fitField" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="spacePad" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
          <parameter name="length" type="Int" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_re" scope="instance" type="RegExp"/>
      <property name="_zeros10" scope="instance" type="String"/>
      <property name="_spaces10" scope="instance" type="String"/>
      <property name="_mapped" scope="instance" type="bool"/>
      <property name="_format" scope="instance" type="Object"/>
      <property name="_tokens" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._parseDelim">
    <methods/>
    <properties>
      <property name="_mapped" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers"/>
  <class type="dojox.string.sprintf.Formatter._specifiers.b">
    <properties>
      <property name="base" scope="instance" type="Number"/>
      <property name="isInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.o">
    <properties>
      <property name="base" scope="instance" type="Number"/>
      <property name="isInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.x">
    <properties>
      <property name="base" scope="instance" type="Number"/>
      <property name="isInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.X">
    <properties>
      <property name="extend" scope="instance" type="Array"/>
      <property name="toUpper" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.d">
    <properties>
      <property name="base" scope="instance" type="Number"/>
      <property name="isInt" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.i">
    <properties>
      <property name="extend" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.u">
    <properties>
      <property name="extend" scope="instance" type="Array"/>
      <property name="isUnsigned" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.c">
    <methods>
      <method name="setArg" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.s">
    <methods>
      <method name="setMaxWidth" scope="instance">
        <parameters>
          <parameter name="token" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.e">
    <properties>
      <property name="isDouble" scope="instance" type="Object"/>
      <property name="doubleNotation" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.E">
    <properties>
      <property name="extend" scope="instance" type="Array"/>
      <property name="toUpper" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.f">
    <properties>
      <property name="isDouble" scope="instance" type="Object"/>
      <property name="doubleNotation" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.F">
    <properties>
      <property name="extend" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.g">
    <properties>
      <property name="isDouble" scope="instance" type="Object"/>
      <property name="doubleNotation" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.string.sprintf.Formatter._specifiers.G">
    <properties>
      <property name="extend" scope="instance" type="Array"/>
      <property name="toUpper" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.testing"/>
  <class type="dojox.testing.DocTest">
    <description>DocTests are tests that are defined inside the comment.
	A doctest looks as if it was copied from the shell (which it mostly is).
	A doctest is executed when the following conditions match:
	1) all lines are comments
	2) the line always starts with spaces/tabs followed by "//"
	and at least one space
	3) the line(s) of the test to execute starts with "&gt;&gt;&gt;"
	preceeded by what is described in 2)
	4) the first line after 3) starting without "&gt;&gt;&gt;" is the exptected result.
	preceeded by what is described in 2)
	5) the test sequence is terminated by an empty line, or the next
	test in the following line, or a new line that does not start as described in 2)
	(simple said: is not a comment)
	preceeded by what is described in 2)
	I.e. the following is a simple doctest, that will actually also be run
	if you run this class against this file here:
	&gt;&gt;&gt; 1+1 // A simple test case. Terminated by an empty line
	2
	&gt;&gt;&gt; 1==2
	false
	&gt;&gt;&gt; "a"+"b" // Also without the empty line before, this is a new test.
	"ab"
	&gt;&gt;&gt; var anything = "anything" // Multiple commands for one test.
	&gt;&gt;&gt; "something"==anything
	false
	DocTests are great for inline documenting a class or method, they also
	are very helpful in understanding what the class/method actually does.
	They don't make sense everywhere, but sometimes they are really handy.</description>
    <methods>
      <method name="getTests" scope="instance">
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getTestsFromString" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getTestsFromString" scope="instance">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
          <parameter name="insideComments" type="Boolean" usage="required">
            <description>Boolean, if false &amp;quot;data&amp;quot; contains only the pure tests, comments already stripped.</description>
          </parameter>
        </parameters>
      </method>
      <method name="run" scope="instance">
        <examples>
          <example>doctest = new dojox.testing.DocTest();
	doctest.run("dojox.testing.DocTest");
	doctest.errors should finally be an empty array.
	// The above is not a doctest, because it just would
	//	execute itself in a never ending loop.
	&gt;&gt;&gt; true==true // Test a new line terminating the test.
	true
	&gt;&gt;&gt; true==true // Test a new test terminating the test.
	true
	&gt;&gt;&gt; true==true // Test a "not a comment"-line, especially an empty line terminating the test.
	true</example>
        </examples>
        <parameters>
          <parameter name="moduleName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_run" scope="instance">
        <parameters>
          <parameter name="tests" type="Array" usage="required">
            <description>Make sure that the types are compared properly. There used to be
	the bug that a return value false was compared to &amp;quot;false&amp;quot; which
	made the test fail. This is fixed and should be verified by the
	following tests.
	&amp;gt;&amp;gt;&amp;gt; false
	false
	&amp;gt;&amp;gt;&amp;gt; &amp;quot;false&amp;quot;
	&amp;quot;false&amp;quot;
	&amp;gt;&amp;gt;&amp;gt; true
	true
	&amp;gt;&amp;gt;&amp;gt; 1
	1
	&amp;gt;&amp;gt;&amp;gt; &amp;quot;s&amp;quot;
	&amp;quot;s&amp;quot;
	&amp;gt;&amp;gt;&amp;gt; dojo.toJson({one:1})
	&amp;quot;{&amp;quot;one&amp;quot;:1}&amp;quot;</description>
          </parameter>
        </parameters>
      </method>
      <method name="runTest" scope="instance">
        <parameters>
          <parameter name="commands" type="Object" usage="required"/>
          <parameter name="expected" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="errors" scope="instance" type="Array"/>
      <property name="tests" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing">
    <properties>
      <property name="ThreadPool" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Sequence">
    <description>This array will contain the sequence defines resolved, so that
	ie. repeat:10 will result in 10 elements in the sequence, so
	the repeat handling is easier and we don't need to handle that
	many extra cases. Also the doneFunction, if given is added at the
	end of the resolved-sequences.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="go" scope="instance">
        <parameters>
          <parameter name="defs" type="Array" usage="required">
            <description>The sequence of actions</description>
          </parameter>
          <parameter name="doneFunction" type="Function|Array" usage="optional">
            <description>The function to call when done</description>
          </parameter>
        </parameters>
      </method>
      <method name="_go" scope="instance"/>
      <method name="goOn" scope="instance"/>
      <method name="stop" scope="instance">
        <description>This can only interrupt the sequence not the last function that
	had been started. If the last function was i.e. a slideshow
	that is handled inside a function that you have given as
	one sequence item it cant be stopped, since it is not controlled
	by this object here. In this case it would be smarter to
	run the slideshow using a sequence object so you can also stop
	it using this method.</description>
      </method>
    </methods>
    <properties>
      <property name="_defsResolved" scope="instance-prototype" type="Array">
        <description>The resolved sequence, for easier handling.</description>
      </property>
      <property name="_goOnPause" scope="instance" type="Integer">
        <description>The pause to wait before really going on.</description>
      </property>
      <property name="_running" scope="instance" type="bool"/>
      <property name="_curId" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.timing.Streamer">
    <methods>
      <method name="inputFunction" scope="instance"/>
      <method name="outputFunction" scope="instance"/>
      <method name="setInterval" scope="instance">
        <parameters>
          <parameter name="ms" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="onTick" scope="instance">
        <parameters>
          <parameter name="obj" type="dojox.timing.Streamer" usage="required"/>
        </parameters>
      </method>
      <method name="start" scope="instance"/>
      <method name="onStart" scope="instance"/>
      <method name="stop" scope="instance"/>
      <method name="onStop" scope="instance"/>
    </methods>
    <properties>
      <property name="interval" scope="instance" type="the">
        <description>interval in ms at which the output function is fired.
	minimum: the minimum number of elements in the internal queue.</description>
      </property>
      <property name="minimumSize" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.timing.threadStates">
    <properties>
      <property name="UNSTARTED" scope="instance" type="String"/>
      <property name="STOPPED" scope="instance" type="String"/>
      <property name="PENDING" scope="instance" type="String"/>
      <property name="RUNNING" scope="instance" type="String"/>
      <property name="SUSPENDED" scope="instance" type="String"/>
      <property name="WAITING" scope="instance" type="String"/>
      <property name="COMPLETE" scope="instance" type="String"/>
      <property name="ERROR" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.timing.threadPriorities">
    <properties>
      <property name="LOWEST" scope="instance" type="Number"/>
      <property name="BELOWNORMAL" scope="instance" type="Number"/>
      <property name="NORMAL" scope="instance" type="Number"/>
      <property name="ABOVENORMAL" scope="instance" type="Number"/>
      <property name="HIGHEST" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.timing.Thread">
    <methods>
      <method name="invoke" scope="instance"/>
    </methods>
    <properties>
      <property name="state" scope="instance" type="Object"/>
      <property name="priority" scope="instance" type="Object"/>
      <property name="lastError" scope="instance" type="Object"/>
      <property name="func" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Timer">
    <methods>
      <method name="onTick" scope="instance"/>
    </methods>
    <properties>
      <property name="timer" scope="instance" type="Object"/>
      <property name="isRunning" scope="instance" type="bool"/>
      <property name="interval" scope="instance" type="Interval">
        <description>between function calls, in milliseconds.</description>
      </property>
      <property name="onStart" scope="instance" type="Object"/>
      <property name="onStop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Timer.setInterval">
    <methods/>
    <properties>
      <property name="interval" scope="instance" type="New">
        <description>interval, in milliseconds.</description>
      </property>
      <property name="timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Timer.start">
    <description>Calls the "onStart()" handler, if defined.
	Note that the onTick() function is not called right away,
	only after first interval passes.</description>
    <methods/>
    <properties>
      <property name="isRunning" scope="instance" type="Object"/>
      <property name="timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.timing.Timer.stop">
    <description>Calls the "onStop()" handler, if defined.</description>
    <methods/>
    <properties>
      <property name="isRunning" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.timing.doLater">
    <description>dojox.timing.doLater(conditional) is testing if the call
	should be done later. So it returns
	true if the param is false.
	arguments:</description>
  </class>
  <class type="dojox.timing.doLater.caller">
    <properties>
      <property name="arguments" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid">
    <methods>
      <method name="assert" scope="instance">
        <description>If the asserted condition is true, this method does nothing. If the
	condition is false, we throw an error with a error message.</description>
        <parameters>
          <parameter name="booleanValue" type="Boolean" usage="required">
            <description>Must be true for the assertion to succeed.</description>
          </parameter>
          <parameter name="message" type="String" usage="optional">
            <description>A string describing the assertion.
	throws: Throws an Error if 'booleanValue' is false.</description>
          </parameter>
        </parameters>
      </method>
      <method name="generateNilUuid" scope="instance">
        <description>The Nil UUID is described in section 4.1.7 of
	RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.1.7
	examples:
	var string = dojox.uuid.generateNilUuid();</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="isValid" scope="instance">
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="getVariant" scope="instance">
        <examples>
          <example>var variant = dojox.uuid.getVariant("3b12f1df-5232-4804-897e-917bf397618a");
	dojox.uuid.assert(variant == dojox.uuid.variant.DCE);</example>
          <example>"3b12f1df-5232-4804-897e-917bf397618a"
	^
	(variant "10__" == DCE)</example>
        </examples>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.uuid.variant"/>
        </return-types>
      </method>
      <method name="getVersion" scope="instance">
        <examples>
          <example>var version = dojox.uuid.getVersion("b4308fb0-86cd-11da-a72b-0800200c9a66");
	dojox.uuid.assert(version == dojox.uuid.version.TIME_BASED);</example>
        </examples>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.uuid.version"/>
        </return-types>
      </method>
      <method name="getNode" scope="instance">
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getTimestamp" scope="instance">
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
          <parameter name="returnType" type="String" usage="optional">
            <description>Any of these five values: &amp;quot;string&amp;quot;, String, &amp;quot;hex&amp;quot;, &amp;quot;date&amp;quot;, Date</description>
          </parameter>
        </parameters>
        <return-description>Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.
	examples:
	var uuidString = "b4308fb0-86cd-11da-a72b-0800200c9a66";
	var date, string, hexString;
	date   = dojox.uuid.getTimestamp(uuidString);         // returns a JavaScript Date
	date   = dojox.uuid.getTimestamp(uuidString, Date);     //
	string = dojox.uuid.getTimestamp(uuidString, String);   // "Mon, 16 Jan 2006 20:21:41 GMT"
	hexString = dojox.uuid.getTimestamp(uuidString, "hex"); // "1da86cdb4308fb0"</return-description>
        <return-types>
          <return-type type="String"/>
          <return-type type="String"/>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="generateRandomUuid" scope="instance">
        <description>A typical generated value would be something like this:
	"3b12f1df-5232-4804-897e-917bf397618a"
	For more information about random UUIDs, see sections 4.4 and
	4.5 of RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.4
	This generator function is designed to be small and fast,
	but not necessarily good.
	Small: This generator has a small footprint. Once comments are
	stripped, it's only about 25 lines of code, and it doesn't
	dojo.require() any other modules.
	Fast: This generator can generate lots of new UUIDs fairly quickly
	(at least, more quickly than the other dojo UUID generators).
	Not necessarily good: We use Math.random() as our source
	of randomness, which may or may not provide much randomness.
	examples:
	var string = dojox.uuid.generateRandomUuid();</description>
        <return-types>
          <return-type type="for example: &quot;3B12F1DF"/>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="NIL_UUID" scope="instance" type="String"/>
      <property name="_ourVariantLookupTable" scope="instance" type="Object"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.Uuid">
    <methods>
      <method name="compare" scope="instance">
        <description>This implementation is intended to match the sample implementation
	in IETF RFC 4122: http://www.ietf.org/rfc/rfc4122.txt</description>
        <parameters>
          <parameter name="uuidOne" type="dojox.uuid.Uuid" usage="required">
            <description>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</description>
          </parameter>
          <parameter name="uuidTwo" type="dojox.uuid.Uuid" usage="required">
            <description>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</description>
          </parameter>
          <parameter name="otherUuid" type="dojox.uuid.Uuid" usage="required">
            <description>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="integer"/>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="setGenerator" scope="instance">
        <parameters>
          <parameter name="generator" type="Function" usage="optional">
            <description>A UUID generator function, such as dojox.uuid.generateTimeBasedUuid.</description>
          </parameter>
        </parameters>
      </method>
      <method name="getGenerator" scope="instance">
        <return-types>
          <return-type type="generator (A UUID generator, such as dojox.uuid.TimeBasedGenerator)"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="isEqual" scope="instance">
        <parameters>
          <parameter name="otherUuid" type="dojox.uuid.Uuid" usage="required">
            <description>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isValid" scope="instance"/>
      <method name="getVariant" scope="instance">
        <examples>
          <example>var uuid = new dojox.uuid.Uuid("3b12f1df-5232-4804-897e-917bf397618a");
	var variant = uuid.getVariant();
	dojox.uuid.assert(variant == dojox.uuid.variant.DCE);</example>
          <example>"3b12f1df-5232-4804-897e-917bf397618a"
	^
	(variant "10__" == DCE)</example>
        </examples>
      </method>
    </methods>
    <properties>
      <property name="_uuidString" scope="instance" type="Object"/>
      <property name="_ourGenerator" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.Uuid.getVersion">
    <methods/>
    <properties>
      <property name="_versionNumber" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.Uuid.getNode">
    <methods/>
    <properties>
      <property name="_nodeString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.Uuid.getTimestamp">
    <methods/>
    <properties>
      <property name="_timestampAsHexString" scope="instance" type="Object"/>
      <property name="_timestampAsDate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.version">
    <properties>
      <property name="UNKNOWN" scope="instance" type="Number"/>
      <property name="TIME_BASED" scope="instance" type="Number"/>
      <property name="DCE_SECURITY" scope="instance" type="Number"/>
      <property name="NAME_BASED_MD5" scope="instance" type="Number"/>
      <property name="RANDOM" scope="instance" type="Number"/>
      <property name="NAME_BASED_SHA1" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.uuid.variant">
    <properties>
      <property name="NCS" scope="instance" type="String"/>
      <property name="DCE" scope="instance" type="String"/>
      <property name="MICROSOFT" scope="instance" type="String"/>
      <property name="UNKNOWN" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.uuid.generateTimeBasedUuid">
    <description>For more info, see
	http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt
	http://www.infonuovo.com/dma/csdocs/sketch/instidid.htm
	http://kruithof.xs4all.nl/uuid/uuidgen
	http://www.opengroup.org/onlinepubs/009629399/apdxa.htm#tagcjh_20
	http://jakarta.apache.org/commons/sandbox/id/apidocs/org/apache/commons/id/uuid/clock/Clock.html</description>
    <methods>
      <method name="isValidNode" scope="instance">
        <parameters>
          <parameter name="node" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getNode" scope="instance">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_generator" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.uuid.generateTimeBasedUuid.setNode">
    <methods/>
    <properties>
      <property name="_uniformNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.validate.br">
    <methods>
      <method name="isValidCnpj" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The CNPJ/CGC number in ##.###.###/####-##, ########/####-##,
	############-## or ############## format</description>
          </parameter>
        </parameters>
      </method>
      <method name="computeCnpjDv" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The CGC number in ##.###.###/#### or ############ format</description>
          </parameter>
        </parameters>
      </method>
      <method name="isValidCpf" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The CPF number in #########-## or ###########,
	format</description>
          </parameter>
        </parameters>
      </method>
      <method name="computeCpfDv" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The CPF number in ######### format</description>
          </parameter>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.validate.ca">
    <methods>
      <method name="isPhoneNumber" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isProvince" scope="instance">
        <parameters>
          <parameter name="value" type="String[2]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isSocialInsuranceNumber" scope="instance">
        <description>Validates Canadian 9 digit social insurance number for several
	common formats. This routine only pattern matches and does not
	use the Luhn Algorithm to validate number.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isPostalCode" scope="instance">
        <description>Validates Canadian 6 digit postal code.
	Canadian postal codes are in the format ANA NAN,
	where A is a letter and N is a digit, with a space
	separating the third and fourth characters.</description>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.validate._cardInfo">
    <description>A hash of valid CC abbreviations and regular expressions</description>
    <properties>
      <property name="mc" scope="instance" type="Mastercard"/>
      <property name="ec" scope="instance" type="Eurocard"/>
      <property name="vi" scope="instance" type="Visa"/>
      <property name="ax" scope="instance" type="American">
        <description>Express</description>
      </property>
      <property name="dc" scope="instance" type="Diners">
        <description>Club</description>
      </property>
      <property name="bl" scope="instance" type="Carte">
        <description>Blanch</description>
      </property>
      <property name="di" scope="instance" type="Discover"/>
      <property name="jcb" scope="instance" type="JCB"/>
      <property name="er" scope="instance" type="Enroute"/>
    </properties>
  </class>
  <class type="dojox.validate.regexp">
    <methods>
      <method name="ipAddress" scope="instance">
        <description>Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
	Supports 2 formats for Ipv6.
	flags  An object.  All flags are boolean with default = true.
	flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
	flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
	flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
	flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
	flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
	Case insensitive.  Zero padding allowed.
	flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
	FIXME: ipv6 can be written multiple ways IIRC
	flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
	followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="host" scope="instance">
        <description>A host is a named host (A-z0-9_- but not starting with -), a domain name or an IP address, possibly followed by a port number.</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object.
	flags.allowNamed Allow a named host for local networks. Default is false.
	flags.allowIP  Allow an IP address for hostname.  Default is true.
	flags.allowLocal  Allow the host to be &amp;quot;localhost&amp;quot;.  Default is false.
	flags.allowPort  Allow a port number to be present.  Default is true.
	flags in regexp.ipAddress can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="url" scope="instance">
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.scheme  Can be true, false, or [true, false].
	This means: required, not allowed, or match either one.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="&quot;; } return &quot;&quot;; }"/>
        </return-types>
      </method>
      <method name="emailAddress" scope="instance">
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.allowCruft  Allow address like &amp;lt;mailto:foo@yahoo.com&amp;gt;.  Default is false.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="numberFormat" scope="instance">
        <description>Use this method for phone numbers, social security numbers, zip-codes, etc.
	The RE can match one format or one of multiple formats.
	Format
	#        Stands for a digit, 0-9.
	?        Stands for an optional digit, 0-9 or nothing.
	All other characters must appear literally in the expression.
	Example
	"(###) ###-####"       -&gt;   (510) 542-9742
	"(###) ###-#### x#???" -&gt;   (510) 542-9742 x153
	"###-##-####"          -&gt;   506-82-1089       i.e. social security number
	"#####-####"           -&gt;   98225-1649        i.e. zip code</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.format  A string or an Array of strings for multiple formats.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="emailAddressList" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.validate.regexp.ca">
    <methods>
      <method name="postalCode" scope="instance"/>
      <method name="province" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.validate.regexp.us">
    <methods>
      <method name="state" scope="instance">
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.validate.us">
    <methods>
      <method name="isState" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>A two character string</description>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <description>An object
	flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
	flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isPhoneNumber" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required">
            <description>The telephone number string</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isSocialSecurityNumber" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isZipCode" scope="instance">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.widget.gauge"/>
  <class type="dojox.widget.gauge.AnalogLineIndicator" superclass="dojox.widget.gauge._Indicator">
    <methods>
      <method name="_getShapes" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <description>Indicates if the drawing should not be animated (vs. the default of doing an animation)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_move" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <description>Indicates if the drawing should not be animated (vs. the default of doing an animation)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge._Indicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="text" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="String"/>
      <property name="length" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Number"/>
      <property name="offset" scope="instance" type="Number"/>
      <property name="highlight" scope="instance" type="String"/>
      <property name="shapes" scope="instance" type="Object"/>
      <property name="currentValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget">
    <description>These are standalone widgets with varying levels of stability. Some are useful,
	some were created for demonstration purposes, and learning tools. The each maintain
	their own .css file (typically dojox/widget/WidgetName/WidgetName.css)</description>
    <properties>
      <property name="CalendarFx" scope="instance" type="Object"/>
      <property name="CalendarViews" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.AnalogGauge" superclass="dojox.widget.gauge._Gauge">
    <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a gauge component, used to display numerical data in a familiar format
	usage:
	&lt;script type="text/javascript"&gt;
	dojo.require("dojox.widget.AnalogGauge");
	dojo.require("dijit.util.parser");
	&lt;/script&gt;
	...
	&lt;div	dojoType="dojox.widget.AnalogGauge"
	id="testGauge"
	width="300"
	height="200"
	cx=150
	cy=175
	radius=125
	image="gaugeOverlay.png"
	imageOverlay="false"
	imageWidth="280"
	imageHeight="155"
	imageX="12"
	imageY="38"&gt;
	&lt;/div&gt;</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_getAngle" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>A value to be converted to an angle for this gauage.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueForAngle" scope="instance">
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>A angle to be converted to a value for this gauge.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getRadians" scope="instance">
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <description>An angle, in degrees, to be converted to radians.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getDegrees" scope="instance">
        <parameters>
          <parameter name="radians" type="Number" usage="required">
            <description>An angle, in radians, to be converted to degrees.</description>
          </parameter>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <description>Draws the gauge by drawing the surface, the ranges, and the indicators.</description>
      </method>
      <method name="drawRange" scope="instance">
        <description>Draws a range (colored area on the background of the gauge)
	based on the given arguments.</description>
        <parameters>
          <parameter name="range" type="Object" usage="required">
            <description>A range is a dojox.widget.gauge.Range or an object
	with similar parameters (low, high, hover, etc.).</description>
          </parameter>
        </parameters>
      </method>
      <method name="getRangeUnderMouse" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <description>The event object as received by the mouse handling functions below.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_dragIndicator" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge._Gauge" scope="instance"/>
    </mixins>
    <properties>
      <property name="startAngle" scope="instance" type="Number">
        <description>angle (in degrees) for start of gauge (default is -90)</description>
      </property>
      <property name="endAngle" scope="instance" type="Number">
        <description>angle (in degrees) for end of gauge (default is 90)</description>
      </property>
      <property name="cx" scope="instance" type="Number">
        <description>center of gauge x coordinate (default is gauge width / 2)</description>
      </property>
      <property name="cy" scope="instance" type="Number">
        <description>center of gauge x coordinate (default is gauge height / 2)</description>
      </property>
      <property name="radius" scope="instance" type="Number">
        <description>radius of gauge (default is smaller of cx-25 or cy-25)</description>
      </property>
      <property name="_defaultIndicator" scope="instance" type="override">
        <description>of dojox.widget._Gauge._defaultIndicator</description>
      </property>
      <property name="_oppositeMiddle" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.widget.AutoRotator" superclass="dojox.widget.Rotator">
    <description>Adds automatic rotating to the dojox.widget.Rotator.  The
	AutoRotator has parameters that control how user input can
	affect the rotator including a suspend when hovering over the
	rotator and pausing when the user manually advances to another
	pane.</description>
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="destroy" scope="instance"/>
      <method name="play" scope="instance">
        <parameters>
          <parameter name="skipCycleDecrement" type="boolean" usage="optional"/>
          <parameter name="skipDuration" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="pause" scope="instance"/>
      <method name="_now" scope="instance"/>
      <method name="_resetTimer" scope="instance"/>
      <method name="_cycle" scope="instance">
        <parameters>
          <parameter name="manual" type="boolean|int" usage="optional"/>
        </parameters>
      </method>
      <method name="onManualChange" scope="instance">
        <parameters>
          <parameter name="action" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.Rotator" scope="instance"/>
    </mixins>
    <properties>
      <property name="suspendOnHover" scope="instance" type="boolean">
        <description>Pause the rotator when the mouse hovers over it.</description>
      </property>
      <property name="duration" scope="instance" type="int">
        <description>The time in milliseconds before transitioning to the next pane.  The
	default value is 4000 (4 seconds).</description>
      </property>
      <property name="autoStart" scope="instance" type="boolean">
        <description>Starts the timer to transition children upon creation.</description>
      </property>
      <property name="pauseOnManualChange" scope="instance" type="boolean">
        <description>Pause the rotator when the pane is changed or a controller's next or
	previous buttons are clicked.</description>
      </property>
      <property name="cycles" scope="instance" type="int">
        <description>Number of cycles before pausing.</description>
      </property>
      <property name="random" scope="instance" type="boolean">
        <description>Determines if the panes should cycle randomly.</description>
      </property>
      <property name="reverse" scope="instance" type="boolean">
        <description>Causes the rotator to rotate in reverse order.</description>
      </property>
      <property name="playing" scope="instance" type="bool"/>
      <property name="_resumeDuration" scope="instance" type="Number"/>
      <property name="_endTime" scope="instance" type="String"/>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="_suspended" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.BarLineIndicator" superclass="dojox.widget.gauge._Indicator">
    <methods>
      <method name="_getShapes" scope="instance"/>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <description>Indicates if the drawing should not be animated (vs. the default of doing an animation)</description>
          </parameter>
        </parameters>
      </method>
      <method name="_move" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <description>Indicates if the drawing should not be animated (vs. the default of doing an animation)</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge._Indicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="Number"/>
      <property name="shapes" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="String"/>
      <property name="length" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Number"/>
      <property name="highlight" scope="instance" type="String"/>
      <property name="highlight2" scope="instance" type="String"/>
      <property name="currentValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.BarLineIndicator._gauge">
    <properties>
      <property name="max" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.BarGauge" superclass="dojox.widget.gauge._Gauge">
    <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a bar graph component, used to display numerical data in a familiar format.
	usage:
	&lt;script type="text/javascript"&gt;
	dojo.require("dojox.widget.BarGauge");
	dojo.require("dijit.util.parser");
	&lt;/script&gt;
	...
	&lt;div 	dojoType="dojox.widget.BarGauge"
	id="testBarGauge"
	barGaugeHeight="55"
	dataY="25"
	dataHeight="25"
	dataWidth="225"&gt;
	&lt;/div&gt;</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_getPosition" scope="instance">
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <description>A value to be converted to a position for this bar graph.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueForPosition" scope="instance">
        <parameters>
          <parameter name="pos" type="Number" usage="required">
            <description>A position to be converted to a value.</description>
          </parameter>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <description>Draws the bar graph by drawing the surface, the ranges, and the indicators.</description>
      </method>
      <method name="drawRange" scope="instance">
        <description>Draws a range (colored area on the background of the gauge)
	based on the given arguments.</description>
        <parameters>
          <parameter name="range" type="Object" usage="required">
            <description>A range is either a dojox.widget.gauge.Range or an object
	with similar parameters (low, high, hover, etc.).</description>
          </parameter>
        </parameters>
      </method>
      <method name="getRangeUnderMouse" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <description>The event object as received by the mouse handling functions below.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_dragIndicator" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge._Gauge" scope="instance"/>
    </mixins>
    <properties>
      <property name="dataX" scope="instance" type="Number">
        <description>x position of data area (default 5)</description>
      </property>
      <property name="dataY" scope="instance" type="Number">
        <description>y position of data area (default 5)</description>
      </property>
      <property name="dataWidth" scope="instance" type="Number">
        <description>width of data area (default is bar graph width - 10)</description>
      </property>
      <property name="dataHeight" scope="instance" type="Number">
        <description>height of data area (default is bar graph width - 10)</description>
      </property>
      <property name="_defaultIndicator" scope="instance" type="override">
        <description>of dojox.widget._Gauge._defaultIndicator</description>
      </property>
    </properties>
  </class>
  <class type="dojox.widget._CalendarBase" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postMixInProperties" scope="instance"/>
      <method name="parseInitialValue" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_makeDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="addFx" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="fromNode" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_isInvalidDate" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="onValueSelected" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_onDateSelected" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
          <parameter name="formattedValue" type="Object" usage="required"/>
          <parameter name="force" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="goToToday" scope="instance"/>
      <method name="_transitionVert" scope="instance">
        <parameters>
          <parameter name="direction" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_updateTitleStyle" scope="instance"/>
      <method name="_slideTable" scope="instance">
        <parameters>
          <parameter name="widget" type="String" usage="required"/>
          <parameter name="direction" type="Number" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_addView" scope="instance">
        <parameters>
          <parameter name="view" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getClassForDate" scope="instance">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_adjustDisplay" scope="instance">
        <parameters>
          <parameter name="part" type="String" usage="required"/>
          <parameter name="amount" type="int" usage="required"/>
          <parameter name="noSlide" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>The template to be used to construct the widget.</description>
      </property>
      <property name="_views" scope="instance-prototype" type="Array">
        <description>The list of mixin views available on this calendar.</description>
      </property>
      <property name="useFx" scope="instance" type="Boolean">
        <description>Specifies if visual effects should be applied to the widget.
	The default behavior of the widget does not contain any effects.
	The dojox.widget.CalendarFx package is needed for these.</description>
      </property>
      <property name="widgetsInTemplate" scope="instance" type="Boolean">
        <description>This widget is a container of other widgets, so this is true.</description>
      </property>
      <property name="value" scope="instance-prototype" type="Date">
        <description>The currently selected Date</description>
      </property>
      <property name="footerFormat" scope="instance" type="String">
        <description>The date format of the date displayed in the footer.	Can be
	'short', 'medium', and 'long'</description>
      </property>
      <property name="displayMonth" scope="instance" type="Object"/>
      <property name="_currentChild" scope="instance" type="Number"/>
      <property name="_internalValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarBase.constraints">
    <properties>
      <property name="min" scope="instance" type="Object"/>
      <property name="max" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarBase.footer">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarBase._children">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarView" superclass="dijit._Widget">
    <methods>
      <method name="cloneClass" scope="instance">
        <parameters>
          <parameter name="clazz" type="Object" usage="required"/>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="before" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="instance">
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getHeader" scope="instance"/>
      <method name="onValueSelected" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjustDate" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDisplay" scope="instance"/>
      <method name="onBeforeDisplay" scope="instance"/>
      <method name="onBeforeUnDisplay" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="headerClass" scope="instance" type="String"/>
      <property name="useHeader" scope="instance" type="Object"/>
      <property name="header" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarDay">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <properties>
      <property name="parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarDayView" superclass="dojox.widget._CalendarView">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onDisplay" scope="instance"/>
      <method name="_onDayClick" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateDays" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarView" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>The template to be used to construct the widget.</description>
      </property>
      <property name="datePart" scope="instance" type="String">
        <description>Specifies how much to increment the displayed date when the user
	clicks the array button to increment of decrement the view.</description>
      </property>
      <property name="dayWidth" scope="instance" type="String">
        <description>Specifies the type of day name to display.	&amp;quot;narrow&amp;quot; causes just one letter to be shown.</description>
      </property>
      <property name="_addedFx" scope="instance" type="Object"/>
      <property name="_lastDate" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarMonthYear">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget._CalendarMonthYearView" superclass="dojox.widget._CalendarView">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getHeader" scope="instance"/>
      <method name="_getMonthNames" scope="instance">
        <parameters>
          <parameter name="format" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_populateMonths" scope="instance"/>
      <method name="_populateYears" scope="instance">
        <parameters>
          <parameter name="year" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSelectedYear" scope="instance"/>
      <method name="_updateSelectedMonth" scope="instance"/>
      <method name="_updateSelectedNode" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="filter" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onOk" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarView" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>The template to be used to construct the widget.</description>
      </property>
      <property name="datePart" scope="instance" type="String">
        <description>Specifies how much to increment the displayed date when the user
	clicks the array button to increment of decrement the view.</description>
      </property>
      <property name="displayedYears" scope="instance" type="Number">
        <description>The number of years to display at once.</description>
      </property>
      <property name="useHeader" scope="instance" type="bool"/>
      <property name="monthContainer" scope="instance" type="Object"/>
      <property name="yearContainer" scope="instance" type="Object"/>
      <property name="_decBtn" scope="instance" type="Object"/>
      <property name="_incBtn" scope="instance" type="Object"/>
      <property name="_cachedDate" scope="instance" type="Object"/>
      <property name="_monthNames" scope="instance" type="Object"/>
      <property name="_displayedYear" scope="instance" type="Object"/>
      <property name="_year" scope="instance" type="Object"/>
      <property name="_month" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Calendar2Pane" superclass="dojox.widget._CalendarBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarDay.prototype" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.Calendar" superclass="dojox.widget._CalendarBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarDay.prototype" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.DailyCalendar" superclass="dojox.widget._CalendarBase">
    <methods>
      <method name="_makeDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarDay.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.MonthAndYearlyCalendar" superclass="dojox.widget._CalendarBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarMonthYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonthYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget._FisheyeFX">
    <methods>
      <method name="addFx" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="fromNode" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.widget.CalendarFisheye" superclass="dojox.widget.Calendar">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._FisheyeFX.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget.Calendar" scope="instance"/>
      <mixin type="dojox.widget._FisheyeFX" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget._CalendarMonth">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget._CalendarMonthView" superclass="dojox.widget._CalendarView">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarView" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>The template to be used to construct the widget.</description>
      </property>
      <property name="datePart" scope="instance" type="String">
        <description>Specifies how much to increment the displayed date when the user
	clicks the array button to increment of decrement the view.</description>
      </property>
      <property name="headerClass" scope="instance" type="String">
        <description>Specifies the CSS class to apply to the header node for this view.</description>
      </property>
      <property name="_getMonthNames" scope="instance" type="Object"/>
      <property name="_populateMonths" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarMonthView.header">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarYear">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <properties>
      <property name="parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._CalendarYearView" superclass="dojox.widget._CalendarView">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="adjustDate" scope="instance">
        <parameters>
          <parameter name="date" type="Object" usage="required"/>
          <parameter name="amount" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarView" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>The template to be used to construct the widget.</description>
      </property>
      <property name="displayedYears" scope="instance" type="Number"/>
      <property name="_populateYears" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Calendar3Pane" superclass="dojox.widget._CalendarBase">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarDay.prototype" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonth.prototype" scope="instance"/>
      <mixin type="dojox.widget._CalendarYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarDay" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonth" scope="instance"/>
      <mixin type="dojox.widget._CalendarYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.MonthlyCalendar" superclass="dojox.widget._CalendarBase">
    <methods>
      <method name="_makeDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarMonth.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarMonth" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.YearlyCalendar" superclass="dojox.widget._CalendarBase">
    <methods>
      <method name="_makeDate" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarYear.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.widget._CalendarBase" scope="instance"/>
      <mixin type="dojox.widget._CalendarYear" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.ColorPicker" superclass="dijit.form._FormWidget">
    <description>Provides an interactive HSV ColorPicker similar to
	PhotoShop's color selction tool. This is an enhanced
	version of the default dijit.ColorPalette, though provides
	no accessibility.</description>
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setColor" scope="instance">
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="force" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setTimer" scope="instance">
        <parameters>
          <parameter name="mover" type="d.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="_clearTimer" scope="instance">
        <parameters>
          <parameter name="mover" type="d.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="_setHue" scope="instance">
        <parameters>
          <parameter name="h" type="Decimal" usage="required">
            <description>0..360</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateHueCursorNode" scope="instance">
        <parameters>
          <parameter name="count" type="Number" usage="required">
            <description>means stop, anything else is just how many times it was called.</description>
          </parameter>
          <parameter name="node" type="The" usage="required">
            <description>node generating the event.</description>
          </parameter>
          <parameter name="e" type="The" usage="required">
            <description>event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateCursorNode" scope="instance">
        <parameters>
          <parameter name="count" type="Number" usage="required">
            <description>means stop, anything else is just how many times it was called.</description>
          </parameter>
          <parameter name="node" type="The" usage="required">
            <description>node generating the event.</description>
          </parameter>
          <parameter name="e" type="The" usage="required">
            <description>event.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_updateColor" scope="instance"/>
      <method name="_colorInputChange" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateValue" scope="instance">
        <parameters>
          <parameter name="col" type="dojox.color.Color" usage="required"/>
          <parameter name="fireChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_updatePickerLocations" scope="instance">
        <parameters>
          <parameter name="col" type="dojox.color.Color" usage="required"/>
        </parameters>
      </method>
      <method name="_updateColorInputs" scope="instance">
        <parameters>
          <parameter name="col" type="dojox.color.Color" usage="required"/>
        </parameters>
      </method>
      <method name="_setHuePoint" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setPoint" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance"/>
      <method name="_stopDrag" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.form._FormWidget" scope="instance"/>
    </mixins>
    <properties>
      <property name="showRgb" scope="instance" type="Boolean">
        <description>show/update RGB input nodes</description>
      </property>
      <property name="showHsv" scope="instance" type="Boolean">
        <description>show/update HSV input nodes</description>
      </property>
      <property name="showHex" scope="instance" type="Boolean">
        <description>show/update Hex value field</description>
      </property>
      <property name="webSafe" scope="instance" type="Boolean">
        <description>deprecated? or just use a toggle to show/hide that node, too?</description>
      </property>
      <property name="animatePoint" scope="instance" type="Boolean">
        <description>toggle to use slideTo (true) or just place the cursor (false) on click</description>
      </property>
      <property name="slideDuration" scope="instance" type="Integer">
        <description>time in ms picker node will slide to next location (non-dragging) when animatePoint=true</description>
      </property>
      <property name="liveUpdate" scope="instance" type="Boolean">
        <description>Set to true to fire onChange in an indeterminate way</description>
      </property>
      <property name="PICKER_HUE_H" scope="instance" type="int">
        <description>Height of the hue picker, used to calculate positions</description>
      </property>
      <property name="PICKER_SAT_VAL_H" scope="instance" type="int">
        <description>Height of the 2d picker, used to calculate positions</description>
      </property>
      <property name="PICKER_SAT_VAL_W" scope="instance" type="int">
        <description>Width of the 2d picker, used to calculate positions</description>
      </property>
      <property name="PICKER_HUE_SELECTOR_H" scope="instance" type="int">
        <description>Height of the hue selector DOM node, used to calc offsets so that selection
	is center of the image node.</description>
      </property>
      <property name="PICKER_SAT_SELECTOR_H" scope="instance" type="int">
        <description>Height of the saturation selector DOM node, used to calc offsets so that selection
	is center of the image node.</description>
      </property>
      <property name="PICKER_SAT_SELECTOR_W" scope="instance" type="int">
        <description>Width of the saturation selector DOM node, used to calc offsets so that selection
	is center of the image node.</description>
      </property>
      <property name="value" scope="instance" type="String">
        <description>Default color for this component. Only hex values are accepted as incoming/returned
	values. Adjust this value with &lt;code&gt;.attr&lt;/code&gt;, eg: dijit.byId(&amp;quot;myPicker&amp;quot;).attr(&amp;quot;value&amp;quot;, &amp;quot;#ededed&amp;quot;);
	to cause the points to adjust and the values to reflect the current color.</description>
      </property>
      <property name="_underlay" scope="instance" type="Object"/>
      <property name="_hueUnderlay" scope="instance" type="Object"/>
      <property name="_pickerPointer" scope="instance" type="Object"/>
      <property name="_huePickerPointer" scope="instance" type="Object"/>
      <property name="_huePickerPointerAlly" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_uId" scope="instance" type="Object"/>
      <property name="_started" scope="instance" type="Object"/>
      <property name="_mover" scope="instance" type="Object"/>
      <property name="_hueMover" scope="instance" type="Object"/>
      <property name="_subs" scope="instance" type="Array"/>
      <property name="_keyListeners" scope="instance" type="Array"/>
      <property name="_timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.colorUnderlay.style">
    <properties>
      <property name="filter" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.colorUnderlay">
    <properties>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.rgbNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.hsvNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.hexNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.safePreviewNode.style">
    <properties>
      <property name="visibility" scope="instance" type="String"/>
      <property name="backgroundColor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.valueNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Rval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Gval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Bval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Hval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Sval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.Vval">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.hexCode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.ColorPicker.previewNode.style">
    <properties>
      <property name="backgroundColor" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <description>The node to attach the data presentation to.
	kwArgs:	Object (see above)</description>
          </parameter>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setURL" scope="instance">
        <parameters>
          <parameter name="url" type="String" usage="optional"/>
          <parameter name="urlContent" type="Object" usage="optional"/>
          <parameter name="refreshInterval" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="setData" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="optional"/>
          <parameter name="refreshInterval" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance"/>
      <method name="cancelRefresh" scope="instance"/>
      <method name="setStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="optional"/>
          <parameter name="query" type="String" usage="optional"/>
          <parameter name="queryOptions" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setPreparedStore" scope="instance">
        <parameters>
          <parameter name="store" type="Object" usage="optional"/>
          <parameter name="query" type="String" usage="optional"/>
          <parameter name="queryOptions" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="renderChartWidget" scope="instance"/>
      <method name="renderGridWidget" scope="instance"/>
      <method name="getChartWidget" scope="instance"/>
      <method name="getGridWidget" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <properties>
      <property name="type" scope="instance" type="String">
        <description>the type of presentation to be applied at the DOM attach point.
	This can be 'chart', 'legend', 'grid', 'title', 'footer'. The
	default type is 'chart'.</description>
      </property>
      <property name="chartType" scope="instance" type="String">
        <description>the type of chart to display. This can be 'clusteredbars',
	'areas', 'stackedcolumns', 'stackedbars', 'stackedareas',
	'lines', 'hybrid'. The default type is 'bar'.</description>
      </property>
      <property name="reverse" scope="instance" type="Boolean">
        <description>true if the chart independant axis should be reversed.</description>
      </property>
      <property name="animate" scope="instance" type="Object">
        <description>if an object is supplied, then the chart bars or columns will animate
	into place. If the object contains a field 'duration' then the value
	supplied is the duration of the animation in milliseconds, otherwise
	a default duration is used. A boolean value true can alternatively be
	supplied to enable animation with the default duration.
	The default is null (no animation).</description>
      </property>
      <property name="labelMod" scope="instance" type="Integer">
        <description>the frequency of label annotations to be included on the
	independent axis. 1=every label. 0=no labels. The default is 1.
	tooltip: String | Function
	a string pattern defining the tooltip text to be applied to chart
	data points, or a function which takes a single parameter and returns
	the tooltip text to be applied to chart data points. The string pattern
	will have the following substitutions applied:
	{0} - the type of chart element ('bar', 'surface', etc)
	{1} - the name of the data series
	{2} - the independent axis value at the tooltip data point
	{3} - the series value at the tooltip data point point
	The function, if supplied, will receive a single parameter exactly
	as per the dojox.charting.action2D.Tooltip class. The default value
	is to apply the default tooltip as defined by the
	dojox.charting.action2D.Tooltip class.</description>
      </property>
      <property name="legendHorizontal" scope="instance-prototype" type="Boolean">
        <description>| Number
	true if the legend should be rendered horizontally, or a number if
	the legend should be rendered as horizontal rows with that number of
	items in each row, or false if the legend should be rendered
	vertically (same as specifying 1). The default is true (legend
	rendered horizontally).
	theme: String|Theme
	a theme to use for the chart, or the name of a theme.
	chartNode: String|DomNode
	an optional DOM node or the id of a DOM node to receive a
	chart presentation of the data. Supply only when a chart is
	required and the type is not 'chart'; when the type is
	'chart' this property will be set to the widget attach point.
	legendNode: String|DomNode
	an optional DOM node or the id of a DOM node to receive a
	chart legend for the data. Supply only when a legend is
	required and the type is not 'legend'; when the type is
	'legend' this property will be set to the widget attach point.
	gridNode: String|DomNode
	an optional DOM node or the id of a DOM node to receive a
	grid presentation of the data. Supply only when a grid is
	required and the type is not 'grid'; when the type is
	'grid' this property will be set to the widget attach point.
	titleNode: String|DomNode
	an optional DOM node or the id of a DOM node to receive a
	title for the data. Supply only when a title is
	required and the type is not 'title'; when the type is
	'title' this property will be set to the widget attach point.
	footerNode: String|DomNode
	an optional DOM node or the id of a DOM node to receive a
	footer presentation of the data. Supply only when a footer is
	required and the type is not 'footer'; when the type is
	'footer' this property will be set to the widget attach point.
	chartWidget: Object
	the chart widget, if any
	legendWidget: Object
	the legend widget, if any
	gridWidget: Object
	the grid widget, if any</description>
      </property>
      <property name="url" scope="instance" type="Object"/>
      <property name="urlContent" scope="instance" type="Object"/>
      <property name="refreshInterval" scope="instance" type="Object"/>
      <property name="refreshIntervalPending" scope="instance" type="Object"/>
      <property name="data" scope="instance" type="Object"/>
      <property name="preparedstore" scope="instance" type="Object"/>
      <property name="query" scope="instance" type="Object"/>
      <property name="queryOptions" scope="instance" type="Object"/>
      <property name="chartWidget" scope="instance" type="Object"/>
      <property name="legendWidget" scope="instance" type="Object"/>
      <property name="gridWidget" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation.chartNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation.legendNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation.gridNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation.titleNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.DataPresentation.footerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Dialog" superclass="dojox.widget.DialogSimple">
    <description>An HTML-capable Dialog widget with advanced sizing
	options, animated show/hide and other useful options.
	This Dialog is also very easy to apply custom styles to.
	It works identically to a `dijit.Dialog` with several
	additional parameters.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setup" scope="instance"/>
      <method name="layout" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setSize" scope="instance"/>
      <method name="show" scope="instance"/>
      <method name="_handleNav" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_position" scope="instance">
        <return-types>
          <return-type type="prevent content: from firing this anim #8914"/>
        </return-types>
      </method>
      <method name="_showContent" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.DialogSimple" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="sizeToViewport" scope="instance" type="Boolean">
        <description>If true, fix the size of the dialog to the Viewport based on
	viewportPadding value rather than the calculated or natural
	stlye. If false, base the size on a passed dimension attribute.
	Eitherway, the viewportPadding value is used if the the content
	extends beyond the viewport size for whatever reason.</description>
      </property>
      <property name="viewportPadding" scope="instance" type="Integer">
        <description>If sizeToViewport=&amp;quot;true&amp;quot;, this is the amount of padding in pixels to leave
	between the dialog border and the viewport edge.
	This value is also used when sizeToViewport=&amp;quot;false&amp;quot; and dimensions exceeded
	by dialog content to ensure dialog does not go outside viewport boundary</description>
      </property>
      <property name="dimensions" scope="instance-prototype" type="Array">
        <description>A two-element array of [widht,height] to animate the Dialog to if sizeToViewport=&amp;quot;false&amp;quot;
	Defaults to [300,300]</description>
      </property>
      <property name="easing" scope="instance-prototype" type="Function|String">
        <description>An easing function to apply to the sizing animation.</description>
      </property>
      <property name="sizeDuration" scope="instance" type="Integer">
        <description>Time (in ms) to use in the Animation for sizing.</description>
      </property>
      <property name="sizeMethod" scope="instance" type="String">
        <description>To be passed to dojox.fx.sizeTo, one of &amp;quot;chain&amp;quot; or &amp;quot;combine&amp;quot; to effect
	the animation sequence.</description>
      </property>
      <property name="showTitle" scope="instance" type="Boolean">
        <description>Toogle to show or hide the Title area. Can only be set at startup.</description>
      </property>
      <property name="draggable" scope="instance" type="Boolean">
        <description>Make the pane draggable. Differs from dijit.Dialog by setting default to false
	simply over-ride the default from dijit.Dialog</description>
      </property>
      <property name="modal" scope="instance" type="Boolean">
        <description>If true, this Dialog instance will be truly modal and prevent closing until
	explicitly told to by calling hide() - Defaults to false to preserve previous
	behaviors.</description>
      </property>
      <property name="_navIn" scope="instance" type="Object"/>
      <property name="_navOut" scope="instance" type="Object"/>
      <property name="_vp" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="_sizing" scope="instance" type="Object"/>
      <property name="_sizingConnect" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Dialog._displaysize">
    <properties>
      <property name="w" scope="instance" type="Object"/>
      <property name="h" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DialogSimple" superclass="dojox.layout.ContentPane">
    <methods/>
    <mixins scope="instance">
      <mixin type="dijit._DialogBase.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._DialogBase" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.DocTester" superclass="dijit._Widget">
    <methods>
      <method name="_fillContent" scope="instance">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="runTests" scope="instance"/>
      <method name="reset" scope="instance"/>
      <method name="_unescapeHtml" scope="instance">
        <parameters>
          <parameter name="str" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="doctests" scope="instance" type="Object"/>
      <property name="tests" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DocTester.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DocTester.numTestsNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.DocTester.numTestsNokNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.DocTester.numTestsOkNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.DynamicTooltip" superclass="dijit.Tooltip">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setLoadingLabel" scope="instance"/>
      <method name="_setHrefAttr" scope="instance">
        <description>resets so next show loads new href</description>
        <parameters>
          <parameter name="href" type="String|Uri" usage="required">
            <description>url to the content you want to show, must be within the same domain as your mainpage</description>
          </parameter>
        </parameters>
      </method>
      <method name="loadContent" scope="instance">
        <description>1. checks if content already loaded
	2. if not, sends XHR to download new data</description>
        <parameters>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="refresh" scope="instance"/>
      <method name="open" scope="instance">
        <parameters>
          <parameter name="target" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Tooltip" scope="instance"/>
    </mixins>
    <properties>
      <property name="hasLoaded" scope="instance" type="Boolean">
        <description>false if the contents are yet to be loaded from the HTTP request</description>
      </property>
      <property name="href" scope="instance" type="String">
        <description>location from where to fetch the contents</description>
      </property>
      <property name="label" scope="instance" type="String">
        <description>contents to diplay in the tooltip. Initialized to a loading icon.</description>
      </property>
      <property name="preventCache" scope="instance" type="Boolean">
        <description>Cache content retreived externally</description>
      </property>
      <property name="_connectNodes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FeedPortlet" superclass="dojox.widget.Portlet">
    <description>The feed is displayed as
	an unordered list of links.	When a link is hovered over
	by the mouse, it displays a summary in a tooltip.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="onFeedError" scope="instance"/>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getTitle" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getLink" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getContent" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setUrlAttr" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="load" scope="instance"/>
      <method name="generateResults" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.Portlet" scope="instance"/>
    </mixins>
    <properties>
      <property name="local" scope="instance" type="Boolean">
        <description>Specifies whether the feed is to be loaded from the same domain as the
	page, or a remote domain.	If local is true, then the feed must be an
	Atom feed.	If it is false, it can be an Atom or RSS feed.</description>
      </property>
      <property name="maxResults" scope="instance" type="Number">
        <description>The number of results to display from the feed.</description>
      </property>
      <property name="url" scope="instance" type="String">
        <description>The URL of the feed to load.	If this is different to the domain
	of the HTML page, local should be set to false.</description>
      </property>
      <property name="openNew" scope="instance" type="Boolean">
        <description>If true, when a link is clicked it will open in a new window.
	If false, it will not.</description>
      </property>
      <property name="showFeedTitle" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="_resultList" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FeedPortlet.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.ExpandableFeedPortlet" superclass="dojox.widget.FeedPortlet">
    <methods>
      <method name="generateResults" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.FeedPortlet" scope="instance"/>
    </mixins>
    <properties>
      <property name="onlyOpenOne" scope="instance" type="Boolean">
        <description>If true, only a single item can be expanded at any given time.</description>
      </property>
      <property name="store" scope="instance" type="Object"/>
      <property name="_resultList" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.PortletFeedSettings" superclass="dojox.widget.PortletSettings">
    <description>It provides form items that the user can use to change the URL
	for a feed to load into the FeedPortlet.
	There are two forms that it can take.	&lt;br&gt;
	The first is to display a text field, with Load and Cancel buttons,
	which is prepopulated with the enclosing FeedPortlet's URL.
	If a &lt;select&gt; DOM node is used as the source node for this widget,
	it displays a list of predefined URLs that the user can select from
	to load into the enclosing FeedPortlet.</description>
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="_setContentAttr" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_getFeedPortletUrlAttr" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.PortletSettings" scope="instance"/>
    </mixins>
    <properties>
      <property name="class" scope="instance" type="String"/>
      <property name="urls" scope="instance" type="Array">
        <description>An array of JSON object specifying URLs to display in the
	PortletFeedSettings object. Each object contains a 'url' and 'label'
	attribute, e.g.
	[{url:'http:google.com', label:'Google'}, {url:'http://dojotoolkit.org', label: 'Dojo'}]</description>
      </property>
      <property name="selectedIndex" scope="instance" type="Number">
        <description>The selected URL. Defaults to zero.</description>
      </property>
      <property name="srcNodeRef" scope="instance" type="Object"/>
      <property name="text" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane" superclass="dojox.widget._RollingListPane">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="onItems" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._RollingListPane" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>The template to be used to construct the widget.</description>
      </property>
      <property name="_messages" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane.items">
    <properties>
      <property name="0" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane.nameNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane.pathNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._FileInfoPane.sizeNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FilePicker" superclass="dojox.widget.RollingList">
    <methods>
      <method name="_itemsMatch" scope="instance">
        <parameters>
          <parameter name="item1" type="item" usage="required"/>
          <parameter name="item2" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="getChildItems" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getMenuItemForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="getPaneForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="_setPathValueAttr" scope="instance">
        <parameters>
          <parameter name="path" type="string" usage="required"/>
          <parameter name="resetLastExec" type="boolean" usage="optional"/>
          <parameter name="onSet" type="function" usage="optional"/>
        </parameters>
      </method>
      <method name="_getPathValueAttr" scope="instance">
        <parameters>
          <parameter name="val" type="item" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.RollingList" scope="instance"/>
    </mixins>
    <properties>
      <property name="className" scope="instance" type="String"/>
      <property name="pathSeparator" scope="instance" type="string">
        <description>Our file separator - it will be guessed if not set</description>
      </property>
      <property name="topDir" scope="instance" type="string">
        <description>The top directory string - it will be guessed if not set</description>
      </property>
      <property name="parentAttr" scope="instance" type="string">
        <description>the attribute to read for finding our parent directory</description>
      </property>
      <property name="pathAttr" scope="instance" type="string">
        <description>the attribute to read for getting the full path of our file</description>
      </property>
      <property name="preloadItems" scope="instance" type="boolean">
        <description>or int
	Set this to a sane number - since we expect to mostly be using the
	dojox.data.FileStore - which doesn't like loading lots of items
	all at once.</description>
      </property>
      <property name="selectDirectories" scope="instance" type="boolean">
        <description>whether or not we allow selection of directories - that is, whether or
	our value can be set to a directory.</description>
      </property>
      <property name="selectFiles" scope="instance" type="boolean">
        <description>whether or not we allow selection of files - that is, we will disable
	the file entries.</description>
      </property>
      <property name="value" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeList" superclass="dijit._Widget">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_initializePositioning" scope="instance"/>
      <method name="_overElement" scope="instance">
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBodyOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setDormant" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already dormant?"/>
        </return-types>
      </method>
      <method name="_setActive" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already activated?"/>
        </return-types>
      </method>
      <method name="_onMouseMove" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onScroll" scope="instance"/>
      <method name="onResized" scope="instance"/>
      <method name="_onGridMouseMove" scope="instance">
        <parameters>
          <parameter name="x" type="Object" usage="required"/>
          <parameter name="y" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_paint" scope="instance"/>
      <method name="_weighAt" scope="instance">
        <parameters>
          <parameter name="cen" type="Integer" usage="required"/>
          <parameter name="i" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_setItemSize" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="scale" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_positionElementsFrom" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
          <parameter name="offset" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_positionLabel" scope="instance">
        <parameters>
          <parameter name="itm" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calcHitGrid" scope="instance"/>
      <method name="_toEdge" scope="instance">
        <parameters>
          <parameter name="inp" type="Object" usage="required"/>
          <parameter name="def" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_expandSlowly" scope="instance"/>
      <method name="destroyRecursive" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="snarfChildDomOutput" scope="instance" type="Object"/>
      <property name="itemWidth" scope="instance" type="Integer">
        <description>width of menu item (in pixels) in it's dormant state (when the mouse is far away)</description>
      </property>
      <property name="itemHeight" scope="instance" type="Integer">
        <description>height of menu item (in pixels) in it's dormant state (when the mouse is far away)</description>
      </property>
      <property name="itemMaxWidth" scope="instance" type="Integer">
        <description>width of menu item (in pixels) in it's fully enlarged state (when the mouse is directly over it)</description>
      </property>
      <property name="itemMaxHeight" scope="instance" type="Integer">
        <description>height of menu item (in pixels) in it's fully enlarged state (when the mouse is directly over it)</description>
      </property>
      <property name="imgNode" scope="instance" type="Object"/>
      <property name="orientation" scope="instance" type="String">
        <description>orientation of the menu, either &amp;quot;horizontal&amp;quot; or &amp;quot;vertical&amp;quot;</description>
      </property>
      <property name="isFixed" scope="instance" type="Boolean">
        <description>toggle to enable additional listener (window scroll) if FisheyeList is in a fixed postion</description>
      </property>
      <property name="conservativeTrigger" scope="instance" type="Boolean">
        <description>if true, don't start enlarging menu items until mouse is over an image;
	if false, start enlarging menu items as the mouse moves near them.</description>
      </property>
      <property name="effectUnits" scope="instance" type="Number">
        <description>controls how much reaction the menu makes, relative to the distance of the mouse from the menu</description>
      </property>
      <property name="itemPadding" scope="instance" type="Integer">
        <description>padding (in pixels) betweeen each menu item</description>
      </property>
      <property name="attachEdge" scope="instance" type="String">
        <description>controls the border that the menu items don't expand past;
	for example, if set to &amp;quot;top&amp;quot;, then the menu items will drop downwards as they expand.
	values
	&amp;quot;center&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;.</description>
      </property>
      <property name="labelEdge" scope="instance" type="String">
        <description>controls were the labels show up in relation to the menu item icons
	values
	&amp;quot;center&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;.</description>
      </property>
      <property name="isHorizontal" scope="instance" type="bool"/>
      <property name="selectedNode" scope="instance" type="Number"/>
      <property name="isOver" scope="instance" type="Object"/>
      <property name="hitX1" scope="instance" type="Number"/>
      <property name="hitY1" scope="instance" type="Number"/>
      <property name="hitX2" scope="instance" type="String"/>
      <property name="hitY2" scope="instance" type="String"/>
      <property name="anchorEdge" scope="instance" type="Object"/>
      <property name="proximityLeft" scope="instance" type="Number"/>
      <property name="proximityRight" scope="instance" type="Number"/>
      <property name="proximityTop" scope="instance" type="Number"/>
      <property name="proximityBottom" scope="instance" type="Number"/>
      <property name="children" scope="instance" type="Object"/>
      <property name="_onMouseMoveHandle" scope="instance" type="Object"/>
      <property name="_onScrollHandle" scope="instance" type="Object"/>
      <property name="_onMouseOutHandle" scope="instance" type="Object"/>
      <property name="_addChildHandle" scope="instance" type="Object"/>
      <property name="_onResizeHandle" scope="instance" type="Object"/>
      <property name="itemCount" scope="instance" type="Object"/>
      <property name="barWidth" scope="instance" type="Number"/>
      <property name="barHeight" scope="instance" type="Number"/>
      <property name="totalWidth" scope="instance" type="String"/>
      <property name="totalHeight" scope="instance" type="String"/>
      <property name="timerScale" scope="instance-prototype" type="Number"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeList.EDGE">
    <properties>
      <property name="CENTER" scope="instance" type="Number"/>
      <property name="LEFT" scope="instance" type="Number"/>
      <property name="RIGHT" scope="instance" type="Number"/>
      <property name="TOP" scope="instance" type="Number"/>
      <property name="BOTTOM" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeList.domNode.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeList.pos">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeListItem" superclass="dijit._Widget">
    <methods>
      <method name="_isNode" scope="instance">
        <parameters>
          <parameter name="wh" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_hasParent" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="onMouseOver" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="iconSrc" scope="instance" type="String">
        <description>pathname to image file (jpg, gif, png, etc.) of icon for this menu item</description>
      </property>
      <property name="label" scope="instance" type="String">
        <description>label to print next to the icon, when it is moused-over</description>
      </property>
      <property name="id" scope="instance" type="String">
        <description>will be set to the id of the orginal div element</description>
      </property>
      <property name="templateString" scope="instance" type="String"/>
      <property name="parent" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeListItem.imgNode">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
      <property name="src" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeListItem.imgNode.style">
    <properties>
      <property name="filter" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.FisheyeLite" superclass="dijit._Widget">
    <description>A Simple FisheyeList-like widget which (in the interest of
	performance) relies on well-styled content for positioning,
	and natural page layout for rendering.
	use position:absolute/relative nodes to prevent layout
	changes, and use caution when seleting properties to
	scale. Negative scaling works, but some properties
	react poorly to being set to negative values, IE being
	particularly annoying in that regard.
	quirk: uses the domNode as the target of the animation
	unless it finds a node class="fisheyeTarget" in the container
	being turned into a FisheyeLite instance</description>
    <methods>
      <method name="easeIn" scope="instance"/>
      <method name="easeOut" scope="instance"/>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="_makeAnims" scope="instance"/>
      <method name="onClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="durationIn" scope="instance" type="Number"/>
      <property name="durationOut" scope="instance" type="Integer">
        <description>The Time (in ms) to run the hide animation</description>
      </property>
      <property name="properties" scope="instance-prototype" type="Object">
        <description>An object of &amp;quot;property&amp;quot;:scale pairs, or &amp;quot;property&amp;quot;:{} pairs.
	defaults to font-size with a scale of 2.75
	If a named property is an integer or float, the &amp;quot;scale multiplier&amp;quot;
	is used. If the named property is an object, that object is mixed
	into the animation directly. eg: height:{ end:20, units:&amp;quot;em&amp;quot; }</description>
      </property>
      <property name="units" scope="instance" type="String">
        <description>Sometimes, you need to specify a unit. Should be part of
	properties attrib, but was trying to shorthand the logic there</description>
      </property>
      <property name="_target" scope="instance" type="Object"/>
      <property name="_runningIn" scope="instance" type="Object"/>
      <property name="_runningOut" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Iterator" superclass="dijit.Declaration">
    <methods>
      <method name="_setSrcIndex" scope="instance">
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="update" scope="instance"/>
      <method name="_addItem" scope="instance">
        <parameters>
          <parameter name="config" type="Object" usage="required"/>
          <parameter name="idx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAttrValuesObj" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDataAvailable" scope="instance">
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="instance">
        <parameters>
          <parameter name="query" type="Object" usage="required"/>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.Declaration" scope="instance"/>
    </mixins>
    <properties>
      <property name="constructor" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Number"/>
      <property name="fetchMax" scope="instance" type="Number"/>
      <property name="attrs" scope="instance-prototype" type="Object"/>
      <property name="defaultValue" scope="instance" type="String"/>
      <property name="widgetCtor" scope="instance-prototype" type="Object"/>
      <property name="dataValues" scope="instance" type="Array"/>
      <property name="data" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object"/>
      <property name="_srcIndex" scope="instance" type="Number"/>
      <property name="_srcParent" scope="instance" type="Object"/>
      <property name="children" scope="instance" type="Array"/>
      <property name="_classes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Iterator.query">
    <properties>
      <property name="name" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Loader" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setMessage" scope="instance">
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_putLoader" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_show" scope="instance"/>
      <method name="_hide" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="loadIcon" scope="instance" type="String">
        <description>location to the icon used.</description>
      </property>
      <property name="loadMessage" scope="instance" type="String">
        <description>string to use for progress loading</description>
      </property>
      <property name="hasVisuals" scope="instance" type="Boolean">
        <description>true to display a fixed loading message in TR cornder, false to unly provide
	&amp;quot;Loader&amp;quot; topic to subscribe to for your own custom loading message.</description>
      </property>
      <property name="attachToPointer" scope="instance" type="Object"/>
      <property name="duration" scope="instance" type="Integer">
        <description>time in ms to toggle in/out the visual load indicator</description>
      </property>
      <property name="_offset" scope="instance" type="Integer">
        <description>distance in px from the mouse pointer to show attachToPointer avatar</description>
      </property>
      <property name="_pointerConnect" scope="instance" type="Object"/>
      <property name="_xhrStart" scope="instance" type="Object"/>
      <property name="_xhrEnd" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Loader.loadNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Loader.loadMessageNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Pager" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_a11yStyle" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_init" scope="instance">
        <parameters>
          <parameter name="items" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderPages" scope="instance"/>
      <method name="_renderPager" scope="instance"/>
      <method name="_renderStatus" scope="instance"/>
      <method name="_pagerSkip" scope="instance">
        <parameters>
          <parameter name="page" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_pagerNext" scope="instance"/>
      <method name="_pagerPrevious" scope="instance"/>
      <method name="onScrollEnd" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="iconPrevious" scope="instance" type="String">
        <description>The url of the previous page icon</description>
      </property>
      <property name="iconNext" scope="instance" type="String">
        <description>The url of the next page icon</description>
      </property>
      <property name="iconPage" scope="instance" type="Object"/>
      <property name="iconPageActive" scope="instance" type="Object"/>
      <property name="store" scope="instance" type="Object">
        <description>A dojo.data Data store
	data store for items</description>
      </property>
      <property name="orientation" scope="instance" type="String">
        <description>Either &amp;quot;horizontal or &amp;quot;vertical&amp;quot; to define the direction the pages will slide
	or vertical</description>
      </property>
      <property name="statusPos" scope="instance" type="String">
        <description>A string describing where to put the Pager &amp;quot;current page&amp;quot; indicator. Options are
	&amp;quot;leading&amp;quot; or &amp;quot;trailing&amp;quot;. In the case of horiztonal orientation, &amp;quot;leading&amp;quot; indicates
	positioned above the PageItems. In the case of vertical, &amp;quot;leading&amp;quot; indicates &amp;quot;before&amp;quot;.</description>
      </property>
      <property name="pagerPos" scope="instance" type="String">
        <description>TODOC</description>
      </property>
      <property name="duration" scope="instance" type="Integer">
        <description>Time in milliseconds to transition the pages</description>
      </property>
      <property name="itemSpace" scope="instance" type="Integer">
        <description>Spacing between items? TODOC</description>
      </property>
      <property name="resizeChildren" scope="instance" type="Boolean">
        <description>TODOC</description>
      </property>
      <property name="itemClass" scope="instance" type="String">
        <description>The full dotted named of a Class to use for the internal Pager Items.</description>
      </property>
      <property name="itemsPage" scope="instance" type="Integer">
        <description>The numbers of items to display in each &amp;quot;Page&amp;quot;</description>
      </property>
      <property name="items" scope="instance" type="Object"/>
      <property name="pagerContainerView" scope="instance" type="Object"/>
      <property name="pagerContainerPager" scope="instance" type="Object"/>
      <property name="_totalPages" scope="instance" type="Object"/>
      <property name="iconWidth" scope="instance" type="Number"/>
      <property name="iconHeight" scope="instance" type="Number"/>
      <property name="iconsLoaded" scope="instance" type="Number"/>
      <property name="_iconConnects" scope="instance" type="Array"/>
      <property name="_toScroll" scope="instance" type="Object"/>
      <property name="_currentPage" scope="instance" type="Number"/>
      <property name="_anim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Pager.pagerIconNext">
    <properties>
      <property name="width" scope="instance" type="Object"/>
      <property name="height" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._PagerItem" superclass="dijit._Widget">
    <methods>
      <method name="resizeChildren" scope="instance"/>
      <method name="parseChildren" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.PlaceholderMenuItem" superclass="dijit.MenuItem">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="menuItems" type="Array&lt;dijit.MenuItem&gt;" usage="required"/>
        </parameters>
        <return-description>true if the replace happened, false if not</return-description>
      </method>
      <method name="unReplace" scope="instance">
        <parameters>
          <parameter name="destroy" type="Boolean" usage="optional">
            <description>Also call destroy on any removed items.</description>
          </parameter>
        </parameters>
        <return-description>The array of items that were actually removed</return-description>
        <return-types>
          <return-type type="Array&lt;dijit.MenuItem&gt;"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.MenuItem" scope="instance"/>
    </mixins>
    <properties>
      <property name="_replaced" scope="instance" type="bool"/>
      <property name="_replacedWith" scope="instance" type="Array"/>
      <property name="_isPlaceholder" scope="instance" type="Object"/>
      <property name="label" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.PlaceholderMenuItem.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Portlet" superclass="dijit.TitlePane">
    <methods>
      <method name="buildRendering" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="_placeSettingsWidgets" scope="instance"/>
      <method name="_createIcon" scope="instance">
        <parameters>
          <parameter name="clazz" type="Object" usage="required"/>
          <parameter name="hoverClazz" type="Object" usage="required"/>
          <parameter name="fn" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSizeChange" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSize" scope="instance"/>
      <method name="onUpdateSize" scope="instance"/>
      <method name="_publish" scope="instance"/>
      <method name="_onTitleClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="child" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroyDescendants" scope="instance">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_setCss" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.TitlePane" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="resizeChildren" scope="instance" type="Boolean">
        <description>If true, when the Portlet is resized, any child widgets
	with a 'resize' method have that method called.</description>
      </property>
      <property name="closable" scope="instance" type="Boolean">
        <description>If true, a close button is placed in the title bar,
	and the Portlet can be hidden. If false, the Portlet
	cannot be closed.</description>
      </property>
      <property name="_parents" scope="instance" type="Array">
        <description>An array of all the StackContainer widgets that this Portlet
	is contained in.	These are used to determine if the portlet
	is visible or not.</description>
      </property>
      <property name="_size" scope="instance" type="Object">
        <description>Cache of the previous size of the portlet, used to determine
	if the size has changed and if the child widgets should be
	resized.</description>
      </property>
      <property name="dragRestriction" scope="instance" type="Boolean">
        <description>To remove the drag capability.</description>
      </property>
      <property name="closeIcon" scope="instance" type="Object"/>
      <property name="_timer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.PortletSettings" superclass="dijit._Container">
    <description>This widget should be placed inside a dojox.widget.Portlet widget.
	It is used to set some preferences for that Portlet.	It is essentially
	a ContentPane, and should contain other widgets and DOM nodes that
	do the real work of setting preferences for the portlet.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_setPortletAttr" scope="instance">
        <parameters>
          <parameter name="portlet" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Container" scope="instance"/>
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
    </mixins>
    <properties>
      <property name="portletIconClass" scope="instance" type="String">
        <description>The CSS class to apply to the icon in the Portlet title bar that is used
	to toggle the visibility of this widget.</description>
      </property>
      <property name="portletIconHoverClass" scope="instance" type="String">
        <description>The CSS class to apply to the icon in the Portlet title bar that is used
	to toggle the visibility of this widget when the mouse hovers over it.</description>
      </property>
      <property name="portlet" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.PortletDialogSettings" superclass="dojox.widget.PortletSettings">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.PortletSettings" scope="instance"/>
    </mixins>
    <properties>
      <property name="dimensions" scope="instance-prototype" type="Array">
        <description>The size of the dialog to display.	This defaults to [300, 300]</description>
      </property>
      <property name="dialog" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Roller" superclass="dijit._Widget">
    <description>The Roller widget takes an unordered-list of items, and converts
	them to a single-area (the size of one list-item, however you so choose
	to style it) and loops continually, fading between items.
	In it's current state, it requires it be created from an unordered (or ordered)
	list, though can contain complex markup.
	You can manipulate the `items` array at any point during the cycle with
	standard array manipulation techniques.
	The class "dojoxRoller" is added to the UL element for styling purposes.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="makeAnims" scope="instance"/>
      <method name="_setupConnects" scope="instance"/>
      <method name="start" scope="instance"/>
      <method name="_run" scope="instance"/>
      <method name="stop" scope="instance"/>
      <method name="_setIndex" scope="instance">
        <parameters>
          <parameter name="i" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="delay" scope="instance" type="Integer">
        <description>Interval between rolls</description>
      </property>
      <property name="autoStart" scope="instance" type="Boolean">
        <description>Toggle to control starup behavior. Call .start() manually
	if set to &lt;code&gt;false&lt;/code&gt;</description>
      </property>
      <property name="itemSelector" scope="instance" type="String">
        <description>A CSS selector to be used by &lt;code&gt;dojo.query&lt;/code&gt; to find the children
	items in this widget. Defaults to &amp;quot;&amp;gt; li&amp;quot;, finding only first-children
	list-items in the list, allowing for embedded lists to occur.</description>
      </property>
      <property name="durationIn" scope="instance" type="Integer">
        <description>Speed (in ms) to apply to the &amp;quot;in&amp;quot; animation (show the node)</description>
      </property>
      <property name="durationOut" scope="instance" type="Integer">
        <description>Speed (in ms) to apply to the &amp;quot;out&amp;quot; animation (hide the showing node)</description>
      </property>
      <property name="items" scope="instance" type="Array">
        <description>If populated prior to instantiation, is used as the Items over the children</description>
      </property>
      <property name="_idx" scope="instance" type="Integer">
        <description>Index of the the currently visible item in the list of items[]</description>
      </property>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="_anim" scope="instance" type="Object"/>
      <property name="rolling" scope="instance" type="bool"/>
      <property name="_timeout" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Roller._roller">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.RollerSlide" superclass="dojox.widget.Roller">
    <methods>
      <method name="makeAnims" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.Roller" scope="instance"/>
    </mixins>
    <properties>
      <property name="durationOut" scope="instance" type="Number"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollerHover">
    <description>A mixin class used to provide a way to automate a "stop on hover" behavior,
	while still allowing for ambigious subclassing for custom animations.
	Simply mix this class into a `dojox.widget.Roller` variant, and instantiate
	as you would. The hover connection is done automatically.
	The "hover" functionality is as such: Stop rotation while the mouse is over the
	instance, and resume again once leaving. Even if autoStart is disabled, the widget
	will start if a mouse enters and leaves the node in this case.</description>
    <methods>
      <method name="postCreate" scope="instance"/>
    </methods>
  </class>
  <class type="dojox.widget._RollingListPane" superclass="dijit.layout.ContentPane">
    <methods>
      <method name="_setContentAndScroll" scope="instance">
        <parameters>
          <parameter name="cont" type="String|DomNode|Nodelist" usage="required"/>
          <parameter name="isFakeContent" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_updateNodeWidth" scope="instance">
        <parameters>
          <parameter name="n" type="Object" usage="required"/>
          <parameter name="min" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onMinWidthChange" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMinWidthAttr" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="_focusKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="force" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onShow" scope="instance"/>
      <method name="_load" scope="instance"/>
      <method name="_doLoadItems" scope="instance">
        <parameters>
          <parameter name="items" type="Array&lt;item&gt;" usage="required"/>
          <parameter name="callback" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="_doQuery" scope="instance"/>
      <method name="_hasItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <description>| array</description>
          </parameter>
        </parameters>
      </method>
      <method name="_onNewItem" scope="instance">
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_onDeleteItem" scope="instance">
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="onFetchStart" scope="instance"/>
      <method name="onFetchError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onLoadStart" scope="instance"/>
      <method name="onLoadError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onItems" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="string">
        <description>our template</description>
      </property>
      <property name="parentPane" scope="instance" type="dojox.widget._RollingListPane">
        <description>The pane that immediately precedes ours</description>
      </property>
      <property name="store" scope="instance" type="store">
        <description>the store we must use</description>
      </property>
      <property name="items" scope="instance" type="Array&lt;item&gt;">
        <description>an array of (possibly not-yet-loaded) items to display in this.
	If this array is null, then the query and query options are used to
	get the top-level items to use.  This array is also used to watch and
	see if the pane needs to be reloaded (store notifications are handled)
	by the pane</description>
      </property>
      <property name="query" scope="instance" type="object">
        <description>a query to pass to the datastore.  This is only used if items are null</description>
      </property>
      <property name="queryOptions" scope="instance" type="object">
        <description>query options to be passed to the datastore</description>
      </property>
      <property name="_focusByNode" scope="instance" type="Object"/>
      <property name="minWidth" scope="instance" type="integer">
        <description>the width (in px) for this pane</description>
      </property>
      <property name="isLoaded" scope="instance" type="bool"/>
      <property name="onLoadDeferred" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollingListPane.parentWidget">
    <properties>
      <property name="_focusedPane" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollingListGroupPane" superclass="dojox.widget._RollingListPane">
    <methods>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="cont" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="_onMinWidthChange" scope="instance">
        <parameters>
          <parameter name="v" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onItems" scope="instance"/>
      <method name="_checkScrollConnection" scope="instance">
        <parameters>
          <parameter name="doLoad" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance"/>
      <method name="focus" scope="instance">
        <parameters>
          <parameter name="force" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getMenu" scope="instance"/>
      <method name="_onScrollPane" scope="instance"/>
      <method name="_loadVisibleItems" scope="instance"/>
      <method name="_getSelected" scope="instance">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="optional"/>
        </parameters>
      </method>
      <method name="_setSelected" scope="instance">
        <parameters>
          <parameter name="item" type="dijit.MenuItem" usage="optional"/>
          <parameter name="menu" type="dijit.Menu" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget._RollingListPane" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="string">
        <description>our template</description>
      </property>
      <property name="_menu" scope="instance" type="dijit.Menu">
        <description>The menu that we will call addChild() on for adding items</description>
      </property>
      <property name="store" scope="instance" type="Object"/>
      <property name="_scrollConn" scope="instance" type="Object"/>
      <property name="_focusByNode" scope="instance" type="Object"/>
      <property name="_pendingFocus" scope="instance" type="Object"/>
      <property name="_visibleLoadPending" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget._RollingListGroupPane.containerNode">
    <properties>
      <property name="innerHTML" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.RollingList" superclass="dijit._Widget">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="_setShowButtonsAttr" scope="instance">
        <parameters>
          <parameter name="doShow" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_itemsMatch" scope="instance">
        <parameters>
          <parameter name="item1" type="item" usage="required"/>
          <parameter name="item2" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_removeAfter" scope="instance">
        <parameters>
          <parameter name="idx" type="Widget" usage="required">
            <description>or int</description>
          </parameter>
        </parameters>
      </method>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="_setMinPaneWidthAttr" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateClass" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="options" type="Object" usage="optional">
            <description>an object with key-value-pairs.  The values are boolean, if true,
	the key is added as a class, if false, it is removed.</description>
          </parameter>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="instance">
        <parameters>
          <parameter name="childWidget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="instance"/>
      <method name="_onChange" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemClick" scope="instance">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
          <parameter name="pane" type="dijit._Contained" usage="required"/>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="_getPaneForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
          <parameter name="parentPane" type="dijit._Contained" usage="optional"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="_getMenuItemForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
        </parameters>
      </method>
      <method name="_setStore" scope="instance">
        <parameters>
          <parameter name="store" type="dojo.data.api.Read" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_resetValue" scope="instance"/>
      <method name="_onCancel" scope="instance"/>
      <method name="_onExecute" scope="instance"/>
      <method name="focus" scope="instance"/>
      <method name="handleKey" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_updateChildClasses" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="getChildItems" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getMenuItemForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="getPaneForItem" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
          <parameter name="parentPane" type="dijit._Contained" usage="optional"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="onItemClick" scope="instance">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="pane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="Array&lt;item&gt;" usage="optional"/>
        </parameters>
      </method>
      <method name="onExecute" scope="instance"/>
      <method name="onCancel" scope="instance"/>
      <method name="onChange" scope="instance">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>The template to be used to construct the widget.</description>
      </property>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="className" scope="instance" type="string">
        <description>an additional class (or space-separated classes) to add for our widget</description>
      </property>
      <property name="store" scope="instance" type="store">
        <description>the store we must use</description>
      </property>
      <property name="query" scope="instance" type="object">
        <description>a query to pass to the datastore.  This is only used if items are null</description>
      </property>
      <property name="queryOptions" scope="instance" type="object">
        <description>query options to be passed to the datastore</description>
      </property>
      <property name="childrenAttrs" scope="instance" type="Array&lt;String&gt;">
        <description>one ore more attributes that holds children of a node</description>
      </property>
      <property name="parentAttr" scope="instance" type="string">
        <description>the attribute to read for finding our parent item (if any)</description>
      </property>
      <property name="value" scope="instance" type="item">
        <description>The value that has been selected</description>
      </property>
      <property name="executeOnDblClick" scope="instance" type="boolean">
        <description>Set to true if you want to call onExecute when an item is
	double-clicked, false if you want to call onExecute yourself. (mainly
	used for popups to control how they want to be handled)</description>
      </property>
      <property name="preloadItems" scope="instance" type="boolean">
        <description>or int
	if set to true, then onItems will be called only *after* all items have
	been loaded (ie store.isLoaded will return true for all of them).  If
	false, then no preloading will occur.  If set to an integer, preloading
	will occur if the number of items is less than or equal to the value
	of the integer.  The onItems function will need to be aware of handling
	items that may not be loaded</description>
      </property>
      <property name="showButtons" scope="instance" type="boolean">
        <description>if set to true, then buttons for &amp;quot;OK&amp;quot; and &amp;quot;Cancel&amp;quot; will be provided</description>
      </property>
      <property name="okButtonLabel" scope="instance" type="string">
        <description>The string to use for the OK button - will use dijit's common &amp;quot;OK&amp;quot; string
	if not set</description>
      </property>
      <property name="cancelButtonLabel" scope="instance" type="string">
        <description>The string to use for the Cancel button - will use dijit's common
	&amp;quot;Cancel&amp;quot; string if not set</description>
      </property>
      <property name="minPaneWidth" scope="instance" type="integer">
        <description>the minimum pane width (in px) for all child panes.  If they are narrower,
	the width will be increased to this value.</description>
      </property>
      <property name="_declaredClasses" scope="instance" type="Object"/>
      <property name="_scrollingTimeout" scope="instance" type="Object"/>
      <property name="buttonsNode" scope="instance" type="Object"/>
      <property name="_focusedPane" scope="instance" type="Object"/>
      <property name="_setInProgress" scope="instance" type="Object"/>
      <property name="_visibleItem" scope="instance" type="Object"/>
      <property name="_isIdentity" scope="instance" type="Object"/>
      <property name="_lastExecutedValue" scope="instance" type="Object"/>
      <property name="_savedFocus" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.RollingList.domNode">
    <properties>
      <property name="style" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Rotator">
    <description>A small, fast, extensible, awesome rotator that cycles, with transitions,
	through panes (child nodes) displaying only one at a time and ties into
	controllers used to change state.
	The Rotator does not rely on dijit.  It is designed to be as lightweight
	as possible.  Controllers and transitions have been externalized
	so builds can be as optimized with only the components you want to use.
	For best results, each rotator pane should be the same height and width as
	the Rotator container node and consider setting overflow to hidden.
	While the Rotator will accept any DOM node for a rotator pane, a block
	element or element with display:block is recommended.
	Note: When the Rotator begins, it does not transition the first pane.
	subscribed topics:
	[id]/rotator/control - Controls the Rotator
	Parameters:
	/*string*/ action        - The name of a method of the Rotator to run
	/*anything?*/ args       - One or more arguments to pass to the action
	published topics:
	[id]/rotator/update - Notifies controllers that a pane or state has changed.
	Parameters:
	/*string*/ type          - the type of notification
	/*dojox.widget.Rotator*/ rotator
	- the rotator instance
	/*object?*/ params		 - params
	declarative dojo/method events (per pane):
	onBeforeIn  - Fired before the transition in starts.
	onAfterIn   - Fired after the transition in ends.
	onBeforeOut - Fired before the transition out starts.
	onAfterOut  - Fired after the transition out ends.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="next" scope="instance"/>
      <method name="prev" scope="instance"/>
      <method name="go" scope="instance">
        <parameters>
          <parameter name="p" type="int|string" usage="optional"/>
        </parameters>
      </method>
      <method name="onUpdate" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
          <parameter name="params" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_resetWaitForEvent" scope="instance"/>
      <method name="control" scope="instance">
        <parameters>
          <parameter name="action" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="instance">
        <parameters>
          <parameter name="width" type="int" usage="required"/>
          <parameter name="height" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="onManualChange" scope="instance"/>
    </methods>
    <properties>
      <property name="transition" scope="instance" type="string">
        <description>The name of a function that is passed two panes nodes and a duration,
	then returns a dojo.Animation object. The default value is
	&amp;quot;dojox.widget.rotator.swap&amp;quot;.</description>
      </property>
      <property name="transitionParams" scope="instance" type="string">
        <description>Parameters for the transition. The string is read in and eval'd as an
	object.  If the duration is absent, the default value will be used.</description>
      </property>
      <property name="panes" scope="instance" type="array">
        <description>Array of panes to be created in the Rotator. Each array element
	will be passed as attributes to a dojo.create() call.</description>
      </property>
      <property name="wfe" scope="instance" type="Object"/>
      <property name="_domNodeContentBox" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.SortList" superclass="dijit.layout._LayoutWidget">
    <methods>
      <method name="_addItem" scope="instance">
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="onSort" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_unset" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleClick" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_updateValues" scope="instance"/>
      <method name="_sorter" scope="instance">
        <parameters>
          <parameter name="a" type="Object" usage="required"/>
          <parameter name="b" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setTitle" scope="instance">
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onChanged" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout._LayoutWidget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="title" scope="instance" type="String">
        <description>The title in the header</description>
      </property>
      <property name="heading" scope="instance" type="String">
        <description>In the event a parent container is expecting a title=&amp;quot;&amp;quot; attribute, set it for the parent
	via title, and the title of this widget via heading=&amp;quot;&amp;quot; ... assuming you want different
	titles for each. eg: TabContainer, AccordionContainer, etc.</description>
      </property>
      <property name="descending" scope="instance" type="Boolean">
        <description>Toggle sort order based on this value.</description>
      </property>
      <property name="selected" scope="instance" type="Array">
        <description>A list of the selected &amp;lt;li&amp;gt; nodes at any given time.</description>
      </property>
      <property name="sortable" scope="instance" type="Boolean">
        <description>toggle to enable/disable sorting</description>
      </property>
      <property name="store" scope="instance" type="Object"/>
      <property name="key" scope="instance" type="String"/>
      <property name="baseClass" scope="instance" type="String"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_selected" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.SortList.bodyWrapper.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.SortList.focusNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Standby" superclass="dijit._Widget">
    <methods>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="isVisible" scope="instance">
        <return-description>boolean indicating if the widget is in 'show' state or not.</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onShow" scope="instance"/>
      <method name="onHide" scope="instance"/>
      <method name="uninitialize" scope="instance"/>
      <method name="_size" scope="instance"/>
      <method name="_cloneStyles" scope="instance">
        <parameters>
          <parameter name="list" type="Array" usage="required">
            <description>An array of style names to clone.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_fadeIn" scope="instance"/>
      <method name="_fadeOut" scope="instance"/>
      <method name="_ignore" scope="instance">
        <parameters>
          <parameter name="event" type="Event" usage="required">
            <description>The event to halt</description>
          </parameter>
        </parameters>
      </method>
      <method name="_scrollerWidths" scope="instance">
        <return-description>Object of form: {v: Number, h: Number} where v is vertical scrollbar width
	and h is horizontal scrollbar width.</return-description>
      </method>
      <method name="_setTextAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>The text to set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setColorAttr" scope="instance">
        <parameters>
          <parameter name="c" type="String" usage="required">
            <description>The color to set the background underlay to in #XXXXXX format..</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setImageTextAttr" scope="instance">
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>The text to set.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setImageAttr" scope="instance">
        <parameters>
          <parameter name="url" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setCenterIndicatorAttr" scope="instance">
        <parameters>
          <parameter name="indicator" type="String" usage="required">
            <description>The indicator to use, either 'image' or 'text'.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_disableOverflow" scope="instance"/>
      <method name="_enableOverflow" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String">
        <description>The template string defining out the basics of the widget.  No need for an external
	file.</description>
      </property>
      <property name="_underlayNode" scope="instance" type="DOMNode">
        <description>The node that is the translucent underlay for the
	image that blocks access to the target.</description>
      </property>
      <property name="_imageNode" scope="instance" type="DOMNode">
        <description>The image node where we attach and define the image to display.</description>
      </property>
      <property name="_centerNode" scope="instance" type="DOMNode">
        <description>Which node to use as the center node, the image or the text node.</description>
      </property>
      <property name="image" scope="instance" type="String">
        <description>The URL to the image to center in the overlay.</description>
      </property>
      <property name="imageText" scope="instance" type="String">
        <description>Text for the ALT tag.</description>
      </property>
      <property name="text" scope="instance" type="String">
        <description>Text/HTML to display in the center of the overlay
	This is used if image center is disabled.</description>
      </property>
      <property name="centerIndicator" scope="instance" type="String">
        <description>Property to define if the image and its alt text should be used, or
	a simple Text/HTML node should be used.  Allowable values are 'image'
	and 'text'.
	Default is 'image'.</description>
      </property>
      <property name="_displayed" scope="instance" type="Boolean">
        <description>Flag to indicate if the overlay is displayed or not.</description>
      </property>
      <property name="_resizeCheck" scope="instance" type="Object">
        <description>Handle to interval function that checks the target for changes.</description>
      </property>
      <property name="color" scope="instance" type="String">
        <description>The color to set the overlay.  Should be in #XXXXXX form.
	Default color for the translucent overlay is light gray.</description>
      </property>
      <property name="duration" scope="instance" type="integer">
        <description>Integer defining how long the show and hide effects should take.</description>
      </property>
      <property name="_started" scope="instance" type="Boolean">
        <description>Trap flag to ensure startup only processes once.</description>
      </property>
      <property name="_parent" scope="instance" type="DOMNode">
        <description>Wrapping div for the widget, also used for IE 7 in dealing with the
	zoom issue.</description>
      </property>
      <property name="zIndex" scope="instance" type="String">
        <description>Control that lets you specify if the zIndex for the overlay
	should be auto-computed based off parent zIndex, or should be set
	to a particular value.  This is useful when you want to overlay
	things in digit.Dialogs, you can specify a base zIndex to append from.</description>
      </property>
      <property name="_ieFixNode" scope="instance" type="Object"/>
      <property name="_anim" scope="instance" type="Object"/>
      <property name="_overflowDisabled" scope="instance" type="Object"/>
      <property name="_oldOverflow" scope="instance" type="String"/>
      <property name="_oldBodyParentOverflow" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Standby._textNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Standby.target">
    <properties>
      <property name="parentNode" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.TitleGroup" superclass="dijit._Widget">
    <description>A container which controls a series of `dijit.TitlePane`s,
	allowing one to be visible and hiding siblings. Behaves similarly
	to a `dijit.layout.AccordionContainer` in that the children
	are all stacked, though merges the TitlePane behavior of
	variable height</description>
    <methods>
      <method name="addChild" scope="instance">
        <parameters>
          <parameter name="widget" type="dijit.TitlePane" usage="required">
            <description>A widget reference to add</description>
          </parameter>
          <parameter name="position" type="String|Int" usage="optional">
            <description>An optional index or position to pass. defaults to &amp;quot;last&amp;quot;</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit.TitlePane"/>
        </return-types>
      </method>
      <method name="removeChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="selectChild" scope="instance">
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit.TitlePane"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="class" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster" superclass="dijit._Widget">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="_handleMessage" scope="instance">
        <parameters>
          <parameter name="message" type="String|Object" usage="required"/>
        </parameters>
      </method>
      <method name="_capitalize" scope="instance">
        <parameters>
          <parameter name="w" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setContent" scope="instance">
        <parameters>
          <parameter name="message" type="String|Function" usage="required">
            <description>the message. If this is a function, it will be called with this toaster widget as the only argument.</description>
          </parameter>
          <parameter name="messageType" type="String" usage="required">
            <description>type of message; possible values in messageTypes enumeration (&amp;quot;message&amp;quot;, &amp;quot;warning&amp;quot;, &amp;quot;error&amp;quot;, &amp;quot;fatal&amp;quot;)</description>
          </parameter>
          <parameter name="duration" type="int" usage="optional">
            <description>duration in milliseconds to display message before removing it. Widget has default value.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_setContent" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_cancelHideTimer" scope="instance"/>
      <method name="_setHideTimer" scope="instance">
        <parameters>
          <parameter name="duration" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_placeClip" scope="instance"/>
      <method name="onSelect" scope="instance">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="String"/>
      <property name="messageTopic" scope="instance" type="String">
        <description>Name of topic; anything published to this topic will be displayed as a message.
	Message format is either String or an object like
	{message: &amp;quot;hello word&amp;quot;, type: &amp;quot;error&amp;quot;, duration: 500}</description>
      </property>
      <property name="defaultType" scope="instance" type="String">
        <description>If message type isn't specified (see &amp;quot;messageTopic&amp;quot; parameter),
	then display message as this type.
	Possible values in messageTypes enumeration (&amp;quot;message&amp;quot;, &amp;quot;warning&amp;quot;, &amp;quot;error&amp;quot;, &amp;quot;fatal&amp;quot;)</description>
      </property>
      <property name="positionDirection" scope="instance" type="String">
        <description>Position from which message slides into screen, one of
	[&amp;quot;br-up&amp;quot;, &amp;quot;br-left&amp;quot;, &amp;quot;bl-up&amp;quot;, &amp;quot;bl-right&amp;quot;, &amp;quot;tr-down&amp;quot;, &amp;quot;tr-left&amp;quot;, &amp;quot;tl-down&amp;quot;, &amp;quot;tl-right&amp;quot;]</description>
      </property>
      <property name="positionDirectionTypes" scope="instance" type="Array">
        <description>Possible values for positionDirection parameter</description>
      </property>
      <property name="duration" scope="instance" type="Integer">
        <description>Number of milliseconds to show message</description>
      </property>
      <property name="slideDuration" scope="instance" type="Integer">
        <description>Number of milliseconds for the slide animation, increasing will cause the Toaster
	to slide in more slowly.</description>
      </property>
      <property name="separator" scope="instance" type="String">
        <description>String used to separate messages if consecutive calls are made to setContent before previous messages go away</description>
      </property>
      <property name="slideAnim" scope="instance" type="Object"/>
      <property name="_hideTimer" scope="instance" type="Object"/>
      <property name="_stickyMessage" scope="instance" type="Object"/>
      <property name="_scrollConnected" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.messageTypes">
    <properties>
      <property name="MESSAGE" scope="instance" type="String"/>
      <property name="WARNING" scope="instance" type="String"/>
      <property name="ERROR" scope="instance" type="String"/>
      <property name="FATAL" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.containerNode"/>
  <class type="dojox.widget.Toaster.containerNode.style">
    <properties>
      <property name="left" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.contentNode">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.clipNode">
    <properties>
      <property name="id" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.clipNode.style">
    <properties>
      <property name="height" scope="instance" type="String"/>
      <property name="width" scope="instance" type="String"/>
      <property name="top" scope="instance" type="String"/>
      <property name="left" scope="instance" type="String"/>
      <property name="clip" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.bgIframe">
    <properties>
      <property name="iframe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Toaster.bgIframe.iframe.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.UpgradeBar" superclass="dijit._Widget">
    <description>You can insert custom validations to trigger the UpgradeBar
	to display. An evaluation of 'true' shows the bar (as this
	version *is* less than it should be). Multiple validations
	may be checked, although only the first in the list will be
	displayed.
	Markup and programmatic are supported. Markup is a little
	cleaner, since a majority of the parameters are the HTML
	snippets to be displayed. In markup, the validate code should
	be an expression that will evaluate to true or false. This
	expression is wrapped in a try/catch, so if it blows up, it
	is assumed to be true and trigger the bar.
	In programmtic, a function should be used that returns true
	or false. You would need to use your own try/catch in that.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="checkNotifications" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="notify" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="instance"/>
      <method name="hide" scope="instance"/>
      <method name="_onDontRemindClick" scope="instance"/>
      <method name="_onCloseEnter" scope="instance"/>
      <method name="_onCloseLeave" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="notifications" scope="instance" type="Array">
        <description>An array of objects that hold the criteria for upgrades.
	message: String
	The message to display in the bar. Can be HTML.
	validate:Function
	The expression to evaluate to determine if the
	bar should show or not. Should be a simple expression
	if used in HTML:
		&amp;lt;div validate=&amp;quot;!google.gears&amp;quot;&amp;gt;
		&amp;lt;div validate=&amp;quot;dojo.isIE&amp;lt;8&amp;quot;&amp;gt;</description>
      </property>
      <property name="buttonCancel" scope="instance" type="String">
        <description>The HTML tip show when hovering over the close button.</description>
      </property>
      <property name="noRemindButton" scope="instance" type="String">
        <description>The text link shown that when clicked, permanently dismisses
	the message (sets a cookie). If this string is blank, this
	link is not displayed.</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_bodyMarginTop" scope="instance" type="Object"/>
      <property name="_size" scope="instance" type="Object"/>
      <property name="_showAnim" scope="instance" type="Object"/>
      <property name="_hideAnim" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard" superclass="dijit.layout.StackContainer">
    <methods>
      <method name="postMixInProperties" scope="instance"/>
      <method name="startup" scope="instance"/>
      <method name="resize" scope="instance"/>
      <method name="_checkButtons" scope="instance"/>
      <method name="_setButtonClass" scope="instance">
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_forward" scope="instance"/>
      <method name="done" scope="instance"/>
      <method name="destroy" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.StackContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="nextButtonLabel" scope="instance" type="String">
        <description>Label override for the &amp;quot;Next&amp;quot; button.</description>
      </property>
      <property name="previousButtonLabel" scope="instance" type="String">
        <description>Label override for the &amp;quot;Previous&amp;quot; button.</description>
      </property>
      <property name="cancelButtonLabel" scope="instance" type="String">
        <description>Label override for the &amp;quot;Cancel&amp;quot; button.</description>
      </property>
      <property name="doneButtonLabel" scope="instance" type="String">
        <description>Label override for the &amp;quot;Done&amp;quot; button.</description>
      </property>
      <property name="cancelFunction" scope="instance" type="Function|String">
        <description>Name of function to call if user presses cancel button.
	Cancel button is not displayed if function is not specified.</description>
      </property>
      <property name="hideDisabled" scope="instance" type="Boolean">
        <description>If true, disabled buttons are hidden; otherwise, they are assigned the
	&amp;quot;WizardButtonDisabled&amp;quot; CSS class</description>
      </property>
      <property name="_subscription" scope="instance" type="Object"/>
      <property name="_started" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard.cancelButton.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard.selectedChildWidget">
    <properties>
      <property name="isLastChild" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard.doneButton.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.Wizard.nextButton.domNode.style">
    <properties>
      <property name="display" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.WizardPane" superclass="dijit.layout.ContentPane">
    <description>An extended ContentPane with additional hooks for passing named
	functions to prevent the pane from going either forward or
	backwards.</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_onShow" scope="instance"/>
      <method name="_checkPass" scope="instance">
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="done" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit.layout.ContentPane" scope="instance"/>
    </mixins>
    <properties>
      <property name="canGoBack" scope="instance" type="Boolean">
        <description>If true, then can move back to a previous panel (by clicking the &amp;quot;Previous&amp;quot; button)</description>
      </property>
      <property name="passFunction" scope="instance" type="String">
        <description>Name of function that checks if it's OK to advance to the next panel.
	If it's not OK (for example, mandatory field hasn't been entered), then
	returns an error message (String) explaining the reason. Can return null (pass)
	or a Boolean (true == pass)</description>
      </property>
      <property name="doneFunction" scope="instance" type="String">
        <description>Name of function that is run if you press the &amp;quot;Done&amp;quot; button from this panel</description>
      </property>
    </properties>
  </class>
  <class type="dojox.widget.gauge.AnalogArcIndicator" superclass="dojox.widget.gauge.AnalogLineIndicator">
    <methods>
      <method name="_createArc" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge.AnalogLineIndicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="currentValue" scope="instance" type="Object"/>
      <property name="color" scope="instance" type="Object"/>
      <property name="shapes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.AnalogArcIndicator._gauge">
    <properties>
      <property name="max" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.AnalogArrowIndicator" superclass="dojox.widget.gauge.AnalogLineIndicator">
    <methods>
      <method name="_getShapes" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge.AnalogLineIndicator" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.widget.gauge.AnalogNeedleIndicator" superclass="dojox.widget.gauge.AnalogLineIndicator">
    <methods>
      <method name="_getShapes" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge.AnalogLineIndicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="color" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.BarIndicator" superclass="dojox.widget.gauge.BarLineIndicator">
    <methods>
      <method name="_getShapes" scope="instance"/>
      <method name="_createShapes" scope="instance">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_move" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.widget.gauge.BarLineIndicator" scope="instance"/>
    </mixins>
    <properties>
      <property name="currentValue" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.BarIndicator._gauge">
    <properties>
      <property name="max" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Gauge" superclass="dijit._Widget">
    <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a gauge component, used to display numerical data in a familiar format
	usage:
	this widget is not to be used alone. it is meant to be subclassed, such as
	dojox.widget.BarGauge or dojox.widget.AnalogGauge</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="_setTicks" scope="instance">
        <parameters>
          <parameter name="oldTicks" type="Object" usage="required"/>
          <parameter name="newTicks" type="Object" usage="required"/>
          <parameter name="label" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setMinorTicks" scope="instance">
        <parameters>
          <parameter name="ticks" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setMajorTicks" scope="instance">
        <parameters>
          <parameter name="ticks" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="instance"/>
      <method name="createSurface" scope="instance"/>
      <method name="setBackground" scope="instance">
        <description>Sets the background using the given object.  Must be the same 'type' of object
	as the original background argument.</description>
        <parameters>
          <parameter name="background" type="An" usage="required">
            <description>object in one of the two forms:
	{'color': 'color-name'}
	OR
	(for a gradient:)
	{'type': 'linear', 'colors': [{offset: 0, color:'#C0C0C0'}, {offset: 1, color: '#E0E0E0'}] }
	If background is null or undefined, this will set the fill to this._backgroundDefault</description>
          </parameter>
        </parameters>
      </method>
      <method name="addRange" scope="instance">
        <description>Creates a range (colored area on the background of the gauge)
	based on the given arguments.</description>
        <parameters>
          <parameter name="range" type="Object" usage="required">
            <description>A range is either a dojox.widget.gauge.Range object, or a object
	with similar parameters (low, high, hover, etc.).</description>
          </parameter>
        </parameters>
      </method>
      <method name="addRanges" scope="instance">
        <description>Creates a range (colored area on the background of the gauge)
	based on the given arguments.
	range:
	A range is either a dojox.widget.gauge.Range object, or a object
	with similar parameters (low, high, hover, etc.).</description>
        <parameters>
          <parameter name="ranges" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="addIndicator" scope="instance">
        <description>This method adds an indicator, such as a tick mark or needle,
	to the bar graph.</description>
        <parameters>
          <parameter name="indicator" type="Object" usage="required">
            <description>A dojox.widget.gauge._Indicator or an object with similar parameters
	(value, color, offset, etc.).</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeIndicator" scope="instance">
        <parameters>
          <parameter name="indicator" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveIndicatorToFront" scope="instance">
        <parameters>
          <parameter name="indicator" type="Object" usage="required">
            <description>A dojox.widget.gauge._Indicator or an object with similar parameters
	(value, color, offset, etc.).</description>
          </parameter>
        </parameters>
      </method>
      <method name="drawText" scope="instance">
        <parameters>
          <parameter name="txt" type="String" usage="required">
            <description>The text to be drawn</description>
          </parameter>
          <parameter name="x" type="Number" usage="required">
            <description>The x coordinate at which to place the text</description>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <description>The y coordinate at which to place the text
	align?:	String
	Indicates how to align the text
	Valid value is 'right', otherwise text is left-aligned
	vAlign?:	String
	Indicates how to align the text vertically.
	Valid value is 'top', otherwise text is bottom-aligned
	color?:	String
	Indicates the color of the text
	font?:	Object
	A font object, generally of the following format:
	{family: &amp;quot;Helvetica&amp;quot;, style: &amp;quot;italic&amp;quot;, variant: 'small-caps', weight: 'bold', size: &amp;quot;18pt&amp;quot;}</description>
          </parameter>
          <parameter name="align" type="String" usage="optional"/>
          <parameter name="vAlign" type="String" usage="optional"/>
          <parameter name="color" type="String" usage="optional"/>
          <parameter name="font" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="removeText" scope="instance">
        <parameters>
          <parameter name="t" type="String" usage="required">
            <description>The text to remove.</description>
          </parameter>
        </parameters>
      </method>
      <method name="updateTooltip" scope="instance">
        <parameters>
          <parameter name="txt" type="String" usage="required">
            <description>The text to put in the tooltip.</description>
          </parameter>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="handleMouseOver" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="handleMouseOut" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="handleMouseDown" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="handleMouseUp" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
      <method name="handleMouseMove" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <description>The event object</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="width" scope="instance" type="The">
        <description>width of the mark
	length: The length of the mark
	interval: The interval the ticks should be added on
	color: The color of the mark and text
	font: an object with any/all of the following parameters:
	{family: &amp;quot;Helvetica&amp;quot;, style: &amp;quot;italic&amp;quot;, variant: 'small-caps', weight: 'bold', size: &amp;quot;18pt&amp;quot;}</description>
      </property>
      <property name="height" scope="instance" type="Number">
        <description>the height of the gauge (default is 200)</description>
      </property>
      <property name="background" scope="instance" type="Object">
        <description>the color of the background.  This must be an object of one of two forms:
	{'color': 'color-name'}
	OR
	(for a gradient:)
	{'type': 'linear', 'x1': 0, 'x2': 0, 'y1': 0, 'y2': 200, 'colors': [{offset: 0, color:'#C0C0C0'}, {offset: 1, color: '#E0E0E0'}] }</description>
      </property>
      <property name="min" scope="instance" type="Number">
        <description>The minimum value of the gauge.  Normally not set explicitly, as it will be determined by
	the ranges that are added.</description>
      </property>
      <property name="max" scope="instance" type="Number">
        <description>The maximum value of the gauge.  Normally not set explicitly, as it will be determined by
	the ranges that are added.</description>
      </property>
      <property name="image" scope="instance" type="String">
        <description>background image for gauge (default is no image)</description>
      </property>
      <property name="useRangeStyles" scope="instance" type="Number">
        <description>indicates whether to use given css classes (dojoxGaugeRangeXX)
	to determine the color (and other style attributes?) of the ranges
	this value should be the number of dojoxGaugeRange classes that are
	defined, starting at dojoxGaugeRange1 (0 indicates falling to default
	hardcoded colors)</description>
      </property>
      <property name="useTooltip" scope="instance" type="Boolean">
        <description>indicates whether tooltips should be displayed for ranges, indicators, etc.</description>
      </property>
      <property name="majorTicks" scope="instance" type="Object">
        <description>An object representing the tick marks that should be added to the gauge. Major tick marks have a text label
	indicating the value.  The object can have the following attributes (required are marked with a *):
	offset: the distance from the 'center' of the gauge.  Used differently for Analog vs. Bar</description>
      </property>
      <property name="minorTicks" scope="instance" type="Object">
        <description>An object of the same format as majorTicks, indicating where the minor (label-less) marks should be placed
	The font parameter is ignored if provided since minor tick marks have no text label.</description>
      </property>
      <property name="_defaultIndicator" scope="instance" type="Objection">
        <description>Should be overridden by any extending classes and used to indicate what the 'default' indicator is.
	This object is used as the indicator when creating tick marks or when an anonmyous object is passed into
	addIndicator.</description>
      </property>
      <property name="defaultColors" scope="instance" type="Array">
        <description>Set of default colors to color ranges with.</description>
      </property>
      <property name="surface" scope="instance" type="Object">
        <description>The SVG/VML surface that the shapes are drawn on.  Can be accessed/used by indicators to draw themselves</description>
      </property>
      <property name="hideValues" scope="instance" type="Boolean">
        <description>indicates whether the text boxes showing the value of the indicator (as text
	content) should be hidden or shown.  Default is not hidden, aka shown.</description>
      </property>
      <property name="gaugeContent" scope="instance" type="Object"/>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="_rangeData" scope="instance" type="Array"/>
      <property name="_drag" scope="instance" type="Object"/>
      <property name="_img" scope="instance" type="Object"/>
      <property name="_overOverlay" scope="instance" type="bool"/>
      <property name="_lastHover" scope="instance" type="String"/>
      <property name="ranges" scope="instance" type="Object"/>
      <property name="indicators" scope="instance" type="Object"/>
      <property name="_background" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Gauge._backgroundDefault">
    <properties>
      <property name="color" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Gauge.gaugeContent.style">
    <properties>
      <property name="width" scope="instance" type="String"/>
      <property name="height" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Gauge._indicatorData">
    <properties>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge.Range" superclass="dijit._Widget">
    <description>a range widget, which has given properties.  drawn by a _Gauge.
	usage:
	&lt;script type="text/javascript"&gt;
	dojo.require("dojox.widget.AnalogGauge");
	dojo.require("dijit.util.parser");
	&lt;/script&gt;
	...
	&lt;div	dojoType="dojox.widget.AnalogGauge"
	id="testGauge"
	width="300"
	height="200"
	cx=150
	cy=175
	radius=125
	image="gaugeOverlay.png"
	imageOverlay="false"
	imageWidth="280"
	imageHeight="155"
	imageX="12"
	imageY="38"&gt;
	&lt;div	dojoType="dojox.widget.gauge.Range"
	low=5
	high=10
	hover="5 - 10"
	&gt;&lt;/div&gt;
	&lt;div	dojoType="dojox.widget.gauge.Range"
	low=10
	high=20
	hover="10 - 20"
	&gt;&lt;/div&gt;
	&lt;/div&gt;</description>
    <methods>
      <method name="startup" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Contained.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
    </mixins>
    <properties>
      <property name="low" scope="instance" type="Number">
        <description>the low value of the range</description>
      </property>
      <property name="high" scope="instance" type="Numbe">
        <description>the high value of the range</description>
      </property>
      <property name="hover" scope="instance" type="String">
        <description>the text to put in the tooltip for the gauge</description>
      </property>
      <property name="color" scope="instance" type="Object">
        <description>the color of the range.  This must be an object of one of two forms:
	{'color': 'color-name'}
	OR
	(for a gradient:)
	{'type': 'linear', 'colors': [{offset: 0, color:'#C0C0C0'}, {offset: 1, color: '#E0E0E0'}] }</description>
      </property>
      <property name="size" scope="instance" type="Number">
        <description>for a circular gauge (such as an AnalogGauge), this dictates the size of the arc</description>
      </property>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Indicator" superclass="dijit._Widget">
    <description>an indicator widget, which has given properties.  drawn by a gauge.
	usage:
	&lt;script type="text/javascript"&gt;
	dojo.require("dojox.widget.AnalogGauge");
	dojo.require("dijit.util.parser");
	&lt;/script&gt;
	...
	&lt;div	dojoType="dojox.widget.AnalogGauge"
	id="testGauge"
	width="300"
	height="200"
	cx=150
	cy=175
	radius=125
	image="gaugeOverlay.png"
	imageOverlay="false"
	imageWidth="280"
	imageHeight="155"
	imageX="12"
	imageY="38"&gt;
	&lt;div 	dojoType="dojox.widget.gauge.Indicator"
	value=17
	type="arrow"
	length=135
	width=3
	hover="Value: 17"
	onDragMove="handleDragMove"&gt;
	&lt;/div&gt;
	&lt;/div&gt;</description>
    <methods>
      <method name="startup" scope="instance"/>
      <method name="onDragMove" scope="instance"/>
      <method name="postCreate" scope="instance"/>
      <method name="_update" scope="instance">
        <parameters>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="update" scope="instance">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="instance">
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <description>Indicates if the drawing should not be animated (rather than teh default, to animate)</description>
          </parameter>
        </parameters>
      </method>
      <method name="remove" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Contained.prototype" scope="instance"/>
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Contained" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="value" scope="instance" type="Number">
        <description>The value (on the gauge) that this indicator should be placed at</description>
      </property>
      <property name="type" scope="instance" type="String">
        <description>The type of indicator to draw.  Varies by gauge type.  Some examples include
	&amp;quot;line&amp;quot;, &amp;quot;arrow&amp;quot;, and &amp;quot;bar&amp;quot;</description>
      </property>
      <property name="color" scope="instance" type="String">
        <description>The color of the indicator.</description>
      </property>
      <property name="label" scope="instance" type="String">
        <description>The text label for the indicator.</description>
      </property>
      <property name="length" scope="instance" type="Number">
        <description>The length of the indicator.  In the above example, the radius of the AnalogGauge
	is 125, but the length of the indicator is 135, meaning it would project beyond
	the edge of the AnalogGauge</description>
      </property>
      <property name="width" scope="instance" type="Number">
        <description>The width of the indicator.</description>
      </property>
      <property name="offset" scope="instance" type="Number">
        <description>The offset of the indicator</description>
      </property>
      <property name="hover" scope="instance" type="String">
        <description>The string to put in the tooltip when this indicator is hovered over.</description>
      </property>
      <property name="front" scope="instance" type="boolean">
        <description>Keep this indicator at the front</description>
      </property>
      <property name="easing" scope="instance" type="String|Object">
        <description>indicates the easing function to be used when animating the of an indicator.</description>
      </property>
      <property name="duration" scope="instance" type="Number">
        <description>indicates how long an animation of the indicator should take</description>
      </property>
      <property name="hideValue" scope="instance" type="bool"/>
      <property name="noChange" scope="instance" type="Boolean">
        <description>indicates whether the indicator's value can be changed.  Useful for
	a static target indicator.  Default is false (that the value can be changed).</description>
      </property>
      <property name="_gauge" scope="instance" type="Object"/>
      <property name="title" scope="instance" type="String">
        <description>The title of the indicator, to be displayed next to it's input box for the text-representation.</description>
      </property>
      <property name="templateString" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Indicator.font">
    <properties>
      <property name="family" scope="instance" type="String"/>
      <property name="size" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.widget.gauge._Indicator.valueNode">
    <properties>
      <property name="value" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.rotator">
    <methods>
      <method name="fade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="crossFade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pan" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="continuous gets a linear easing by default"/>
        </return-types>
      </method>
      <method name="panDown" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panRight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panUp" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panLeft" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFade" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="continuous gets a linear easing by default"/>
        </return-types>
      </method>
      <method name="panFadeDown" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFadeRight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFadeUp" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panFadeLeft" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideDown" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideRight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideUp" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideLeft" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeDown" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeRight" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeUp" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeLeft" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="Fade" scope="instance" type="Object"/>
      <property name="Pan" scope="instance" type="Object"/>
      <property name="PanFade" scope="instance" type="Object"/>
      <property name="Slide" scope="instance" type="Object"/>
      <property name="Wipe" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.rotator.Controller">
    <description>Displays a series of controls that send actions to a Rotator or
	AutoRotator.  The Controller supports the following controls:
	* Next pane
	* Previous pane
	* Play/Pause toggler
	* Numbered tabs
	* Titled tabs
	* Information
	You may specify any of these controls in any order.  You may also
	have multiple Controllers tied to a single Rotator instance.
	The Controller's DOM node may also be styled for positioning or
	other styled preferences.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_togglePlay" scope="instance">
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_buildInfo" scope="instance">
        <parameters>
          <parameter name="r" type="dojox.widget.Rotator" usage="required"/>
        </parameters>
      </method>
      <method name="_onUpdate" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="commands" scope="instance" type="string">
        <description>A comma-separated list of commands. Valid commands are:
	prev			An icon button to go to the previous pane.
	next			An icon button to go to the next pane.
	play/pause	A play and pause toggle icon button.
	info			Displays the current and total panes. (ie &amp;quot;1 / 4&amp;quot;)
	#				Displays a number button for each pane. (ie &amp;quot;1 2 3 4&amp;quot;)
	titles		Displays each pane's title as a tab. (ie &amp;quot;Home Services Contact Blog&amp;quot;)</description>
      </property>
      <property name="_domNode" scope="instance" type="Object"/>
      <property name="_con" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.rotator.Controller.rotator">
    <properties>
      <property name="playing" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.rotator.Controller._info">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.widget.rotator.ThumbnailController">
    <description>The ThumbnailController will look at each of the rotator's panes and
	only if the node is an &lt;img&gt; tag, then it will create an thumbnail of
	the pane's image using the &lt;img&gt; tag's "thumbsrc" or "src" attribute.
	The size of the thumbnails and the style of the selected thumbnail is
	controlled using CSS.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="instance"/>
      <method name="_onUpdate" scope="instance">
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="rotator" scope="instance-prototype" type="dojox.widget.Rotator">
        <description>An instance of a Rotator widget.</description>
      </property>
      <property name="_domNode" scope="instance" type="Object"/>
      <property name="_con" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire">
    <methods>
      <method name="register" scope="instance">
        <parameters>
          <parameter name="wireClass" type="Function|String" usage="required">
            <description>A class or full qualified class name</description>
          </parameter>
          <parameter name="key" type="String" usage="required">
            <description>A key property of arguments to create a Wire</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getClass" scope="instance">
        <description>The class is loaded by dojo.require() and returned
	by dojo.getObject().</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <description>A class name</description>
          </parameter>
        </parameters>
        <return-description>A class</return-description>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="create" scope="instance">
        <description>If 'args' specifies 'wireClass', it is used as a class or full
	qualified class name to create a Wire with 'args' as arguments.
	Otherwise, a Wire class is determined by other proeprties of 'args'
	checking if 'args' specifies a key property for a Wire class.
	If no key property found, the default Wire class is used.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to create a Wire</description>
          </parameter>
        </parameters>
        <return-description>A Wire</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="isWire" scope="instance">
        <description>If the specified object is a Wire, true is returned.
	Otherwise, false is returned.</description>
        <parameters>
          <parameter name="wire" type="Object" usage="required">
            <description>An object to check</description>
          </parameter>
        </parameters>
        <return-description>True if the object is a Wire, otherwise false</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="transfer" scope="instance">
        <description>If 'source' and/or 'target' are not Wires, Wires are created with
	them as arguments.
	A value is got through the source Wire and set through the target
	Wire.
	'defaultObject' is passed to Wires as a default root object.
	If 'defaultTargetObject' is specified, it is passed to the target
	Wire as a default root object, instead of 'defaultObject'.</description>
        <parameters>
          <parameter name="source" type="Wire|Object" usage="required">
            <description>A Wire or arguments to create a Wire for a source value</description>
          </parameter>
          <parameter name="target" type="Wire|Object" usage="required">
            <description>A Wire or arguments to create a Wire for a target value</description>
          </parameter>
          <parameter name="defaultObject" type="Object" usage="optional">
            <description>defaultTargetObject; Optional default root objects passed to Wires</description>
          </parameter>
          <parameter name="defaultTargetObject" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="connect" scope="instance">
        <description>If 'trigger' specifies 'topic', the topic is subscribed to transer
	a value on the topic.
	Otherwise, the event specified to 'event' of 'trigger' is listened
	to transfer a value.
	On the specified event or topic, transfer() is called with
	'source', 'target' and the arguments of the event or topic (as
	default root objects).</description>
        <parameters>
          <parameter name="trigger" type="Object" usage="required">
            <description>An event or topic to trigger a transfer</description>
          </parameter>
          <parameter name="source" type="Wire|Object" usage="required">
            <description>A Wire or arguments to create a Wire for a source value</description>
          </parameter>
          <parameter name="target" type="Wire|Object" usage="required">
            <description>A Wire or arguments to create a Wire for a target value</description>
          </parameter>
        </parameters>
        <return-description>A connection handle for disconnect()</return-description>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <description>If 'handle' has 'topic', the topic is unsubscribed.
	Otherwise, the listener to an event is removed.</description>
        <parameters>
          <parameter name="connection" type="Object" usage="required">
            <description>A connection handle returned by connect()</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="_defaultWireClass" scope="instance" type="String"/>
      <property name="_base" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.CompositeWire" superclass="dojox.wire.Wire">
    <description>This class has multiple child Wires for object properties or array
	elements.
	When an object with Wires is specified to 'children' property, they
	are used to get or set an object with property values.
	When an array of Wiares is specified to 'children' property, they
	are used to get or set an array with element values.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If object properties or array elements specified in 'children'
	property are not Wires, Wires are created from them as
	arguments, with 'parent' property set to this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	children:
	An object or array containing child Wires</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method calls getValue() method of the child Wires with
	'object' argument and returns an object with the values as
	properties or an arary of the values as elements.</description>
        <parameters>
          <parameter name="object" type="Object|Array" usage="required">
            <description>A root object</description>
          </parameter>
        </parameters>
        <return-description>An object or array with values</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="object" type="Object|Array" usage="required">
            <description>A root object</description>
          </parameter>
          <parameter name="value" type="Object|Array" usage="required">
            <description>An object or array with values to set</description>
          </parameter>
        </parameters>
        <return-description>'object'</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_initializeChildren" scope="instance">
        <description>If object properties or array elements specified in 'children'
	argument are not Wires, Wires are created from them as
	arguments, with 'parent' property set to this Wire instance.</description>
        <parameters>
          <parameter name="children" type="Object|Array" usage="required">
            <description>An object or array containing child Wires</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.Wire" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.DataWire" superclass="dojox.wire.Wire">
    <description>This class accesses item attributes of data stores with a dotted
	notation of attribute names specified to 'attribute' property,
	using data APIs of a data store specified to 'dataStore' property.
	The root object for this class must be an item of the data store.
	Intermediate attribute names in the dotted notation specify
	attributes for child items, which are used for repeated calls to
	data APIs until reached to a descendant attribute.
	Attribute names may have an array index, such as "a[0]", to
	identify an array element of the attribute value.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If 'dataStore' property is not specified, but 'parent' property
	is specified, 'dataStore' property is copied from the parent.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method uses a root item passed in 'object' argument and
	'attribute' property to call getValue() method of
	'dataStore'.
	If an attribute name have an array suffix ("[]"), getValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is returned, instead of the array itself.</description>
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>A root item</description>
          </parameter>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="undefined"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <description>This method uses a root item passed in 'object' argument and
	'attribute' property to identify an item.
	Then, setValue() method of 'dataStore' is called with a leaf
	attribute name and 'value' argument.
	If an attribute name have an array suffix ("[]"), setValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is set to 'value', instead of the array itself.</description>
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>A root item</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
        <return-description>'object', or 'undefined' for invalid attribute</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getAttributeValue" scope="instance">
        <description>This method uses an item passed in 'item' argument and
	'attribute' argument to call getValue() method of 'dataStore'.
	If an attribute name have an array suffix ("[]"), getValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is returned, instead of the array itself.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <description>An item
	attribute
	An attribute name</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setAttributeValue" scope="instance">
        <description>This method uses an item passed in 'item' argument and
	'attribute' argument to call setValue() method of 'dataStore'
	with 'value' argument.
	If an attribute name have an array suffix ("[]"), setValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is set to 'value', instead of the array itself.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <description>An item</description>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <description>An attribute name</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.Wire" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
      <property name="dataStore" scope="instance" type="A">
        <description>data store
	attribute:
	A dotted notation to a descendant attribute</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.TableAdapter" superclass="dojox.wire.CompositeWire">
    <description>This class has multiple child Wires for object properties or array
	elements of a table row.
	The root object for this class must be an array.
	When an object with Wires is specified to 'columns' property, they
	are used to get a row object with property values.
	When an array of Wires is specified to 'columns' property, they
	are used to get a row array with element values.
	The row values are returned in an array.
	This class only supports getValue(), but not setValue().</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If object properties or array elements specified in 'columns'
	property are not Wires, Wires are created from them as
	arguments, with 'parent' property set to this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	columns:
	An object or array containing child Wires for column values</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method iterates over an array specified to 'object'
	argument and calls getValue() method of the child Wires with
	each element of the array to get a row object or array.
	Finally, an array with the row objects or arrays are retuned.</description>
        <parameters>
          <parameter name="object" type="Array" usage="required">
            <description>A root array</description>
          </parameter>
        </parameters>
        <return-description>An array of table row value</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="object" type="Array" usage="required"/>
          <parameter name="value" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_getRow" scope="instance">
        <description>This method calls getValue() method of the child Wires to
	create a row object or array.</description>
        <parameters>
          <parameter name="object" type="Object|Array" usage="required"/>
        </parameters>
        <return-description>An array or object for a table row</return-description>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Object"/>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.CompositeWire" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.TextAdapter" superclass="dojox.wire.CompositeWire">
    <description>This class has multiple child Wires for text segment values.
	Wires in 'segments' property are used to get text segments and
	values are concatenated with an optional delimiter string specified
	to 'delimiter' property.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If array elements specified in 'segments' are not Wires, Wires
	are created from them as arguments, with 'parent' property set
	to this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	segments:
	An array containing child Wires for text segment values</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method calls getValue() method of the child Wires wuth
	'object' argument and concatenate the values with 'delimiter'
	property to return.
	arg:
	A root object</description>
        <parameters>
          <parameter name="object" type="Object|Array" usage="required"/>
        </parameters>
        <return-description>A concatinated text</return-description>
        <return-types>
          <return-type type="Object"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="object" type="Object|Array" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_addSegment" scope="instance">
        <description>This method add a text segment specified to 'segment' argument
	to a base text specified to 'text', with 'delimiter' property.</description>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <description>A base text</description>
          </parameter>
          <parameter name="segment" type="String" usage="required">
            <description>A text segment to add</description>
          </parameter>
        </parameters>
        <return-description>A concatinated text</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.CompositeWire" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
      <property name="delimiter" scope="instance" type="A">
        <description>delimiter string</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.TreeAdapter" superclass="dojox.wire.CompositeWire">
    <description>This class has multiple child Wires for tree nodes, their title and
	child nodes.
	The root object for this class must be an array.
	'node' Wires in 'nodes' property is used to identify an object
	representing a node.
	'title' Wires in 'nodes' property is used to get the title string
	of a node.
	'children' Wires in 'nodes' property is used to iterate over child
	node objects.
	The node values are returned in an array as follows:
	[
	{title: title1,
	children: [
	{title: title2,
	child: ...},
	{title: title3,
	child: ...},
	...
	]},
	...
	]
	This class only supports getValue(), but not setValue().</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If object properties ('node', 'title' and 'children') of array
	elements specified in 'nodes' property are not Wires, Wires are
	created from them as arguments, with 'parent' property set to
	this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	nodes:
	An array containing objects for child Wires for node values</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method iterates over an array specified to 'object'
	argument and calls getValue() method of 'node' Wires with each
	element of the array to get object(s) that represetns nodes.
	(If 'node' Wires are omitted, the array element is used for
	further processing.)
	Then, getValue() method of 'title' Wires are called to get
	title strings for nodes.
	(If 'title' Wires are omitted, the objects representing nodes
	are used as title strings.)
	And if an array of objects with 'node' and 'title' Wires is
	specified to 'children', it is used to gather child nodes and
	their title strings in the same way recursively.
	Finally, an array of the top-level node objects are retuned.</description>
        <parameters>
          <parameter name="object" type="Array" usage="required">
            <description>A root array</description>
          </parameter>
        </parameters>
        <return-description>An array of tree node values</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <parameters>
          <parameter name="object" type="Array" usage="required"/>
          <parameter name="value" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_initializeChildren" scope="instance">
        <description>If 'node' or 'title' properties of array elements specified in
	'children' argument are not Wires, Wires are created from them
	as arguments, with 'parent' property set to this Wire instance.
	If an array element has 'children' property, this method is
	called recursively with it.</description>
        <parameters>
          <parameter name="children" type="Array" usage="required">
            <description>An array of objects containing child Wires</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getNodes" scope="instance">
        <description>This method calls getValue() method of 'node' Wires with
	'object' argument to get object(s) that represents nodes.
	(If 'node' Wires are omitted, 'object' is used for further
	processing.)
	Then, getValue() method of 'title' Wires are called to get
	title strings for nodes.
	(If 'title' Wires are omitted, the objects representing nodes
	are used as title strings.)
	And if an array of objects with 'node' and 'title' Wires is
	specified to 'children', it is used to gather child nodes and
	their title strings in the same way recursively.
	Finally, an array of node objects are returned.</description>
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <description>An object</description>
          </parameter>
          <parameter name="child" type="Object" usage="required">
            <description>An object with child Wires</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.CompositeWire" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.Wire">
    <description>This class accesses a property of an object with a dotted notation
	specified to 'property' property, such as "a.b.c", which identifies
	a descendant property, "object.a.b.c".
	Property names in the dotted notation may have an array index, such
	as "a[0]", to identify an array element, literally, "object.a[0]".
	When a notation start with an array index, such as "[0].a", it
	specifies an array element of the root object (array),
	"object[0].a".
	This class also serves as a base class for other Wire classes,
	preparing a root object and converting a return value, so that
	sub-classes just can implement _getValue() and _setValue() called
	from getValue() and setValue() implemented by this calss.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>If 'converter' property is specified and is a string for
	a converter class, an instanceof the converter class is
	created.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	object:
	A root object (or another Wire to access a root object)
	property:
	A dotted notation to a descendant property
	type:
	A type of the return value (for the source Wire)</description>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <description>This method first determins a root object as follows:
	1. If 'object' property specified,
	1.1 If 'object' is a Wire, its getValue() method is called to
	obtain a root object.
	1.2 Otherwise, use 'object' as a root object.
	2. Otherwise, use 'defaultObject' argument.
	3. If 'property' is specified, it is used to get a property
	value.
	Then, if a sub-class implements _getValue() method, it is
	called with the root object to get the return value.
	Otherwise, the root object (typically, a property valye) is
	used for the return value.
	Finally, if 'type' property is specified, the return value is
	converted to the specified primitive type ("string", "number",
	"boolean" and "array").
	If 'converter' property is specified, its convert() method is
	called to convert the value.</description>
        <parameters>
          <parameter name="defaultObject" type="Object|Array" usage="required">
            <description>A default root object</description>
          </parameter>
        </parameters>
        <return-description>A value found</return-description>
        <return-types>
          <return-type type="anything (null, undefined, etc)"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="setValue" scope="instance">
        <description>This method first determins a root object as follows:
	1. If 'object' property specified,
	1.1 If 'object' is a Wire, its getValue() method is called to
	obtain a root object.
	1.2 Otherwise, use 'object' as a root object.
	2. Otherwise, use 'defaultObject' argument.
	3. If 'property' is specified, it is used to get a property
	value.
	Then, if a sub-class implements _setValue() method, it is
	called with the root object and 'value' argument to set
	the value.
	Otherwise, 'value' is set to a property specified with
	'property' property.
	If the root object is undefined and 'object' property is a Wire
	and a new object is created and returned by _setValue() it is
	set through 'object' (setValue() method).</description>
        <parameters>
          <parameter name="value" type="anything" usage="required">
            <description>A value to set</description>
          </parameter>
          <parameter name="defaultObject" type="Object|Array" usage="required">
            <description>A default root object</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getPropertyValue" scope="instance">
        <description>A value for 'property' of 'object' is returned.
	If 'property' ends with an array index, it is used to indentify
	an element of an array property.
	If 'object' implements getPropertyValue(), it is called with
	'property' to obtain the property value.
	If 'object' implements a getter for the property, it is called
	to obtain the property value.</description>
        <parameters>
          <parameter name="object" type="Object|Array" usage="required">
            <description>A default root object</description>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setPropertyValue" scope="instance">
        <description>'value' is set to 'property' of 'object'.
	If 'property' ends with an array index, it is used to indentify
	an element of an array property to set the value.
	If 'object' implements setPropertyValue(), it is called with
	'property' and 'value' to set the property value.
	If 'object' implements a setter for the property, it is called
	with 'value' to set the property value.</description>
        <parameters>
          <parameter name="object" type="Object|Array" usage="required">
            <description>An object</description>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
      </method>
      <method name="_useGet" scope="instance">
        <parameters>
          <parameter name="object" type="The" usage="required">
            <description>target object to set the property of.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_useSet" scope="instance">
        <parameters>
          <parameter name="object" type="The" usage="required">
            <description>target object to set the property of.</description>
          </parameter>
        </parameters>
      </method>
      <method name="_useAttr" scope="instance">
        <parameters>
          <parameter name="object" type="The" usage="required">
            <description>target object to set the property of.</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
      <property name="converter" scope="instance" type="A">
        <description>converter object (or class name) to convert the return
	value (for the source Wire)</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.XmlWire" superclass="dojox.wire.Wire">
    <description>This class accesses XML nodes or value with a simplified XPath
	specified to 'path' property.
	The root object for this class must be an DOM document or element
	node.
	"@name" accesses to an attribute value of an element and "text()"
	accesses to a text value of an element.
	The hierarchy of the elements from the root node can be specified
	with slash-separated list, such as "a/b/@c", which specifies
	the value of an attribute named "c" of an element named "b" as
	a child of another element named "a" of a child of the root node.</description>
    <methods>
      <method name="constructor" scope="instance">
        <description>'args' is just mixed in with no further processing.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>Arguments to initialize properties
	path:
	A simplified XPath to an attribute, a text or elements</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="instance">
        <description>This method first uses a root node passed in 'object' argument
	and 'path' property to identify an attribute, a text or
	elements.
	If 'path' starts with a slash (absolute), the first path
	segment is ignored assuming it point to the root node.
	(That is, "/a/b/@c" and "b/@c" against a root node access
	the same attribute value, assuming the root node is an element
	with a tag name, "a".)</description>
        <parameters>
          <parameter name="object" type="Node" usage="required">
            <description>A root node</description>
          </parameter>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="Node"/>
          <return-type type="undefined"/>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <description>This method first uses a root node passed in 'object' argument
	and 'path' property to identify an attribute, a text or
	elements.
	If an intermediate element does not exist, it creates
	an element of the tag name in the 'path' segment as a child
	node of the current node.
	Finally, 'value' argument is set to an attribute or a text
	(a child node) of the leaf element.</description>
        <parameters>
          <parameter name="object" type="Node" usage="required">
            <description>A root node</description>
          </parameter>
          <parameter name="value" type="String" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getNodeValue" scope="instance">
        <description>If 'exp' starts with '@', an attribute value of the specified
	attribute is returned.
	If 'exp' is "text()", a child text value is returned.
	Otherwise, an array of child elements, the tag name of which
	match 'exp', is returned.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A node</description>
          </parameter>
          <parameter name="exp" type="String" usage="required">
            <description>An expression for attribute, text or elements</description>
          </parameter>
        </parameters>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <return-types>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setNodeValue" scope="instance">
        <description>If 'exp' starts with '@', 'value' is set to the specified
	attribute.
	If 'exp' is "text()", 'value' is set to a child text.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A node</description>
          </parameter>
          <parameter name="exp" type="String" usage="required">
            <description>An expression for attribute or text</description>
          </parameter>
          <parameter name="value" type="String" usage="required">
            <description>A value to set</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getChildNode" scope="instance">
        <description>A child element of the tag name specified with 'name' is
	returned.
	If 'name' ends with an array index, it is used to pick up
	the corresponding element from multiple child elements.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>A parent node</description>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <description>A tag name</description>
          </parameter>
        </parameters>
        <return-description>A child node</return-description>
        <return-types>
          <return-type type="Node"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_getDocument" scope="instance">
        <description>If 'node' is specified, a DOM document of the node is returned.
	Otherwise, a DOM document is created.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-description>A DOM document</return-description>
        <return-types>
          <return-type type="Document"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.Wire" scope="instance"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire._wireClasses">
    <properties>
      <property name="attribute" scope="instance" type="String"/>
      <property name="path" scope="instance" type="String"/>
      <property name="children" scope="instance" type="String"/>
      <property name="columns" scope="instance" type="String"/>
      <property name="nodes" scope="instance" type="String"/>
      <property name="segments" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml">
    <methods>
      <method name="_getValue" scope="instance">
        <description>This method obtains an object by an ID of a widget or an DOM
	element.
	If 'source' specifies a dotted notation to its property, a Wire is
	used to get the object property.
	If 'source' starts with "arguments", 'args' is used as a root
	object for the Wire.</description>
        <parameters>
          <parameter name="source" type="String" usage="required">
            <description>A string to specify an object and its property</description>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <description>An optional arguments array</description>
          </parameter>
        </parameters>
        <return-description>A value</return-description>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="Object"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setValue" scope="instance">
        <description>This method stores a value by an ID of a widget or an DOM
	element with a dotted notation to its property, using a Wire.</description>
        <parameters>
          <parameter name="target" type="String" usage="required">
            <description>A string to specify an object and its property</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="util" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Action" superclass="dijit._Widget">
    <description>This widget represents a controller task to be run when an event
	(a function) or a topic is issued.
	Sub-classes must implement _run() method to implement their tasks.
	'trigger' specifies an event scope, an ID of a widget or an DOM
	element, or its property with the optional dotted notation.
	If this widget has child ActionFilter widgets, their filter()
	methods are called with the arguments to the event or the topic.
	If one of filter() methods returns false, run() won't be invoked.
	This widget also can serve as a composite task to run child
	Actions on an event or a topic specified to this widget.</description>
    <methods>
      <method name="postCreate" scope="instance">
        <description>See _connect().</description>
      </method>
      <method name="_connect" scope="instance">
        <description>If 'triggerEvent' and 'trigger' are specified, connect() is
	used to set up run() to be called on the event.
	If 'triggerTopic' is specified, subscribe() is used to set up
	run() to be called on the topic.</description>
      </method>
      <method name="_disconnect" scope="instance">
        <description>If 'triggerEvent' and 'trigger' are specified, disconnect() is
	used to set up run() not to be called on the event.
	If 'triggerTopic' is specified, unsubscribe() is used to set up
	run() not to be called on the topic.</description>
      </method>
      <method name="run" scope="instance">
        <description>This method calls filter() method of child ActionFilter
	widgets.
	If one of them returns false, this method returns.
	Otherwise, _run() method is called.</description>
      </method>
      <method name="_run" scope="instance">
        <description>If this widget has child Action widgets, their run() methods
	are called.</description>
      </method>
      <method name="uninitialize" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="trigger" scope="instance" type="An">
        <description>event scope</description>
      </property>
      <property name="triggerEvent" scope="instance" type="An">
        <description>event (function) name</description>
      </property>
      <property name="triggerTopic" scope="instance" type="A">
        <description>topic name</description>
      </property>
      <property name="_triggerHandle" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.ActionFilter" superclass="dijit._Widget">
    <description>This base class checks a required property specified with
	'required' attribute.
	If 'message' is specified, the message is set to a property
	specified with 'error'.
	Subclasses may implement their own filter() method.</description>
    <methods>
      <method name="filter" scope="instance">
        <description>If a value is undefined for a property, specified with
	'required', this method returns false.
	If the value for a property is defined, but there isn't a requiredValue for it
	then any non-false value will cause the method to return true.
	if requiredValue is set, then filter compares that value with the value from
	the required property and returns true if and only if they match.
	The type option just allows for a way to convert the required property values
	into a proper form for comparison (boolean, number, etc).
	If 'message' is specified, it is set to a proeprty specified
	with 'error' or shown with alert().
	If 'required' starts with "arguments", a property of
	the method arguments are checked.</description>
        <return-description>True if a required property is specified (and if requiredValue is specified,
	that they match), otherwise false</return-description>
        <return-types>
          <return-type type="Boolean"/>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="required" scope="instance" type="A">
        <description>property required</description>
      </property>
      <property name="requiredValue" scope="instance" type="Optional">
        <description>A specific value the property is required to have.  If this isn't provided
	than any non-false/non-null value of the required propery will cause this filter
	to pass.</description>
      </property>
      <property name="type" scope="instance" type="Optional">
        <description>A specific type to compare the values as (if requiredValue is set)
	Valid values for type are boolean, int, string.  Default is string.</description>
      </property>
      <property name="message" scope="instance" type="An">
        <description>error message to emit if the filter doesn't execute due to property mismatch.</description>
      </property>
      <property name="error" scope="instance" type="A">
        <description>property to store an error due to property mismatch.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.Data" superclass="dijit._Widget">
    <description>This widget represents an object with '_properties' property.
	If child 'DataProperty' widgets exist, they are used to initialize
	propertiy values of '_properties' object.</description>
    <methods>
      <method name="startup" scope="instance">
        <description>See _initializeProperties().</description>
      </method>
      <method name="_initializeProperties" scope="instance">
        <description>If this widget has child DataProperty widgets, their getValue()
	methods are called and set the return value to a property
	specified by 'name' attribute of the child widgets.</description>
        <parameters>
          <parameter name="reset" type="Boolean" usage="required">
            <description>A boolean to reset current properties</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPropertyValue" scope="instance">
        <description>This method returns the value of a property, specified with
	'property' argument, in '_properties' object.</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
        </parameters>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="setPropertyValue" scope="instance">
        <description>This method stores 'value' as a property, specified with
	'property' argument, in '_properties' object.</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <description>A property value</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="_properties" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.DataProperty" superclass="dijit._Widget">
    <description>Attributes of this widget are used to add a property to the parent
	Data widget.
	'type' attribute specifies one of "string", "number", "boolean",
	"array", "object" and "element" (DOM Element)
	(default to "string").
	If 'type' is "array" or "object", child DataProperty widgets are
	used to initialize the array elements or the object properties.</description>
    <methods>
      <method name="_getValueAttr" scope="instance"/>
      <method name="getValue" scope="instance">
        <description>If 'type' is specified, 'value' attribute is converted to
	the specified type and returned.
	Otherwise, 'value' attribute is returned as is.</description>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="name" scope="instance" type="A">
        <description>property name</description>
      </property>
      <property name="type" scope="instance" type="A">
        <description>property type name</description>
      </property>
      <property name="value" scope="instance" type="A">
        <description>property value</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.DataStore" superclass="dijit._Widget">
    <description>This widget represents a data store of 'storeClass' attribute.</description>
    <methods>
      <method name="postCreate" scope="instance">
        <description>See _createStore().</description>
      </method>
      <method name="_createStore" scope="instance">
        <return-description>A data store</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="instance">
        <description>See dojo.data.api.Read.getFeatures().</description>
        <return-description>A features object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="fetch" scope="instance">
        <description>See dojo.data.api.Read.fetch().</description>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <description>A request object</description>
          </parameter>
        </parameters>
        <return-description>A request object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="save" scope="instance">
        <description>See dojo.data.api.Write.save().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>A save arguments object</description>
          </parameter>
        </parameters>
      </method>
      <method name="newItem" scope="instance">
        <description>See dojo.data.api.Write.newItem().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <description>A new item arguments object</description>
          </parameter>
        </parameters>
        <return-description>A new item</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="instance">
        <description>See dojo.data.api.Write.deleteItem().</description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-description>A boolean</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="revert" scope="instance">
        <description>See dojo.data.api.Write.revert().</description>
        <return-description>A boolean</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="storeClass" scope="instance" type="A">
        <description>class name of a data store</description>
      </property>
      <property name="store" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.DataStore.domNode">
    <properties>
      <property name="attributes" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Invocation" superclass="dojox.wire.ml.Action">
    <description>This widget represents a controller task to invoke a method or
	publish a topic when an event (a function) or a topic is issued.</description>
    <methods>
      <method name="_run" scope="instance">
        <description>If 'topic' is specified, the topic is published with arguments
	specified to 'parameters'.
	If 'method' and 'object' are specified, the method is invoked
	with arguments specified to 'parameters' and set the return
	value to a property specified to 'result'.
	'object', 'parameters' and 'result' can specify properties of
	a widget or an DOM element with the dotted notation.
	If 'parameters' are omitted, the arguments to this method are
	passed as is.</description>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="onComplete" scope="instance">
        <description>If 'result' attribute is specified, the result object also set
	to the specified property.</description>
        <parameters>
          <parameter name="result" type="anything" usage="required">
            <description>The return value of a method or undefined for a topic</description>
          </parameter>
        </parameters>
      </method>
      <method name="onError" scope="instance">
        <description>If 'error' attribute is specified, the error object also set to
	the specified property.</description>
        <parameters>
          <parameter name="error" type="anything" usage="required">
            <description>The exception or error occurred</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getParameters" scope="instance">
        <description>This method retunrs an array of arguments specified by
	'parameters' attribute, a comma-separated list of IDs and
	their properties in a dotted notation.
	If 'parameters' are omitted, the original arguments are
	used.</description>
        <parameters>
          <parameter name="args" type="Array" usage="required">
            <description>Arguments to a trigger event or topic</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.Action" scope="instance"/>
    </mixins>
    <properties>
      <property name="object" scope="instance" type="A">
        <description>scope of a method to invoke</description>
      </property>
      <property name="method" scope="instance" type="A">
        <description>name of a method to invoke</description>
      </property>
      <property name="topic" scope="instance" type="A">
        <description>name of a topic to publish</description>
      </property>
      <property name="parameters" scope="instance" type="Arguments">
        <description>for the method or the topic</description>
      </property>
      <property name="result" scope="instance" type="A">
        <description>property to store a return value of the method call</description>
      </property>
      <property name="error" scope="instance" type="A">
        <description>property to store an error on the method call</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.Service" superclass="dijit._Widget">
    <description>This widget represents a service defined by a service description
	specified with 'url' attribute.
	If 'serviceType' and 'serviceUrl' attributes are specified, 'url'
	attribute can be omitted.</description>
    <methods>
      <method name="postCreate" scope="instance">
        <description>See _createHandler().</description>
      </method>
      <method name="_createHandler" scope="instance">
        <return-description>A service handler</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="callMethod" scope="instance">
        <parameters>
          <parameter name="method" type="A" usage="required">
            <description>method name</description>
          </parameter>
          <parameter name="parameters" type="An" usage="required">
            <description>array parameters</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="url" scope="instance" type="A">
        <description>URL to a service description</description>
      </property>
      <property name="serviceUrl" scope="instance" type="A">
        <description>URL to a service</description>
      </property>
      <property name="serviceType" scope="instance" type="A">
        <description>service type</description>
      </property>
      <property name="handlerClass" scope="instance" type="A">
        <description>service handler class name</description>
      </property>
      <property name="preventCache" scope="instance" type="Object"/>
      <property name="handler" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Service._handlerClasses">
    <properties>
      <property name="TEXT" scope="instance" type="String"/>
      <property name="XML" scope="instance" type="String"/>
      <property name="JSON" scope="instance" type="String"/>
      <property name="JSON-RPC" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.RestHandler">
    <description>This class serves as a base REST service.
	Sub-classes may override _getContent() and _getResult() to handle
	specific content types.</description>
    <methods>
      <method name="bind" scope="instance">
        <description>A service is called with a URL generated by _getUrl() and
	an HTTP method specified with 'method'.
	For "POST" and "PUT", a content is generated by _getContent().
	When data is loaded, _getResult() is used to pass the result to
	Deferred.callback().</description>
        <parameters>
          <parameter name="method" type="A" usage="required">
            <description>method name</description>
          </parameter>
          <parameter name="parameters" type="An" usage="required">
            <description>array of parameters</description>
          </parameter>
          <parameter name="deferred" type="'Deferred'" usage="required"/>
          <parameter name="url" type="A" usage="required">
            <description>URL for the method</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getUrl" scope="instance">
        <description>If 'method' is "GET" or "DELETE", a query string is generated
	from a query object specified to the first parameter in
	'parameters' and appended to 'url'.
	If 'url' contains variable seguments ("{parameter_name}"),
	they are replaced with corresponding parameter values, instead.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>A method name</description>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <description>An array of parameters</description>
          </parameter>
          <parameter name="url" type="String" usage="required">
            <description>A base URL</description>
          </parameter>
        </parameters>
        <return-description>A URL</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getContent" scope="instance">
        <description>If 'method' is "POST" or "PUT", the first parameter in
	'parameters' is returned.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>A method name</description>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <description>An array of parameters</description>
          </parameter>
        </parameters>
        <return-description>A request content</return-description>
        <return-types>
          <return-type type="anything"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_getResult" scope="instance">
        <description>A response data is returned as is.</description>
        <parameters>
          <parameter name="data" type="anything" usage="required">
            <description>A response data returned by a service</description>
          </parameter>
        </parameters>
        <return-description>A result object</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
    </methods>
    <properties>
      <property name="contentType" scope="instance" type="String"/>
      <property name="handleAs" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.XmlHandler" superclass="dojox.wire.ml.RestHandler">
    <description>This class provides XML handling for a REST service.</description>
    <methods>
      <method name="_getContent" scope="instance">
        <description>If 'method' is "POST" or "PUT", the first parameter in
	'parameters' is used to generate an XML content.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>A method name</description>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <description>An array of parameters</description>
          </parameter>
        </parameters>
        <return-description>A request content</return-description>
      </method>
      <method name="_getResult" scope="instance">
        <description>A response data (XML Document) is returned wrapped with
	XmlElement.</description>
        <parameters>
          <parameter name="data" type="Document" usage="required">
            <description>A response data returned by a service</description>
          </parameter>
        </parameters>
        <return-description>A result object</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.RestHandler" scope="instance"/>
    </mixins>
    <properties>
      <property name="contentType" scope="instance" type="String"/>
      <property name="handleAs" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.JsonHandler" superclass="dojox.wire.ml.RestHandler">
    <description>This class provides JSON handling for a REST service.</description>
    <methods>
      <method name="_getContent" scope="instance">
        <description>If 'method' is "POST" or "PUT", the first parameter in
	'parameter' is used to generate a JSON content.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <description>A method name</description>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <description>An array of parameters</description>
          </parameter>
        </parameters>
        <return-description>A request content</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.RestHandler" scope="instance"/>
    </mixins>
    <properties>
      <property name="contentType" scope="instance" type="String"/>
      <property name="handleAs" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.JsonHandler.headers">
    <properties>
      <property name="Accept" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.Transfer" superclass="dojox.wire.ml.Action">
    <description>This widget represents a controller task to transfer a value from
	a source to a target, through a source and a target Wires, when
	an event (a function) or a topic is issued.
	If this widget has child ChildWire widgets, their _addWire()
	methods are called to add Wire arguments to a source or a target
	Wire.</description>
    <methods>
      <method name="_run" scope="instance">
        <description>First, Wires for a source and a target are created from attributes.
	Then, a value is obtained by getValue() of the source Wire is set
	by setValue() of the target Wire.
	The arguments to this method is passed to getValue() and setValue()
	of Wires, so that they can be used to identify the root objects off
	the arguments.</description>
      </method>
      <method name="_getWire" scope="instance">
        <description>Arguments object for a source or a target Wire, specified by
	'which' argument, are build from corresponding attributes,
	including '*Store' (for 'dataStore'), '*Attribute'
	(for 'attribute), '*Path' (for 'path'), 'type' and 'converter'.
	'source' or 'target' attribute is parsed as:
	"object_id.property_name[.sub_property_name...]"
	If 'source' or 'target' starts with "arguments", 'object'
	argument for a Wire is set to null, so that the root object is
	given as an event or topic arguments.
	If this widget has child ChildWire widgets with a corresponding
	'which' attribute, their _addWire() methods are called to add
	additional Wire arguments and nested Wire is created,
	specifying the Wire defined by this widget to 'object' argument.</description>
        <parameters>
          <parameter name="which" type="String" usage="required">
            <description>Which Wire arguments to build, &amp;quot;source&amp;quot; or &amp;quot;target&amp;quot;</description>
          </parameter>
        </parameters>
        <return-description>Wire arguments object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.Action" scope="instance"/>
    </mixins>
    <properties>
      <property name="source" scope="instance" type="A">
        <description>source object and/or property</description>
      </property>
      <property name="sourceStore" scope="instance" type="A">
        <description>data store for a source data item</description>
      </property>
      <property name="sourceAttribute" scope="instance" type="An">
        <description>attribute of a source data item</description>
      </property>
      <property name="sourcePath" scope="instance" type="A">
        <description>simplified XPath to a source property of an XML element</description>
      </property>
      <property name="type" scope="instance" type="A">
        <description>type of the value to be transferred</description>
      </property>
      <property name="converter" scope="instance" type="A">
        <description>class name of a converter for the value to be transferred</description>
      </property>
      <property name="delimiter" scope="instance" type="String"/>
      <property name="target" scope="instance" type="A">
        <description>target object and/or property</description>
      </property>
      <property name="targetStore" scope="instance" type="A">
        <description>data store for a target data item</description>
      </property>
      <property name="targetAttribute" scope="instance" type="An">
        <description>attribute of a target data item</description>
      </property>
      <property name="targetPath" scope="instance" type="A">
        <description>simplified XPath to a target property of an XML element</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.ChildWire" superclass="dijit._Widget">
    <description>Attributes of this widget are used to add a child Wire to
	a composite Wire of the parent Transfer widget.</description>
    <methods>
      <method name="_addWire" scope="instance">
        <description>If 'name' attribute is specified, a child Wire is added as
	the named property of 'children' object of 'args'.
	Otherwise, a child Wire is added to 'children' array of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <description>Wire arguments</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getWire" scope="instance">
        <description>Arguments object for a child Wire are build from attributes,
	including 'object', 'property', 'type', 'converter',
	'attribute' and 'path'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
        </parameters>
        <return-description>Wire arguments object</return-description>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Widget" scope="instance"/>
    </mixins>
    <properties>
      <property name="which" scope="instance" type="Which">
        <description>Wire to add a child Wire, &amp;quot;source&amp;quot; or &amp;quot;target&amp;quot;, default to
	&amp;quot;source&amp;quot;</description>
      </property>
      <property name="object" scope="instance" type="A">
        <description>root object for the value</description>
      </property>
      <property name="property" scope="instance" type="A">
        <description>property for the value</description>
      </property>
      <property name="type" scope="instance" type="A">
        <description>type of the value</description>
      </property>
      <property name="converter" scope="instance" type="A">
        <description>class name of a converter for the value</description>
      </property>
      <property name="attribute" scope="instance" type="A">
        <description>data item attribute for the value</description>
      </property>
      <property name="path" scope="instance" type="A">
        <description>simplified XPath for the value</description>
      </property>
      <property name="name" scope="instance" type="A">
        <description>composite property name</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.ColumnWire" superclass="dojox.wire.ml.ChildWire">
    <description>Attributes of this widget are used to add a column Wire to
	a TableAdapter of the parent Transfer widget.</description>
    <methods>
      <method name="_addWire" scope="instance">
        <description>If 'column' attribute is specified, a column Wire is added as
	the named property of 'columns' object of 'args'.
	Otherwise, a column Wire is added to 'columns' array of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <description>Wire arguments</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.ChildWire" scope="instance"/>
    </mixins>
    <properties>
      <property name="column" scope="instance" type="A">
        <description>column name</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.NodeWire" superclass="dojox.wire.ml.ChildWire">
    <description>Attributes of this widget are used to add node Wires to
	a TreeAdapter of the parent Transfer widget.</description>
    <methods>
      <method name="_addWire" scope="instance">
        <description>Node Wires are added to 'nodes' array of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <description>Wire arguments</description>
          </parameter>
        </parameters>
      </method>
      <method name="_getWires" scope="instance">
        <description>Arguments object for 'node' Wire are build from attributes,
	including 'object', 'property', 'type', 'converter',
	'attribute' and 'path'.
	Arguments object for 'title' Wire are build from another set of
	attributes, 'titleProperty', 'titleAttribute' and 'titlePath'.
	If this widget has child NodeWire widgets, their _getWires()
	methods are called recursively to build 'children' array of
	'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
        </parameters>
        <return-description>Wire arguments object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Container.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.ChildWire" scope="instance"/>
      <mixin type="dijit._Container" scope="instance"/>
    </mixins>
    <properties>
      <property name="titleProperty" scope="instance" type="A">
        <description>property for the node title</description>
      </property>
      <property name="titleAttribute" scope="instance" type="A">
        <description>data item attribute for the node title</description>
      </property>
      <property name="titlePath" scope="instance" type="A">
        <description>simplified XPath for the node title</description>
      </property>
    </properties>
  </class>
  <class type="dojox.wire.ml.SegmentWire" superclass="dojox.wire.ml.ChildWire">
    <description>Attributes of this widget are used to add a segment Wire to
	a TextAdapter of the parent Transfer widget.</description>
    <methods>
      <method name="_addWire" scope="instance">
        <description>A segment Wire is added to 'segments' array of 'args'.
	If 'parent' has 'delimiter' attribute, it is used for
	'delimiter' property of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <description>A parent Transfer widget</description>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <description>Wire arguments</description>
          </parameter>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.wire.ml.ChildWire" scope="instance"/>
    </mixins>
  </class>
  <class type="dojox.wire.ml.XmlElement">
    <description>This class represents an XML element.</description>
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="element" type="Element|String" usage="required">
            <description>An XML element or a tag name</description>
          </parameter>
        </parameters>
      </method>
      <method name="getPropertyValue" scope="instance">
        <description>If 'property' starts with '@', the attribute value is returned.
	If 'property' specifies "text()", the value of the first child
	text is returned.
	Otherwise, child elements of the tag name specified with
	'property' are returned.</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
        </parameters>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="String"/>
          <return-type type="Object"/>
          <return-type type="Array"/>
          <return-type type="XmlElement"/>
        </return-types>
      </method>
      <method name="setPropertyValue" scope="instance">
        <description>If 'property' starts with '@', 'value' is set to the attribute.
	If 'property' specifies "text()", 'value' is set as the first
	child text.
	If 'value' is a string, a child element of the tag name
	specified with 'property' is created and 'value' is set as
	the first child text of the child element.
	Otherwise, 'value' is set to as child elements.</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <description>A property name</description>
          </parameter>
          <parameter name="value" type="String|Array|XmlElement" usage="required">
            <description>A property value</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <description>A value of the first text child of the element is returned.</description>
        <return-description>A value of the first text child of the element</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toObject" scope="instance">
        <description>An object with properties for child elements, attributes and
	text is returned.</description>
        <return-description>An object representation of the element</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_getDocument" scope="instance">
        <description>If 'element' is specified, a DOM document of the element is
	returned.
	Otherwise, a DOM document is created.</description>
        <return-description>A DOM document</return-description>
        <return-types>
          <return-type type="Document"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.wire.ml.XmlElement.element"/>
  <class type="dojox.wire.ml.XmlElement.element.firstChild">
    <properties>
      <property name="nodeValue" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.wire.ml.XmlElement.element.attributes">
    <properties>
      <property name="length" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.xml">
    <properties>
      <property name="DomParser" scope="instance" type="Object"/>
      <property name="widgetParser" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xml.Script">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xml.parser">
    <methods>
      <method name="parse" scope="instance">
        <parameters>
          <parameter name="str" type="String" usage="optional">
            <description>Optional text to create the document from.  If not provided, an empty XML document will be created.
	If str is empty string &amp;quot;&amp;quot;, then a new empty document will be created.</description>
          </parameter>
          <parameter name="mimetype" type="String" usage="optional">
            <description>Optional mimetype of the text.  Typically, this is text/xml.  Will be defaulted to text/xml if not provided.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="textContent" scope="instance">
        <description>Implementation of the DOM Level 3 attribute; scan node for text
	This function can also update the text of a node by replacing all child
	content of the node.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The node to get the text off of or set the text on.</description>
          </parameter>
          <parameter name="text" type="String" usage="optional">
            <description>Optional argument of the text to apply to the node.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="replaceChildren" scope="instance">
        <description>Removes all children of node and appends newChild. All the existing
	children will be destroyed.</description>
        <parameters>
          <parameter name="node" type="Element" usage="required">
            <description>The node to modify the children on</description>
          </parameter>
          <parameter name="newChildren" type="Node" usage="required">
            <description>The children to add to the node.  It can either be a single Node or an
	array of Nodes.</description>
          </parameter>
        </parameters>
      </method>
      <method name="removeChildren" scope="instance">
        <parameters>
          <parameter name="node" type="Element" usage="required">
            <description>The node to remove all the children from.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="innerXML" scope="instance">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <description>The node from which to generate the XML text representation.</description>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp"/>
  <class type="dojox.xmpp.ChatService">
    <methods>
      <method name="constructor" scope="instance"/>
      <method name="recieveMessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="initial" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setSession" scope="instance">
        <parameters>
          <parameter name="session" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setState" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="invite" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendChatState" scope="instance">
        <parameters>
          <parameter name="state" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onNewMessage" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onInvite" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="state" scope="instance-prototype" type="String"/>
      <property name="session" scope="instance" type="Object"/>
      <property name="uid" scope="instance" type="Object"/>
      <property name="_currentState" scope="instance" type="Object"/>
      <property name="chatid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.chat">
    <properties>
      <property name="CHAT_STATE_NS" scope="instance" type="String"/>
      <property name="ACTIVE_STATE" scope="instance" type="String"/>
      <property name="COMPOSING_STATE" scope="instance" type="String"/>
      <property name="INACTIVE_STATE" scope="instance" type="String"/>
      <property name="PAUSED_STATE" scope="instance" type="String"/>
      <property name="GONE_STATE" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.PresenceService">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="xmppService" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="publish" scope="instance">
        <parameters>
          <parameter name="presence" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendAvatarHash" scope="instance">
        <parameters>
          <parameter name="avatarHash" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setPresence" scope="instance"/>
      <method name="toggleBlockContact" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="toggleContactInvisiblity" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_createRestrictedJid" scope="instance"/>
      <method name="_updateRestricted" scope="instance"/>
      <method name="_setVisible" scope="instance"/>
      <method name="_setInvisible" scope="instance"/>
      <method name="_manageSubscriptions" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="approveSubscription" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribe" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="declineSubscription" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="cancelSubscription" scope="instance">
        <parameters>
          <parameter name="contact" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="avatarHash" scope="instance-prototype" type="Object"/>
      <property name="isInvisible" scope="instance-prototype" type="bool"/>
      <property name="session" scope="instance" type="Object"/>
      <property name="restrictedContactjids" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.PresenceService.presence">
    <properties>
      <property name="priority" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.xmpp.presence">
    <properties>
      <property name="UPDATE" scope="instance" type="Number"/>
      <property name="SUBSCRIPTION_REQUEST" scope="instance" type="Number"/>
      <property name="SUBSCRIPTION_SUBSTATUS_NONE" scope="instance" type="Number"/>
      <property name="SUBSCRIPTION_NONE" scope="instance" type="String"/>
      <property name="SUBSCRIPTION_FROM" scope="instance" type="String"/>
      <property name="SUBSCRIPTION_TO" scope="instance" type="String"/>
      <property name="SUBSCRIPTION_BOTH" scope="instance" type="String"/>
      <property name="SUBSCRIPTION_REQUEST_PENDING" scope="instance" type="203">
        <description>used when 'ask' attribute is absent on a roster item</description>
      </property>
      <property name="STATUS_ONLINE" scope="instance" type="String"/>
      <property name="STATUS_AWAY" scope="instance" type="String"/>
      <property name="STATUS_CHAT" scope="instance" type="String"/>
      <property name="STATUS_DND" scope="instance" type="String"/>
      <property name="STATUS_EXTENDED_AWAY" scope="instance" type="String"/>
      <property name="STATUS_OFFLINE" scope="instance" type="String"/>
      <property name="STATUS_INVISIBLE" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.RosterService">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="xmppSession" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRosterItem" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="groups" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateRosterItem" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="name" type="Object" usage="required"/>
          <parameter name="groups" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="verifyRoster" scope="instance">
        <parameters>
          <parameter name="res" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addRosterItemToGroup" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterGroup" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renameRosterGroup" scope="instance">
        <parameters>
          <parameter name="group" type="Object" usage="required"/>
          <parameter name="newGroup" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterItemFromGroup" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="group" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rosterItemRenameGroup" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="oldGroup" type="Object" usage="required"/>
          <parameter name="newGroup" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="renameRosterItem" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
          <parameter name="newName" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterItem" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getAvatar" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="publishAvatar" scope="instance">
        <parameters>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="binval" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onVerifyRoster" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onVerifyRosterFailed" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp.RosterService.session">
    <properties>
      <property name="roster" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.roster">
    <properties>
      <property name="ADDED" scope="instance" type="Number"/>
      <property name="CHANGED" scope="instance" type="Number"/>
      <property name="REMOVED" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession">
    <methods>
      <method name="_sendLogin" scope="instance"/>
      <method name="_sendRestart" scope="instance"/>
      <method name="processScriptSrc" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="instance">
        <parameters>
          <parameter name="protocolMsg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="redispatchPacket" scope="instance">
        <parameters>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addToOutboundQueue" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeFromOutboundQueue" scope="instance">
        <parameters>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processInboundQueue" scope="instance"/>
      <method name="addToInboundQueue" scope="instance">
        <parameters>
          <parameter name="doc" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processProtocolResponse" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isTerminated" scope="instance"/>
      <method name="onTerminate" scope="instance">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onProcessProtocolResponse" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onReady" scope="instance">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="rid" scope="instance" type="Number"/>
      <property name="hold" scope="instance" type="Number"/>
      <property name="polling" scope="instance" type="Number"/>
      <property name="secure" scope="instance" type="bool"/>
      <property name="wait" scope="instance" type="Number"/>
      <property name="lang" scope="instance" type="String"/>
      <property name="submitContentType" scope="instance" type="String"/>
      <property name="serviceUrl" scope="instance" type="String"/>
      <property name="defaultResource" scope="instance" type="String"/>
      <property name="domain" scope="instance" type="String"/>
      <property name="sendTimeout" scope="instance-prototype" type="Number"/>
      <property name="useScriptSrcTransport" scope="instance" type="bool"/>
      <property name="keepAliveTimer" scope="instance" type="Object"/>
      <property name="state" scope="instance" type="String"/>
      <property name="transmitState" scope="instance" type="String"/>
      <property name="protocolPacketQueue" scope="instance" type="Array"/>
      <property name="outboundQueue" scope="instance" type="Array"/>
      <property name="outboundRequests" scope="instance" type="Object"/>
      <property name="inboundQueue" scope="instance" type="Array"/>
      <property name="deferredRequests" scope="instance" type="Object"/>
      <property name="matchTypeIdAttribute" scope="instance" type="Object"/>
      <property name="transportIframes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.open">
    <methods/>
    <properties>
      <property name="status" scope="instance" type="String"/>
      <property name="rid" scope="instance" type="Object"/>
      <property name="protocolPacketQueue" scope="instance" type="Array"/>
      <property name="outboundQueue" scope="instance" type="Array"/>
      <property name="outboundRequests" scope="instance" type="Object"/>
      <property name="inboundQueue" scope="instance" type="Array"/>
      <property name="deferredRequests" scope="instance" type="Object"/>
      <property name="matchTypeIdAttribute" scope="instance" type="Object"/>
      <property name="keepAliveTimer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession._keepAlive">
    <methods/>
    <properties>
      <property name="keepAliveTimer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.dispatchPacket">
    <methods/>
    <properties>
      <property name="dispatchTimer" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession._dispatchPacket">
    <methods/>
    <properties>
      <property name="dispatchTimer" scope="instance" type="Object"/>
      <property name="lastPollTime" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.processProtocolPacketQueue">
    <methods/>
    <properties>
      <property name="protocolPacketQueue" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.sendXml">
    <methods/>
    <properties>
      <property name="transmitState" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.processDocument">
    <methods/>
    <properties>
      <property name="transmitState" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.processDocument.outboundQueue.0">
    <properties>
      <property name="rid" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.processResponse">
    <methods/>
    <properties>
      <property name="sid" scope="instance" type="Object"/>
      <property name="authId" scope="instance" type="Object"/>
      <property name="wait" scope="instance" type="Object"/>
      <property name="polling" scope="instance" type="Number"/>
      <property name="inactivity" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.setState">
    <methods/>
    <properties>
      <property name="state" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.TransportSession.processError">
    <methods/>
    <properties>
      <property name="transmitState" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.UserService">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="xmppService" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getPersonalProfile" scope="instance"/>
      <method name="setPersonalProfile" scope="instance">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetPersonalProfile" scope="instance">
        <parameters>
          <parameter name="response" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetPersonalProfile" scope="instance">
        <parameters>
          <parameter name="id" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetPersonalProfileFailure" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onGetPersonalProfile" scope="instance">
        <parameters>
          <parameter name="profile" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onGetPersonalProfile" scope="instance">
        <parameters>
          <parameter name="profile" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onGetPersonalProfileFailure" scope="instance">
        <parameters>
          <parameter name="err" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="session" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.bosh">
    <methods>
      <method name="_iframeOnload" scope="instance">
        <parameters>
          <parameter name="index" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="findOpenIframe" scope="instance"/>
      <method name="handle" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="rid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="instance">
        <parameters>
          <parameter name="args" type="dojox.xmpp.bosh.__ioArgs" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="_makeScriptDeferred" scope="instance">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_deferredCancel" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredOk" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredError" scope="instance">
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_addDeadScript" scope="instance">
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_validCheck" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_ioCheck" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_resHandle" scope="instance">
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="transportIframes" scope="instance" type="Array"/>
      <property name="_deadScripts" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.xmpp.bosh.__initArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <properties>
      <property name="iframes" scope="instance" type="The">
        <description>number of iframes to use for transmission</description>
      </property>
      <property name="load" scope="instance" type="The">
        <description>function called when the first iframe is
	loaded.  Generally used to signal when to send
	login information</description>
      </property>
    </properties>
  </class>
  <class type="dojox.xmpp.bosh.__ioArgs" superclass="dojo.__IoArgs">
    <methods>
      <method name="constructor" scope="instance"/>
    </methods>
    <mixins scope="instance">
      <mixin type="dojo.__IoArgs" scope="instance"/>
    </mixins>
    <properties>
      <property name="rid" scope="instance" type="The">
        <description>rid of the message being sent.</description>
      </property>
    </properties>
  </class>
  <class type="dojox.xmpp.bosh.initialize">
    <methods/>
    <properties>
      <property name="transportIframes" scope="instance" type="Array"/>
    </properties>
  </class>
  <class type="dojox.xmpp.sasl">
    <properties>
      <property name="saslNS" scope="instance" type="String"/>
      <property name="registry" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.sasl._Base">
    <methods>
      <method name="constructor" scope="instance">
        <parameters>
          <parameter name="session" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startAuth" scope="instance"/>
      <method name="appendToAuth" scope="instance">
        <parameters>
          <parameter name="auth" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChallenge" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstChallenge" scope="instance"/>
      <method name="onSecondChallenge" scope="instance"/>
      <method name="onSuccess" scope="instance"/>
    </methods>
    <properties>
      <property name="mechanism" scope="instance" type="Object"/>
      <property name="closeAuthTag" scope="instance" type="Object"/>
      <property name="first_challenge" scope="instance" type="Object"/>
      <property name="session" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.sasl.SunWebClientAuth" superclass="dojox.xmpp.sasl._Base">
    <methods/>
    <mixins scope="instance">
      <mixin type="dojox.xmpp.sasl._Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="mechanism" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.sasl.Plain" superclass="dojox.xmpp.sasl._Base">
    <methods>
      <method name="appendToAuth" scope="instance">
        <parameters>
          <parameter name="auth" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.xmpp.sasl._Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="mechanism" scope="instance" type="String"/>
      <property name="closeAuthTag" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.xmpp.sasl.DigestMD5" superclass="dojox.xmpp.sasl._Base">
    <methods>
      <method name="onFirstChallenge" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSecondChallenge" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dojox.xmpp.sasl._Base" scope="instance"/>
    </mixins>
    <properties>
      <property name="mechanism" scope="instance" type="String"/>
      <property name="rspauth" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.util">
    <methods>
      <method name="xmlEncode" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="encodeJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decodeJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createElement" scope="instance">
        <parameters>
          <parameter name="tag" type="Object" usage="required"/>
          <parameter name="attributes" type="Object" usage="required"/>
          <parameter name="terminal" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="stripHtml" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decodeHtmlEntities" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="htmlToPlain" scope="instance">
        <parameters>
          <parameter name="str" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp.util.Base64">
    <methods>
      <method name="encode" scope="instance">
        <parameters>
          <parameter name="input" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="decode" scope="instance">
        <parameters>
          <parameter name="input" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </class>
  <class type="dojox.xmpp.widget"/>
  <class type="dojox.xmpp.widget.ChatSession" superclass="dijit.layout.LayoutContainer">
    <methods>
      <method name="postCreate" scope="instance"/>
      <method name="displayMessage" scope="instance">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="goToLastMessage" scope="instance"/>
      <method name="onKeyPress" scope="instance">
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <mixins scope="instance">
      <mixin type="dijit._Templated.prototype" scope="instance"/>
    </mixins>
    <mixins scope="instance">
      <mixin type="dijit.layout.LayoutContainer" scope="instance"/>
      <mixin type="dijit._Templated" scope="instance"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance" type="Object"/>
      <property name="enableSubWidgets" scope="instance" type="Object"/>
      <property name="widgetsInTemplate" scope="instance" type="Object"/>
      <property name="widgetType" scope="instance" type="String"/>
      <property name="chatWith" scope="instance" type="Object"/>
      <property name="instance" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.widget.ChatSession.messages.domNode">
    <properties>
      <property name="scrollTop" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.widget.ChatSession.chatInput">
    <properties>
      <property name="value" scope="instance" type="String"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession">
    <methods>
      <method name="processProtocolResponse" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="messageHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iqHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="presenceHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="saslHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendRestart" scope="instance"/>
      <method name="simpleMessageHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerChatInstance" scope="instance">
        <parameters>
          <parameter name="chatInstance" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="iqSetHandler" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendIqResult" scope="instance">
        <parameters>
          <parameter name="iqId" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="rosterSetHandler" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="presenceUpdate" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="retrieveRoster" scope="instance"/>
      <method name="getRosterIndex" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="createRosterEntry" scope="instance">
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bindResource" scope="instance">
        <parameters>
          <parameter name="hasSession" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getNextIqId" scope="instance"/>
      <method name="presenceSubscriptionRequest" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchPacket" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
          <parameter name="type" type="Object" usage="required"/>
          <parameter name="matchId" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="search" scope="instance">
        <parameters>
          <parameter name="searchString" type="Object" usage="required"/>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="searchAttribute" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onSearchResults" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onLogin" scope="instance"/>
      <method name="onLoginFailure" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onBindSession" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSearchResults" scope="instance">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRetrieveRoster" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterUpdated" scope="instance"/>
      <method name="onSubscriptionRequest" scope="instance">
        <parameters>
          <parameter name="req" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPresenceUpdate" scope="instance">
        <parameters>
          <parameter name="p" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onTransportTerminate" scope="instance">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onConnected" scope="instance"/>
      <method name="onTerminate" scope="instance">
        <parameters>
          <parameter name="newState" type="Object" usage="required"/>
          <parameter name="oldState" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onActive" scope="instance"/>
      <method name="onRegisterChatInstance" scope="instance">
        <parameters>
          <parameter name="chatInstance" type="Object" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterAdded" scope="instance">
        <parameters>
          <parameter name="ri" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterRemoved" scope="instance">
        <parameters>
          <parameter name="ri" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterChanged" scope="instance">
        <parameters>
          <parameter name="ri" type="Object" usage="required"/>
          <parameter name="previousCopy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="processXmppError" scope="instance">
        <parameters>
          <parameter name="msg" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="sendStanzaError" scope="instance">
        <parameters>
          <parameter name="stanzaType" type="Object" usage="required"/>
          <parameter name="to" type="Object" usage="required"/>
          <parameter name="id" type="Object" usage="required"/>
          <parameter name="errorType" type="Object" usage="required"/>
          <parameter name="condition" type="Object" usage="required"/>
          <parameter name="text" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getBareJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getResourceFromJid" scope="instance">
        <parameters>
          <parameter name="jid" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
    <properties>
      <property name="roster" scope="instance-prototype" type="Array"/>
      <property name="chatRegister" scope="instance-prototype" type="Array"/>
      <property name="_iqId" scope="instance-prototype" type="Object"/>
      <property name="session" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.open">
    <methods/>
    <properties>
      <property name="jid" scope="instance" type="String"/>
      <property name="password" scope="instance" type="Object"/>
      <property name="resource" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.close">
    <methods/>
    <properties>
      <property name="state" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.featuresHandler">
    <methods/>
    <properties>
      <property name="auth" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.chatHandler">
    <methods/>
    <properties>
      <property name="useChatState" scope="instance" type="bool"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.setState">
    <methods/>
    <properties>
      <property name="state" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.onBindResource">
    <methods/>
    <properties>
      <property name="jid" scope="instance" type="Object"/>
      <property name="resource" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmppSession.onTransportReady">
    <methods/>
    <properties>
      <property name="rosterService" scope="instance" type="Object"/>
      <property name="presenceService" scope="instance" type="Object"/>
      <property name="userService" scope="instance" type="Object"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmpp">
    <properties>
      <property name="STREAM_NS" scope="instance" type="String"/>
      <property name="CLIENT_NS" scope="instance" type="String"/>
      <property name="STANZA_NS" scope="instance" type="String"/>
      <property name="SASL_NS" scope="instance" type="String"/>
      <property name="BIND_NS" scope="instance" type="String"/>
      <property name="SESSION_NS" scope="instance" type="String"/>
      <property name="BODY_NS" scope="instance" type="String"/>
      <property name="XHTML_BODY_NS" scope="instance" type="String"/>
      <property name="XHTML_IM_NS" scope="instance" type="String"/>
      <property name="INACTIVE" scope="instance" type="String"/>
      <property name="CONNECTED" scope="instance" type="String"/>
      <property name="ACTIVE" scope="instance" type="String"/>
      <property name="TERMINATE" scope="instance" type="String"/>
      <property name="LOGIN_FAILURE" scope="instance" type="String"/>
      <property name="INVALID_ID" scope="instance" type="Number"/>
      <property name="NO_ID" scope="instance" type="Number"/>
    </properties>
  </class>
  <class type="dojox.xmpp.xmpp.error">
    <properties>
      <property name="BAD_REQUEST" scope="instance" type="String"/>
      <property name="CONFLICT" scope="instance" type="String"/>
      <property name="FEATURE_NOT_IMPLEMENTED" scope="instance" type="String"/>
      <property name="FORBIDDEN" scope="instance" type="String"/>
      <property name="GONE" scope="instance" type="String"/>
      <property name="INTERNAL_SERVER_ERROR" scope="instance" type="String"/>
      <property name="ITEM_NOT_FOUND" scope="instance" type="String"/>
      <property name="ID_MALFORMED" scope="instance" type="String"/>
      <property name="NOT_ACCEPTABLE" scope="instance" type="String"/>
      <property name="NOT_ALLOWED" scope="instance" type="String"/>
      <property name="NOT_AUTHORIZED" scope="instance" type="String"/>
      <property name="SERVICE_UNAVAILABLE" scope="instance" type="String"/>
      <property name="SUBSCRIPTION_REQUIRED" scope="instance" type="String"/>
      <property name="UNEXPECTED_REQUEST" scope="instance" type="String"/>
    </properties>
  </class>
</javascript>